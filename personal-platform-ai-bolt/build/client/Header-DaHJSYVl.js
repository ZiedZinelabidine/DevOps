import { r as I, j as k, t as Qe, v as LT, k as _B, w as gZ, x as yZ, u as bZ, l as vB, o as _Z } from "./components-6L62PiHE.js";
import { c as O2, a as nn, u as mt, b as vZ, t as Vg, m as Ol, d as Sr, e as wB, l as hr, f as nt, s as wZ, r as Eu } from "./stripIndent-DDQ8P60l.js";
import { p as je, g as Is, t as Jn, u as EZ } from "./single-fetch-DXQUw6pg.js";
const SZ = 5, Gl = 6, Mp = 10;
let xZ = (t, e, n, r) => (t.events = t.events || {}, t.events[n + Mp] || (t.events[n + Mp] = r((s) => {
  t.events[n].reduceRight((i, o) => (o(i), i), {
    shared: {},
    ...s
  });
})), t.events[n] = t.events[n] || [], t.events[n].push(e), () => {
  let s = t.events[n], i = s.indexOf(e);
  s.splice(i, 1), s.length || (delete t.events[n], t.events[n + Mp](), delete t.events[n + Mp]);
}), TZ = 1e3, CZ = (t, e) => xZ(t, (r) => {
  let s = e(r);
  s && t.events[Gl].push(s);
}, SZ, (r) => {
  let s = t.listen;
  t.listen = (...o) => (!t.lc && !t.active && (t.active = !0, r()), s(...o));
  let i = t.off;
  if (t.events[Gl] = [], t.off = () => {
    i(), setTimeout(() => {
      if (t.active && !t.lc) {
        t.active = !1;
        for (let o of t.events[Gl]) o();
        t.events[Gl] = [];
      }
    }, TZ);
  }, je.env.NODE_ENV !== "production") {
    let o = t[O2];
    t[O2] = () => {
      for (let a of t.events[Gl]) a();
      t.events[Gl] = [], t.active = !1, o();
    };
  }
  return () => {
    t.listen = s, t.off = i;
  };
}), kZ = (t, e, n) => {
  Array.isArray(t) || (t = [t]);
  let r, s = 0, i = () => {
    let l = t.map((c) => c.get());
    if (r === void 0 || l.some((c, u) => c !== r[u])) {
      let c = ++s;
      r = l;
      let u = e(...l);
      u && u.then && u.t ? u.then((h) => {
        c === s && o.set(h);
      }) : o.set(u);
    }
  }, o = nn(void 0, Math.max(...t.map((l) => l.l)) + 1), a = i;
  return CZ(o, () => {
    let l = t.map((c) => c.listen(a, -1 / o.l));
    return i(), () => {
      for (let c of l) c();
    };
  }), o;
}, MT = (t, e) => kZ(t, e);
function AZ() {
  return () => {
  };
}
function RZ() {
  return I.useSyncExternalStore(AZ, () => !0, () => !1);
}
function Oo({ children: t, fallback: e = null }) {
  return RZ() ? I.createElement(I.Fragment, null, t()) : I.createElement(I.Fragment, null, e);
}
const BT = I.createContext({});
function vd(t) {
  const e = I.useRef(null);
  return e.current === null && (e.current = t()), e.current;
}
const Qy = I.createContext(null), FT = I.createContext({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
});
class IZ extends I.Component {
  getSnapshotBeforeUpdate(e) {
    const n = this.props.childRef.current;
    if (n && e.isPresent && !this.props.isPresent) {
      const r = this.props.sizeRef.current;
      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PZ({ children: t, isPresent: e }) {
  const n = I.useId(), r = I.useRef(null), s = I.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: i } = I.useContext(FT);
  return I.useInsertionEffect(() => {
    const { width: o, height: a, top: l, left: c } = s.current;
    if (e || !r.current || !o || !a)
      return;
    r.current.dataset.motionPopId = n;
    const u = document.createElement("style");
    return i && (u.nonce = i), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `), () => {
      document.head.removeChild(u);
    };
  }, [e]), k.jsx(IZ, { isPresent: e, childRef: r, sizeRef: s, children: I.cloneElement(t, { ref: r }) });
}
const OZ = ({ children: t, initial: e, isPresent: n, onExitComplete: r, custom: s, presenceAffectsLayout: i, mode: o }) => {
  const a = vd(DZ), l = I.useId(), c = I.useCallback((h) => {
    a.set(h, !0);
    for (const d of a.values())
      if (!d)
        return;
    r && r();
  }, [a, r]), u = I.useMemo(
    () => ({
      id: l,
      initial: e,
      isPresent: n,
      custom: s,
      onExitComplete: c,
      register: (h) => (a.set(h, !1), () => a.delete(h))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    i ? [Math.random(), c] : [n, c]
  );
  return I.useMemo(() => {
    a.forEach((h, d) => a.set(d, !1));
  }, [n]), I.useEffect(() => {
    !n && !a.size && r && r();
  }, [n]), o === "popLayout" && (t = k.jsx(PZ, { isPresent: n, children: t })), k.jsx(Qy.Provider, { value: u, children: t });
};
function DZ() {
  return /* @__PURE__ */ new Map();
}
function EB(t = !0) {
  const e = I.useContext(Qy);
  if (e === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: r, register: s } = e, i = I.useId();
  I.useEffect(() => {
    t && s(i);
  }, [t]);
  const o = I.useCallback(() => t && r && r(i), [i, r, t]);
  return !n && r ? [!1, o] : [!0];
}
const Bp = (t) => t.key || "";
function D2(t) {
  const e = [];
  return I.Children.forEach(t, (n) => {
    I.isValidElement(n) && e.push(n);
  }), e;
}
const $T = typeof window < "u", SB = $T ? I.useLayoutEffect : I.useEffect, cl = ({ children: t, custom: e, initial: n = !0, onExitComplete: r, presenceAffectsLayout: s = !0, mode: i = "sync", propagate: o = !1 }) => {
  const [a, l] = EB(o), c = I.useMemo(() => D2(t), [t]), u = o && !a ? [] : c.map(Bp), h = I.useRef(!0), d = I.useRef(c), f = vd(() => /* @__PURE__ */ new Map()), [g, y] = I.useState(c), [p, m] = I.useState(c);
  SB(() => {
    h.current = !1, d.current = c;
    for (let v = 0; v < p.length; v++) {
      const w = Bp(p[v]);
      u.includes(w) ? f.delete(w) : f.get(w) !== !0 && f.set(w, !1);
    }
  }, [p, u.length, u.join("-")]);
  const b = [];
  if (c !== g) {
    let v = [...c];
    for (let w = 0; w < p.length; w++) {
      const E = p[w], x = Bp(E);
      u.includes(x) || (v.splice(w, 0, E), b.push(E));
    }
    i === "wait" && b.length && (v = b), m(D2(v)), y(c);
    return;
  }
  je.env.NODE_ENV !== "production" && i === "wait" && p.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: _ } = I.useContext(BT);
  return k.jsx(k.Fragment, { children: p.map((v) => {
    const w = Bp(v), E = o && !a ? !1 : c === p || u.includes(w), x = () => {
      if (f.has(w))
        f.set(w, !0);
      else
        return;
      let S = !0;
      f.forEach((T) => {
        T || (S = !1);
      }), S && (_?.(), m(d.current), o && l?.(), r && r());
    };
    return k.jsx(OZ, { isPresent: E, initial: !h.current || n ? void 0 : !1, custom: E ? void 0 : e, presenceAffectsLayout: s, mode: i, onExitComplete: E ? void 0 : x, children: v }, w);
  }) });
}, yr = /* @__NO_SIDE_EFFECTS__ */ (t) => t;
let Su = yr, Si = yr;
je.env.NODE_ENV !== "production" && (Su = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, Si = (t, e) => {
  if (!t)
    throw new Error(e);
});
// @__NO_SIDE_EFFECTS__
function UT(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const ul = /* @__NO_SIDE_EFFECTS__ */ (t, e, n) => {
  const r = e - t;
  return r === 0 ? 1 : (n - t) / r;
}, _s = /* @__NO_SIDE_EFFECTS__ */ (t) => t * 1e3, bi = /* @__NO_SIDE_EFFECTS__ */ (t) => t / 1e3, NZ = {
  useManualTiming: !1
};
function LZ(t) {
  let e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), r = !1, s = !1;
  const i = /* @__PURE__ */ new WeakSet();
  let o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(c) {
    i.has(c) && (l.schedule(c), t()), c(o);
  }
  const l = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (c, u = !1, h = !1) => {
      const f = h && r ? e : n;
      return u && i.add(c), f.has(c) || f.add(c), c;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (c) => {
      n.delete(c), i.delete(c);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (c) => {
      if (o = c, r) {
        s = !0;
        return;
      }
      r = !0, [e, n] = [n, e], e.forEach(a), e.clear(), r = !1, s && (s = !1, l.process(c));
    }
  };
  return l;
}
const Fp = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], MZ = 40;
function xB(t, e) {
  let n = !1, r = !0;
  const s = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, i = () => n = !0, o = Fp.reduce((m, b) => (m[b] = LZ(i), m), {}), { read: a, resolveKeyframes: l, update: c, preRender: u, render: h, postRender: d } = o, f = () => {
    const m = performance.now();
    n = !1, s.delta = r ? 1e3 / 60 : Math.max(Math.min(m - s.timestamp, MZ), 1), s.timestamp = m, s.isProcessing = !0, a.process(s), l.process(s), c.process(s), u.process(s), h.process(s), d.process(s), s.isProcessing = !1, n && e && (r = !1, t(f));
  }, g = () => {
    n = !0, r = !0, s.isProcessing || t(f);
  };
  return { schedule: Fp.reduce((m, b) => {
    const _ = o[b];
    return m[b] = (v, w = !1, E = !1) => (n || g(), _.schedule(v, w, E)), m;
  }, {}), cancel: (m) => {
    for (let b = 0; b < Fp.length; b++)
      o[Fp[b]].cancel(m);
  }, state: s, steps: o };
}
const { schedule: Mt, cancel: Zo, state: Tn, steps: B_ } = xB(typeof requestAnimationFrame < "u" ? requestAnimationFrame : yr, !0), TB = I.createContext({ strict: !1 }), N2 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, qc = {};
for (const t in N2)
  qc[t] = {
    isEnabled: (e) => N2[t].some((n) => !!e[n])
  };
function BZ(t) {
  for (const e in t)
    qc[e] = {
      ...qc[e],
      ...t[e]
    };
}
const FZ = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function Wg(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || FZ.has(t);
}
let CB = (t) => !Wg(t);
function $Z(t) {
  t && (CB = (e) => e.startsWith("on") ? !Wg(e) : t(e));
}
try {
  $Z(require("@emotion/is-prop-valid").default);
} catch {
}
function UZ(t, e, n) {
  const r = {};
  for (const s in t)
    s === "values" && typeof t.values == "object" || (CB(s) || n === !0 && Wg(s) || !e && !Wg(s) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && s.startsWith("onDrag")) && (r[s] = t[s]);
  return r;
}
const L2 = /* @__PURE__ */ new Set();
function eb(t, e, n) {
  t || L2.has(e) || (console.warn(e), L2.add(e));
}
function jZ(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), n = (...r) => (je.env.NODE_ENV !== "production" && eb(!1, "motion() is deprecated. Use motion.create() instead."), t(...r));
  return new Proxy(n, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (r, s) => s === "create" ? t : (e.has(s) || e.set(s, t(s)), e.get(s))
  });
}
const tb = I.createContext({});
function wd(t) {
  return typeof t == "string" || Array.isArray(t);
}
function nb(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const jT = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], HT = ["initial", ...jT];
function rb(t) {
  return nb(t.animate) || HT.some((e) => wd(t[e]));
}
function kB(t) {
  return !!(rb(t) || t.variants);
}
function HZ(t, e) {
  if (rb(t)) {
    const { initial: n, animate: r } = t;
    return {
      initial: n === !1 || wd(n) ? n : void 0,
      animate: wd(r) ? r : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function zZ(t) {
  const { initial: e, animate: n } = HZ(t, I.useContext(tb));
  return I.useMemo(() => ({ initial: e, animate: n }), [M2(e), M2(n)]);
}
function M2(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const GZ = Symbol.for("motionComponentSymbol");
function uc(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
function VZ(t, e, n) {
  return I.useCallback(
    (r) => {
      r && t.onMount && t.onMount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : uc(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
const zT = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), WZ = "framerAppearId", AB = "data-" + zT(WZ), { schedule: GT } = xB(queueMicrotask, !1), RB = I.createContext({});
function qZ(t, e, n, r, s) {
  var i, o;
  const { visualElement: a } = I.useContext(tb), l = I.useContext(TB), c = I.useContext(Qy), u = I.useContext(FT).reducedMotion, h = I.useRef(null);
  r = r || l.renderer, !h.current && r && (h.current = r(t, {
    visualState: e,
    parent: a,
    props: n,
    presenceContext: c,
    blockInitialAnimation: c ? c.initial === !1 : !1,
    reducedMotionConfig: u
  }));
  const d = h.current, f = I.useContext(RB);
  d && !d.projection && s && (d.type === "html" || d.type === "svg") && KZ(h.current, n, s, f);
  const g = I.useRef(!1);
  I.useInsertionEffect(() => {
    d && g.current && d.update(n, c);
  });
  const y = n[AB], p = I.useRef(!!y && !(!((i = window.MotionHandoffIsComplete) === null || i === void 0) && i.call(window, y)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, y)));
  return SB(() => {
    d && (g.current = !0, window.MotionIsMounted = !0, d.updateFeatures(), GT.render(d.render), p.current && d.animationState && d.animationState.animateChanges());
  }), I.useEffect(() => {
    d && (!p.current && d.animationState && d.animationState.animateChanges(), p.current && (queueMicrotask(() => {
      var m;
      (m = window.MotionHandoffMarkAsComplete) === null || m === void 0 || m.call(window, y);
    }), p.current = !1));
  }), d;
}
function KZ(t, e, n, r) {
  const { layoutId: s, layout: i, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: c } = e;
  t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : IB(t.parent)), t.projection.setOptions({
    layoutId: s,
    layout: i,
    alwaysMeasureLayout: !!o || a && uc(a),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof i == "string" ? i : "both",
    initialPromotionConfig: r,
    layoutScroll: l,
    layoutRoot: c
  });
}
function IB(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : IB(t.parent);
}
function YZ({ preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: r, Component: s }) {
  var i, o;
  t && BZ(t);
  function a(c, u) {
    let h;
    const d = {
      ...I.useContext(FT),
      ...c,
      layoutId: ZZ(c)
    }, { isStatic: f } = d, g = zZ(c), y = r(c, f);
    if (!f && $T) {
      JZ(d, t);
      const p = XZ(d);
      h = p.MeasureLayout, g.visualElement = qZ(s, y, d, e, p.ProjectionNode);
    }
    return k.jsxs(tb.Provider, { value: g, children: [h && g.visualElement ? k.jsx(h, { visualElement: g.visualElement, ...d }) : null, n(s, c, VZ(y, g.visualElement, u), y, f, g.visualElement)] });
  }
  a.displayName = `motion.${typeof s == "string" ? s : `create(${(o = (i = s.displayName) !== null && i !== void 0 ? i : s.name) !== null && o !== void 0 ? o : ""})`}`;
  const l = I.forwardRef(a);
  return l[GZ] = s, l;
}
function ZZ({ layoutId: t }) {
  const e = I.useContext(BT).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function JZ(t, e) {
  const n = I.useContext(TB).strict;
  if (je.env.NODE_ENV !== "production" && e && n) {
    const r = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? Su(!1, r) : Si(!1, r);
  }
}
function XZ(t) {
  const { drag: e, layout: n } = qc;
  if (!e && !n)
    return {};
  const r = { ...e, ...n };
  return {
    MeasureLayout: e?.isEnabled(t) || n?.isEnabled(t) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
const QZ = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function VT(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(QZ.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function B2(t) {
  const e = [{}, {}];
  return t?.values.forEach((n, r) => {
    e[0][r] = n.get(), e[1][r] = n.getVelocity();
  }), e;
}
function WT(t, e, n, r) {
  if (typeof e == "function") {
    const [s, i] = B2(r);
    e = e(n !== void 0 ? n : t.custom, s, i);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [s, i] = B2(r);
    e = e(n !== void 0 ? n : t.custom, s, i);
  }
  return e;
}
const P1 = (t) => Array.isArray(t), eJ = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), tJ = (t) => P1(t) ? t[t.length - 1] || 0 : t, wn = (t) => !!(t && t.getVelocity);
function lg(t) {
  const e = wn(t) ? t.get() : t;
  return eJ(e) ? e.toValue() : e;
}
function nJ({ scrapeMotionValuesFromProps: t, createRenderState: e, onUpdate: n }, r, s, i) {
  const o = {
    latestValues: rJ(r, s, i, t),
    renderState: e()
  };
  return n && (o.onMount = (a) => n({ props: r, current: a, ...o }), o.onUpdate = (a) => n(a)), o;
}
const PB = (t) => (e, n) => {
  const r = I.useContext(tb), s = I.useContext(Qy), i = () => nJ(t, e, r, s);
  return n ? i() : vd(i);
};
function rJ(t, e, n, r) {
  const s = {}, i = r(t, {});
  for (const d in i)
    s[d] = lg(i[d]);
  let { initial: o, animate: a } = t;
  const l = rb(t), c = kB(t);
  e && c && !l && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let u = n ? n.initial === !1 : !1;
  u = u || o === !1;
  const h = u ? a : o;
  if (h && typeof h != "boolean" && !nb(h)) {
    const d = Array.isArray(h) ? h : [h];
    for (let f = 0; f < d.length; f++) {
      const g = WT(t, d[f]);
      if (g) {
        const { transitionEnd: y, transition: p, ...m } = g;
        for (const b in m) {
          let _ = m[b];
          if (Array.isArray(_)) {
            const v = u ? _.length - 1 : 0;
            _ = _[v];
          }
          _ !== null && (s[b] = _);
        }
        for (const b in y)
          s[b] = y[b];
      }
    }
  }
  return s;
}
const xu = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Dl = new Set(xu), OB = (t) => (e) => typeof e == "string" && e.startsWith(t), DB = /* @__PURE__ */ OB("--"), sJ = /* @__PURE__ */ OB("var(--"), qT = (t) => sJ(t) ? iJ.test(t.split("/*")[0].trim()) : !1, iJ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, NB = (t, e) => e && typeof t == "number" ? e.transform(t) : t, lo = (t, e, n) => n > e ? e : n < t ? t : n, Tu = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, Ed = {
  ...Tu,
  transform: (t) => lo(0, 1, t)
}, $p = {
  ...Tu,
  default: 1
}, Jf = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), xo = /* @__PURE__ */ Jf("deg"), _i = /* @__PURE__ */ Jf("%"), Ye = /* @__PURE__ */ Jf("px"), oJ = /* @__PURE__ */ Jf("vh"), aJ = /* @__PURE__ */ Jf("vw"), F2 = {
  ..._i,
  parse: (t) => _i.parse(t) / 100,
  transform: (t) => _i.transform(t * 100)
}, lJ = {
  // Border props
  borderWidth: Ye,
  borderTopWidth: Ye,
  borderRightWidth: Ye,
  borderBottomWidth: Ye,
  borderLeftWidth: Ye,
  borderRadius: Ye,
  radius: Ye,
  borderTopLeftRadius: Ye,
  borderTopRightRadius: Ye,
  borderBottomRightRadius: Ye,
  borderBottomLeftRadius: Ye,
  // Positioning props
  width: Ye,
  maxWidth: Ye,
  height: Ye,
  maxHeight: Ye,
  top: Ye,
  right: Ye,
  bottom: Ye,
  left: Ye,
  // Spacing props
  padding: Ye,
  paddingTop: Ye,
  paddingRight: Ye,
  paddingBottom: Ye,
  paddingLeft: Ye,
  margin: Ye,
  marginTop: Ye,
  marginRight: Ye,
  marginBottom: Ye,
  marginLeft: Ye,
  // Misc
  backgroundPositionX: Ye,
  backgroundPositionY: Ye
}, cJ = {
  rotate: xo,
  rotateX: xo,
  rotateY: xo,
  rotateZ: xo,
  scale: $p,
  scaleX: $p,
  scaleY: $p,
  scaleZ: $p,
  skew: xo,
  skewX: xo,
  skewY: xo,
  distance: Ye,
  translateX: Ye,
  translateY: Ye,
  translateZ: Ye,
  x: Ye,
  y: Ye,
  z: Ye,
  perspective: Ye,
  transformPerspective: Ye,
  opacity: Ed,
  originX: F2,
  originY: F2,
  originZ: Ye
}, $2 = {
  ...Tu,
  transform: Math.round
}, KT = {
  ...lJ,
  ...cJ,
  zIndex: $2,
  size: Ye,
  // SVG
  fillOpacity: Ed,
  strokeOpacity: Ed,
  numOctaves: $2
}, uJ = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, hJ = xu.length;
function dJ(t, e, n) {
  let r = "", s = !0;
  for (let i = 0; i < hJ; i++) {
    const o = xu[i], a = t[o];
    if (a === void 0)
      continue;
    let l = !0;
    if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) {
      const c = NB(a, KT[o]);
      if (!l) {
        s = !1;
        const u = uJ[o] || o;
        r += `${u}(${c}) `;
      }
      n && (e[o] = c);
    }
  }
  return r = r.trim(), n ? r = n(e, s ? "" : r) : s && (r = "none"), r;
}
function YT(t, e, n) {
  const { style: r, vars: s, transformOrigin: i } = t;
  let o = !1, a = !1;
  for (const l in e) {
    const c = e[l];
    if (Dl.has(l)) {
      o = !0;
      continue;
    } else if (DB(l)) {
      s[l] = c;
      continue;
    } else {
      const u = NB(c, KT[l]);
      l.startsWith("origin") ? (a = !0, i[l] = u) : r[l] = u;
    }
  }
  if (e.transform || (o || n ? r.transform = dJ(e, t.transform, n) : r.transform && (r.transform = "none")), a) {
    const { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = i;
    r.transformOrigin = `${l} ${c} ${u}`;
  }
}
const fJ = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, pJ = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function mJ(t, e, n = 1, r = 0, s = !0) {
  t.pathLength = 1;
  const i = s ? fJ : pJ;
  t[i.offset] = Ye.transform(-r);
  const o = Ye.transform(e), a = Ye.transform(n);
  t[i.array] = `${o} ${a}`;
}
function U2(t, e, n) {
  return typeof t == "string" ? t : Ye.transform(e + n * t);
}
function gJ(t, e, n) {
  const r = U2(e, t.x, t.width), s = U2(n, t.y, t.height);
  return `${r} ${s}`;
}
function ZT(t, {
  attrX: e,
  attrY: n,
  attrScale: r,
  originX: s,
  originY: i,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...c
}, u, h) {
  if (YT(t, c, h), u) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: d, style: f, dimensions: g } = t;
  d.transform && (g && (f.transform = d.transform), delete d.transform), g && (s !== void 0 || i !== void 0 || f.transform) && (f.transformOrigin = gJ(g, s !== void 0 ? s : 0.5, i !== void 0 ? i : 0.5)), e !== void 0 && (d.x = e), n !== void 0 && (d.y = n), r !== void 0 && (d.scale = r), o !== void 0 && mJ(d, o, a, l, !1);
}
const JT = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), LB = () => ({
  ...JT(),
  attrs: {}
}), XT = (t) => typeof t == "string" && t.toLowerCase() === "svg";
function MB(t, { style: e, vars: n }, r, s) {
  Object.assign(t.style, e, s && s.getProjectionStyles(r));
  for (const i in n)
    t.style.setProperty(i, n[i]);
}
const BB = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function FB(t, e, n, r) {
  MB(t, e, void 0, r);
  for (const s in e.attrs)
    t.setAttribute(BB.has(s) ? s : zT(s), e.attrs[s]);
}
const qg = {};
function yJ(t) {
  Object.assign(qg, t);
}
function $B(t, { layout: e, layoutId: n }) {
  return Dl.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!qg[t] || t === "opacity");
}
function QT(t, e, n) {
  var r;
  const { style: s } = t, i = {};
  for (const o in s)
    (wn(s[o]) || e.style && wn(e.style[o]) || $B(o, t) || ((r = n?.getValue(o)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (i[o] = s[o]);
  return i;
}
function UB(t, e, n) {
  const r = QT(t, e, n);
  for (const s in t)
    if (wn(t[s]) || wn(e[s])) {
      const i = xu.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s;
      r[i] = t[s];
    }
  return r;
}
function bJ(t, e) {
  try {
    e.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
  } catch {
    e.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
const j2 = ["x", "y", "width", "height", "cx", "cy", "r"], _J = {
  useVisualState: PB({
    scrapeMotionValuesFromProps: UB,
    createRenderState: LB,
    onUpdate: ({ props: t, prevProps: e, current: n, renderState: r, latestValues: s }) => {
      if (!n)
        return;
      let i = !!t.drag;
      if (!i) {
        for (const a in s)
          if (Dl.has(a)) {
            i = !0;
            break;
          }
      }
      if (!i)
        return;
      let o = !e;
      if (e)
        for (let a = 0; a < j2.length; a++) {
          const l = j2[a];
          t[l] !== e[l] && (o = !0);
        }
      o && Mt.read(() => {
        bJ(n, r), Mt.render(() => {
          ZT(r, s, XT(n.tagName), t.transformTemplate), FB(n, r);
        });
      });
    }
  })
}, vJ = {
  useVisualState: PB({
    scrapeMotionValuesFromProps: QT,
    createRenderState: JT
  })
};
function jB(t, e, n) {
  for (const r in e)
    !wn(e[r]) && !$B(r, n) && (t[r] = e[r]);
}
function wJ({ transformTemplate: t }, e) {
  return I.useMemo(() => {
    const n = JT();
    return YT(n, e, t), Object.assign({}, n.vars, n.style);
  }, [e]);
}
function EJ(t, e) {
  const n = t.style || {}, r = {};
  return jB(r, n, t), Object.assign(r, wJ(t, e)), r;
}
function SJ(t, e) {
  const n = {}, r = EJ(t, e);
  return t.drag && t.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
function xJ(t, e, n, r) {
  const s = I.useMemo(() => {
    const i = LB();
    return ZT(i, e, XT(r), t.transformTemplate), {
      ...i.attrs,
      style: { ...i.style }
    };
  }, [e]);
  if (t.style) {
    const i = {};
    jB(i, t.style, t), s.style = { ...i, ...s.style };
  }
  return s;
}
function TJ(t = !1) {
  return (n, r, s, { latestValues: i }, o) => {
    const l = (VT(n) ? xJ : SJ)(r, i, o, n), c = UZ(r, typeof n == "string", t), u = n !== I.Fragment ? { ...c, ...l, ref: s } : {}, { children: h } = r, d = I.useMemo(() => wn(h) ? h.get() : h, [h]);
    return I.createElement(n, {
      ...u,
      children: d
    });
  };
}
function CJ(t, e) {
  return function(r, { forwardMotionProps: s } = { forwardMotionProps: !1 }) {
    const o = {
      ...VT(r) ? _J : vJ,
      preloadedFeatures: t,
      useRender: TJ(s),
      createVisualElement: e,
      Component: r
    };
    return YZ(o);
  };
}
function HB(t, e) {
  if (!Array.isArray(e))
    return !1;
  const n = e.length;
  if (n !== t.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function sb(t, e, n) {
  const r = t.getProps();
  return WT(r, e, n !== void 0 ? n : r.custom, t);
}
const kJ = /* @__PURE__ */ UT(() => window.ScrollTimeline !== void 0);
class AJ {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((e) => "finished" in e ? e.finished : e));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, n) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][e] = n;
  }
  attachTimeline(e, n) {
    const r = this.animations.map((s) => {
      if (kJ() && s.attachTimeline)
        return s.attachTimeline(e);
      if (typeof n == "function")
        return n(s);
    });
    return () => {
      r.forEach((s, i) => {
        s && s(), this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let n = 0; n < this.animations.length; n++)
      e = Math.max(e, this.animations[n].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((n) => n[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class zB extends AJ {
  then(e, n) {
    return Promise.all(this.animations).then(e).catch(n);
  }
}
function eC(t, e) {
  return t ? t[e] || t.default || t : void 0;
}
const Kg = 2e4;
function tC(t) {
  let e = 0;
  const n = 50;
  let r = t.next(e);
  for (; !r.done && e < Kg; )
    e += n, r = t.next(e);
  return e >= Kg ? 1 / 0 : e;
}
function RJ(t, e = 100, n) {
  const r = n({ ...t, keyframes: [0, e] }), s = Math.min(tC(r), Kg);
  return {
    type: "keyframes",
    ease: (i) => r.next(s * i).value / e,
    duration: /* @__PURE__ */ bi(s)
  };
}
function ib(t) {
  return typeof t == "function";
}
function H2(t, e) {
  t.timeline = e, t.onfinish = null;
}
const nC = (t) => Array.isArray(t) && typeof t[0] == "number", IJ = {
  linearEasing: void 0
};
function PJ(t, e) {
  const n = /* @__PURE__ */ UT(t);
  return () => {
    var r;
    return (r = IJ[e]) !== null && r !== void 0 ? r : n();
  };
}
const Yg = /* @__PURE__ */ PJ(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), GB = (t, e, n = 10) => {
  let r = "";
  const s = Math.max(Math.round(e / n), 2);
  for (let i = 0; i < s; i++)
    r += t(/* @__PURE__ */ ul(0, s - 1, i)) + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
};
function VB(t) {
  return !!(typeof t == "function" && Yg() || !t || typeof t == "string" && (t in O1 || Yg()) || nC(t) || Array.isArray(t) && t.every(VB));
}
const wh = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`, O1 = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ wh([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ wh([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ wh([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ wh([0.33, 1.53, 0.69, 0.99])
};
function WB(t, e) {
  if (t)
    return typeof t == "function" && Yg() ? GB(t, e) : nC(t) ? wh(t) : Array.isArray(t) ? t.map((n) => WB(n, e) || O1.easeOut) : O1[t];
}
const fs = {
  x: !1,
  y: !1
};
function qB() {
  return fs.x || fs.y;
}
function KB(t, e, n) {
  var r;
  if (t instanceof Element)
    return [t];
  if (typeof t == "string") {
    let s = document;
    e && (s = e.current);
    const i = (r = n?.[t]) !== null && r !== void 0 ? r : s.querySelectorAll(t);
    return i ? Array.from(i) : [];
  }
  return Array.from(t);
}
function YB(t, e) {
  const n = KB(t), r = new AbortController(), s = {
    passive: !0,
    ...e,
    signal: r.signal
  };
  return [n, s, () => r.abort()];
}
function z2(t) {
  return (e) => {
    e.pointerType === "touch" || qB() || t(e);
  };
}
function OJ(t, e, n = {}) {
  const [r, s, i] = YB(t, n), o = z2((a) => {
    const { target: l } = a, c = e(a);
    if (typeof c != "function" || !l)
      return;
    const u = z2((h) => {
      c(h), l.removeEventListener("pointerleave", u);
    });
    l.addEventListener("pointerleave", u, s);
  });
  return r.forEach((a) => {
    a.addEventListener("pointerenter", o, s);
  }), i;
}
const ZB = (t, e) => e ? t === e ? !0 : ZB(t, e.parentElement) : !1, rC = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1, DJ = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function NJ(t) {
  return DJ.has(t.tagName) || t.tabIndex !== -1;
}
const Eh = /* @__PURE__ */ new WeakSet();
function G2(t) {
  return (e) => {
    e.key === "Enter" && t(e);
  };
}
function F_(t, e) {
  t.dispatchEvent(new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 }));
}
const LJ = (t, e) => {
  const n = t.currentTarget;
  if (!n)
    return;
  const r = G2(() => {
    if (Eh.has(n))
      return;
    F_(n, "down");
    const s = G2(() => {
      F_(n, "up");
    }), i = () => F_(n, "cancel");
    n.addEventListener("keyup", s, e), n.addEventListener("blur", i, e);
  });
  n.addEventListener("keydown", r, e), n.addEventListener("blur", () => n.removeEventListener("keydown", r), e);
};
function V2(t) {
  return rC(t) && !qB();
}
function MJ(t, e, n = {}) {
  const [r, s, i] = YB(t, n), o = (a) => {
    const l = a.currentTarget;
    if (!V2(a) || Eh.has(l))
      return;
    Eh.add(l);
    const c = e(a), u = (f, g) => {
      window.removeEventListener("pointerup", h), window.removeEventListener("pointercancel", d), !(!V2(f) || !Eh.has(l)) && (Eh.delete(l), typeof c == "function" && c(f, { success: g }));
    }, h = (f) => {
      u(f, n.useGlobalTarget || ZB(l, f.target));
    }, d = (f) => {
      u(f, !1);
    };
    window.addEventListener("pointerup", h, s), window.addEventListener("pointercancel", d, s);
  };
  return r.forEach((a) => {
    !NJ(a) && a.getAttribute("tabindex") === null && (a.tabIndex = 0), (n.useGlobalTarget ? window : a).addEventListener("pointerdown", o, s), a.addEventListener("focus", (c) => LJ(c, s), s);
  }), i;
}
function BJ(t) {
  return t === "x" || t === "y" ? fs[t] ? null : (fs[t] = !0, () => {
    fs[t] = !1;
  }) : fs.x || fs.y ? null : (fs.x = fs.y = !0, () => {
    fs.x = fs.y = !1;
  });
}
const JB = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...xu
]);
let cg;
function FJ() {
  cg = void 0;
}
const vi = {
  now: () => (cg === void 0 && vi.set(Tn.isProcessing || NZ.useManualTiming ? Tn.timestamp : performance.now()), cg),
  set: (t) => {
    cg = t, queueMicrotask(FJ);
  }
};
function sC(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function ob(t, e) {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}
class iC {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return sC(this.subscriptions, e), () => ob(this.subscriptions, e);
  }
  notify(e, n, r) {
    const s = this.subscriptions.length;
    if (s)
      if (s === 1)
        this.subscriptions[0](e, n, r);
      else
        for (let i = 0; i < s; i++) {
          const o = this.subscriptions[i];
          o && o(e, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function XB(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const W2 = 30, $J = (t) => !isNaN(parseFloat(t));
class UJ {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, n = {}) {
    this.version = "11.18.2", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, s = !0) => {
      const i = vi.now();
      this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), s && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = vi.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = $J(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return je.env.NODE_ENV !== "production" && eb(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, n) {
    this.events[e] || (this.events[e] = new iC());
    const r = this.events[e].add(n);
    return e === "change" ? () => {
      r(), Mt.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, n) {
    this.passiveEffect = e, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, n = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = vi.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > W2)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, W2);
    return XB(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Sd(t, e) {
  return new UJ(t, e);
}
function jJ(t, e, n) {
  t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Sd(n));
}
function HJ(t, e) {
  const n = sb(t, e);
  let { transitionEnd: r = {}, transition: s = {}, ...i } = n || {};
  i = { ...i, ...r };
  for (const o in i) {
    const a = tJ(i[o]);
    jJ(t, o, a);
  }
}
function zJ(t) {
  return !!(wn(t) && t.add);
}
function D1(t, e) {
  const n = t.getValue("willChange");
  if (zJ(n))
    return n.add(e);
}
function QB(t) {
  return t.props[AB];
}
const e6 = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, GJ = 1e-7, VJ = 12;
function WJ(t, e, n, r, s) {
  let i, o, a = 0;
  do
    o = e + (n - e) / 2, i = e6(o, r, s) - t, i > 0 ? n = o : e = o;
  while (Math.abs(i) > GJ && ++a < VJ);
  return o;
}
function Nl(t, e, n, r) {
  if (t === e && n === r)
    return yr;
  const s = (i) => WJ(i, 0, 1, t, n);
  return (i) => i === 0 || i === 1 ? i : e6(s(i), e, r);
}
const t6 = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, n6 = (t) => (e) => 1 - t(1 - e), r6 = /* @__PURE__ */ Nl(0.33, 1.53, 0.69, 0.99), oC = /* @__PURE__ */ n6(r6), s6 = /* @__PURE__ */ t6(oC), i6 = (t) => (t *= 2) < 1 ? 0.5 * oC(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), aC = (t) => 1 - Math.sin(Math.acos(t)), o6 = n6(aC), a6 = t6(aC), l6 = (t) => /^0[^.\s]+$/u.test(t);
function qJ(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || l6(t) : !0;
}
const Fh = (t) => Math.round(t * 1e5) / 1e5, lC = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function KJ(t) {
  return t == null;
}
const YJ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, cC = (t, e) => (n) => !!(typeof n == "string" && YJ.test(n) && n.startsWith(t) || e && !KJ(n) && Object.prototype.hasOwnProperty.call(n, e)), c6 = (t, e, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [s, i, o, a] = r.match(lC);
  return {
    [t]: parseFloat(s),
    [e]: parseFloat(i),
    [n]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, ZJ = (t) => lo(0, 255, t), $_ = {
  ...Tu,
  transform: (t) => Math.round(ZJ(t))
}, Ua = {
  test: /* @__PURE__ */ cC("rgb", "red"),
  parse: /* @__PURE__ */ c6("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + $_.transform(t) + ", " + $_.transform(e) + ", " + $_.transform(n) + ", " + Fh(Ed.transform(r)) + ")"
};
function JJ(t) {
  let e = "", n = "", r = "", s = "";
  return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), s = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), s = t.substring(4, 5), e += e, n += n, r += r, s += s), {
    red: parseInt(e, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: s ? parseInt(s, 16) / 255 : 1
  };
}
const N1 = {
  test: /* @__PURE__ */ cC("#"),
  parse: JJ,
  transform: Ua.transform
}, hc = {
  test: /* @__PURE__ */ cC("hsl", "hue"),
  parse: /* @__PURE__ */ c6("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + _i.transform(Fh(e)) + ", " + _i.transform(Fh(n)) + ", " + Fh(Ed.transform(r)) + ")"
}, Mn = {
  test: (t) => Ua.test(t) || N1.test(t) || hc.test(t),
  parse: (t) => Ua.test(t) ? Ua.parse(t) : hc.test(t) ? hc.parse(t) : N1.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? Ua.transform(t) : hc.transform(t)
}, XJ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function QJ(t) {
  var e, n;
  return isNaN(t) && typeof t == "string" && (((e = t.match(lC)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(XJ)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const u6 = "number", h6 = "color", eX = "var", tX = "var(", q2 = "${}", nX = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function xd(t) {
  const e = t.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, s = [];
  let i = 0;
  const a = e.replace(nX, (l) => (Mn.test(l) ? (r.color.push(i), s.push(h6), n.push(Mn.parse(l))) : l.startsWith(tX) ? (r.var.push(i), s.push(eX), n.push(l)) : (r.number.push(i), s.push(u6), n.push(parseFloat(l))), ++i, q2)).split(q2);
  return { values: n, split: a, indexes: r, types: s };
}
function d6(t) {
  return xd(t).values;
}
function f6(t) {
  const { split: e, types: n } = xd(t), r = e.length;
  return (s) => {
    let i = "";
    for (let o = 0; o < r; o++)
      if (i += e[o], s[o] !== void 0) {
        const a = n[o];
        a === u6 ? i += Fh(s[o]) : a === h6 ? i += Mn.transform(s[o]) : i += s[o];
      }
    return i;
  };
}
const rX = (t) => typeof t == "number" ? 0 : t;
function sX(t) {
  const e = d6(t);
  return f6(t)(e.map(rX));
}
const Jo = {
  test: QJ,
  parse: d6,
  createTransformer: f6,
  getAnimatableNone: sX
}, iX = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function oX(t) {
  const [e, n] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [r] = n.match(lC) || [];
  if (!r)
    return t;
  const s = n.replace(r, "");
  let i = iX.has(e) ? 1 : 0;
  return r !== n && (i *= 100), e + "(" + i + s + ")";
}
const aX = /\b([a-z-]*)\(.*?\)/gu, L1 = {
  ...Jo,
  getAnimatableNone: (t) => {
    const e = t.match(aX);
    return e ? e.map(oX).join(" ") : t;
  }
}, lX = {
  ...KT,
  // Color props
  color: Mn,
  backgroundColor: Mn,
  outlineColor: Mn,
  fill: Mn,
  stroke: Mn,
  // Border props
  borderColor: Mn,
  borderTopColor: Mn,
  borderRightColor: Mn,
  borderBottomColor: Mn,
  borderLeftColor: Mn,
  filter: L1,
  WebkitFilter: L1
}, uC = (t) => lX[t];
function p6(t, e) {
  let n = uC(t);
  return n !== L1 && (n = Jo), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0;
}
const cX = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function uX(t, e, n) {
  let r = 0, s;
  for (; r < t.length && !s; ) {
    const i = t[r];
    typeof i == "string" && !cX.has(i) && xd(i).values.length && (s = t[r]), r++;
  }
  if (s && n)
    for (const i of e)
      t[i] = p6(n, s);
}
const K2 = (t) => t === Tu || t === Ye, Y2 = (t, e) => parseFloat(t.split(", ")[e]), Z2 = (t, e) => (n, { transform: r }) => {
  if (r === "none" || !r)
    return 0;
  const s = r.match(/^matrix3d\((.+)\)$/u);
  if (s)
    return Y2(s[1], e);
  {
    const i = r.match(/^matrix\((.+)\)$/u);
    return i ? Y2(i[1], t) : 0;
  }
}, hX = /* @__PURE__ */ new Set(["x", "y", "z"]), dX = xu.filter((t) => !hX.has(t));
function fX(t) {
  const e = [];
  return dX.forEach((n) => {
    const r = t.getValue(n);
    r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), e;
}
const Kc = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: Z2(4, 13),
  y: Z2(5, 14)
};
Kc.translateX = Kc.x;
Kc.translateY = Kc.y;
const Qa = /* @__PURE__ */ new Set();
let M1 = !1, B1 = !1;
function m6() {
  if (B1) {
    const t = Array.from(Qa).filter((r) => r.needsMeasurement), e = new Set(t.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    e.forEach((r) => {
      const s = fX(r);
      s.length && (n.set(r, s), r.render());
    }), t.forEach((r) => r.measureInitialState()), e.forEach((r) => {
      r.render();
      const s = n.get(r);
      s && s.forEach(([i, o]) => {
        var a;
        (a = r.getValue(i)) === null || a === void 0 || a.set(o);
      });
    }), t.forEach((r) => r.measureEndState()), t.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  B1 = !1, M1 = !1, Qa.forEach((t) => t.complete()), Qa.clear();
}
function g6() {
  Qa.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (B1 = !0);
  });
}
function pX() {
  g6(), m6();
}
class hC {
  constructor(e, n, r, s, i, o = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = r, this.motionValue = s, this.element = i, this.isAsync = o;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (Qa.add(this), M1 || (M1 = !0, Mt.read(g6), Mt.resolveKeyframes(m6))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: n, element: r, motionValue: s } = this;
    for (let i = 0; i < e.length; i++)
      if (e[i] === null)
        if (i === 0) {
          const o = s?.get(), a = e[e.length - 1];
          if (o !== void 0)
            e[0] = o;
          else if (r && n) {
            const l = r.readValue(n, a);
            l != null && (e[0] = l);
          }
          e[0] === void 0 && (e[0] = a), s && o === void 0 && s.set(e[0]);
        } else
          e[i] = e[i - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Qa.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, Qa.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const y6 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), mX = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function gX(t) {
  const e = mX.exec(t);
  if (!e)
    return [,];
  const [, n, r, s] = e;
  return [`--${n ?? r}`, s];
}
const yX = 4;
function b6(t, e, n = 1) {
  Si(n <= yX, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [r, s] = gX(t);
  if (!r)
    return;
  const i = window.getComputedStyle(e).getPropertyValue(r);
  if (i) {
    const o = i.trim();
    return y6(o) ? parseFloat(o) : o;
  }
  return qT(s) ? b6(s, e, n + 1) : s;
}
const _6 = (t) => (e) => e.test(t), bX = {
  test: (t) => t === "auto",
  parse: (t) => t
}, v6 = [Tu, Ye, _i, xo, aJ, oJ, bX], J2 = (t) => v6.find(_6(t));
class w6 extends hC {
  constructor(e, n, r, s, i) {
    super(e, n, r, s, i, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      if (typeof c == "string" && (c = c.trim(), qT(c))) {
        const u = b6(c, n.current);
        u !== void 0 && (e[l] = u), l === e.length - 1 && (this.finalKeyframe = c);
      }
    }
    if (this.resolveNoneKeyframes(), !JB.has(r) || e.length !== 2)
      return;
    const [s, i] = e, o = J2(s), a = J2(i);
    if (o !== a)
      if (K2(o) && K2(a))
        for (let l = 0; l < e.length; l++) {
          const c = e[l];
          typeof c == "string" && (e[l] = parseFloat(c));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: n } = this, r = [];
    for (let s = 0; s < e.length; s++)
      qJ(e[s]) && r.push(s);
    r.length && uX(e, r, n);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: n, name: r } = this;
    if (!e || !e.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Kc[r](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin;
    const s = n[n.length - 1];
    s !== void 0 && e.getValue(r, s).jump(s, !1);
  }
  measureEndState() {
    var e;
    const { element: n, name: r, unresolvedKeyframes: s } = this;
    if (!n || !n.current)
      return;
    const i = n.getValue(r);
    i && i.jump(this.measuredOrigin, !1);
    const o = s.length - 1, a = s[o];
    s[o] = Kc[r](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([l, c]) => {
      n.getValue(l).set(c);
    }), this.resolveNoneKeyframes();
  }
}
const X2 = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(Jo.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function _X(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e)
      return !0;
}
function vX(t, e, n, r) {
  const s = t[0];
  if (s === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const i = t[t.length - 1], o = X2(s, e), a = X2(i, e);
  return Su(o === a, `You are trying to animate ${e} from "${s}" to "${i}". ${s} is not an animatable value - to enable this animation set ${s} to a value animatable to ${i} via the \`style\` property.`), !o || !a ? !1 : _X(t) || (n === "spring" || ib(n)) && r;
}
const wX = (t) => t !== null;
function ab(t, { repeat: e, repeatType: n = "loop" }, r) {
  const s = t.filter(wX), i = e && n !== "loop" && e % 2 === 1 ? 0 : s.length - 1;
  return !i || r === void 0 ? s[i] : r;
}
const EX = 40;
class E6 {
  constructor({ autoplay: e = !0, delay: n = 0, type: r = "keyframes", repeat: s = 0, repeatDelay: i = 0, repeatType: o = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = vi.now(), this.options = {
      autoplay: e,
      delay: n,
      type: r,
      repeat: s,
      repeatDelay: i,
      repeatType: o,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > EX ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && pX(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, n) {
    this.resolvedAt = vi.now(), this.hasAttemptedResolve = !0;
    const { name: r, type: s, velocity: i, delay: o, onComplete: a, onUpdate: l, isGenerator: c } = this.options;
    if (!c && !vX(e, r, s, i))
      if (o)
        this.options.duration = 0;
      else {
        l && l(ab(e, this.options, n)), a && a(), this.resolveFinishedPromise();
        return;
      }
    const u = this.initPlayback(e, n);
    u !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: n,
      ...u
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, n) {
    return this.currentFinishedPromise.then(e, n);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
const Ut = (t, e, n) => t + (e - t) * n;
function U_(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function SX({ hue: t, saturation: e, lightness: n, alpha: r }) {
  t /= 360, e /= 100, n /= 100;
  let s = 0, i = 0, o = 0;
  if (!e)
    s = i = o = n;
  else {
    const a = n < 0.5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a;
    s = U_(l, a, t + 1 / 3), i = U_(l, a, t), o = U_(l, a, t - 1 / 3);
  }
  return {
    red: Math.round(s * 255),
    green: Math.round(i * 255),
    blue: Math.round(o * 255),
    alpha: r
  };
}
function Zg(t, e) {
  return (n) => n > 0 ? e : t;
}
const j_ = (t, e, n) => {
  const r = t * t, s = n * (e * e - r) + r;
  return s < 0 ? 0 : Math.sqrt(s);
}, xX = [N1, Ua, hc], TX = (t) => xX.find((e) => e.test(t));
function Q2(t) {
  const e = TX(t);
  if (Su(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let n = e.parse(t);
  return e === hc && (n = SX(n)), n;
}
const eR = (t, e) => {
  const n = Q2(t), r = Q2(e);
  if (!n || !r)
    return Zg(t, e);
  const s = { ...n };
  return (i) => (s.red = j_(n.red, r.red, i), s.green = j_(n.green, r.green, i), s.blue = j_(n.blue, r.blue, i), s.alpha = Ut(n.alpha, r.alpha, i), Ua.transform(s));
}, CX = (t, e) => (n) => e(t(n)), Xf = (...t) => t.reduce(CX), F1 = /* @__PURE__ */ new Set(["none", "hidden"]);
function kX(t, e) {
  return F1.has(t) ? (n) => n <= 0 ? t : e : (n) => n >= 1 ? e : t;
}
function AX(t, e) {
  return (n) => Ut(t, e, n);
}
function dC(t) {
  return typeof t == "number" ? AX : typeof t == "string" ? qT(t) ? Zg : Mn.test(t) ? eR : PX : Array.isArray(t) ? S6 : typeof t == "object" ? Mn.test(t) ? eR : RX : Zg;
}
function S6(t, e) {
  const n = [...t], r = n.length, s = t.map((i, o) => dC(i)(i, e[o]));
  return (i) => {
    for (let o = 0; o < r; o++)
      n[o] = s[o](i);
    return n;
  };
}
function RX(t, e) {
  const n = { ...t, ...e }, r = {};
  for (const s in n)
    t[s] !== void 0 && e[s] !== void 0 && (r[s] = dC(t[s])(t[s], e[s]));
  return (s) => {
    for (const i in r)
      n[i] = r[i](s);
    return n;
  };
}
function IX(t, e) {
  var n;
  const r = [], s = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < e.values.length; i++) {
    const o = e.types[i], a = t.indexes[o][s[o]], l = (n = t.values[a]) !== null && n !== void 0 ? n : 0;
    r[i] = l, s[o]++;
  }
  return r;
}
const PX = (t, e) => {
  const n = Jo.createTransformer(e), r = xd(t), s = xd(e);
  return r.indexes.var.length === s.indexes.var.length && r.indexes.color.length === s.indexes.color.length && r.indexes.number.length >= s.indexes.number.length ? F1.has(t) && !s.values.length || F1.has(e) && !r.values.length ? kX(t, e) : Xf(S6(IX(r, s), s.values), n) : (Su(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Zg(t, e));
};
function x6(t, e, n) {
  return typeof t == "number" && typeof e == "number" && typeof n == "number" ? Ut(t, e, n) : dC(t)(t, e);
}
const OX = 5;
function T6(t, e, n) {
  const r = Math.max(e - OX, 0);
  return XB(n - t(r), e - r);
}
const zt = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, tR = 1e-3;
function DX({ duration: t = zt.duration, bounce: e = zt.bounce, velocity: n = zt.velocity, mass: r = zt.mass }) {
  let s, i;
  Su(t <= /* @__PURE__ */ _s(zt.maxDuration), "Spring duration must be 10 seconds or less");
  let o = 1 - e;
  o = lo(zt.minDamping, zt.maxDamping, o), t = lo(zt.minDuration, zt.maxDuration, /* @__PURE__ */ bi(t)), o < 1 ? (s = (c) => {
    const u = c * o, h = u * t, d = u - n, f = $1(c, o), g = Math.exp(-h);
    return tR - d / f * g;
  }, i = (c) => {
    const h = c * o * t, d = h * n + n, f = Math.pow(o, 2) * Math.pow(c, 2) * t, g = Math.exp(-h), y = $1(Math.pow(c, 2), o);
    return (-s(c) + tR > 0 ? -1 : 1) * ((d - f) * g) / y;
  }) : (s = (c) => {
    const u = Math.exp(-c * t), h = (c - n) * t + 1;
    return -1e-3 + u * h;
  }, i = (c) => {
    const u = Math.exp(-c * t), h = (n - c) * (t * t);
    return u * h;
  });
  const a = 5 / t, l = LX(s, i, a);
  if (t = /* @__PURE__ */ _s(t), isNaN(l))
    return {
      stiffness: zt.stiffness,
      damping: zt.damping,
      duration: t
    };
  {
    const c = Math.pow(l, 2) * r;
    return {
      stiffness: c,
      damping: o * 2 * Math.sqrt(r * c),
      duration: t
    };
  }
}
const NX = 12;
function LX(t, e, n) {
  let r = n;
  for (let s = 1; s < NX; s++)
    r = r - t(r) / e(r);
  return r;
}
function $1(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const MX = ["duration", "bounce"], BX = ["stiffness", "damping", "mass"];
function nR(t, e) {
  return e.some((n) => t[n] !== void 0);
}
function FX(t) {
  let e = {
    velocity: zt.velocity,
    stiffness: zt.stiffness,
    damping: zt.damping,
    mass: zt.mass,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!nR(t, BX) && nR(t, MX))
    if (t.visualDuration) {
      const n = t.visualDuration, r = 2 * Math.PI / (n * 1.2), s = r * r, i = 2 * lo(0.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(s);
      e = {
        ...e,
        mass: zt.mass,
        stiffness: s,
        damping: i
      };
    } else {
      const n = DX(t);
      e = {
        ...e,
        ...n,
        mass: zt.mass
      }, e.isResolvedFromDuration = !0;
    }
  return e;
}
function fC(t = zt.visualDuration, e = zt.bounce) {
  const n = typeof t != "object" ? {
    visualDuration: t,
    keyframes: [0, 1],
    bounce: e
  } : t;
  let { restSpeed: r, restDelta: s } = n;
  const i = n.keyframes[0], o = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: i }, { stiffness: l, damping: c, mass: u, duration: h, velocity: d, isResolvedFromDuration: f } = FX({
    ...n,
    velocity: -/* @__PURE__ */ bi(n.velocity || 0)
  }), g = d || 0, y = c / (2 * Math.sqrt(l * u)), p = o - i, m = /* @__PURE__ */ bi(Math.sqrt(l / u)), b = Math.abs(p) < 5;
  r || (r = b ? zt.restSpeed.granular : zt.restSpeed.default), s || (s = b ? zt.restDelta.granular : zt.restDelta.default);
  let _;
  if (y < 1) {
    const w = $1(m, y);
    _ = (E) => {
      const x = Math.exp(-y * m * E);
      return o - x * ((g + y * m * p) / w * Math.sin(w * E) + p * Math.cos(w * E));
    };
  } else if (y === 1)
    _ = (w) => o - Math.exp(-m * w) * (p + (g + m * p) * w);
  else {
    const w = m * Math.sqrt(y * y - 1);
    _ = (E) => {
      const x = Math.exp(-y * m * E), S = Math.min(w * E, 300);
      return o - x * ((g + y * m * p) * Math.sinh(S) + w * p * Math.cosh(S)) / w;
    };
  }
  const v = {
    calculatedDuration: f && h || null,
    next: (w) => {
      const E = _(w);
      if (f)
        a.done = w >= h;
      else {
        let x = 0;
        y < 1 && (x = w === 0 ? /* @__PURE__ */ _s(g) : T6(_, w, E));
        const S = Math.abs(x) <= r, T = Math.abs(o - E) <= s;
        a.done = S && T;
      }
      return a.value = a.done ? o : E, a;
    },
    toString: () => {
      const w = Math.min(tC(v), Kg), E = GB((x) => v.next(w * x).value, w, 30);
      return w + "ms " + E;
    }
  };
  return v;
}
function rR({ keyframes: t, velocity: e = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: s = 10, bounceStiffness: i = 500, modifyTarget: o, min: a, max: l, restDelta: c = 0.5, restSpeed: u }) {
  const h = t[0], d = {
    done: !1,
    value: h
  }, f = (S) => a !== void 0 && S < a || l !== void 0 && S > l, g = (S) => a === void 0 ? l : l === void 0 || Math.abs(a - S) < Math.abs(l - S) ? a : l;
  let y = n * e;
  const p = h + y, m = o === void 0 ? p : o(p);
  m !== p && (y = m - h);
  const b = (S) => -y * Math.exp(-S / r), _ = (S) => m + b(S), v = (S) => {
    const T = b(S), R = _(S);
    d.done = Math.abs(T) <= c, d.value = d.done ? m : R;
  };
  let w, E;
  const x = (S) => {
    f(d.value) && (w = S, E = fC({
      keyframes: [d.value, g(d.value)],
      velocity: T6(_, S, d.value),
      // TODO: This should be passing * 1000
      damping: s,
      stiffness: i,
      restDelta: c,
      restSpeed: u
    }));
  };
  return x(0), {
    calculatedDuration: null,
    next: (S) => {
      let T = !1;
      return !E && w === void 0 && (T = !0, v(S), x(S)), w !== void 0 && S >= w ? E.next(S - w) : (!T && v(S), d);
    }
  };
}
const $X = /* @__PURE__ */ Nl(0.42, 0, 1, 1), UX = /* @__PURE__ */ Nl(0, 0, 0.58, 1), C6 = /* @__PURE__ */ Nl(0.42, 0, 0.58, 1), k6 = (t) => Array.isArray(t) && typeof t[0] != "number", sR = {
  linear: yr,
  easeIn: $X,
  easeInOut: C6,
  easeOut: UX,
  circIn: aC,
  circInOut: a6,
  circOut: o6,
  backIn: oC,
  backInOut: s6,
  backOut: r6,
  anticipate: i6
}, iR = (t) => {
  if (nC(t)) {
    Si(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, n, r, s] = t;
    return Nl(e, n, r, s);
  } else if (typeof t == "string")
    return Si(sR[t] !== void 0, `Invalid easing type '${t}'`), sR[t];
  return t;
};
function jX(t, e, n) {
  const r = [], s = n || x6, i = t.length - 1;
  for (let o = 0; o < i; o++) {
    let a = s(t[o], t[o + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[o] || yr : e;
      a = Xf(l, a);
    }
    r.push(a);
  }
  return r;
}
function HX(t, e, { clamp: n = !0, ease: r, mixer: s } = {}) {
  const i = t.length;
  if (Si(i === e.length, "Both input and output ranges must be the same length"), i === 1)
    return () => e[0];
  if (i === 2 && e[0] === e[1])
    return () => e[1];
  const o = t[0] === t[1];
  t[0] > t[i - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const a = jX(e, r, s), l = a.length, c = (u) => {
    if (o && u < t[0])
      return e[0];
    let h = 0;
    if (l > 1)
      for (; h < t.length - 2 && !(u < t[h + 1]); h++)
        ;
    const d = /* @__PURE__ */ ul(t[h], t[h + 1], u);
    return a[h](d);
  };
  return n ? (u) => c(lo(t[0], t[i - 1], u)) : c;
}
function A6(t, e) {
  const n = t[t.length - 1];
  for (let r = 1; r <= e; r++) {
    const s = /* @__PURE__ */ ul(0, e, r);
    t.push(Ut(n, 1, s));
  }
}
function R6(t) {
  const e = [0];
  return A6(e, t.length - 1), e;
}
function zX(t, e) {
  return t.map((n) => n * e);
}
function GX(t, e) {
  return t.map(() => e || C6).splice(0, t.length - 1);
}
function Jg({ duration: t = 300, keyframes: e, times: n, ease: r = "easeInOut" }) {
  const s = k6(r) ? r.map(iR) : iR(r), i = {
    done: !1,
    value: e[0]
  }, o = zX(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === e.length ? n : R6(e),
    t
  ), a = HX(o, e, {
    ease: Array.isArray(s) ? s : GX(e, s)
  });
  return {
    calculatedDuration: t,
    next: (l) => (i.value = a(l), i.done = l >= t, i)
  };
}
const VX = (t) => {
  const e = ({ timestamp: n }) => t(n);
  return {
    start: () => Mt.update(e, !0),
    stop: () => Zo(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Tn.isProcessing ? Tn.timestamp : vi.now()
  };
}, WX = {
  decay: rR,
  inertia: rR,
  tween: Jg,
  keyframes: Jg,
  spring: fC
}, qX = (t) => t / 100;
class pC extends E6 {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: l } = this.options;
      l && l();
    };
    const { name: n, motionValue: r, element: s, keyframes: i } = this.options, o = s?.KeyframeResolver || hC, a = (l, c) => this.onKeyframesResolved(l, c);
    this.resolver = new o(i, a, n, r, s), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(e) {
    const { type: n = "keyframes", repeat: r = 0, repeatDelay: s = 0, repeatType: i, velocity: o = 0 } = this.options, a = ib(n) ? n : WX[n] || Jg;
    let l, c;
    a !== Jg && typeof e[0] != "number" && (je.env.NODE_ENV !== "production" && Si(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), l = Xf(qX, x6(e[0], e[1])), e = [0, 100]);
    const u = a({ ...this.options, keyframes: e });
    i === "mirror" && (c = a({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -o
    })), u.calculatedDuration === null && (u.calculatedDuration = tC(u));
    const { calculatedDuration: h } = u, d = h + s, f = d * (r + 1) - s;
    return {
      generator: u,
      mirroredGenerator: c,
      mapPercentToKeyframes: l,
      calculatedDuration: h,
      resolvedDuration: d,
      totalDuration: f
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, n = !1) {
    const { resolved: r } = this;
    if (!r) {
      const { keyframes: S } = this.options;
      return { done: !0, value: S[S.length - 1] };
    }
    const { finalKeyframe: s, generator: i, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: c, totalDuration: u, resolvedDuration: h } = r;
    if (this.startTime === null)
      return i.next(0);
    const { delay: d, repeat: f, repeatType: g, repeatDelay: y, onUpdate: p } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - u / this.speed, this.startTime)), n ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const m = this.currentTime - d * (this.speed >= 0 ? 1 : -1), b = this.speed >= 0 ? m < 0 : m > u;
    this.currentTime = Math.max(m, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = u);
    let _ = this.currentTime, v = i;
    if (f) {
      const S = Math.min(this.currentTime, u) / h;
      let T = Math.floor(S), R = S % 1;
      !R && S >= 1 && (R = 1), R === 1 && T--, T = Math.min(T, f + 1), !!(T % 2) && (g === "reverse" ? (R = 1 - R, y && (R -= y / h)) : g === "mirror" && (v = o)), _ = lo(0, 1, R) * h;
    }
    const w = b ? { done: !1, value: l[0] } : v.next(_);
    a && (w.value = a(w.value));
    let { done: E } = w;
    !b && c !== null && (E = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
    const x = this.holdTime === null && (this.state === "finished" || this.state === "running" && E);
    return x && s !== void 0 && (w.value = ab(l, this.options, s)), p && p(w.value), x && this.finish(), w;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? /* @__PURE__ */ bi(e.calculatedDuration) : 0;
  }
  get time() {
    return /* @__PURE__ */ bi(this.currentTime);
  }
  set time(e) {
    e = /* @__PURE__ */ _s(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const n = this.playbackSpeed !== e;
    this.playbackSpeed = e, n && (this.time = /* @__PURE__ */ bi(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = VX, onPlay: n, startTime: r } = this.options;
    this.driver || (this.driver = e((i) => this.tick(i))), n && n();
    const s = this.driver.now();
    this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = s) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const KX = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]);
function YX(t, e, n, { delay: r = 0, duration: s = 300, repeat: i = 0, repeatType: o = "loop", ease: a = "easeInOut", times: l } = {}) {
  const c = { [e]: n };
  l && (c.offset = l);
  const u = WB(a, s);
  return Array.isArray(u) && (c.easing = u), t.animate(c, {
    delay: r,
    duration: s,
    easing: Array.isArray(u) ? "linear" : u,
    fill: "both",
    iterations: i + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
const ZX = /* @__PURE__ */ UT(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Xg = 10, JX = 2e4;
function XX(t) {
  return ib(t.type) || t.type === "spring" || !VB(t.ease);
}
function QX(t, e) {
  const n = new pC({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let r = { done: !1, value: t[0] };
  const s = [];
  let i = 0;
  for (; !r.done && i < JX; )
    r = n.sample(i), s.push(r.value), i += Xg;
  return {
    times: void 0,
    keyframes: s,
    duration: i - Xg,
    ease: "linear"
  };
}
const I6 = {
  anticipate: i6,
  backInOut: s6,
  circInOut: a6
};
function eQ(t) {
  return t in I6;
}
class oR extends E6 {
  constructor(e) {
    super(e);
    const { name: n, motionValue: r, element: s, keyframes: i } = this.options;
    this.resolver = new w6(i, (o, a) => this.onKeyframesResolved(o, a), n, r, s), this.resolver.scheduleResolve();
  }
  initPlayback(e, n) {
    let { duration: r = 300, times: s, ease: i, type: o, motionValue: a, name: l, startTime: c } = this.options;
    if (!a.owner || !a.owner.current)
      return !1;
    if (typeof i == "string" && Yg() && eQ(i) && (i = I6[i]), XX(this.options)) {
      const { onComplete: h, onUpdate: d, motionValue: f, element: g, ...y } = this.options, p = QX(e, y);
      e = p.keyframes, e.length === 1 && (e[1] = e[0]), r = p.duration, s = p.times, i = p.ease, o = "keyframes";
    }
    const u = YX(a.owner.current, l, e, { ...this.options, duration: r, times: s, ease: i });
    return u.startTime = c ?? this.calcStartTime(), this.pendingTimeline ? (H2(u, this.pendingTimeline), this.pendingTimeline = void 0) : u.onfinish = () => {
      const { onComplete: h } = this.options;
      a.set(ab(e, this.options, n)), h && h(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: u,
      duration: r,
      times: s,
      type: o,
      ease: i,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: n } = e;
    return /* @__PURE__ */ bi(n);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: n } = e;
    return /* @__PURE__ */ bi(n.currentTime || 0);
  }
  set time(e) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: r } = n;
    r.currentTime = /* @__PURE__ */ _s(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: n } = e;
    return n.playbackRate;
  }
  set speed(e) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: r } = n;
    r.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: n } = e;
    return n.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: n } = e;
    return n.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: n } = this;
      if (!n)
        return yr;
      const { animation: r } = n;
      H2(r, e);
    }
    return yr;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n } = e;
    n.playState === "finished" && this.updateFinishedPromise(), n.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n } = e;
    n.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n, keyframes: r, duration: s, type: i, ease: o, times: a } = e;
    if (n.playState === "idle" || n.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: c, onUpdate: u, onComplete: h, element: d, ...f } = this.options, g = new pC({
        ...f,
        keyframes: r,
        duration: s,
        type: i,
        ease: o,
        times: a,
        isGenerator: !0
      }), y = /* @__PURE__ */ _s(this.time);
      c.setWithVelocity(g.sample(y - Xg).value, g.sample(y).value, Xg);
    }
    const { onStop: l } = this.options;
    l && l(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: n, name: r, repeatDelay: s, repeatType: i, damping: o, type: a } = e;
    if (!n || !n.owner || !(n.owner.current instanceof HTMLElement))
      return !1;
    const { onUpdate: l, transformTemplate: c } = n.owner.getProps();
    return ZX() && r && KX.has(r) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !l && !c && !s && i !== "mirror" && o !== 0 && a !== "inertia";
  }
}
const tQ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, nQ = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), rQ = {
  type: "keyframes",
  duration: 0.8
}, sQ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, iQ = (t, { keyframes: e }) => e.length > 2 ? rQ : Dl.has(t) ? t.startsWith("scale") ? nQ(e[1]) : tQ : sQ;
function oQ({ when: t, delay: e, delayChildren: n, staggerChildren: r, staggerDirection: s, repeat: i, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...u }) {
  return !!Object.keys(u).length;
}
const mC = (t, e, n, r = {}, s, i) => (o) => {
  const a = eC(r, t) || {}, l = a.delay || r.delay || 0;
  let { elapsed: c = 0 } = r;
  c = c - /* @__PURE__ */ _s(l);
  let u = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...a,
    delay: -c,
    onUpdate: (d) => {
      e.set(d), a.onUpdate && a.onUpdate(d);
    },
    onComplete: () => {
      o(), a.onComplete && a.onComplete();
    },
    name: t,
    motionValue: e,
    element: i ? void 0 : s
  };
  oQ(a) || (u = {
    ...u,
    ...iQ(t, u)
  }), u.duration && (u.duration = /* @__PURE__ */ _s(u.duration)), u.repeatDelay && (u.repeatDelay = /* @__PURE__ */ _s(u.repeatDelay)), u.from !== void 0 && (u.keyframes[0] = u.from);
  let h = !1;
  if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0, u.delay === 0 && (h = !0)), h && !i && e.get() !== void 0) {
    const d = ab(u.keyframes, a);
    if (d !== void 0)
      return Mt.update(() => {
        u.onUpdate(d), u.onComplete();
      }), new zB([]);
  }
  return !i && oR.supports(u) ? new oR(u) : new pC(u);
};
function aQ({ protectedKeys: t, needsAnimating: e }, n) {
  const r = t.hasOwnProperty(n) && e[n] !== !0;
  return e[n] = !1, r;
}
function gC(t, e, { delay: n = 0, transitionOverride: r, type: s } = {}) {
  var i;
  let { transition: o = t.getDefaultTransition(), transitionEnd: a, ...l } = e;
  r && (o = r);
  const c = [], u = s && t.animationState && t.animationState.getState()[s];
  for (const h in l) {
    const d = t.getValue(h, (i = t.latestValues[h]) !== null && i !== void 0 ? i : null), f = l[h];
    if (f === void 0 || u && aQ(u, h))
      continue;
    const g = {
      delay: n,
      ...eC(o || {}, h)
    };
    let y = !1;
    if (window.MotionHandoffAnimation) {
      const m = QB(t);
      if (m) {
        const b = window.MotionHandoffAnimation(m, h, Mt);
        b !== null && (g.startTime = b, y = !0);
      }
    }
    D1(t, h), d.start(mC(h, d, f, t.shouldReduceMotion && JB.has(h) ? { type: !1 } : g, t, y));
    const p = d.animation;
    p && c.push(p);
  }
  return a && Promise.all(c).then(() => {
    Mt.update(() => {
      a && HJ(t, a);
    });
  }), c;
}
function U1(t, e, n = {}) {
  var r;
  const s = sb(t, e, n.type === "exit" ? (r = t.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
  let { transition: i = t.getDefaultTransition() || {} } = s || {};
  n.transitionOverride && (i = n.transitionOverride);
  const o = s ? () => Promise.all(gC(t, s, n)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (c = 0) => {
    const { delayChildren: u = 0, staggerChildren: h, staggerDirection: d } = i;
    return lQ(t, e, u + c, h, d, n);
  } : () => Promise.resolve(), { when: l } = i;
  if (l) {
    const [c, u] = l === "beforeChildren" ? [o, a] : [a, o];
    return c().then(() => u());
  } else
    return Promise.all([o(), a(n.delay)]);
}
function lQ(t, e, n = 0, r = 0, s = 1, i) {
  const o = [], a = (t.variantChildren.size - 1) * r, l = s === 1 ? (c = 0) => c * r : (c = 0) => a - c * r;
  return Array.from(t.variantChildren).sort(cQ).forEach((c, u) => {
    c.notify("AnimationStart", e), o.push(U1(c, e, {
      ...i,
      delay: n + l(u)
    }).then(() => c.notify("AnimationComplete", e)));
  }), Promise.all(o);
}
function cQ(t, e) {
  return t.sortNodePosition(e);
}
function uQ(t, e, n = {}) {
  t.notify("AnimationStart", e);
  let r;
  if (Array.isArray(e)) {
    const s = e.map((i) => U1(t, i, n));
    r = Promise.all(s);
  } else if (typeof e == "string")
    r = U1(t, e, n);
  else {
    const s = typeof e == "function" ? sb(t, e, n.custom) : e;
    r = Promise.all(gC(t, s, n));
  }
  return r.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const hQ = HT.length;
function P6(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const n = t.parent ? P6(t.parent) || {} : {};
    return t.props.initial !== void 0 && (n.initial = t.props.initial), n;
  }
  const e = {};
  for (let n = 0; n < hQ; n++) {
    const r = HT[n], s = t.props[r];
    (wd(s) || s === !1) && (e[r] = s);
  }
  return e;
}
const dQ = [...jT].reverse(), fQ = jT.length;
function pQ(t) {
  return (e) => Promise.all(e.map(({ animation: n, options: r }) => uQ(t, n, r)));
}
function mQ(t) {
  let e = pQ(t), n = aR(), r = !0;
  const s = (l) => (c, u) => {
    var h;
    const d = sb(t, u, l === "exit" ? (h = t.presenceContext) === null || h === void 0 ? void 0 : h.custom : void 0);
    if (d) {
      const { transition: f, transitionEnd: g, ...y } = d;
      c = { ...c, ...y, ...g };
    }
    return c;
  };
  function i(l) {
    e = l(t);
  }
  function o(l) {
    const { props: c } = t, u = P6(t.parent) || {}, h = [], d = /* @__PURE__ */ new Set();
    let f = {}, g = 1 / 0;
    for (let p = 0; p < fQ; p++) {
      const m = dQ[p], b = n[m], _ = c[m] !== void 0 ? c[m] : u[m], v = wd(_), w = m === l ? b.isActive : null;
      w === !1 && (g = p);
      let E = _ === u[m] && _ !== c[m] && v;
      if (E && r && t.manuallyAnimateOnMount && (E = !1), b.protectedKeys = { ...f }, // If it isn't active and hasn't *just* been set as inactive
      !b.isActive && w === null || // If we didn't and don't have any defined prop for this animation type
      !_ && !b.prevProp || // Or if the prop doesn't define an animation
      nb(_) || typeof _ == "boolean")
        continue;
      const x = gQ(b.prevProp, _);
      let S = x || // If we're making this variant active, we want to always make it active
      m === l && b.isActive && !E && v || // If we removed a higher-priority variant (i is in reverse order)
      p > g && v, T = !1;
      const R = Array.isArray(_) ? _ : [_];
      let F = R.reduce(s(m), {});
      w === !1 && (F = {});
      const { prevResolvedValues: P = {} } = b, M = {
        ...P,
        ...F
      }, A = (K) => {
        S = !0, d.has(K) && (T = !0, d.delete(K)), b.needsAnimating[K] = !0;
        const te = t.getValue(K);
        te && (te.liveStyle = !1);
      };
      for (const K in M) {
        const te = F[K], N = P[K];
        if (f.hasOwnProperty(K))
          continue;
        let L = !1;
        P1(te) && P1(N) ? L = !HB(te, N) : L = te !== N, L ? te != null ? A(K) : d.add(K) : te !== void 0 && d.has(K) ? A(K) : b.protectedKeys[K] = !0;
      }
      b.prevProp = _, b.prevResolvedValues = F, b.isActive && (f = { ...f, ...F }), r && t.blockInitialAnimation && (S = !1), S && (!(E && x) || T) && h.push(...R.map((K) => ({
        animation: K,
        options: { type: m }
      })));
    }
    if (d.size) {
      const p = {};
      d.forEach((m) => {
        const b = t.getBaseTarget(m), _ = t.getValue(m);
        _ && (_.liveStyle = !0), p[m] = b ?? null;
      }), h.push({ animation: p });
    }
    let y = !!h.length;
    return r && (c.initial === !1 || c.initial === c.animate) && !t.manuallyAnimateOnMount && (y = !1), r = !1, y ? e(h) : Promise.resolve();
  }
  function a(l, c) {
    var u;
    if (n[l].isActive === c)
      return Promise.resolve();
    (u = t.variantChildren) === null || u === void 0 || u.forEach((d) => {
      var f;
      return (f = d.animationState) === null || f === void 0 ? void 0 : f.setActive(l, c);
    }), n[l].isActive = c;
    const h = o(l);
    for (const d in n)
      n[d].protectedKeys = {};
    return h;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: i,
    getState: () => n,
    reset: () => {
      n = aR(), r = !0;
    }
  };
}
function gQ(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !HB(e, t) : !1;
}
function Sa(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function aR() {
  return {
    animate: Sa(!0),
    whileInView: Sa(),
    whileHover: Sa(),
    whileTap: Sa(),
    whileDrag: Sa(),
    whileFocus: Sa(),
    exit: Sa()
  };
}
class ga {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class yQ extends ga {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = mQ(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    nb(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    e !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let bQ = 0;
class _Q extends ga {
  constructor() {
    super(...arguments), this.id = bQ++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r)
      return;
    const s = this.node.animationState.setActive("exit", !e);
    n && !e && s.then(() => n(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const vQ = {
  animation: {
    Feature: yQ
  },
  exit: {
    Feature: _Q
  }
};
function Td(t, e, n, r = { passive: !0 }) {
  return t.addEventListener(e, n, r), () => t.removeEventListener(e, n);
}
function Qf(t) {
  return {
    point: {
      x: t.pageX,
      y: t.pageY
    }
  };
}
const wQ = (t) => (e) => rC(e) && t(e, Qf(e));
function $h(t, e, n, r) {
  return Td(t, e, wQ(n), r);
}
const lR = (t, e) => Math.abs(t - e);
function EQ(t, e) {
  const n = lR(t.x, e.x), r = lR(t.y, e.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
class O6 {
  constructor(e, n, { transformPagePoint: r, contextWindow: s, dragSnapToOrigin: i = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const h = z_(this.lastMoveEventInfo, this.history), d = this.startEvent !== null, f = EQ(h.offset, { x: 0, y: 0 }) >= 3;
      if (!d && !f)
        return;
      const { point: g } = h, { timestamp: y } = Tn;
      this.history.push({ ...g, timestamp: y });
      const { onStart: p, onMove: m } = this.handlers;
      d || (p && p(this.lastMoveEvent, h), this.startEvent = this.lastMoveEvent), m && m(this.lastMoveEvent, h);
    }, this.handlePointerMove = (h, d) => {
      this.lastMoveEvent = h, this.lastMoveEventInfo = H_(d, this.transformPagePoint), Mt.update(this.updatePoint, !0);
    }, this.handlePointerUp = (h, d) => {
      this.end();
      const { onEnd: f, onSessionEnd: g, resumeAnimation: y } = this.handlers;
      if (this.dragSnapToOrigin && y && y(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const p = z_(h.type === "pointercancel" ? this.lastMoveEventInfo : H_(d, this.transformPagePoint), this.history);
      this.startEvent && f && f(h, p), g && g(h, p);
    }, !rC(e))
      return;
    this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r, this.contextWindow = s || window;
    const o = Qf(e), a = H_(o, this.transformPagePoint), { point: l } = a, { timestamp: c } = Tn;
    this.history = [{ ...l, timestamp: c }];
    const { onSessionStart: u } = n;
    u && u(e, z_(a, this.history)), this.removeListeners = Xf($h(this.contextWindow, "pointermove", this.handlePointerMove), $h(this.contextWindow, "pointerup", this.handlePointerUp), $h(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Zo(this.updatePoint);
  }
}
function H_(t, e) {
  return e ? { point: e(t.point) } : t;
}
function cR(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function z_({ point: t }, e) {
  return {
    point: t,
    delta: cR(t, D6(e)),
    offset: cR(t, SQ(e)),
    velocity: xQ(e, 0.1)
  };
}
function SQ(t) {
  return t[0];
}
function D6(t) {
  return t[t.length - 1];
}
function xQ(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let n = t.length - 1, r = null;
  const s = D6(t);
  for (; n >= 0 && (r = t[n], !(s.timestamp - r.timestamp > /* @__PURE__ */ _s(e))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const i = /* @__PURE__ */ bi(s.timestamp - r.timestamp);
  if (i === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (s.x - r.x) / i,
    y: (s.y - r.y) / i
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
const N6 = 1e-4, TQ = 1 - N6, CQ = 1 + N6, L6 = 0.01, kQ = 0 - L6, AQ = 0 + L6;
function Mr(t) {
  return t.max - t.min;
}
function RQ(t, e, n) {
  return Math.abs(t - e) <= n;
}
function uR(t, e, n, r = 0.5) {
  t.origin = r, t.originPoint = Ut(e.min, e.max, t.origin), t.scale = Mr(n) / Mr(e), t.translate = Ut(n.min, n.max, t.origin) - t.originPoint, (t.scale >= TQ && t.scale <= CQ || isNaN(t.scale)) && (t.scale = 1), (t.translate >= kQ && t.translate <= AQ || isNaN(t.translate)) && (t.translate = 0);
}
function Uh(t, e, n, r) {
  uR(t.x, e.x, n.x, r ? r.originX : void 0), uR(t.y, e.y, n.y, r ? r.originY : void 0);
}
function hR(t, e, n) {
  t.min = n.min + e.min, t.max = t.min + Mr(e);
}
function IQ(t, e, n) {
  hR(t.x, e.x, n.x), hR(t.y, e.y, n.y);
}
function dR(t, e, n) {
  t.min = e.min - n.min, t.max = t.min + Mr(e);
}
function jh(t, e, n) {
  dR(t.x, e.x, n.x), dR(t.y, e.y, n.y);
}
function PQ(t, { min: e, max: n }, r) {
  return e !== void 0 && t < e ? t = r ? Ut(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? Ut(n, t, r.max) : Math.min(t, n)), t;
}
function fR(t, e, n) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
  };
}
function OQ(t, { top: e, left: n, bottom: r, right: s }) {
  return {
    x: fR(t.x, n, s),
    y: fR(t.y, e, r)
  };
}
function pR(t, e) {
  let n = e.min - t.min, r = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), { min: n, max: r };
}
function DQ(t, e) {
  return {
    x: pR(t.x, e.x),
    y: pR(t.y, e.y)
  };
}
function NQ(t, e) {
  let n = 0.5;
  const r = Mr(t), s = Mr(e);
  return s > r ? n = /* @__PURE__ */ ul(e.min, e.max - r, t.min) : r > s && (n = /* @__PURE__ */ ul(t.min, t.max - s, e.min)), lo(0, 1, n);
}
function LQ(t, e) {
  const n = {};
  return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;
}
const j1 = 0.35;
function MQ(t = j1) {
  return t === !1 ? t = 0 : t === !0 && (t = j1), {
    x: mR(t, "left", "right"),
    y: mR(t, "top", "bottom")
  };
}
function mR(t, e, n) {
  return {
    min: gR(t, e),
    max: gR(t, n)
  };
}
function gR(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const yR = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), dc = () => ({
  x: yR(),
  y: yR()
}), bR = () => ({ min: 0, max: 0 }), qt = () => ({
  x: bR(),
  y: bR()
});
function zr(t) {
  return [t("x"), t("y")];
}
function M6({ top: t, left: e, right: n, bottom: r }) {
  return {
    x: { min: e, max: n },
    y: { min: t, max: r }
  };
}
function BQ({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function FQ(t, e) {
  if (!e)
    return t;
  const n = e({ x: t.left, y: t.top }), r = e({ x: t.right, y: t.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function G_(t) {
  return t === void 0 || t === 1;
}
function H1({ scale: t, scaleX: e, scaleY: n }) {
  return !G_(t) || !G_(e) || !G_(n);
}
function Ia(t) {
  return H1(t) || B6(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function B6(t) {
  return _R(t.x) || _R(t.y);
}
function _R(t) {
  return t && t !== "0%";
}
function Qg(t, e, n) {
  const r = t - n, s = e * r;
  return n + s;
}
function vR(t, e, n, r, s) {
  return s !== void 0 && (t = Qg(t, s, r)), Qg(t, n, r) + e;
}
function z1(t, e = 0, n = 1, r, s) {
  t.min = vR(t.min, e, n, r, s), t.max = vR(t.max, e, n, r, s);
}
function F6(t, { x: e, y: n }) {
  z1(t.x, e.translate, e.scale, e.originPoint), z1(t.y, n.translate, n.scale, n.originPoint);
}
const wR = 0.999999999999, ER = 1.0000000000001;
function $Q(t, e, n, r = !1) {
  const s = n.length;
  if (!s)
    return;
  e.x = e.y = 1;
  let i, o;
  for (let a = 0; a < s; a++) {
    i = n[a], o = i.projectionDelta;
    const { visualElement: l } = i.options;
    l && l.props.style && l.props.style.display === "contents" || (r && i.options.layoutScroll && i.scroll && i !== i.root && pc(t, {
      x: -i.scroll.offset.x,
      y: -i.scroll.offset.y
    }), o && (e.x *= o.x.scale, e.y *= o.y.scale, F6(t, o)), r && Ia(i.latestValues) && pc(t, i.latestValues));
  }
  e.x < ER && e.x > wR && (e.x = 1), e.y < ER && e.y > wR && (e.y = 1);
}
function fc(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function SR(t, e, n, r, s = 0.5) {
  const i = Ut(t.min, t.max, s);
  z1(t, e, n, i, r);
}
function pc(t, e) {
  SR(t.x, e.x, e.scaleX, e.scale, e.originX), SR(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function $6(t, e) {
  return M6(FQ(t.getBoundingClientRect(), e));
}
function UQ(t, e, n) {
  const r = $6(t, n), { scroll: s } = e;
  return s && (fc(r.x, s.offset.x), fc(r.y, s.offset.y)), r;
}
const U6 = ({ current: t }) => t ? t.ownerDocument.defaultView : null, jQ = /* @__PURE__ */ new WeakMap();
class HQ {
  constructor(e) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = qt(), this.visualElement = e;
  }
  start(e, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1)
      return;
    const s = (u) => {
      const { dragSnapToOrigin: h } = this.getProps();
      h ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(Qf(u).point);
    }, i = (u, h) => {
      const { drag: d, dragPropagation: f, onDragStart: g } = this.getProps();
      if (d && !f && (this.openDragLock && this.openDragLock(), this.openDragLock = BJ(d), !this.openDragLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), zr((p) => {
        let m = this.getAxisMotionValue(p).get() || 0;
        if (_i.test(m)) {
          const { projection: b } = this.visualElement;
          if (b && b.layout) {
            const _ = b.layout.layoutBox[p];
            _ && (m = Mr(_) * (parseFloat(m) / 100));
          }
        }
        this.originPoint[p] = m;
      }), g && Mt.postRender(() => g(u, h)), D1(this.visualElement, "transform");
      const { animationState: y } = this.visualElement;
      y && y.setActive("whileDrag", !0);
    }, o = (u, h) => {
      const { dragPropagation: d, dragDirectionLock: f, onDirectionLock: g, onDrag: y } = this.getProps();
      if (!d && !this.openDragLock)
        return;
      const { offset: p } = h;
      if (f && this.currentDirection === null) {
        this.currentDirection = zQ(p), this.currentDirection !== null && g && g(this.currentDirection);
        return;
      }
      this.updateAxis("x", h.point, p), this.updateAxis("y", h.point, p), this.visualElement.render(), y && y(u, h);
    }, a = (u, h) => this.stop(u, h), l = () => zr((u) => {
      var h;
      return this.getAnimationState(u) === "paused" && ((h = this.getAxisMotionValue(u).animation) === null || h === void 0 ? void 0 : h.play());
    }), { dragSnapToOrigin: c } = this.getProps();
    this.panSession = new O6(e, {
      onSessionStart: s,
      onStart: i,
      onMove: o,
      onSessionEnd: a,
      resumeAnimation: l
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: c,
      contextWindow: U6(this.visualElement)
    });
  }
  stop(e, n) {
    const r = this.isDragging;
    if (this.cancel(), !r)
      return;
    const { velocity: s } = n;
    this.startAnimation(s);
    const { onDragEnd: i } = this.getProps();
    i && Mt.postRender(() => i(e, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: n } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(e, n, r) {
    const { drag: s } = this.getProps();
    if (!r || !Up(e, s, this.currentDirection))
      return;
    const i = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + r[e];
    this.constraints && this.constraints[e] && (o = PQ(o, this.constraints[e], this.elastic[e])), i.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: n, dragElastic: r } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, i = this.constraints;
    n && uc(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && s ? this.constraints = OQ(s.layoutBox, n) : this.constraints = !1, this.elastic = MQ(r), i !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && zr((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = LQ(s.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps();
    if (!e || !uc(e))
      return !1;
    const r = e.current;
    Si(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: s } = this.visualElement;
    if (!s || !s.layout)
      return !1;
    const i = UQ(r, s.root, this.visualElement.getTransformPagePoint());
    let o = DQ(s.layout.layoutBox, i);
    if (n) {
      const a = n(BQ(o));
      this.hasMutatedConstraints = !!a, a && (o = M6(a));
    }
    return o;
  }
  startAnimation(e) {
    const { drag: n, dragMomentum: r, dragElastic: s, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, c = zr((u) => {
      if (!Up(u, n, this.currentDirection))
        return;
      let h = l && l[u] || {};
      o && (h = { min: 0, max: 0 });
      const d = s ? 200 : 1e6, f = s ? 40 : 1e7, g = {
        type: "inertia",
        velocity: r ? e[u] : 0,
        bounceStiffness: d,
        bounceDamping: f,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...i,
        ...h
      };
      return this.startAxisValueAnimation(u, g);
    });
    return Promise.all(c).then(a);
  }
  startAxisValueAnimation(e, n) {
    const r = this.getAxisMotionValue(e);
    return D1(this.visualElement, e), r.start(mC(e, r, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    zr((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    zr((e) => {
      var n;
      return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.pause();
    });
  }
  getAnimationState(e) {
    var n;
    return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const n = `_drag${e.toUpperCase()}`, r = this.visualElement.getProps(), s = r[n];
    return s || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    zr((n) => {
      const { drag: r } = this.getProps();
      if (!Up(n, r, this.currentDirection))
        return;
      const { projection: s } = this.visualElement, i = this.getAxisMotionValue(n);
      if (s && s.layout) {
        const { min: o, max: a } = s.layout.layoutBox[n];
        i.set(e[n] - Ut(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!uc(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const s = { x: 0, y: 0 };
    zr((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const l = a.get();
        s[o] = NQ({ min: l, max: l }, this.constraints[o]);
      }
    });
    const { transformTemplate: i } = this.visualElement.getProps();
    this.visualElement.current.style.transform = i ? i({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), zr((o) => {
      if (!Up(o, e, null))
        return;
      const a = this.getAxisMotionValue(o), { min: l, max: c } = this.constraints[o];
      a.set(Ut(l, c, s[o]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    jQ.set(this.visualElement, this);
    const e = this.visualElement.current, n = $h(e, "pointerdown", (l) => {
      const { drag: c, dragListener: u = !0 } = this.getProps();
      c && u && this.start(l);
    }), r = () => {
      const { dragConstraints: l } = this.getProps();
      uc(l) && l.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: s } = this.visualElement, i = s.addEventListener("measure", r);
    s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), Mt.read(r);
    const o = Td(window, "resize", () => this.scalePositionWithinConstraints()), a = s.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => {
      this.isDragging && c && (zr((u) => {
        const h = this.getAxisMotionValue(u);
        h && (this.originPoint[u] += l[u].translate, h.set(h.get() + l[u].translate));
      }), this.visualElement.render());
    });
    return () => {
      o(), n(), i(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: s = !1, dragConstraints: i = !1, dragElastic: o = j1, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: s,
      dragConstraints: i,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function Up(t, e, n) {
  return (e === !0 || e === t) && (n === null || n === t);
}
function zQ(t, e = 10) {
  let n = null;
  return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n;
}
class GQ extends ga {
  constructor(e) {
    super(e), this.removeGroupControls = yr, this.removeListeners = yr, this.controls = new HQ(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || yr;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const xR = (t) => (e, n) => {
  t && Mt.postRender(() => t(e, n));
};
class VQ extends ga {
  constructor() {
    super(...arguments), this.removePointerDownListener = yr;
  }
  onPointerDown(e) {
    this.session = new O6(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: U6(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: s } = this.node.getProps();
    return {
      onSessionStart: xR(e),
      onStart: xR(n),
      onMove: r,
      onEnd: (i, o) => {
        delete this.session, s && Mt.postRender(() => s(i, o));
      }
    };
  }
  mount() {
    this.removePointerDownListener = $h(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const ug = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function TR(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const Zu = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (Ye.test(t))
        t = parseFloat(t);
      else
        return t;
    const n = TR(t, e.target.x), r = TR(t, e.target.y);
    return `${n}% ${r}%`;
  }
}, WQ = {
  correct: (t, { treeScale: e, projectionDelta: n }) => {
    const r = t, s = Jo.parse(t);
    if (s.length > 5)
      return r;
    const i = Jo.createTransformer(t), o = typeof s[0] != "number" ? 1 : 0, a = n.x.scale * e.x, l = n.y.scale * e.y;
    s[0 + o] /= a, s[1 + o] /= l;
    const c = Ut(a, l, 0.5);
    return typeof s[2 + o] == "number" && (s[2 + o] /= c), typeof s[3 + o] == "number" && (s[3 + o] /= c), i(s);
  }
};
class qQ extends I.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: s } = this.props, { projection: i } = e;
    yJ(KQ), i && (n.group && n.group.add(i), r && r.register && s && r.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), i.setOptions({
      ...i.options,
      onExitComplete: () => this.safeToRemove()
    })), ug.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: n, visualElement: r, drag: s, isPresent: i } = this.props, o = r.projection;
    return o && (o.isPresent = i, s || e.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== i && (i ? o.promote() : o.relegate() || Mt.postRender(() => {
      const a = o.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), GT.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: s } = e;
    s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), r && r.deregister && r.deregister(s));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function j6(t) {
  const [e, n] = EB(), r = I.useContext(BT);
  return k.jsx(qQ, { ...t, layoutGroup: r, switchLayoutGroup: I.useContext(RB), isPresent: e, safeToRemove: n });
}
const KQ = {
  borderRadius: {
    ...Zu,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Zu,
  borderTopRightRadius: Zu,
  borderBottomLeftRadius: Zu,
  borderBottomRightRadius: Zu,
  boxShadow: WQ
};
function H6(t, e, n) {
  const r = wn(t) ? t : Sd(t);
  return r.start(mC("", r, e, n)), r.animation;
}
function z6(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
const YQ = (t, e) => t.depth - e.depth;
class ZQ {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    sC(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    ob(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(YQ), this.isDirty = !1, this.children.forEach(e);
  }
}
function JQ(t, e) {
  const n = vi.now(), r = ({ timestamp: s }) => {
    const i = s - n;
    i >= e && (Zo(r), t(i - e));
  };
  return Mt.read(r, !0), () => Zo(r);
}
const G6 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], XQ = G6.length, CR = (t) => typeof t == "string" ? parseFloat(t) : t, kR = (t) => typeof t == "number" || Ye.test(t);
function QQ(t, e, n, r, s, i) {
  s ? (t.opacity = Ut(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    eee(r)
  ), t.opacityExit = Ut(e.opacity !== void 0 ? e.opacity : 1, 0, tee(r))) : i && (t.opacity = Ut(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
  for (let o = 0; o < XQ; o++) {
    const a = `border${G6[o]}Radius`;
    let l = AR(e, a), c = AR(n, a);
    if (l === void 0 && c === void 0)
      continue;
    l || (l = 0), c || (c = 0), l === 0 || c === 0 || kR(l) === kR(c) ? (t[a] = Math.max(Ut(CR(l), CR(c), r), 0), (_i.test(c) || _i.test(l)) && (t[a] += "%")) : t[a] = c;
  }
  (e.rotate || n.rotate) && (t.rotate = Ut(e.rotate || 0, n.rotate || 0, r));
}
function AR(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const eee = /* @__PURE__ */ V6(0, 0.5, o6), tee = /* @__PURE__ */ V6(0.5, 0.95, yr);
function V6(t, e, n) {
  return (r) => r < t ? 0 : r > e ? 1 : n(/* @__PURE__ */ ul(t, e, r));
}
function RR(t, e) {
  t.min = e.min, t.max = e.max;
}
function jr(t, e) {
  RR(t.x, e.x), RR(t.y, e.y);
}
function IR(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function PR(t, e, n, r, s) {
  return t -= e, t = Qg(t, 1 / n, r), s !== void 0 && (t = Qg(t, 1 / s, r)), t;
}
function nee(t, e = 0, n = 1, r = 0.5, s, i = t, o = t) {
  if (_i.test(e) && (e = parseFloat(e), e = Ut(o.min, o.max, e / 100) - o.min), typeof e != "number")
    return;
  let a = Ut(i.min, i.max, r);
  t === i && (a -= e), t.min = PR(t.min, e, n, a, s), t.max = PR(t.max, e, n, a, s);
}
function OR(t, e, [n, r, s], i, o) {
  nee(t, e[n], e[r], e[s], e.scale, i, o);
}
const ree = ["x", "scaleX", "originX"], see = ["y", "scaleY", "originY"];
function DR(t, e, n, r) {
  OR(t.x, e, ree, n ? n.x : void 0, r ? r.x : void 0), OR(t.y, e, see, n ? n.y : void 0, r ? r.y : void 0);
}
function NR(t) {
  return t.translate === 0 && t.scale === 1;
}
function W6(t) {
  return NR(t.x) && NR(t.y);
}
function LR(t, e) {
  return t.min === e.min && t.max === e.max;
}
function iee(t, e) {
  return LR(t.x, e.x) && LR(t.y, e.y);
}
function MR(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function q6(t, e) {
  return MR(t.x, e.x) && MR(t.y, e.y);
}
function BR(t) {
  return Mr(t.x) / Mr(t.y);
}
function FR(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class oee {
  constructor() {
    this.members = [];
  }
  add(e) {
    sC(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (ob(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(e) {
    const n = this.members.findIndex((s) => e === s);
    if (n === 0)
      return !1;
    let r;
    for (let s = n; s >= 0; s--) {
      const i = this.members[s];
      if (i.isPresent !== !1) {
        r = i;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(e, n) {
    const r = this.lead;
    if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) {
      r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: s } = e.options;
      s === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: n, resumingFrom: r } = e;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function aee(t, e, n) {
  let r = "";
  const s = t.x.translate / e.x, i = t.y.translate / e.y, o = n?.z || 0;
  if ((s || i || o) && (r = `translate3d(${s}px, ${i}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `), n) {
    const { transformPerspective: c, rotate: u, rotateX: h, rotateY: d, skewX: f, skewY: g } = n;
    c && (r = `perspective(${c}px) ${r}`), u && (r += `rotate(${u}deg) `), h && (r += `rotateX(${h}deg) `), d && (r += `rotateY(${d}deg) `), f && (r += `skewX(${f}deg) `), g && (r += `skewY(${g}deg) `);
  }
  const a = t.x.scale * e.x, l = t.y.scale * e.y;
  return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none";
}
const Pa = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, Sh = typeof window < "u" && window.MotionDebug !== void 0, V_ = ["", "X", "Y", "Z"], lee = { visibility: "hidden" }, $R = 1e3;
let cee = 0;
function W_(t, e, n, r) {
  const { latestValues: s } = e;
  s[t] && (n[t] = s[t], e.setStaticValue(t, 0), r && (r[t] = 0));
}
function K6(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const n = QB(e);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: s, layoutId: i } = t.options;
    window.MotionCancelOptimisedAnimation(n, "transform", Mt, !(s || i));
  }
  const { parent: r } = t;
  r && !r.hasCheckedOptimisedAppear && K6(r);
}
function Y6({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: r, resetTransform: s }) {
  return class {
    constructor(o = {}, a = e?.()) {
      this.id = cee++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Sh && (Pa.totalNodes = Pa.resolvedTargetDeltas = Pa.recalculatedProjection = 0), this.nodes.forEach(dee), this.nodes.forEach(yee), this.nodes.forEach(bee), this.nodes.forEach(fee), Sh && window.MotionDebug.record(Pa);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new ZQ());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new iC()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o);
      l && l.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    /**
     * Lifecycles
     */
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = z6(o), this.instance = o;
      const { layoutId: l, layout: c, visualElement: u } = this.options;
      if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), t) {
        let h;
        const d = () => this.root.updateBlockedByResize = !1;
        t(o, () => {
          this.root.updateBlockedByResize = !0, h && h(), h = JQ(d, 250), ug.hasAnimatedSinceResize && (ug.hasAnimatedSinceResize = !1, this.nodes.forEach(jR));
        });
      }
      l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: h, hasLayoutChanged: d, hasRelativeTargetChanged: f, layout: g }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const y = this.options.transition || u.getDefaultTransition() || See, { onLayoutAnimationStart: p, onLayoutAnimationComplete: m } = u.getProps(), b = !this.targetLayout || !q6(this.targetLayout, g) || f, _ = !d && f;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || _ || d && (b || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(h, _);
          const v = {
            ...eC(y, "layout"),
            onPlay: p,
            onComplete: m
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (v.delay = 0, v.type = !1), this.startAnimation(v);
        } else
          d || jR(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = g;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Zo(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(_ee), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && K6(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u];
        h.shouldResetTransform = !0, h.updateScroll("snapshot"), h.options.layoutRoot && h.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l)
        return;
      const c = this.getTransformTemplate();
      this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(UR);
        return;
      }
      this.isUpdating || this.nodes.forEach(mee), this.isUpdating = !1, this.nodes.forEach(gee), this.nodes.forEach(uee), this.nodes.forEach(hee), this.clearAllSnapshots();
      const a = vi.now();
      Tn.delta = lo(0, 1e3 / 60, a - Tn.timestamp), Tn.timestamp = a, Tn.isProcessing = !0, B_.update.process(Tn), B_.preRender.process(Tn), B_.render.process(Tn), Tn.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, GT.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(pee), this.sharedNodes.forEach(vee);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Mt.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Mt.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++)
          this.path[l].updateScroll();
      const o = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = qt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
        const l = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: l,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l
        };
      }
    }
    resetTransform() {
      if (!s)
        return;
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !W6(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue;
      o && (a || Ia(this.latestValues) || u) && (s(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return o && (l = this.removeTransform(l)), xee(l), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: l,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: a } = this.options;
      if (!a)
        return qt();
      const l = a.measureViewportBox();
      if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(Tee))) {
        const { scroll: u } = this.root;
        u && (fc(l.x, u.offset.x), fc(l.y, u.offset.y));
      }
      return l;
    }
    removeElementScroll(o) {
      var a;
      const l = qt();
      if (jr(l, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return l;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c], { scroll: h, options: d } = u;
        u !== this.root && h && d.layoutScroll && (h.wasRoot && jr(l, o), fc(l.x, h.offset.x), fc(l.y, h.offset.y));
      }
      return l;
    }
    applyTransform(o, a = !1) {
      const l = qt();
      jr(l, o);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        !a && u.options.layoutScroll && u.scroll && u !== u.root && pc(l, {
          x: -u.scroll.offset.x,
          y: -u.scroll.offset.y
        }), Ia(u.latestValues) && pc(l, u.latestValues);
      }
      return Ia(this.latestValues) && pc(l, this.latestValues), l;
    }
    removeTransform(o) {
      const a = qt();
      jr(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !Ia(c.latestValues))
          continue;
        H1(c.latestValues) && c.updateSnapshot();
        const u = qt(), h = c.measurePageBox();
        jr(u, h), DR(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u);
      }
      return Ia(this.latestValues) && DR(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Tn.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== l;
      if (!(o || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: h, layoutId: d } = this.options;
      if (!(!this.layout || !(h || d))) {
        if (this.resolvedRelativeTargetAt = Tn.timestamp, !this.targetDelta && !this.relativeTarget) {
          const f = this.getClosestProjectingParent();
          f && f.layout && this.animationProgress !== 1 ? (this.relativeParent = f, this.forceRelativeParentToResolveTarget(), this.relativeTarget = qt(), this.relativeTargetOrigin = qt(), jh(this.relativeTargetOrigin, this.layout.layoutBox, f.layout.layoutBox), jr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = qt(), this.targetWithTransforms = qt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), IQ(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : jr(this.target, this.layout.layoutBox), F6(this.target, this.targetDelta)) : jr(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const f = this.getClosestProjectingParent();
            f && !!f.resumingFrom == !!this.resumingFrom && !f.options.layoutScroll && f.target && this.animationProgress !== 1 ? (this.relativeParent = f, this.forceRelativeParentToResolveTarget(), this.relativeTarget = qt(), this.relativeTargetOrigin = qt(), jh(this.relativeTargetOrigin, this.target, f.target), jr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Sh && Pa.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || H1(this.parent.latestValues) || B6(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var o;
      const a = this.getLead(), l = !!this.resumingFrom || this !== a;
      let c = !0;
      if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === Tn.timestamp && (c = !1), c)
        return;
      const { layout: u, layoutId: h } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || h))
        return;
      jr(this.layoutCorrected, this.layout.layoutBox);
      const d = this.treeScale.x, f = this.treeScale.y;
      $Q(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = qt());
      const { target: g } = a;
      if (!g) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (IR(this.prevProjectionDelta.x, this.projectionDelta.x), IR(this.prevProjectionDelta.y, this.projectionDelta.y)), Uh(this.projectionDelta, this.layoutCorrected, g, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== f || !FR(this.projectionDelta.x, this.prevProjectionDelta.x) || !FR(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", g)), Sh && Pa.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = dc(), this.projectionDelta = dc(), this.projectionDeltaWithTransform = dc();
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, h = dc();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const d = qt(), f = l ? l.source : void 0, g = this.layout ? this.layout.source : void 0, y = f !== g, p = this.getStack(), m = !p || p.members.length <= 1, b = !!(y && !m && this.options.crossfade === !0 && !this.path.some(Eee));
      this.animationProgress = 0;
      let _;
      this.mixTargetDelta = (v) => {
        const w = v / 1e3;
        HR(h.x, o.x, w), HR(h.y, o.y, w), this.setTargetDelta(h), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (jh(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), wee(this.relativeTarget, this.relativeTargetOrigin, d, w), _ && iee(this.relativeTarget, _) && (this.isProjectionDirty = !1), _ || (_ = qt()), jr(_, this.relativeTarget)), y && (this.animationValues = u, QQ(u, c, this.latestValues, w, b, m)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = w;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Zo(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Mt.update(() => {
        ug.hasAnimatedSinceResize = !0, this.currentAnimation = H6(0, $R, {
          ...o,
          onUpdate: (a) => {
            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
          },
          onComplete: () => {
            o.onComplete && o.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const o = this.getStack();
      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta($R), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: l, layout: c, latestValues: u } = o;
      if (!(!a || !l || !c)) {
        if (this !== o && this.layout && c && Z6(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
          l = this.target || qt();
          const h = Mr(this.layout.layoutBox.x);
          l.x.min = o.target.x.min, l.x.max = l.x.min + h;
          const d = Mr(this.layout.layoutBox.y);
          l.y.min = o.target.y.min, l.y.max = l.y.min + d;
        }
        jr(a, l), pc(a, u), Uh(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new oee()), this.sharedNodes.get(o).add(a);
      const c = a.options.initialPromotionConfig;
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: l } = o;
      if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a)
        return;
      const c = {};
      l.z && W_("z", o, c, this.animationValues);
      for (let u = 0; u < V_.length; u++)
        W_(`rotate${V_[u]}`, o, c, this.animationValues), W_(`skew${V_[u]}`, o, c, this.animationValues);
      o.render();
      for (const u in c)
        o.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, l;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return lee;
      const c = {
        visibility: ""
      }, u = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, c.opacity = "", c.pointerEvents = lg(o?.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c;
      const h = this.getLead();
      if (!this.projectionDelta || !this.layout || !h.target) {
        const y = {};
        return this.options.layoutId && (y.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, y.pointerEvents = lg(o?.pointerEvents) || ""), this.hasProjected && !Ia(this.latestValues) && (y.transform = u ? u({}, "") : "none", this.hasProjected = !1), y;
      }
      const d = h.animationValues || h.latestValues;
      this.applyTransformsToTarget(), c.transform = aee(this.projectionDeltaWithTransform, this.treeScale, d), u && (c.transform = u(d, c.transform));
      const { x: f, y: g } = this.projectionDelta;
      c.transformOrigin = `${f.origin * 100}% ${g.origin * 100}% 0`, h.animationValues ? c.opacity = h === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = h === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
      for (const y in qg) {
        if (d[y] === void 0)
          continue;
        const { correct: p, applyTo: m } = qg[y], b = c.transform === "none" ? d[y] : p(d[y], h);
        if (m) {
          const _ = m.length;
          for (let v = 0; v < _; v++)
            c[m[v]] = b;
        } else
          c[y] = b;
      }
      return this.options.layoutId && (c.pointerEvents = h === this ? lg(o?.pointerEvents) || "" : "none"), c;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(UR), this.root.sharedNodes.clear();
    }
  };
}
function uee(t) {
  t.updateLayout();
}
function hee(t) {
  var e;
  const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: s } = t.layout, { animationType: i } = t.options, o = n.source !== t.layout.source;
    i === "size" ? zr((h) => {
      const d = o ? n.measuredBox[h] : n.layoutBox[h], f = Mr(d);
      d.min = r[h].min, d.max = d.min + f;
    }) : Z6(i, n.layoutBox, r) && zr((h) => {
      const d = o ? n.measuredBox[h] : n.layoutBox[h], f = Mr(r[h]);
      d.max = d.min + f, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[h].max = t.relativeTarget[h].min + f);
    });
    const a = dc();
    Uh(a, r, n.layoutBox);
    const l = dc();
    o ? Uh(l, t.applyTransform(s, !0), n.measuredBox) : Uh(l, r, n.layoutBox);
    const c = !W6(a);
    let u = !1;
    if (!t.resumeFrom) {
      const h = t.getClosestProjectingParent();
      if (h && !h.resumeFrom) {
        const { snapshot: d, layout: f } = h;
        if (d && f) {
          const g = qt();
          jh(g, n.layoutBox, d.layoutBox);
          const y = qt();
          jh(y, r, f.layoutBox), q6(g, y) || (u = !0), h.options.layoutRoot && (t.relativeTarget = y, t.relativeTargetOrigin = g, t.relativeParent = h);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: r,
      snapshot: n,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: c,
      hasRelativeTargetChanged: u
    });
  } else if (t.isLead()) {
    const { onExitComplete: r } = t.options;
    r && r();
  }
  t.options.transition = void 0;
}
function dee(t) {
  Sh && Pa.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function fee(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function pee(t) {
  t.clearSnapshot();
}
function UR(t) {
  t.clearMeasurements();
}
function mee(t) {
  t.isLayoutDirty = !1;
}
function gee(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function jR(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function yee(t) {
  t.resolveTargetDelta();
}
function bee(t) {
  t.calcProjection();
}
function _ee(t) {
  t.resetSkewAndRotation();
}
function vee(t) {
  t.removeLeadSnapshot();
}
function HR(t, e, n) {
  t.translate = Ut(e.translate, 0, n), t.scale = Ut(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;
}
function zR(t, e, n, r) {
  t.min = Ut(e.min, n.min, r), t.max = Ut(e.max, n.max, r);
}
function wee(t, e, n, r) {
  zR(t.x, e.x, n.x, r), zR(t.y, e.y, n.y, r);
}
function Eee(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const See = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, GR = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), VR = GR("applewebkit/") && !GR("chrome/") ? Math.round : yr;
function WR(t) {
  t.min = VR(t.min), t.max = VR(t.max);
}
function xee(t) {
  WR(t.x), WR(t.y);
}
function Z6(t, e, n) {
  return t === "position" || t === "preserve-aspect" && !RQ(BR(e), BR(n), 0.2);
}
function Tee(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const Cee = Y6({
  attachResizeListener: (t, e) => Td(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), q_ = {
  current: void 0
}, J6 = Y6({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!q_.current) {
      const t = new Cee({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), q_.current = t;
    }
    return q_.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), kee = {
  pan: {
    Feature: VQ
  },
  drag: {
    Feature: GQ,
    ProjectionNode: J6,
    MeasureLayout: j6
  }
};
function qR(t, e, n) {
  const { props: r } = t;
  t.animationState && r.whileHover && t.animationState.setActive("whileHover", n === "Start");
  const s = "onHover" + n, i = r[s];
  i && Mt.postRender(() => i(e, Qf(e)));
}
class Aee extends ga {
  mount() {
    const { current: e } = this.node;
    e && (this.unmount = OJ(e, (n) => (qR(this.node, n, "Start"), (r) => qR(this.node, r, "End"))));
  }
  unmount() {
  }
}
class Ree extends ga {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Xf(Td(this.node.current, "focus", () => this.onFocus()), Td(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function KR(t, e, n) {
  const { props: r } = t;
  t.animationState && r.whileTap && t.animationState.setActive("whileTap", n === "Start");
  const s = "onTap" + (n === "End" ? "" : n), i = r[s];
  i && Mt.postRender(() => i(e, Qf(e)));
}
class Iee extends ga {
  mount() {
    const { current: e } = this.node;
    e && (this.unmount = MJ(e, (n) => (KR(this.node, n, "Start"), (r, { success: s }) => KR(this.node, r, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const G1 = /* @__PURE__ */ new WeakMap(), K_ = /* @__PURE__ */ new WeakMap(), Pee = (t) => {
  const e = G1.get(t.target);
  e && e(t);
}, Oee = (t) => {
  t.forEach(Pee);
};
function Dee({ root: t, ...e }) {
  const n = t || document;
  K_.has(n) || K_.set(n, {});
  const r = K_.get(n), s = JSON.stringify(e);
  return r[s] || (r[s] = new IntersectionObserver(Oee, { root: t, ...e })), r[s];
}
function Nee(t, e, n) {
  const r = Dee(e);
  return G1.set(t, n), r.observe(t), () => {
    G1.delete(t), r.unobserve(t);
  };
}
const Lee = {
  some: 0,
  all: 1
};
class Mee extends ga {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: n, margin: r, amount: s = "some", once: i } = e, o = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof s == "number" ? s : Lee[s]
    }, a = (l) => {
      const { isIntersecting: c } = l;
      if (this.isInView === c || (this.isInView = c, i && !c && this.hasEnteredView))
        return;
      c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
      const { onViewportEnter: u, onViewportLeave: h } = this.node.getProps(), d = c ? u : h;
      d && d(l);
    };
    return Nee(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Bee(e, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Bee({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (n) => t[n] !== e[n];
}
const Fee = {
  inView: {
    Feature: Mee
  },
  tap: {
    Feature: Iee
  },
  focus: {
    Feature: Ree
  },
  hover: {
    Feature: Aee
  }
}, $ee = {
  layout: {
    ProjectionNode: J6,
    MeasureLayout: j6
  }
}, V1 = { current: null }, X6 = { current: !1 };
function Uee() {
  if (X6.current = !0, !!$T)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => V1.current = t.matches;
      t.addListener(e), e();
    } else
      V1.current = !1;
}
const jee = [...v6, Mn, Jo], Hee = (t) => jee.find(_6(t)), Yc = /* @__PURE__ */ new WeakMap();
function zee(t, e, n) {
  for (const r in e) {
    const s = e[r], i = n[r];
    if (wn(s))
      t.addValue(r, s), je.env.NODE_ENV === "development" && eb(s.version === "11.18.2", `Attempting to mix Motion versions ${s.version} with 11.18.2 may not work as expected.`);
    else if (wn(i))
      t.addValue(r, Sd(s, { owner: t }));
    else if (i !== s)
      if (t.hasValue(r)) {
        const o = t.getValue(r);
        o.liveStyle === !0 ? o.jump(s) : o.hasAnimated || o.set(s);
      } else {
        const o = t.getStaticValue(r);
        t.addValue(r, Sd(o !== void 0 ? o : s, { owner: t }));
      }
  }
  for (const r in n)
    e[r] === void 0 && t.removeValue(r);
  return e;
}
const YR = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class Q6 {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, n, r) {
    return {};
  }
  constructor({ parent: e, props: n, presenceContext: r, reducedMotionConfig: s, blockInitialAnimation: i, visualState: o }, a = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = hC, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const f = vi.now();
      this.renderScheduledAt < f && (this.renderScheduledAt = f, Mt.render(this.render, !1, !0));
    };
    const { latestValues: l, renderState: c, onUpdate: u } = o;
    this.onUpdate = u, this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = c, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = s, this.options = a, this.blockInitialAnimation = !!i, this.isControllingVariants = rb(n), this.isVariantNode = kB(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: h, ...d } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const f in d) {
      const g = d[f];
      l[f] !== void 0 && wn(g) && g.set(l[f], !1);
    }
  }
  mount(e) {
    this.current = e, Yc.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), X6.current || Uee(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : V1.current, je.env.NODE_ENV !== "production" && eb(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    Yc.delete(this.current), this.projection && this.projection.unmount(), Zo(this.notifyUpdate), Zo(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const n = this.features[e];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, n) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const r = Dl.has(e), s = n.on("change", (a) => {
      this.latestValues[e] = a, this.props.onUpdate && Mt.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0);
    }), i = n.on("renderRequest", this.scheduleRender);
    let o;
    window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => {
      s(), i(), o && o(), n.owner && n.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in qc) {
      const n = qc[e];
      if (!n)
        continue;
      const { isEnabled: r, Feature: s } = n;
      if (!this.features[e] && s && r(this.props) && (this.features[e] = new s(this)), this.features[e]) {
        const i = this.features[e];
        i.isMounted ? i.update() : (i.mount(), i.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : qt();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, n) {
    this.latestValues[e] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, n) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < YR.length; r++) {
      const s = YR[r];
      this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]);
      const i = "on" + s, o = e[i];
      o && (this.propEventSubscriptions[s] = this.on(s, o));
    }
    this.prevMotionValues = zee(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, n) {
    const r = this.values.get(e);
    n !== r && (r && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const n = this.valueSubscriptions.get(e);
    n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, n) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let r = this.values.get(e);
    return r === void 0 && n !== void 0 && (r = Sd(n === null ? void 0 : n, { owner: this }), this.addValue(e, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, n) {
    var r;
    let s = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (r = this.getBaseTargetFromProps(this.props, e)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, e, this.options);
    return s != null && (typeof s == "string" && (y6(s) || l6(s)) ? s = parseFloat(s) : !Hee(s) && Jo.test(n) && (s = p6(e, n)), this.setBaseTarget(e, wn(s) ? s.get() : s)), wn(s) ? s.get() : s;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, n) {
    this.baseTarget[e] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var n;
    const { initial: r } = this.props;
    let s;
    if (typeof r == "string" || typeof r == "object") {
      const o = WT(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
      o && (s = o[e]);
    }
    if (r && s !== void 0)
      return s;
    const i = this.getBaseTargetFromProps(this.props, e);
    return i !== void 0 && !wn(i) ? i : this.initialValues[e] !== void 0 && s === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, n) {
    return this.events[e] || (this.events[e] = new iC()), this.events[e].add(n);
  }
  notify(e, ...n) {
    this.events[e] && this.events[e].notify(...n);
  }
}
class e4 extends Q6 {
  constructor() {
    super(...arguments), this.KeyframeResolver = w6;
  }
  sortInstanceNodePosition(e, n) {
    return e.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, n) {
    return e.style ? e.style[n] : void 0;
  }
  removeValueFromRenderState(e, { vars: n, style: r }) {
    delete n[e], delete r[e];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    wn(e) && (this.childSubscription = e.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
function Gee(t) {
  return window.getComputedStyle(t);
}
class t4 extends e4 {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = MB;
  }
  readValueFromInstance(e, n) {
    if (Dl.has(n)) {
      const r = uC(n);
      return r && r.default || 0;
    } else {
      const r = Gee(e), s = (DB(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: n }) {
    return $6(e, n);
  }
  build(e, n, r) {
    YT(e, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, n, r) {
    return QT(e, n, r);
  }
}
class n4 extends e4 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = qt;
  }
  getBaseTargetFromProps(e, n) {
    return e[n];
  }
  readValueFromInstance(e, n) {
    if (Dl.has(n)) {
      const r = uC(n);
      return r && r.default || 0;
    }
    return n = BB.has(n) ? n : zT(n), e.getAttribute(n);
  }
  scrapeMotionValuesFromProps(e, n, r) {
    return UB(e, n, r);
  }
  build(e, n, r) {
    ZT(e, n, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(e, n, r, s) {
    FB(e, n, r, s);
  }
  mount(e) {
    this.isSVGTag = XT(e.tagName), super.mount(e);
  }
}
const Vee = (t, e) => VT(t) ? new n4(e) : new t4(e, {
  allowProjection: t !== I.Fragment
}), Wee = /* @__PURE__ */ CJ({
  ...vQ,
  ...Fee,
  ...kee,
  ...$ee
}, Vee), hn = /* @__PURE__ */ jZ(Wee);
function qee(t) {
  return I.useEffect(() => () => t(), []);
}
const Kee = (t, e, n) => {
  const r = e - t;
  return ((n - t) % r + r) % r + t;
};
function r4(t, e) {
  return k6(t) ? t[Kee(0, t.length, e)] : t;
}
function yC(t) {
  return typeof t == "object" && !Array.isArray(t);
}
function s4(t, e, n, r) {
  return typeof t == "string" && yC(e) ? KB(t, n, r) : t instanceof NodeList ? Array.from(t) : Array.isArray(t) ? t : [t];
}
function Yee(t, e, n) {
  return t * (e + 1);
}
function ZR(t, e, n, r) {
  var s;
  return typeof e == "number" ? e : e.startsWith("-") || e.startsWith("+") ? Math.max(0, t + parseFloat(e)) : e === "<" ? n : (s = r.get(e)) !== null && s !== void 0 ? s : t;
}
function Zee(t, e, n) {
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    s.at > e && s.at < n && (ob(t, s), r--);
  }
}
function Jee(t, e, n, r, s, i) {
  Zee(t, s, i);
  for (let o = 0; o < e.length; o++)
    t.push({
      value: e[o],
      at: Ut(s, i, r[o]),
      easing: r4(n, o)
    });
}
function Xee(t, e) {
  for (let n = 0; n < t.length; n++)
    t[n] = t[n] / (e + 1);
}
function Qee(t, e) {
  return t.at === e.at ? t.value === null ? 1 : e.value === null ? -1 : 0 : t.at - e.at;
}
const ete = "easeInOut", tte = 20;
function nte(t, { defaultTransition: e = {}, ...n } = {}, r, s) {
  const i = e.duration || 0.3, o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), l = {}, c = /* @__PURE__ */ new Map();
  let u = 0, h = 0, d = 0;
  for (let f = 0; f < t.length; f++) {
    const g = t[f];
    if (typeof g == "string") {
      c.set(g, h);
      continue;
    } else if (!Array.isArray(g)) {
      c.set(g.name, ZR(h, g.at, u, c));
      continue;
    }
    let [y, p, m = {}] = g;
    m.at !== void 0 && (h = ZR(h, m.at, u, c));
    let b = 0;
    const _ = (v, w, E, x = 0, S = 0) => {
      const T = rte(v), { delay: R = 0, times: F = R6(T), type: P = "keyframes", repeat: M, repeatType: A, repeatDelay: V = 0, ...ee } = w;
      let { ease: K = e.ease || "easeOut", duration: te } = w;
      const N = typeof R == "function" ? R(x, S) : R, L = T.length, j = ib(P) ? P : s?.[P];
      if (L <= 2 && j) {
        let ne = 100;
        if (L === 2 && ote(T)) {
          const z = T[1] - T[0];
          ne = Math.abs(z);
        }
        const he = { ...ee };
        te !== void 0 && (he.duration = /* @__PURE__ */ _s(te));
        const X = RJ(he, ne, j);
        K = X.ease, te = X.duration;
      }
      te ?? (te = i);
      const H = h + N;
      F.length === 1 && F[0] === 0 && (F[1] = 1);
      const U = F.length - T.length;
      if (U > 0 && A6(F, U), T.length === 1 && T.unshift(null), M) {
        Si(M < tte, "Repeat count too high, must be less than 20"), te = Yee(te, M);
        const ne = [...T], he = [...F];
        K = Array.isArray(K) ? [...K] : [K];
        const X = [...K];
        for (let z = 0; z < M; z++) {
          T.push(...ne);
          for (let ue = 0; ue < ne.length; ue++)
            F.push(he[ue] + (z + 1)), K.push(ue === 0 ? "linear" : r4(X, ue - 1));
        }
        Xee(F, M);
      }
      const Y = H + te;
      Jee(E, T, K, F, H, Y), b = Math.max(N + te, b), d = Math.max(Y, d);
    };
    if (wn(y)) {
      const v = JR(y, a);
      _(p, m, XR("default", v));
    } else {
      const v = s4(y, p, r, l), w = v.length;
      for (let E = 0; E < w; E++) {
        p = p, m = m;
        const x = v[E], S = JR(x, a);
        for (const T in p)
          _(p[T], ste(m, T), XR(T, S), E, w);
      }
    }
    u = h, h += b;
  }
  return a.forEach((f, g) => {
    for (const y in f) {
      const p = f[y];
      p.sort(Qee);
      const m = [], b = [], _ = [];
      for (let w = 0; w < p.length; w++) {
        const { at: E, value: x, easing: S } = p[w];
        m.push(x), b.push(/* @__PURE__ */ ul(0, d, E)), _.push(S || "easeOut");
      }
      b[0] !== 0 && (b.unshift(0), m.unshift(m[0]), _.unshift(ete)), b[b.length - 1] !== 1 && (b.push(1), m.push(null)), o.has(g) || o.set(g, {
        keyframes: {},
        transition: {}
      });
      const v = o.get(g);
      v.keyframes[y] = m, v.transition[y] = {
        ...e,
        duration: d,
        ease: _,
        times: b,
        ...n
      };
    }
  }), o;
}
function JR(t, e) {
  return !e.has(t) && e.set(t, {}), e.get(t);
}
function XR(t, e) {
  return e[t] || (e[t] = []), e[t];
}
function rte(t) {
  return Array.isArray(t) ? t : [t];
}
function ste(t, e) {
  return t && t[e] ? {
    ...t,
    ...t[e]
  } : { ...t };
}
const ite = (t) => typeof t == "number", ote = (t) => t.every(ite);
function ate(t, e) {
  return t in e;
}
class lte extends Q6 {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(e, n) {
    if (ate(n, e)) {
      const r = e[n];
      if (typeof r == "string" || typeof r == "number")
        return r;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(e, n) {
    delete n.output[e];
  }
  measureInstanceViewportBox() {
    return qt();
  }
  build(e, n) {
    Object.assign(e.output, n);
  }
  renderInstance(e, { output: n }) {
    Object.assign(e, n);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function cte(t) {
  const e = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, n = z6(t) ? new n4(e) : new t4(e);
  n.mount(t), Yc.set(t, n);
}
function ute(t) {
  const e = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, n = new lte(e);
  n.mount(t), Yc.set(t, n);
}
function hte(t, e) {
  return wn(t) || typeof t == "number" || typeof t == "string" && !yC(e);
}
function i4(t, e, n, r) {
  const s = [];
  if (hte(t, e))
    s.push(H6(t, yC(e) && e.default || e, n && (n.default || n)));
  else {
    const i = s4(t, e, r), o = i.length;
    Si(!!o, "No valid elements provided.");
    for (let a = 0; a < o; a++) {
      const l = i[a], c = l instanceof Element ? cte : ute;
      Yc.has(l) || c(l);
      const u = Yc.get(l), h = { ...n };
      "delay" in h && typeof h.delay == "function" && (h.delay = h.delay(a, o)), s.push(...gC(u, { ...e, transition: h }, {}));
    }
  }
  return s;
}
function dte(t, e, n) {
  const r = [];
  return nte(t, e, n, { spring: fC }).forEach(({ keyframes: i, transition: o }, a) => {
    r.push(...i4(a, i, o));
  }), r;
}
function fte(t) {
  return Array.isArray(t) && t.some(Array.isArray);
}
function pte(t) {
  function e(n, r, s) {
    let i = [];
    fte(n) ? i = dte(n, r, t) : i = i4(n, r, s, t);
    const o = new zB(i);
    return t && t.animations.push(o), o;
  }
  return e;
}
function mte() {
  const t = vd(() => ({
    current: null,
    // Will be hydrated by React
    animations: []
  })), e = vd(() => pte(t));
  return qee(() => {
    t.animations.forEach((n) => n.stop());
  }), [t, e];
}
function o4(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = o4(t[e])) && (r && (r += " "), r += n);
  } else for (n in t) t[n] && (r && (r += " "), r += n);
  return r;
}
function Uo() {
  for (var t, e, n = 0, r = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = o4(t)) && (r && (r += " "), r += e);
  return r;
}
const Cd = (t) => typeof t == "number" && !isNaN(t), el = (t) => typeof t == "string", Ir = (t) => typeof t == "function", hg = (t) => el(t) || Ir(t) ? t : null, W1 = (t) => I.isValidElement(t) || el(t) || Ir(t) || Cd(t);
function gte(t, e, n) {
  n === void 0 && (n = 300);
  const { scrollHeight: r, style: s } = t;
  requestAnimationFrame(() => {
    s.minHeight = "initial", s.height = r + "px", s.transition = `all ${n}ms`, requestAnimationFrame(() => {
      s.height = "0", s.padding = "0", s.margin = "0", setTimeout(e, n);
    });
  });
}
function ep(t) {
  let { enter: e, exit: n, appendPosition: r = !1, collapse: s = !0, collapseDuration: i = 300 } = t;
  return function(o) {
    let { children: a, position: l, preventExitTransition: c, done: u, nodeRef: h, isIn: d, playToast: f } = o;
    const g = r ? `${e}--${l}` : e, y = r ? `${n}--${l}` : n, p = I.useRef(0);
    return I.useLayoutEffect(() => {
      const m = h.current, b = g.split(" "), _ = (v) => {
        v.target === h.current && (f(), m.removeEventListener("animationend", _), m.removeEventListener("animationcancel", _), p.current === 0 && v.type !== "animationcancel" && m.classList.remove(...b));
      };
      m.classList.add(...b), m.addEventListener("animationend", _), m.addEventListener("animationcancel", _);
    }, []), I.useEffect(() => {
      const m = h.current, b = () => {
        m.removeEventListener("animationend", b), s ? gte(m, u, i) : u();
      };
      d || (c ? b() : (p.current = 1, m.className += ` ${y}`, m.addEventListener("animationend", b)));
    }, [d]), Qe.createElement(Qe.Fragment, null, a);
  };
}
function QR(t, e) {
  return t != null ? { content: t.content, containerId: t.props.containerId, id: t.props.toastId, theme: t.props.theme, type: t.props.type, data: t.props.data || {}, isLoading: t.props.isLoading, icon: t.props.icon, status: e } : {};
}
const Xn = /* @__PURE__ */ new Map();
let kd = [];
const q1 = /* @__PURE__ */ new Set(), yte = (t) => q1.forEach((e) => e(t)), a4 = () => Xn.size > 0;
function l4(t, e) {
  var n;
  if (e) return !((n = Xn.get(e)) == null || !n.isToastActive(t));
  let r = !1;
  return Xn.forEach((s) => {
    s.isToastActive(t) && (r = !0);
  }), r;
}
function c4(t, e) {
  W1(t) && (a4() || kd.push({ content: t, options: e }), Xn.forEach((n) => {
    n.buildToast(t, e);
  }));
}
function eI(t, e) {
  Xn.forEach((n) => {
    e != null && e != null && e.containerId ? e?.containerId === n.id && n.toggle(t, e?.id) : n.toggle(t, e?.id);
  });
}
function bte(t) {
  const { subscribe: e, getSnapshot: n, setProps: r } = I.useRef(function(i) {
    const o = i.containerId || 1;
    return { subscribe(a) {
      const l = /* @__PURE__ */ function(u, h, d) {
        let f = 1, g = 0, y = [], p = [], m = [], b = h;
        const _ = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Set(), w = () => {
          m = Array.from(_.values()), v.forEach((S) => S());
        }, E = (S) => {
          p = S == null ? [] : p.filter((T) => T !== S), w();
        }, x = (S) => {
          const { toastId: T, onOpen: R, updateId: F, children: P } = S.props, M = F == null;
          S.staleId && _.delete(S.staleId), _.set(T, S), p = [...p, S.props.toastId].filter((A) => A !== S.staleId), w(), d(QR(S, M ? "added" : "updated")), M && Ir(R) && R(I.isValidElement(P) && P.props);
        };
        return { id: u, props: b, observe: (S) => (v.add(S), () => v.delete(S)), toggle: (S, T) => {
          _.forEach((R) => {
            T != null && T !== R.props.toastId || Ir(R.toggle) && R.toggle(S);
          });
        }, removeToast: E, toasts: _, clearQueue: () => {
          g -= y.length, y = [];
        }, buildToast: (S, T) => {
          if (((H) => {
            let { containerId: U, toastId: Y, updateId: ne } = H;
            const he = U ? U !== u : u !== 1, X = _.has(Y) && ne == null;
            return he || X;
          })(T)) return;
          const { toastId: R, updateId: F, data: P, staleId: M, delay: A } = T, V = () => {
            E(R);
          }, ee = F == null;
          ee && g++;
          const K = { ...b, style: b.toastStyle, key: f++, ...Object.fromEntries(Object.entries(T).filter((H) => {
            let [U, Y] = H;
            return Y != null;
          })), toastId: R, updateId: F, data: P, closeToast: V, isIn: !1, className: hg(T.className || b.toastClassName), bodyClassName: hg(T.bodyClassName || b.bodyClassName), progressClassName: hg(T.progressClassName || b.progressClassName), autoClose: !T.isLoading && (te = T.autoClose, N = b.autoClose, te === !1 || Cd(te) && te > 0 ? te : N), deleteToast() {
            const H = _.get(R), { onClose: U, children: Y } = H.props;
            Ir(U) && U(I.isValidElement(Y) && Y.props), d(QR(H, "removed")), _.delete(R), g--, g < 0 && (g = 0), y.length > 0 ? x(y.shift()) : w();
          } };
          var te, N;
          K.closeButton = b.closeButton, T.closeButton === !1 || W1(T.closeButton) ? K.closeButton = T.closeButton : T.closeButton === !0 && (K.closeButton = !W1(b.closeButton) || b.closeButton);
          let L = S;
          I.isValidElement(S) && !el(S.type) ? L = I.cloneElement(S, { closeToast: V, toastProps: K, data: P }) : Ir(S) && (L = S({ closeToast: V, toastProps: K, data: P }));
          const j = { content: L, props: K, staleId: M };
          b.limit && b.limit > 0 && g > b.limit && ee ? y.push(j) : Cd(A) ? setTimeout(() => {
            x(j);
          }, A) : x(j);
        }, setProps(S) {
          b = S;
        }, setToggle: (S, T) => {
          _.get(S).toggle = T;
        }, isToastActive: (S) => p.some((T) => T === S), getSnapshot: () => m };
      }(o, i, yte);
      Xn.set(o, l);
      const c = l.observe(a);
      return kd.forEach((u) => c4(u.content, u.options)), kd = [], () => {
        c(), Xn.delete(o);
      };
    }, setProps(a) {
      var l;
      (l = Xn.get(o)) == null || l.setProps(a);
    }, getSnapshot() {
      var a;
      return (a = Xn.get(o)) == null ? void 0 : a.getSnapshot();
    } };
  }(t)).current;
  r(t);
  const s = I.useSyncExternalStore(e, n, n);
  return { getToastToRender: function(i) {
    if (!s) return [];
    const o = /* @__PURE__ */ new Map();
    return t.newestOnTop && s.reverse(), s.forEach((a) => {
      const { position: l } = a.props;
      o.has(l) || o.set(l, []), o.get(l).push(a);
    }), Array.from(o, (a) => i(a[0], a[1]));
  }, isToastActive: l4, count: s?.length };
}
function _te(t) {
  const [e, n] = I.useState(!1), [r, s] = I.useState(!1), i = I.useRef(null), o = I.useRef({ start: 0, delta: 0, removalDistance: 0, canCloseOnClick: !0, canDrag: !1, didMove: !1 }).current, { autoClose: a, pauseOnHover: l, closeToast: c, onClick: u, closeOnClick: h } = t;
  var d, f;
  function g() {
    n(!0);
  }
  function y() {
    n(!1);
  }
  function p(_) {
    const v = i.current;
    o.canDrag && v && (o.didMove = !0, e && y(), o.delta = t.draggableDirection === "x" ? _.clientX - o.start : _.clientY - o.start, o.start !== _.clientX && (o.canCloseOnClick = !1), v.style.transform = `translate3d(${t.draggableDirection === "x" ? `${o.delta}px, var(--y)` : `0, calc(${o.delta}px + var(--y))`},0)`, v.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance)));
  }
  function m() {
    document.removeEventListener("pointermove", p), document.removeEventListener("pointerup", m);
    const _ = i.current;
    if (o.canDrag && o.didMove && _) {
      if (o.canDrag = !1, Math.abs(o.delta) > o.removalDistance) return s(!0), t.closeToast(), void t.collapseAll();
      _.style.transition = "transform 0.2s, opacity 0.2s", _.style.removeProperty("transform"), _.style.removeProperty("opacity");
    }
  }
  (f = Xn.get((d = { id: t.toastId, containerId: t.containerId, fn: n }).containerId || 1)) == null || f.setToggle(d.id, d.fn), I.useEffect(() => {
    if (t.pauseOnFocusLoss) return document.hasFocus() || y(), window.addEventListener("focus", g), window.addEventListener("blur", y), () => {
      window.removeEventListener("focus", g), window.removeEventListener("blur", y);
    };
  }, [t.pauseOnFocusLoss]);
  const b = { onPointerDown: function(_) {
    if (t.draggable === !0 || t.draggable === _.pointerType) {
      o.didMove = !1, document.addEventListener("pointermove", p), document.addEventListener("pointerup", m);
      const v = i.current;
      o.canCloseOnClick = !0, o.canDrag = !0, v.style.transition = "none", t.draggableDirection === "x" ? (o.start = _.clientX, o.removalDistance = v.offsetWidth * (t.draggablePercent / 100)) : (o.start = _.clientY, o.removalDistance = v.offsetHeight * (t.draggablePercent === 80 ? 1.5 * t.draggablePercent : t.draggablePercent) / 100);
    }
  }, onPointerUp: function(_) {
    const { top: v, bottom: w, left: E, right: x } = i.current.getBoundingClientRect();
    _.nativeEvent.type !== "touchend" && t.pauseOnHover && _.clientX >= E && _.clientX <= x && _.clientY >= v && _.clientY <= w ? y() : g();
  } };
  return a && l && (b.onMouseEnter = y, t.stacked || (b.onMouseLeave = g)), h && (b.onClick = (_) => {
    u && u(_), o.canCloseOnClick && c();
  }), { playToast: g, pauseToast: y, isRunning: e, preventExitTransition: r, toastRef: i, eventHandlers: b };
}
function vte(t) {
  let { delay: e, isRunning: n, closeToast: r, type: s = "default", hide: i, className: o, style: a, controlledProgress: l, progress: c, rtl: u, isIn: h, theme: d } = t;
  const f = i || l && c === 0, g = { ...a, animationDuration: `${e}ms`, animationPlayState: n ? "running" : "paused" };
  l && (g.transform = `scaleX(${c})`);
  const y = Uo("Toastify__progress-bar", l ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${d}`, `Toastify__progress-bar--${s}`, { "Toastify__progress-bar--rtl": u }), p = Ir(o) ? o({ rtl: u, type: s, defaultClassName: y }) : Uo(y, o), m = { [l && c >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: l && c < 1 ? null : () => {
    h && r();
  } };
  return Qe.createElement("div", { className: "Toastify__progress-bar--wrp", "data-hidden": f }, Qe.createElement("div", { className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${d} Toastify__progress-bar--${s}` }), Qe.createElement("div", { role: "progressbar", "aria-hidden": f ? "true" : "false", "aria-label": "notification timer", className: p, style: g, ...m }));
}
let wte = 1;
const u4 = () => "" + wte++;
function Ete(t) {
  return t && (el(t.toastId) || Cd(t.toastId)) ? t.toastId : u4();
}
function Hh(t, e) {
  return c4(t, e), e.toastId;
}
function e0(t, e) {
  return { ...e, type: e && e.type || t, toastId: Ete(e) };
}
function jp(t) {
  return (e, n) => Hh(e, e0(t, n));
}
function $e(t, e) {
  return Hh(t, e0("default", e));
}
$e.loading = (t, e) => Hh(t, e0("default", { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...e })), $e.promise = function(t, e, n) {
  let r, { pending: s, error: i, success: o } = e;
  s && (r = el(s) ? $e.loading(s, n) : $e.loading(s.render, { ...n, ...s }));
  const a = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, l = (u, h, d) => {
    if (h == null) return void $e.dismiss(r);
    const f = { type: u, ...a, ...n, data: d }, g = el(h) ? { render: h } : h;
    return r ? $e.update(r, { ...f, ...g }) : $e(g.render, { ...f, ...g }), d;
  }, c = Ir(t) ? t() : t;
  return c.then((u) => l("success", o, u)).catch((u) => l("error", i, u)), c;
}, $e.success = jp("success"), $e.info = jp("info"), $e.error = jp("error"), $e.warning = jp("warning"), $e.warn = $e.warning, $e.dark = (t, e) => Hh(t, e0("default", { theme: "dark", ...e })), $e.dismiss = function(t) {
  (function(e) {
    var n;
    if (a4()) {
      if (e == null || el(n = e) || Cd(n)) Xn.forEach((r) => {
        r.removeToast(e);
      });
      else if (e && ("containerId" in e || "id" in e)) {
        const r = Xn.get(e.containerId);
        r ? r.removeToast(e.id) : Xn.forEach((s) => {
          s.removeToast(e.id);
        });
      }
    } else kd = kd.filter((r) => e != null && r.options.toastId !== e);
  })(t);
}, $e.clearWaitingQueue = function(t) {
  t === void 0 && (t = {}), Xn.forEach((e) => {
    !e.props.limit || t.containerId && e.id !== t.containerId || e.clearQueue();
  });
}, $e.isActive = l4, $e.update = function(t, e) {
  e === void 0 && (e = {});
  const n = ((r, s) => {
    var i;
    let { containerId: o } = s;
    return (i = Xn.get(o || 1)) == null ? void 0 : i.toasts.get(r);
  })(t, e);
  if (n) {
    const { props: r, content: s } = n, i = { delay: 100, ...r, ...e, toastId: e.toastId || t, updateId: u4() };
    i.toastId !== t && (i.staleId = t);
    const o = i.render || s;
    delete i.render, Hh(o, i);
  }
}, $e.done = (t) => {
  $e.update(t, { progress: 1 });
}, $e.onChange = function(t) {
  return q1.add(t), () => {
    q1.delete(t);
  };
}, $e.play = (t) => eI(!0, t), $e.pause = (t) => eI(!1, t);
const Ste = typeof window < "u" ? I.useLayoutEffect : I.useEffect, Hp = (t) => {
  let { theme: e, type: n, isLoading: r, ...s } = t;
  return Qe.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: e === "colored" ? "currentColor" : `var(--toastify-icon-color-${n})`, ...s });
}, Y_ = { info: function(t) {
  return Qe.createElement(Hp, { ...t }, Qe.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}, warning: function(t) {
  return Qe.createElement(Hp, { ...t }, Qe.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}, success: function(t) {
  return Qe.createElement(Hp, { ...t }, Qe.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}, error: function(t) {
  return Qe.createElement(Hp, { ...t }, Qe.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}, spinner: function() {
  return Qe.createElement("div", { className: "Toastify__spinner" });
} }, xte = (t) => {
  const { isRunning: e, preventExitTransition: n, toastRef: r, eventHandlers: s, playToast: i } = _te(t), { closeButton: o, children: a, autoClose: l, onClick: c, type: u, hideProgressBar: h, closeToast: d, transition: f, position: g, className: y, style: p, bodyClassName: m, bodyStyle: b, progressClassName: _, progressStyle: v, updateId: w, role: E, progress: x, rtl: S, toastId: T, deleteToast: R, isIn: F, isLoading: P, closeOnClick: M, theme: A } = t, V = Uo("Toastify__toast", `Toastify__toast-theme--${A}`, `Toastify__toast--${u}`, { "Toastify__toast--rtl": S }, { "Toastify__toast--close-on-click": M }), ee = Ir(y) ? y({ rtl: S, position: g, type: u, defaultClassName: V }) : Uo(V, y), K = function(j) {
    let { theme: H, type: U, isLoading: Y, icon: ne } = j, he = null;
    const X = { theme: H, type: U };
    return ne === !1 || (Ir(ne) ? he = ne({ ...X, isLoading: Y }) : I.isValidElement(ne) ? he = I.cloneElement(ne, X) : Y ? he = Y_.spinner() : ((z) => z in Y_)(U) && (he = Y_[U](X))), he;
  }(t), te = !!x || !l, N = { closeToast: d, type: u, theme: A };
  let L = null;
  return o === !1 || (L = Ir(o) ? o(N) : I.isValidElement(o) ? I.cloneElement(o, N) : function(j) {
    let { closeToast: H, theme: U, ariaLabel: Y = "close" } = j;
    return Qe.createElement("button", { className: `Toastify__close-button Toastify__close-button--${U}`, type: "button", onClick: (ne) => {
      ne.stopPropagation(), H(ne);
    }, "aria-label": Y }, Qe.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, Qe.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
  }(N)), Qe.createElement(f, { isIn: F, done: R, position: g, preventExitTransition: n, nodeRef: r, playToast: i }, Qe.createElement("div", { id: T, onClick: c, "data-in": F, className: ee, ...s, style: p, ref: r }, Qe.createElement("div", { ...F && { role: E }, className: Ir(m) ? m({ type: u }) : Uo("Toastify__toast-body", m), style: b }, K != null && Qe.createElement("div", { className: Uo("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !P }) }, K), Qe.createElement("div", null, a)), L, Qe.createElement(vte, { ...w && !te ? { key: `pb-${w}` } : {}, rtl: S, theme: A, delay: l, isRunning: e, isIn: F, closeToast: d, hide: h, type: u, style: v, className: _, controlledProgress: te, progress: x || 0 })));
}, lb = function(t, e) {
  return e === void 0 && (e = !1), { enter: `Toastify--animate Toastify__${t}-enter`, exit: `Toastify--animate Toastify__${t}-exit`, appendPosition: e };
}, Tte = ep(lb("bounce", !0));
ep(lb("slide", !0));
ep(lb("zoom"));
ep(lb("flip"));
const Cte = { position: "top-right", transition: Tte, autoClose: 5e3, closeButton: !0, pauseOnHover: !0, pauseOnFocusLoss: !0, draggable: "touch", draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light" };
function kte(t) {
  let e = { ...Cte, ...t };
  const n = t.stacked, [r, s] = I.useState(!0), i = I.useRef(null), { getToastToRender: o, isToastActive: a, count: l } = bte(e), { className: c, style: u, rtl: h, containerId: d } = e;
  function f(y) {
    const p = Uo("Toastify__toast-container", `Toastify__toast-container--${y}`, { "Toastify__toast-container--rtl": h });
    return Ir(c) ? c({ position: y, rtl: h, defaultClassName: p }) : Uo(p, hg(c));
  }
  function g() {
    n && (s(!0), $e.play());
  }
  return Ste(() => {
    if (n) {
      var y;
      const p = i.current.querySelectorAll('[data-in="true"]'), m = 12, b = (y = e.position) == null ? void 0 : y.includes("top");
      let _ = 0, v = 0;
      Array.from(p).reverse().forEach((w, E) => {
        const x = w;
        x.classList.add("Toastify__toast--stacked"), E > 0 && (x.dataset.collapsed = `${r}`), x.dataset.pos || (x.dataset.pos = b ? "top" : "bot");
        const S = _ * (r ? 0.2 : 1) + (r ? 0 : m * E);
        x.style.setProperty("--y", `${b ? S : -1 * S}px`), x.style.setProperty("--g", `${m}`), x.style.setProperty("--s", "" + (1 - (r ? v : 0))), _ += x.offsetHeight, v += 0.025;
      });
    }
  }, [r, l, n]), Qe.createElement("div", { ref: i, className: "Toastify", id: d, onMouseEnter: () => {
    n && (s(!1), $e.pause());
  }, onMouseLeave: g }, o((y, p) => {
    const m = p.length ? { ...u } : { ...u, pointerEvents: "none" };
    return Qe.createElement("div", { className: f(y), style: m, key: `container-${y}` }, p.map((b) => {
      let { content: _, props: v } = b;
      return Qe.createElement(xte, { ...v, stacked: n, collapseAll: g, isIn: a(v.toastId, v.containerId), style: v.style, key: `toast-${v.key}` }, _);
    }));
  }));
}
function Ke(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(s) {
    if (t?.(s), n === !1 || !s.defaultPrevented)
      return e?.(s);
  };
}
function tI(t, e) {
  if (typeof t == "function")
    return t(e);
  t != null && (t.current = e);
}
function cb(...t) {
  return (e) => {
    let n = !1;
    const r = t.map((s) => {
      const i = tI(s, e);
      return !n && typeof i == "function" && (n = !0), i;
    });
    if (n)
      return () => {
        for (let s = 0; s < r.length; s++) {
          const i = r[s];
          typeof i == "function" ? i() : tI(t[s], null);
        }
      };
  };
}
function Yt(...t) {
  return I.useCallback(cb(...t), t);
}
function Ate(t, e) {
  const n = I.createContext(e), r = (i) => {
    const { children: o, ...a } = i, l = I.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ k.jsx(n.Provider, { value: l, children: o });
  };
  r.displayName = t + "Provider";
  function s(i) {
    const o = I.useContext(n);
    if (o) return o;
    if (e !== void 0) return e;
    throw new Error(`\`${i}\` must be used within \`${t}\``);
  }
  return [r, s];
}
function Ii(t, e = []) {
  let n = [];
  function r(i, o) {
    const a = I.createContext(o), l = n.length;
    n = [...n, o];
    const c = (h) => {
      const { scope: d, children: f, ...g } = h, y = d?.[t]?.[l] || a, p = I.useMemo(() => g, Object.values(g));
      return /* @__PURE__ */ k.jsx(y.Provider, { value: p, children: f });
    };
    c.displayName = i + "Provider";
    function u(h, d) {
      const f = d?.[t]?.[l] || a, g = I.useContext(f);
      if (g) return g;
      if (o !== void 0) return o;
      throw new Error(`\`${h}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const s = () => {
    const i = n.map((o) => I.createContext(o));
    return function(a) {
      const l = a?.[t] || i;
      return I.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: l } }),
        [a, l]
      );
    };
  };
  return s.scopeName = t, [r, Rte(s, ...e)];
}
function Rte(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(i) {
      const o = r.reduce((a, { useScope: l, scopeName: c }) => {
        const h = l(i)[`__scope${c}`];
        return { ...a, ...h };
      }, {});
      return I.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
var hl = globalThis?.document ? I.useLayoutEffect : () => {
}, Ite = LT.useId || (() => {
}), Pte = 0;
function Ad(t) {
  const [e, n] = I.useState(Ite());
  return hl(() => {
    n((r) => r ?? String(Pte++));
  }, [t]), e ? `radix-${e}` : "";
}
function rs(t) {
  const e = I.useRef(t);
  return I.useEffect(() => {
    e.current = t;
  }), I.useMemo(() => (...n) => e.current?.(...n), []);
}
function tp({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  }
}) {
  const [r, s] = Ote({ defaultProp: e, onChange: n }), i = t !== void 0, o = i ? t : r, a = rs(n), l = I.useCallback(
    (c) => {
      if (i) {
        const h = typeof c == "function" ? c(t) : c;
        h !== t && a(h);
      } else
        s(c);
    },
    [i, t, s, a]
  );
  return [o, l];
}
function Ote({
  defaultProp: t,
  onChange: e
}) {
  const n = I.useState(t), [r] = n, s = I.useRef(r), i = rs(e);
  return I.useEffect(() => {
    s.current !== r && (i(r), s.current = r);
  }, [r, s, i]), n;
}
var dl = I.forwardRef((t, e) => {
  const { children: n, ...r } = t, s = I.Children.toArray(n), i = s.find(Dte);
  if (i) {
    const o = i.props.children, a = s.map((l) => l === i ? I.Children.count(o) > 1 ? I.Children.only(null) : I.isValidElement(o) ? o.props.children : null : l);
    return /* @__PURE__ */ k.jsx(K1, { ...r, ref: e, children: I.isValidElement(o) ? I.cloneElement(o, void 0, a) : null });
  }
  return /* @__PURE__ */ k.jsx(K1, { ...r, ref: e, children: n });
});
dl.displayName = "Slot";
var K1 = I.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (I.isValidElement(n)) {
    const s = Lte(n);
    return I.cloneElement(n, {
      ...Nte(r, n.props),
      // @ts-ignore
      ref: e ? cb(e, s) : s
    });
  }
  return I.Children.count(n) > 1 ? I.Children.only(null) : null;
});
K1.displayName = "SlotClone";
var h4 = ({ children: t }) => /* @__PURE__ */ k.jsx(k.Fragment, { children: t });
function Dte(t) {
  return I.isValidElement(t) && t.type === h4;
}
function Nte(t, e) {
  const n = { ...e };
  for (const r in e) {
    const s = t[r], i = e[r];
    /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => {
      i(...a), s(...a);
    } : s && (n[r] = s) : r === "style" ? n[r] = { ...s, ...i } : r === "className" && (n[r] = [s, i].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function Lte(t) {
  let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var Mte = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Pt = Mte.reduce((t, e) => {
  const n = I.forwardRef((r, s) => {
    const { asChild: i, ...o } = r, a = i ? dl : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ k.jsx(a, { ...o, ref: s });
  });
  return n.displayName = `Primitive.${e}`, { ...t, [e]: n };
}, {});
function d4(t, e) {
  t && _B.flushSync(() => t.dispatchEvent(e));
}
function Bte(t, e = globalThis?.document) {
  const n = rs(t);
  I.useEffect(() => {
    const r = (s) => {
      s.key === "Escape" && n(s);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var Fte = "DismissableLayer", Y1 = "dismissableLayer.update", $te = "dismissableLayer.pointerDownOutside", Ute = "dismissableLayer.focusOutside", nI, f4 = I.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), np = I.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: s,
      onFocusOutside: i,
      onInteractOutside: o,
      onDismiss: a,
      ...l
    } = t, c = I.useContext(f4), [u, h] = I.useState(null), d = u?.ownerDocument ?? globalThis?.document, [, f] = I.useState({}), g = Yt(e, (x) => h(x)), y = Array.from(c.layers), [p] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), m = y.indexOf(p), b = u ? y.indexOf(u) : -1, _ = c.layersWithOutsidePointerEventsDisabled.size > 0, v = b >= m, w = zte((x) => {
      const S = x.target, T = [...c.branches].some((R) => R.contains(S));
      !v || T || (s?.(x), o?.(x), x.defaultPrevented || a?.());
    }, d), E = Gte((x) => {
      const S = x.target;
      [...c.branches].some((R) => R.contains(S)) || (i?.(x), o?.(x), x.defaultPrevented || a?.());
    }, d);
    return Bte((x) => {
      b === c.layers.size - 1 && (r?.(x), !x.defaultPrevented && a && (x.preventDefault(), a()));
    }, d), I.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (nI = d.body.style.pointerEvents, d.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), rI(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = nI);
        };
    }, [u, d, n, c]), I.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), rI());
    }, [u, c]), I.useEffect(() => {
      const x = () => f({});
      return document.addEventListener(Y1, x), () => document.removeEventListener(Y1, x);
    }, []), /* @__PURE__ */ k.jsx(
      Pt.div,
      {
        ...l,
        ref: g,
        style: {
          pointerEvents: _ ? v ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: Ke(t.onFocusCapture, E.onFocusCapture),
        onBlurCapture: Ke(t.onBlurCapture, E.onBlurCapture),
        onPointerDownCapture: Ke(
          t.onPointerDownCapture,
          w.onPointerDownCapture
        )
      }
    );
  }
);
np.displayName = Fte;
var jte = "DismissableLayerBranch", Hte = I.forwardRef((t, e) => {
  const n = I.useContext(f4), r = I.useRef(null), s = Yt(e, r);
  return I.useEffect(() => {
    const i = r.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ k.jsx(Pt.div, { ...t, ref: s });
});
Hte.displayName = jte;
function zte(t, e = globalThis?.document) {
  const n = rs(t), r = I.useRef(!1), s = I.useRef(() => {
  });
  return I.useEffect(() => {
    const i = (a) => {
      if (a.target && !r.current) {
        let l = function() {
          p4(
            $te,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: a };
        a.pointerType === "touch" ? (e.removeEventListener("click", s.current), s.current = l, e.addEventListener("click", s.current, { once: !0 })) : l();
      } else
        e.removeEventListener("click", s.current);
      r.current = !1;
    }, o = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(o), e.removeEventListener("pointerdown", i), e.removeEventListener("click", s.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function Gte(t, e = globalThis?.document) {
  const n = rs(t), r = I.useRef(!1);
  return I.useEffect(() => {
    const s = (i) => {
      i.target && !r.current && p4(Ute, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", s), () => e.removeEventListener("focusin", s);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function rI() {
  const t = new CustomEvent(Y1);
  document.dispatchEvent(t);
}
function p4(t, e, n, { discrete: r }) {
  const s = n.originalEvent.target, i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && s.addEventListener(t, e, { once: !0 }), r ? d4(s, i) : s.dispatchEvent(i);
}
var Z_ = "focusScope.autoFocusOnMount", J_ = "focusScope.autoFocusOnUnmount", sI = { bubbles: !1, cancelable: !0 }, Vte = "FocusScope", ub = I.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: s,
    onUnmountAutoFocus: i,
    ...o
  } = t, [a, l] = I.useState(null), c = rs(s), u = rs(i), h = I.useRef(null), d = Yt(e, (y) => l(y)), f = I.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  I.useEffect(() => {
    if (r) {
      let y = function(_) {
        if (f.paused || !a) return;
        const v = _.target;
        a.contains(v) ? h.current = v : To(h.current, { select: !0 });
      }, p = function(_) {
        if (f.paused || !a) return;
        const v = _.relatedTarget;
        v !== null && (a.contains(v) || To(h.current, { select: !0 }));
      }, m = function(_) {
        if (document.activeElement === document.body)
          for (const w of _)
            w.removedNodes.length > 0 && To(a);
      };
      document.addEventListener("focusin", y), document.addEventListener("focusout", p);
      const b = new MutationObserver(m);
      return a && b.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", y), document.removeEventListener("focusout", p), b.disconnect();
      };
    }
  }, [r, a, f.paused]), I.useEffect(() => {
    if (a) {
      oI.add(f);
      const y = document.activeElement;
      if (!a.contains(y)) {
        const m = new CustomEvent(Z_, sI);
        a.addEventListener(Z_, c), a.dispatchEvent(m), m.defaultPrevented || (Wte(Jte(m4(a)), { select: !0 }), document.activeElement === y && To(a));
      }
      return () => {
        a.removeEventListener(Z_, c), setTimeout(() => {
          const m = new CustomEvent(J_, sI);
          a.addEventListener(J_, u), a.dispatchEvent(m), m.defaultPrevented || To(y ?? document.body, { select: !0 }), a.removeEventListener(J_, u), oI.remove(f);
        }, 0);
      };
    }
  }, [a, c, u, f]);
  const g = I.useCallback(
    (y) => {
      if (!n && !r || f.paused) return;
      const p = y.key === "Tab" && !y.altKey && !y.ctrlKey && !y.metaKey, m = document.activeElement;
      if (p && m) {
        const b = y.currentTarget, [_, v] = qte(b);
        _ && v ? !y.shiftKey && m === v ? (y.preventDefault(), n && To(_, { select: !0 })) : y.shiftKey && m === _ && (y.preventDefault(), n && To(v, { select: !0 })) : m === b && y.preventDefault();
      }
    },
    [n, r, f.paused]
  );
  return /* @__PURE__ */ k.jsx(Pt.div, { tabIndex: -1, ...o, ref: d, onKeyDown: g });
});
ub.displayName = Vte;
function Wte(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (To(r, { select: e }), document.activeElement !== n) return;
}
function qte(t) {
  const e = m4(t), n = iI(e, t), r = iI(e.reverse(), t);
  return [n, r];
}
function m4(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const s = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function iI(t, e) {
  for (const n of t)
    if (!Kte(n, { upTo: e })) return n;
}
function Kte(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function Yte(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function To(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && Yte(t) && e && t.select();
  }
}
var oI = Zte();
function Zte() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && n?.pause(), t = aI(t, e), t.unshift(e);
    },
    remove(e) {
      t = aI(t, e), t[0]?.resume();
    }
  };
}
function aI(t, e) {
  const n = [...t], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function Jte(t) {
  return t.filter((e) => e.tagName !== "A");
}
var Xte = "Portal", rp = I.forwardRef((t, e) => {
  const { container: n, ...r } = t, [s, i] = I.useState(!1);
  hl(() => i(!0), []);
  const o = n || s && globalThis?.document?.body;
  return o ? gZ.createPortal(/* @__PURE__ */ k.jsx(Pt.div, { ...r, ref: e }), o) : null;
});
rp.displayName = Xte;
function Qte(t, e) {
  return I.useReducer((n, r) => e[n][r] ?? n, t);
}
var ls = (t) => {
  const { present: e, children: n } = t, r = ene(e), s = typeof n == "function" ? n({ present: r.isPresent }) : I.Children.only(n), i = Yt(r.ref, tne(s));
  return typeof n == "function" || r.isPresent ? I.cloneElement(s, { ref: i }) : null;
};
ls.displayName = "Presence";
function ene(t) {
  const [e, n] = I.useState(), r = I.useRef({}), s = I.useRef(t), i = I.useRef("none"), o = t ? "mounted" : "unmounted", [a, l] = Qte(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return I.useEffect(() => {
    const c = zp(r.current);
    i.current = a === "mounted" ? c : "none";
  }, [a]), hl(() => {
    const c = r.current, u = s.current;
    if (u !== t) {
      const d = i.current, f = zp(c);
      t ? l("MOUNT") : f === "none" || c?.display === "none" ? l("UNMOUNT") : l(u && d !== f ? "ANIMATION_OUT" : "UNMOUNT"), s.current = t;
    }
  }, [t, l]), hl(() => {
    if (e) {
      let c;
      const u = e.ownerDocument.defaultView ?? window, h = (f) => {
        const y = zp(r.current).includes(f.animationName);
        if (f.target === e && y && (l("ANIMATION_END"), !s.current)) {
          const p = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = p);
          });
        }
      }, d = (f) => {
        f.target === e && (i.current = zp(r.current));
      };
      return e.addEventListener("animationstart", d), e.addEventListener("animationcancel", h), e.addEventListener("animationend", h), () => {
        u.clearTimeout(c), e.removeEventListener("animationstart", d), e.removeEventListener("animationcancel", h), e.removeEventListener("animationend", h);
      };
    } else
      l("ANIMATION_END");
  }, [e, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: I.useCallback((c) => {
      c && (r.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function zp(t) {
  return t?.animationName || "none";
}
function tne(t) {
  let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var X_ = 0;
function bC() {
  I.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? lI()), document.body.insertAdjacentElement("beforeend", t[1] ?? lI()), X_++, () => {
      X_ === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), X_--;
    };
  }, []);
}
function lI() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var ni = function() {
  return ni = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, ni.apply(this, arguments);
};
function g4(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)
      e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (n[r[s]] = t[r[s]]);
  return n;
}
function nne(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (h) {
        o(h);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (h) {
        o(h);
      }
    }
    function c(u) {
      u.done ? i(u.value) : s(u.value).then(a, l);
    }
    c((r = r.apply(t, e || [])).next());
  });
}
function rne(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return o.next = a(0), o.throw = a(1), o.return = a(2), typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (n = 0)), n; ) try {
      if (r = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return n.label++, { value: c[1], done: !1 };
        case 5:
          n.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            n = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            n.label = c[1];
            break;
          }
          if (c[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = c;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(c);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      c = e.call(t, n);
    } catch (u) {
      c = [6, u], s = 0;
    } finally {
      r = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
function sne(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n) return n.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function ine(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, s = e.length, i; r < s; r++)
    (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var dg = "right-scroll-bar-position", fg = "width-before-scroll-bar", one = "with-scroll-bars-hidden", ane = "--removed-body-scroll-bar-size";
function Q_(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function lne(t, e) {
  var n = I.useState(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var s = n.value;
          s !== r && (n.value = r, n.callback(r, s));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var cne = typeof window < "u" ? I.useLayoutEffect : I.useEffect, cI = /* @__PURE__ */ new WeakMap();
function une(t, e) {
  var n = lne(null, function(r) {
    return t.forEach(function(s) {
      return Q_(s, r);
    });
  });
  return cne(function() {
    var r = cI.get(n);
    if (r) {
      var s = new Set(r), i = new Set(t), o = n.current;
      s.forEach(function(a) {
        i.has(a) || Q_(a, null);
      }), i.forEach(function(a) {
        s.has(a) || Q_(a, o);
      });
    }
    cI.set(n, t);
  }, [t]), n;
}
function hne(t) {
  return t;
}
function dne(t, e) {
  e === void 0 && (e = hne);
  var n = [], r = !1, s = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(i) {
      var o = e(i, r);
      return n.push(o), function() {
        n = n.filter(function(a) {
          return a !== o;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (r = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(i);
      }
      n = {
        push: function(a) {
          return i(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      r = !0;
      var o = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(i), o = n;
      }
      var l = function() {
        var u = o;
        o = [], u.forEach(i);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          o.push(u), c();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return s;
}
function fne(t) {
  t === void 0 && (t = {});
  var e = dne(null);
  return e.options = ni({ async: !0, ssr: !1 }, t), e;
}
var y4 = function(t) {
  var e = t.sideCar, n = g4(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return I.createElement(r, ni({}, n));
};
y4.isSideCarExport = !0;
function pne(t, e) {
  return t.useMedium(e), y4;
}
var b4 = fne(), ev = function() {
}, hb = I.forwardRef(function(t, e) {
  var n = I.useRef(null), r = I.useState({
    onScrollCapture: ev,
    onWheelCapture: ev,
    onTouchMoveCapture: ev
  }), s = r[0], i = r[1], o = t.forwardProps, a = t.children, l = t.className, c = t.removeScrollBar, u = t.enabled, h = t.shards, d = t.sideCar, f = t.noIsolation, g = t.inert, y = t.allowPinchZoom, p = t.as, m = p === void 0 ? "div" : p, b = t.gapMode, _ = g4(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), v = d, w = une([n, e]), E = ni(ni({}, _), s);
  return I.createElement(
    I.Fragment,
    null,
    u && I.createElement(v, { sideCar: b4, removeScrollBar: c, shards: h, noIsolation: f, inert: g, setCallbacks: i, allowPinchZoom: !!y, lockRef: n, gapMode: b }),
    o ? I.cloneElement(I.Children.only(a), ni(ni({}, E), { ref: w })) : I.createElement(m, ni({}, E, { className: l, ref: w }), a)
  );
});
hb.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
hb.classNames = {
  fullWidth: fg,
  zeroRight: dg
};
var mne = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function gne() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = mne();
  return e && t.setAttribute("nonce", e), t;
}
function yne(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function bne(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var _ne = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = gne()) && (yne(e, n), bne(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, vne = function() {
  var t = _ne();
  return function(e, n) {
    I.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, _4 = function() {
  var t = vne(), e = function(n) {
    var r = n.styles, s = n.dynamic;
    return t(r, s), null;
  };
  return e;
}, wne = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, tv = function(t) {
  return parseInt(t || "", 10) || 0;
}, Ene = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], s = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [tv(n), tv(r), tv(s)];
}, Sne = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return wne;
  var e = Ene(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, xne = _4(), kc = "data-scroll-locked", Tne = function(t, e, n, r) {
  var s = t.left, i = t.top, o = t.right, a = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(one, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(kc, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(dg, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(fg, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(dg, " .").concat(dg, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(fg, " .").concat(fg, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(kc, `] {
    `).concat(ane, ": ").concat(a, `px;
  }
`);
}, uI = function() {
  var t = parseInt(document.body.getAttribute(kc) || "0", 10);
  return isFinite(t) ? t : 0;
}, Cne = function() {
  I.useEffect(function() {
    return document.body.setAttribute(kc, (uI() + 1).toString()), function() {
      var t = uI() - 1;
      t <= 0 ? document.body.removeAttribute(kc) : document.body.setAttribute(kc, t.toString());
    };
  }, []);
}, kne = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, s = r === void 0 ? "margin" : r;
  Cne();
  var i = I.useMemo(function() {
    return Sne(s);
  }, [s]);
  return I.createElement(xne, { styles: Tne(i, !e, s, n ? "" : "!important") });
}, Z1 = !1;
if (typeof window < "u")
  try {
    var Gp = Object.defineProperty({}, "passive", {
      get: function() {
        return Z1 = !0, !0;
      }
    });
    window.addEventListener("test", Gp, Gp), window.removeEventListener("test", Gp, Gp);
  } catch {
    Z1 = !1;
  }
var Vl = Z1 ? { passive: !1 } : !1, Ane = function(t) {
  return t.tagName === "TEXTAREA";
}, v4 = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Ane(t) && n[e] === "visible")
  );
}, Rne = function(t) {
  return v4(t, "overflowY");
}, Ine = function(t) {
  return v4(t, "overflowX");
}, hI = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var s = w4(t, r);
    if (s) {
      var i = E4(t, r), o = i[1], a = i[2];
      if (o > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, Pne = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, One = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, w4 = function(t, e) {
  return t === "v" ? Rne(e) : Ine(e);
}, E4 = function(t, e) {
  return t === "v" ? Pne(e) : One(e);
}, Dne = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, Nne = function(t, e, n, r, s) {
  var i = Dne(t, window.getComputedStyle(e).direction), o = i * r, a = n.target, l = e.contains(a), c = !1, u = o > 0, h = 0, d = 0;
  do {
    var f = E4(t, a), g = f[0], y = f[1], p = f[2], m = y - p - i * g;
    (g || m) && w4(t, a) && (h += m, d += g), a instanceof ShadowRoot ? a = a.host : a = a.parentNode;
  } while (
    // portaled content
    !l && a !== document.body || // self content
    l && (e.contains(a) || e === a)
  );
  return (u && Math.abs(h) < 1 || !u && Math.abs(d) < 1) && (c = !0), c;
}, Vp = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, dI = function(t) {
  return [t.deltaX, t.deltaY];
}, fI = function(t) {
  return t && "current" in t ? t.current : t;
}, Lne = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, Mne = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, Bne = 0, Wl = [];
function Fne(t) {
  var e = I.useRef([]), n = I.useRef([0, 0]), r = I.useRef(), s = I.useState(Bne++)[0], i = I.useState(_4)[0], o = I.useRef(t);
  I.useEffect(function() {
    o.current = t;
  }, [t]), I.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(s));
      var y = ine([t.lockRef.current], (t.shards || []).map(fI), !0).filter(Boolean);
      return y.forEach(function(p) {
        return p.classList.add("allow-interactivity-".concat(s));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(s)), y.forEach(function(p) {
          return p.classList.remove("allow-interactivity-".concat(s));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = I.useCallback(function(y, p) {
    if ("touches" in y && y.touches.length === 2 || y.type === "wheel" && y.ctrlKey)
      return !o.current.allowPinchZoom;
    var m = Vp(y), b = n.current, _ = "deltaX" in y ? y.deltaX : b[0] - m[0], v = "deltaY" in y ? y.deltaY : b[1] - m[1], w, E = y.target, x = Math.abs(_) > Math.abs(v) ? "h" : "v";
    if ("touches" in y && x === "h" && E.type === "range")
      return !1;
    var S = hI(x, E);
    if (!S)
      return !0;
    if (S ? w = x : (w = x === "v" ? "h" : "v", S = hI(x, E)), !S)
      return !1;
    if (!r.current && "changedTouches" in y && (_ || v) && (r.current = w), !w)
      return !0;
    var T = r.current || w;
    return Nne(T, p, y, T === "h" ? _ : v);
  }, []), l = I.useCallback(function(y) {
    var p = y;
    if (!(!Wl.length || Wl[Wl.length - 1] !== i)) {
      var m = "deltaY" in p ? dI(p) : Vp(p), b = e.current.filter(function(w) {
        return w.name === p.type && (w.target === p.target || p.target === w.shadowParent) && Lne(w.delta, m);
      })[0];
      if (b && b.should) {
        p.cancelable && p.preventDefault();
        return;
      }
      if (!b) {
        var _ = (o.current.shards || []).map(fI).filter(Boolean).filter(function(w) {
          return w.contains(p.target);
        }), v = _.length > 0 ? a(p, _[0]) : !o.current.noIsolation;
        v && p.cancelable && p.preventDefault();
      }
    }
  }, []), c = I.useCallback(function(y, p, m, b) {
    var _ = { name: y, delta: p, target: m, should: b, shadowParent: $ne(m) };
    e.current.push(_), setTimeout(function() {
      e.current = e.current.filter(function(v) {
        return v !== _;
      });
    }, 1);
  }, []), u = I.useCallback(function(y) {
    n.current = Vp(y), r.current = void 0;
  }, []), h = I.useCallback(function(y) {
    c(y.type, dI(y), y.target, a(y, t.lockRef.current));
  }, []), d = I.useCallback(function(y) {
    c(y.type, Vp(y), y.target, a(y, t.lockRef.current));
  }, []);
  I.useEffect(function() {
    return Wl.push(i), t.setCallbacks({
      onScrollCapture: h,
      onWheelCapture: h,
      onTouchMoveCapture: d
    }), document.addEventListener("wheel", l, Vl), document.addEventListener("touchmove", l, Vl), document.addEventListener("touchstart", u, Vl), function() {
      Wl = Wl.filter(function(y) {
        return y !== i;
      }), document.removeEventListener("wheel", l, Vl), document.removeEventListener("touchmove", l, Vl), document.removeEventListener("touchstart", u, Vl);
    };
  }, []);
  var f = t.removeScrollBar, g = t.inert;
  return I.createElement(
    I.Fragment,
    null,
    g ? I.createElement(i, { styles: Mne(s) }) : null,
    f ? I.createElement(kne, { gapMode: t.gapMode }) : null
  );
}
function $ne(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const Une = pne(b4, Fne);
var db = I.forwardRef(function(t, e) {
  return I.createElement(hb, ni({}, t, { ref: e, sideCar: Une }));
});
db.classNames = hb.classNames;
var jne = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, ql = /* @__PURE__ */ new WeakMap(), Wp = /* @__PURE__ */ new WeakMap(), qp = {}, nv = 0, S4 = function(t) {
  return t && (t.host || S4(t.parentNode));
}, Hne = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = S4(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, zne = function(t, e, n, r) {
  var s = Hne(e, Array.isArray(t) ? t : [t]);
  qp[n] || (qp[n] = /* @__PURE__ */ new WeakMap());
  var i = qp[n], o = [], a = /* @__PURE__ */ new Set(), l = new Set(s), c = function(h) {
    !h || a.has(h) || (a.add(h), c(h.parentNode));
  };
  s.forEach(c);
  var u = function(h) {
    !h || l.has(h) || Array.prototype.forEach.call(h.children, function(d) {
      if (a.has(d))
        u(d);
      else
        try {
          var f = d.getAttribute(r), g = f !== null && f !== "false", y = (ql.get(d) || 0) + 1, p = (i.get(d) || 0) + 1;
          ql.set(d, y), i.set(d, p), o.push(d), y === 1 && g && Wp.set(d, !0), p === 1 && d.setAttribute(n, "true"), g || d.setAttribute(r, "true");
        } catch (m) {
          console.error("aria-hidden: cannot operate on ", d, m);
        }
    });
  };
  return u(e), a.clear(), nv++, function() {
    o.forEach(function(h) {
      var d = ql.get(h) - 1, f = i.get(h) - 1;
      ql.set(h, d), i.set(h, f), d || (Wp.has(h) || h.removeAttribute(r), Wp.delete(h)), f || h.removeAttribute(n);
    }), nv--, nv || (ql = /* @__PURE__ */ new WeakMap(), ql = /* @__PURE__ */ new WeakMap(), Wp = /* @__PURE__ */ new WeakMap(), qp = {});
  };
}, _C = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), s = jne(t);
  return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live]"))), zne(r, s, n, "aria-hidden")) : function() {
    return null;
  };
}, x4 = "Dialog", [T4, OGe] = Ii(x4), [DGe, Ps] = T4(x4), C4 = "DialogTrigger", Gne = I.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = Ps(C4, n), i = Yt(e, s.triggerRef);
    return /* @__PURE__ */ k.jsx(
      Pt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": s.open,
        "aria-controls": s.contentId,
        "data-state": EC(s.open),
        ...r,
        ref: i,
        onClick: Ke(t.onClick, s.onOpenToggle)
      }
    );
  }
);
Gne.displayName = C4;
var vC = "DialogPortal", [Vne, k4] = T4(vC, {
  forceMount: void 0
}), A4 = (t) => {
  const { __scopeDialog: e, forceMount: n, children: r, container: s } = t, i = Ps(vC, e);
  return /* @__PURE__ */ k.jsx(Vne, { scope: e, forceMount: n, children: I.Children.map(r, (o) => /* @__PURE__ */ k.jsx(ls, { present: n || i.open, children: /* @__PURE__ */ k.jsx(rp, { asChild: !0, container: s, children: o }) })) });
};
A4.displayName = vC;
var t0 = "DialogOverlay", R4 = I.forwardRef(
  (t, e) => {
    const n = k4(t0, t.__scopeDialog), { forceMount: r = n.forceMount, ...s } = t, i = Ps(t0, t.__scopeDialog);
    return i.modal ? /* @__PURE__ */ k.jsx(ls, { present: r || i.open, children: /* @__PURE__ */ k.jsx(Wne, { ...s, ref: e }) }) : null;
  }
);
R4.displayName = t0;
var Wne = I.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = Ps(t0, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ k.jsx(db, { as: dl, allowPinchZoom: !0, shards: [s.contentRef], children: /* @__PURE__ */ k.jsx(
        Pt.div,
        {
          "data-state": EC(s.open),
          ...r,
          ref: e,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), fl = "DialogContent", I4 = I.forwardRef(
  (t, e) => {
    const n = k4(fl, t.__scopeDialog), { forceMount: r = n.forceMount, ...s } = t, i = Ps(fl, t.__scopeDialog);
    return /* @__PURE__ */ k.jsx(ls, { present: r || i.open, children: i.modal ? /* @__PURE__ */ k.jsx(qne, { ...s, ref: e }) : /* @__PURE__ */ k.jsx(Kne, { ...s, ref: e }) });
  }
);
I4.displayName = fl;
var qne = I.forwardRef(
  (t, e) => {
    const n = Ps(fl, t.__scopeDialog), r = I.useRef(null), s = Yt(e, n.contentRef, r);
    return I.useEffect(() => {
      const i = r.current;
      if (i) return _C(i);
    }, []), /* @__PURE__ */ k.jsx(
      P4,
      {
        ...t,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ke(t.onCloseAutoFocus, (i) => {
          i.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: Ke(t.onPointerDownOutside, (i) => {
          const o = i.detail.originalEvent, a = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || a) && i.preventDefault();
        }),
        onFocusOutside: Ke(
          t.onFocusOutside,
          (i) => i.preventDefault()
        )
      }
    );
  }
), Kne = I.forwardRef(
  (t, e) => {
    const n = Ps(fl, t.__scopeDialog), r = I.useRef(!1), s = I.useRef(!1);
    return /* @__PURE__ */ k.jsx(
      P4,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          t.onCloseAutoFocus?.(i), i.defaultPrevented || (r.current || n.triggerRef.current?.focus(), i.preventDefault()), r.current = !1, s.current = !1;
        },
        onInteractOutside: (i) => {
          t.onInteractOutside?.(i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (s.current = !0));
          const o = i.target;
          n.triggerRef.current?.contains(o) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && s.current && i.preventDefault();
        }
      }
    );
  }
), P4 = I.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: s, onCloseAutoFocus: i, ...o } = t, a = Ps(fl, n), l = I.useRef(null), c = Yt(e, l);
    return bC(), /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
      /* @__PURE__ */ k.jsx(
        ub,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: s,
          onUnmountAutoFocus: i,
          children: /* @__PURE__ */ k.jsx(
            np,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": EC(a.open),
              ...o,
              ref: c,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
        /* @__PURE__ */ k.jsx(Yne, { titleId: a.titleId }),
        /* @__PURE__ */ k.jsx(Jne, { contentRef: l, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), wC = "DialogTitle", O4 = I.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = Ps(wC, n);
    return /* @__PURE__ */ k.jsx(Pt.h2, { id: s.titleId, ...r, ref: e });
  }
);
O4.displayName = wC;
var D4 = "DialogDescription", N4 = I.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = Ps(D4, n);
    return /* @__PURE__ */ k.jsx(Pt.p, { id: s.descriptionId, ...r, ref: e });
  }
);
N4.displayName = D4;
var L4 = "DialogClose", M4 = I.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = Ps(L4, n);
    return /* @__PURE__ */ k.jsx(
      Pt.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: Ke(t.onClick, () => s.onOpenChange(!1))
      }
    );
  }
);
M4.displayName = L4;
function EC(t) {
  return t ? "open" : "closed";
}
var B4 = "DialogTitleWarning", [NGe, F4] = Ate(B4, {
  contentName: fl,
  titleName: wC,
  docsSlug: "dialog"
}), Yne = ({ titleId: t }) => {
  const e = F4(B4), n = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
  return I.useEffect(() => {
    t && (document.getElementById(t) || console.error(n));
  }, [n, t]), null;
}, Zne = "DialogDescriptionWarning", Jne = ({ contentRef: t, descriptionId: e }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${F4(Zne).contentName}}.`;
  return I.useEffect(() => {
    const s = t.current?.getAttribute("aria-describedby");
    e && s && (document.getElementById(e) || console.warn(r));
  }, [r, t, e]), null;
}, Xne = A4, Qne = R4, ere = I4, tre = O4, nre = N4, rre = M4;
function qe(...t) {
  let e = "";
  for (const n of t)
    e = $4(e, sre(n));
  return e;
}
function sre(t) {
  if (typeof t == "string" || typeof t == "number")
    return t;
  if (typeof t != "object")
    return "";
  if (Array.isArray(t))
    return qe(...t);
  let e = "";
  for (const n in t)
    t[n] && (e = $4(e, n));
  return e;
}
function $4(t, e) {
  return e ? t ? t + " " + e : t + e : t;
}
const xs = Nl(0.4, 0, 0.2, 1), Vt = I.memo(
  I.forwardRef(
    ({
      icon: t,
      size: e = "xl",
      className: n,
      iconClassName: r,
      disabledClassName: s,
      disabled: i = !1,
      title: o,
      onClick: a,
      children: l
    }, c) => /* @__PURE__ */ k.jsx(
      "button",
      {
        ref: c,
        className: qe(
          "flex items-center text-bolt-elements-item-contentDefault bg-transparent enabled:hover:text-bolt-elements-item-contentActive rounded-md p-1 enabled:hover:bg-bolt-elements-item-backgroundActive disabled:cursor-not-allowed",
          {
            [qe("opacity-30", s)]: i
          },
          n
        ),
        title: o,
        disabled: i,
        onClick: (u) => {
          i || a?.(u);
        },
        children: l || /* @__PURE__ */ k.jsx("div", { className: qe(t, ire(e), r) })
      }
    )
  )
);
function ire(t) {
  return t === "sm" ? "text-sm" : t === "md" ? "text-md" : t === "lg" ? "text-lg" : t === "xl" ? "text-xl" : "text-2xl";
}
const n0 = {
  duration: 0.15,
  ease: xs
}, ore = {
  closed: {
    opacity: 0,
    transition: n0
  },
  open: {
    opacity: 1,
    transition: n0
  }
}, are = {
  closed: {
    x: "-50%",
    y: "-40%",
    scale: 0.96,
    opacity: 0,
    transition: n0
  },
  open: {
    x: "-50%",
    y: "-50%",
    scale: 1,
    opacity: 1,
    transition: n0
  }
};
I.memo(({ type: t, children: e, onClick: n }) => /* @__PURE__ */ k.jsx(
  "button",
  {
    className: qe(
      "inline-flex h-[35px] items-center justify-center rounded-lg px-4 text-sm leading-none focus:outline-none",
      {
        "bg-bolt-elements-button-primary-background text-bolt-elements-button-primary-text hover:bg-bolt-elements-button-primary-backgroundHover": t === "primary",
        "bg-bolt-elements-button-secondary-background text-bolt-elements-button-secondary-text hover:bg-bolt-elements-button-secondary-backgroundHover": t === "secondary",
        "bg-bolt-elements-button-danger-background text-bolt-elements-button-danger-text hover:bg-bolt-elements-button-danger-backgroundHover": t === "danger"
      }
    ),
    onClick: n,
    children: e
  }
));
I.memo(({ className: t, children: e, ...n }) => /* @__PURE__ */ k.jsx(
  tre,
  {
    className: qe(
      "px-5 py-4 flex items-center justify-between border-b border-bolt-elements-borderColor text-lg font-semibold leading-6 text-bolt-elements-textPrimary",
      t
    ),
    ...n,
    children: e
  }
));
I.memo(({ className: t, children: e, ...n }) => /* @__PURE__ */ k.jsx(
  nre,
  {
    className: qe("px-5 py-4 text-bolt-elements-textPrimary text-md", t),
    ...n,
    children: e
  }
));
I.memo(({ className: t, children: e, onBackdrop: n, onClose: r }) => /* @__PURE__ */ k.jsxs(Xne, { children: [
  /* @__PURE__ */ k.jsx(Qne, { onClick: n, asChild: !0, children: /* @__PURE__ */ k.jsx(
    hn.div,
    {
      className: "bg-black/50 fixed inset-0 z-max",
      initial: "closed",
      animate: "open",
      exit: "closed",
      variants: ore
    }
  ) }),
  /* @__PURE__ */ k.jsx(ere, { asChild: !0, children: /* @__PURE__ */ k.jsxs(
    hn.div,
    {
      className: qe(
        "fixed top-[50%] left-[50%] z-max max-h-[85vh] w-[90vw] max-w-[450px] translate-x-[-50%] translate-y-[-50%] border border-bolt-elements-borderColor rounded-lg bg-bolt-elements-background-depth-2 shadow-lg focus:outline-none overflow-hidden",
        t
      ),
      initial: "closed",
      animate: "open",
      exit: "closed",
      variants: are,
      children: [
        e,
        /* @__PURE__ */ k.jsx(rre, { asChild: !0, onClick: r, children: /* @__PURE__ */ k.jsx(Vt, { icon: "i-ph:x", className: "absolute top-[10px] right-[10px]" }) })
      ]
    }
  ) })
] }));
I.memo(({ className: t }) => {
  const e = mt(Vg), [n, r] = I.useState(!1);
  return I.useEffect(() => {
    r(!0);
  }, []), n && /* @__PURE__ */ k.jsx(
    Vt,
    {
      className: t,
      icon: e === "dark" ? "i-ph-sun-dim-duotone" : "i-ph-moon-stars-duotone",
      size: "xl",
      title: "Toggle Theme",
      onClick: vZ
    }
  );
});
function lre(t) {
  const e = I.useRef({ value: t, previous: t });
  return I.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t]);
}
function U4(t) {
  const [e, n] = I.useState(void 0);
  return hl(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const r = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length)
          return;
        const i = s[0];
        let o, a;
        if ("borderBoxSize" in i) {
          const l = i.borderBoxSize, c = Array.isArray(l) ? l[0] : l;
          o = c.inlineSize, a = c.blockSize;
        } else
          o = t.offsetWidth, a = t.offsetHeight;
        n({ width: o, height: a });
      });
      return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
var SC = "Switch", [cre, LGe] = Ii(SC), [ure, hre] = cre(SC), j4 = I.forwardRef(
  (t, e) => {
    const {
      __scopeSwitch: n,
      name: r,
      checked: s,
      defaultChecked: i,
      required: o,
      disabled: a,
      value: l = "on",
      onCheckedChange: c,
      form: u,
      ...h
    } = t, [d, f] = I.useState(null), g = Yt(e, (_) => f(_)), y = I.useRef(!1), p = d ? u || !!d.closest("form") : !0, [m = !1, b] = tp({
      prop: s,
      defaultProp: i,
      onChange: c
    });
    return /* @__PURE__ */ k.jsxs(ure, { scope: n, checked: m, disabled: a, children: [
      /* @__PURE__ */ k.jsx(
        Pt.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": m,
          "aria-required": o,
          "data-state": G4(m),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: l,
          ...h,
          ref: g,
          onClick: Ke(t.onClick, (_) => {
            b((v) => !v), p && (y.current = _.isPropagationStopped(), y.current || _.stopPropagation());
          })
        }
      ),
      p && /* @__PURE__ */ k.jsx(
        dre,
        {
          control: d,
          bubbles: !y.current,
          name: r,
          value: l,
          checked: m,
          required: o,
          disabled: a,
          form: u,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
j4.displayName = SC;
var H4 = "SwitchThumb", z4 = I.forwardRef(
  (t, e) => {
    const { __scopeSwitch: n, ...r } = t, s = hre(H4, n);
    return /* @__PURE__ */ k.jsx(
      Pt.span,
      {
        "data-state": G4(s.checked),
        "data-disabled": s.disabled ? "" : void 0,
        ...r,
        ref: e
      }
    );
  }
);
z4.displayName = H4;
var dre = (t) => {
  const { control: e, checked: n, bubbles: r = !0, ...s } = t, i = I.useRef(null), o = lre(n), a = U4(e);
  return I.useEffect(() => {
    const l = i.current, c = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(c, "checked").set;
    if (o !== n && h) {
      const d = new Event("click", { bubbles: r });
      h.call(l, n), l.dispatchEvent(d);
    }
  }, [o, n, r]), /* @__PURE__ */ k.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": !0,
      defaultChecked: n,
      ...s,
      tabIndex: -1,
      ref: i,
      style: {
        ...t.style,
        ...a,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function G4(t) {
  return t ? "checked" : "unchecked";
}
var fre = j4, pre = z4;
I.memo(({ className: t, onCheckedChange: e, checked: n }) => /* @__PURE__ */ k.jsx(
  fre,
  {
    className: qe(
      "relative h-6 w-11 cursor-pointer rounded-full bg-bolt-elements-button-primary-background",
      "transition-colors duration-200 ease-in-out",
      "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2",
      "disabled:cursor-not-allowed disabled:opacity-50",
      "data-[state=checked]:bg-bolt-elements-item-contentAccent",
      t
    ),
    checked: n,
    onCheckedChange: (r) => e?.(r),
    children: /* @__PURE__ */ k.jsx(
      pre,
      {
        className: qe(
          "block h-5 w-5 rounded-full bg-white",
          "shadow-lg shadow-black/20",
          "transition-transform duration-200 ease-in-out",
          "translate-x-0.5",
          "data-[state=checked]:translate-x-[1.375rem]",
          "will-change-transform"
        )
      }
    )
  }
));
var pn = {}, fb = {};
fb.byteLength = yre;
fb.toByteArray = _re;
fb.fromByteArray = Ere;
var ri = [], Gr = [], mre = typeof Uint8Array < "u" ? Uint8Array : Array, rv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Kl = 0, gre = rv.length; Kl < gre; ++Kl)
  ri[Kl] = rv[Kl], Gr[rv.charCodeAt(Kl)] = Kl;
Gr[45] = 62;
Gr[95] = 63;
function V4(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = t.indexOf("=");
  n === -1 && (n = e);
  var r = n === e ? 0 : 4 - n % 4;
  return [n, r];
}
function yre(t) {
  var e = V4(t), n = e[0], r = e[1];
  return (n + r) * 3 / 4 - r;
}
function bre(t, e, n) {
  return (e + n) * 3 / 4 - n;
}
function _re(t) {
  var e, n = V4(t), r = n[0], s = n[1], i = new mre(bre(t, r, s)), o = 0, a = s > 0 ? r - 4 : r, l;
  for (l = 0; l < a; l += 4)
    e = Gr[t.charCodeAt(l)] << 18 | Gr[t.charCodeAt(l + 1)] << 12 | Gr[t.charCodeAt(l + 2)] << 6 | Gr[t.charCodeAt(l + 3)], i[o++] = e >> 16 & 255, i[o++] = e >> 8 & 255, i[o++] = e & 255;
  return s === 2 && (e = Gr[t.charCodeAt(l)] << 2 | Gr[t.charCodeAt(l + 1)] >> 4, i[o++] = e & 255), s === 1 && (e = Gr[t.charCodeAt(l)] << 10 | Gr[t.charCodeAt(l + 1)] << 4 | Gr[t.charCodeAt(l + 2)] >> 2, i[o++] = e >> 8 & 255, i[o++] = e & 255), i;
}
function vre(t) {
  return ri[t >> 18 & 63] + ri[t >> 12 & 63] + ri[t >> 6 & 63] + ri[t & 63];
}
function wre(t, e, n) {
  for (var r, s = [], i = e; i < n; i += 3)
    r = (t[i] << 16 & 16711680) + (t[i + 1] << 8 & 65280) + (t[i + 2] & 255), s.push(vre(r));
  return s.join("");
}
function Ere(t) {
  for (var e, n = t.length, r = n % 3, s = [], i = 16383, o = 0, a = n - r; o < a; o += i)
    s.push(wre(t, o, o + i > a ? a : o + i));
  return r === 1 ? (e = t[n - 1], s.push(
    ri[e >> 2] + ri[e << 4 & 63] + "=="
  )) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1], s.push(
    ri[e >> 10] + ri[e >> 4 & 63] + ri[e << 2 & 63] + "="
  )), s.join("");
}
var xC = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
xC.read = function(t, e, n, r, s) {
  var i, o, a = s * 8 - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, h = n ? s - 1 : 0, d = n ? -1 : 1, f = t[e + h];
  for (h += d, i = f & (1 << -u) - 1, f >>= -u, u += a; u > 0; i = i * 256 + t[e + h], h += d, u -= 8)
    ;
  for (o = i & (1 << -u) - 1, i >>= -u, u += r; u > 0; o = o * 256 + t[e + h], h += d, u -= 8)
    ;
  if (i === 0)
    i = 1 - c;
  else {
    if (i === l)
      return o ? NaN : (f ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, r), i = i - c;
  }
  return (f ? -1 : 1) * o * Math.pow(2, i - r);
};
xC.write = function(t, e, n, r, s, i) {
  var o, a, l, c = i * 8 - s - 1, u = (1 << c) - 1, h = u >> 1, d = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : i - 1, g = r ? 1 : -1, y = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + h >= 1 ? e += d / l : e += d * Math.pow(2, 1 - h), e * l >= 2 && (o++, l /= 2), o + h >= u ? (a = 0, o = u) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, s), o = o + h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, s), o = 0)); s >= 8; t[n + f] = a & 255, f += g, a /= 256, s -= 8)
    ;
  for (o = o << s | a, c += s; c > 0; t[n + f] = o & 255, f += g, o /= 256, c -= 8)
    ;
  t[n + f - g] |= y * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = fb, n = xC, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = u, t.SlowBuffer = w, t.INSPECT_MAX_BYTES = 50;
  const s = 2147483647;
  t.kMaxLength = s;
  const { Uint8Array: i, ArrayBuffer: o, SharedArrayBuffer: a } = globalThis;
  u.TYPED_ARRAY_SUPPORT = l(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function l() {
    try {
      const G = new i(1), O = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(O, i.prototype), Object.setPrototypeOf(G, O), G.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function c(G) {
    if (G > s)
      throw new RangeError('The value "' + G + '" is invalid for option "size"');
    const O = new i(G);
    return Object.setPrototypeOf(O, u.prototype), O;
  }
  function u(G, O, B) {
    if (typeof G == "number") {
      if (typeof O == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return g(G);
    }
    return h(G, O, B);
  }
  u.poolSize = 8192;
  function h(G, O, B) {
    if (typeof G == "string")
      return y(G, O);
    if (o.isView(G))
      return m(G);
    if (G == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof G
      );
    if (Ee(G, o) || G && Ee(G.buffer, o) || typeof a < "u" && (Ee(G, a) || G && Ee(G.buffer, a)))
      return b(G, O, B);
    if (typeof G == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Z = G.valueOf && G.valueOf();
    if (Z != null && Z !== G)
      return u.from(Z, O, B);
    const le = _(G);
    if (le) return le;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof G[Symbol.toPrimitive] == "function")
      return u.from(G[Symbol.toPrimitive]("string"), O, B);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof G
    );
  }
  u.from = function(G, O, B) {
    return h(G, O, B);
  }, Object.setPrototypeOf(u.prototype, i.prototype), Object.setPrototypeOf(u, i);
  function d(G) {
    if (typeof G != "number")
      throw new TypeError('"size" argument must be of type number');
    if (G < 0)
      throw new RangeError('The value "' + G + '" is invalid for option "size"');
  }
  function f(G, O, B) {
    return d(G), G <= 0 ? c(G) : O !== void 0 ? typeof B == "string" ? c(G).fill(O, B) : c(G).fill(O) : c(G);
  }
  u.alloc = function(G, O, B) {
    return f(G, O, B);
  };
  function g(G) {
    return d(G), c(G < 0 ? 0 : v(G) | 0);
  }
  u.allocUnsafe = function(G) {
    return g(G);
  }, u.allocUnsafeSlow = function(G) {
    return g(G);
  };
  function y(G, O) {
    if ((typeof O != "string" || O === "") && (O = "utf8"), !u.isEncoding(O))
      throw new TypeError("Unknown encoding: " + O);
    const B = E(G, O) | 0;
    let Z = c(B);
    const le = Z.write(G, O);
    return le !== B && (Z = Z.slice(0, le)), Z;
  }
  function p(G) {
    const O = G.length < 0 ? 0 : v(G.length) | 0, B = c(O);
    for (let Z = 0; Z < O; Z += 1)
      B[Z] = G[Z] & 255;
    return B;
  }
  function m(G) {
    if (Ee(G, i)) {
      const O = new i(G);
      return b(O.buffer, O.byteOffset, O.byteLength);
    }
    return p(G);
  }
  function b(G, O, B) {
    if (O < 0 || G.byteLength < O)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (G.byteLength < O + (B || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Z;
    return O === void 0 && B === void 0 ? Z = new i(G) : B === void 0 ? Z = new i(G, O) : Z = new i(G, O, B), Object.setPrototypeOf(Z, u.prototype), Z;
  }
  function _(G) {
    if (u.isBuffer(G)) {
      const O = v(G.length) | 0, B = c(O);
      return B.length === 0 || G.copy(B, 0, 0, O), B;
    }
    if (G.length !== void 0)
      return typeof G.length != "number" || oe(G.length) ? c(0) : p(G);
    if (G.type === "Buffer" && Array.isArray(G.data))
      return p(G.data);
  }
  function v(G) {
    if (G >= s)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
    return G | 0;
  }
  function w(G) {
    return +G != G && (G = 0), u.alloc(+G);
  }
  u.isBuffer = function(O) {
    return O != null && O._isBuffer === !0 && O !== u.prototype;
  }, u.compare = function(O, B) {
    if (Ee(O, i) && (O = u.from(O, O.offset, O.byteLength)), Ee(B, i) && (B = u.from(B, B.offset, B.byteLength)), !u.isBuffer(O) || !u.isBuffer(B))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (O === B) return 0;
    let Z = O.length, le = B.length;
    for (let ge = 0, we = Math.min(Z, le); ge < we; ++ge)
      if (O[ge] !== B[ge]) {
        Z = O[ge], le = B[ge];
        break;
      }
    return Z < le ? -1 : le < Z ? 1 : 0;
  }, u.isEncoding = function(O) {
    switch (String(O).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(O, B) {
    if (!Array.isArray(O))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (O.length === 0)
      return u.alloc(0);
    let Z;
    if (B === void 0)
      for (B = 0, Z = 0; Z < O.length; ++Z)
        B += O[Z].length;
    const le = u.allocUnsafe(B);
    let ge = 0;
    for (Z = 0; Z < O.length; ++Z) {
      let we = O[Z];
      if (Ee(we, i))
        ge + we.length > le.length ? (u.isBuffer(we) || (we = u.from(we)), we.copy(le, ge)) : i.prototype.set.call(
          le,
          we,
          ge
        );
      else if (u.isBuffer(we))
        we.copy(le, ge);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ge += we.length;
    }
    return le;
  };
  function E(G, O) {
    if (u.isBuffer(G))
      return G.length;
    if (o.isView(G) || Ee(G, o))
      return G.byteLength;
    if (typeof G != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof G
      );
    const B = G.length, Z = arguments.length > 2 && arguments[2] === !0;
    if (!Z && B === 0) return 0;
    let le = !1;
    for (; ; )
      switch (O) {
        case "ascii":
        case "latin1":
        case "binary":
          return B;
        case "utf8":
        case "utf-8":
          return ye(G).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return B * 2;
        case "hex":
          return B >>> 1;
        case "base64":
          return Ce(G).length;
        default:
          if (le)
            return Z ? -1 : ye(G).length;
          O = ("" + O).toLowerCase(), le = !0;
      }
  }
  u.byteLength = E;
  function x(G, O, B) {
    let Z = !1;
    if ((O === void 0 || O < 0) && (O = 0), O > this.length || ((B === void 0 || B > this.length) && (B = this.length), B <= 0) || (B >>>= 0, O >>>= 0, B <= O))
      return "";
    for (G || (G = "utf8"); ; )
      switch (G) {
        case "hex":
          return H(this, O, B);
        case "utf8":
        case "utf-8":
          return K(this, O, B);
        case "ascii":
          return L(this, O, B);
        case "latin1":
        case "binary":
          return j(this, O, B);
        case "base64":
          return ee(this, O, B);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return U(this, O, B);
        default:
          if (Z) throw new TypeError("Unknown encoding: " + G);
          G = (G + "").toLowerCase(), Z = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function S(G, O, B) {
    const Z = G[O];
    G[O] = G[B], G[B] = Z;
  }
  u.prototype.swap16 = function() {
    const O = this.length;
    if (O % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let B = 0; B < O; B += 2)
      S(this, B, B + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const O = this.length;
    if (O % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let B = 0; B < O; B += 4)
      S(this, B, B + 3), S(this, B + 1, B + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const O = this.length;
    if (O % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let B = 0; B < O; B += 8)
      S(this, B, B + 7), S(this, B + 1, B + 6), S(this, B + 2, B + 5), S(this, B + 3, B + 4);
    return this;
  }, u.prototype.toString = function() {
    const O = this.length;
    return O === 0 ? "" : arguments.length === 0 ? K(this, 0, O) : x.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(O) {
    if (!u.isBuffer(O)) throw new TypeError("Argument must be a Buffer");
    return this === O ? !0 : u.compare(this, O) === 0;
  }, u.prototype.inspect = function() {
    let O = "";
    const B = t.INSPECT_MAX_BYTES;
    return O = this.toString("hex", 0, B).replace(/(.{2})/g, "$1 ").trim(), this.length > B && (O += " ... "), "<Buffer " + O + ">";
  }, r && (u.prototype[r] = u.prototype.inspect), u.prototype.compare = function(O, B, Z, le, ge) {
    if (Ee(O, i) && (O = u.from(O, O.offset, O.byteLength)), !u.isBuffer(O))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof O
      );
    if (B === void 0 && (B = 0), Z === void 0 && (Z = O ? O.length : 0), le === void 0 && (le = 0), ge === void 0 && (ge = this.length), B < 0 || Z > O.length || le < 0 || ge > this.length)
      throw new RangeError("out of range index");
    if (le >= ge && B >= Z)
      return 0;
    if (le >= ge)
      return -1;
    if (B >= Z)
      return 1;
    if (B >>>= 0, Z >>>= 0, le >>>= 0, ge >>>= 0, this === O) return 0;
    let we = ge - le, Je = Z - B;
    const ft = Math.min(we, Je), Ot = this.slice(le, ge), Bt = O.slice(B, Z);
    for (let Ct = 0; Ct < ft; ++Ct)
      if (Ot[Ct] !== Bt[Ct]) {
        we = Ot[Ct], Je = Bt[Ct];
        break;
      }
    return we < Je ? -1 : Je < we ? 1 : 0;
  };
  function T(G, O, B, Z, le) {
    if (G.length === 0) return -1;
    if (typeof B == "string" ? (Z = B, B = 0) : B > 2147483647 ? B = 2147483647 : B < -2147483648 && (B = -2147483648), B = +B, oe(B) && (B = le ? 0 : G.length - 1), B < 0 && (B = G.length + B), B >= G.length) {
      if (le) return -1;
      B = G.length - 1;
    } else if (B < 0)
      if (le) B = 0;
      else return -1;
    if (typeof O == "string" && (O = u.from(O, Z)), u.isBuffer(O))
      return O.length === 0 ? -1 : R(G, O, B, Z, le);
    if (typeof O == "number")
      return O = O & 255, typeof i.prototype.indexOf == "function" ? le ? i.prototype.indexOf.call(G, O, B) : i.prototype.lastIndexOf.call(G, O, B) : R(G, [O], B, Z, le);
    throw new TypeError("val must be string, number or Buffer");
  }
  function R(G, O, B, Z, le) {
    let ge = 1, we = G.length, Je = O.length;
    if (Z !== void 0 && (Z = String(Z).toLowerCase(), Z === "ucs2" || Z === "ucs-2" || Z === "utf16le" || Z === "utf-16le")) {
      if (G.length < 2 || O.length < 2)
        return -1;
      ge = 2, we /= 2, Je /= 2, B /= 2;
    }
    function ft(Bt, Ct) {
      return ge === 1 ? Bt[Ct] : Bt.readUInt16BE(Ct * ge);
    }
    let Ot;
    if (le) {
      let Bt = -1;
      for (Ot = B; Ot < we; Ot++)
        if (ft(G, Ot) === ft(O, Bt === -1 ? 0 : Ot - Bt)) {
          if (Bt === -1 && (Bt = Ot), Ot - Bt + 1 === Je) return Bt * ge;
        } else
          Bt !== -1 && (Ot -= Ot - Bt), Bt = -1;
    } else
      for (B + Je > we && (B = we - Je), Ot = B; Ot >= 0; Ot--) {
        let Bt = !0;
        for (let Ct = 0; Ct < Je; Ct++)
          if (ft(G, Ot + Ct) !== ft(O, Ct)) {
            Bt = !1;
            break;
          }
        if (Bt) return Ot;
      }
    return -1;
  }
  u.prototype.includes = function(O, B, Z) {
    return this.indexOf(O, B, Z) !== -1;
  }, u.prototype.indexOf = function(O, B, Z) {
    return T(this, O, B, Z, !0);
  }, u.prototype.lastIndexOf = function(O, B, Z) {
    return T(this, O, B, Z, !1);
  };
  function F(G, O, B, Z) {
    B = Number(B) || 0;
    const le = G.length - B;
    Z ? (Z = Number(Z), Z > le && (Z = le)) : Z = le;
    const ge = O.length;
    Z > ge / 2 && (Z = ge / 2);
    let we;
    for (we = 0; we < Z; ++we) {
      const Je = parseInt(O.substr(we * 2, 2), 16);
      if (oe(Je)) return we;
      G[B + we] = Je;
    }
    return we;
  }
  function P(G, O, B, Z) {
    return ve(ye(O, G.length - B), G, B, Z);
  }
  function M(G, O, B, Z) {
    return ve(xe(O), G, B, Z);
  }
  function A(G, O, B, Z) {
    return ve(Ce(O), G, B, Z);
  }
  function V(G, O, B, Z) {
    return ve(fe(O, G.length - B), G, B, Z);
  }
  u.prototype.write = function(O, B, Z, le) {
    if (B === void 0)
      le = "utf8", Z = this.length, B = 0;
    else if (Z === void 0 && typeof B == "string")
      le = B, Z = this.length, B = 0;
    else if (isFinite(B))
      B = B >>> 0, isFinite(Z) ? (Z = Z >>> 0, le === void 0 && (le = "utf8")) : (le = Z, Z = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ge = this.length - B;
    if ((Z === void 0 || Z > ge) && (Z = ge), O.length > 0 && (Z < 0 || B < 0) || B > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    le || (le = "utf8");
    let we = !1;
    for (; ; )
      switch (le) {
        case "hex":
          return F(this, O, B, Z);
        case "utf8":
        case "utf-8":
          return P(this, O, B, Z);
        case "ascii":
        case "latin1":
        case "binary":
          return M(this, O, B, Z);
        case "base64":
          return A(this, O, B, Z);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return V(this, O, B, Z);
        default:
          if (we) throw new TypeError("Unknown encoding: " + le);
          le = ("" + le).toLowerCase(), we = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ee(G, O, B) {
    return O === 0 && B === G.length ? e.fromByteArray(G) : e.fromByteArray(G.slice(O, B));
  }
  function K(G, O, B) {
    B = Math.min(G.length, B);
    const Z = [];
    let le = O;
    for (; le < B; ) {
      const ge = G[le];
      let we = null, Je = ge > 239 ? 4 : ge > 223 ? 3 : ge > 191 ? 2 : 1;
      if (le + Je <= B) {
        let ft, Ot, Bt, Ct;
        switch (Je) {
          case 1:
            ge < 128 && (we = ge);
            break;
          case 2:
            ft = G[le + 1], (ft & 192) === 128 && (Ct = (ge & 31) << 6 | ft & 63, Ct > 127 && (we = Ct));
            break;
          case 3:
            ft = G[le + 1], Ot = G[le + 2], (ft & 192) === 128 && (Ot & 192) === 128 && (Ct = (ge & 15) << 12 | (ft & 63) << 6 | Ot & 63, Ct > 2047 && (Ct < 55296 || Ct > 57343) && (we = Ct));
            break;
          case 4:
            ft = G[le + 1], Ot = G[le + 2], Bt = G[le + 3], (ft & 192) === 128 && (Ot & 192) === 128 && (Bt & 192) === 128 && (Ct = (ge & 15) << 18 | (ft & 63) << 12 | (Ot & 63) << 6 | Bt & 63, Ct > 65535 && Ct < 1114112 && (we = Ct));
        }
      }
      we === null ? (we = 65533, Je = 1) : we > 65535 && (we -= 65536, Z.push(we >>> 10 & 1023 | 55296), we = 56320 | we & 1023), Z.push(we), le += Je;
    }
    return N(Z);
  }
  const te = 4096;
  function N(G) {
    const O = G.length;
    if (O <= te)
      return String.fromCharCode.apply(String, G);
    let B = "", Z = 0;
    for (; Z < O; )
      B += String.fromCharCode.apply(
        String,
        G.slice(Z, Z += te)
      );
    return B;
  }
  function L(G, O, B) {
    let Z = "";
    B = Math.min(G.length, B);
    for (let le = O; le < B; ++le)
      Z += String.fromCharCode(G[le] & 127);
    return Z;
  }
  function j(G, O, B) {
    let Z = "";
    B = Math.min(G.length, B);
    for (let le = O; le < B; ++le)
      Z += String.fromCharCode(G[le]);
    return Z;
  }
  function H(G, O, B) {
    const Z = G.length;
    (!O || O < 0) && (O = 0), (!B || B < 0 || B > Z) && (B = Z);
    let le = "";
    for (let ge = O; ge < B; ++ge)
      le += Te[G[ge]];
    return le;
  }
  function U(G, O, B) {
    const Z = G.slice(O, B);
    let le = "";
    for (let ge = 0; ge < Z.length - 1; ge += 2)
      le += String.fromCharCode(Z[ge] + Z[ge + 1] * 256);
    return le;
  }
  u.prototype.slice = function(O, B) {
    const Z = this.length;
    O = ~~O, B = B === void 0 ? Z : ~~B, O < 0 ? (O += Z, O < 0 && (O = 0)) : O > Z && (O = Z), B < 0 ? (B += Z, B < 0 && (B = 0)) : B > Z && (B = Z), B < O && (B = O);
    const le = this.subarray(O, B);
    return Object.setPrototypeOf(le, u.prototype), le;
  };
  function Y(G, O, B) {
    if (G % 1 !== 0 || G < 0) throw new RangeError("offset is not uint");
    if (G + O > B) throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(O, B, Z) {
    O = O >>> 0, B = B >>> 0, Z || Y(O, B, this.length);
    let le = this[O], ge = 1, we = 0;
    for (; ++we < B && (ge *= 256); )
      le += this[O + we] * ge;
    return le;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(O, B, Z) {
    O = O >>> 0, B = B >>> 0, Z || Y(O, B, this.length);
    let le = this[O + --B], ge = 1;
    for (; B > 0 && (ge *= 256); )
      le += this[O + --B] * ge;
    return le;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(O, B) {
    return O = O >>> 0, B || Y(O, 1, this.length), this[O];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(O, B) {
    return O = O >>> 0, B || Y(O, 2, this.length), this[O] | this[O + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(O, B) {
    return O = O >>> 0, B || Y(O, 2, this.length), this[O] << 8 | this[O + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(O, B) {
    return O = O >>> 0, B || Y(O, 4, this.length), (this[O] | this[O + 1] << 8 | this[O + 2] << 16) + this[O + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(O, B) {
    return O = O >>> 0, B || Y(O, 4, this.length), this[O] * 16777216 + (this[O + 1] << 16 | this[O + 2] << 8 | this[O + 3]);
  }, u.prototype.readBigUInt64LE = ke(function(O) {
    O = O >>> 0, re(O, "offset");
    const B = this[O], Z = this[O + 7];
    (B === void 0 || Z === void 0) && W(O, this.length - 8);
    const le = B + this[++O] * 2 ** 8 + this[++O] * 2 ** 16 + this[++O] * 2 ** 24, ge = this[++O] + this[++O] * 2 ** 8 + this[++O] * 2 ** 16 + Z * 2 ** 24;
    return BigInt(le) + (BigInt(ge) << BigInt(32));
  }), u.prototype.readBigUInt64BE = ke(function(O) {
    O = O >>> 0, re(O, "offset");
    const B = this[O], Z = this[O + 7];
    (B === void 0 || Z === void 0) && W(O, this.length - 8);
    const le = B * 2 ** 24 + this[++O] * 2 ** 16 + this[++O] * 2 ** 8 + this[++O], ge = this[++O] * 2 ** 24 + this[++O] * 2 ** 16 + this[++O] * 2 ** 8 + Z;
    return (BigInt(le) << BigInt(32)) + BigInt(ge);
  }), u.prototype.readIntLE = function(O, B, Z) {
    O = O >>> 0, B = B >>> 0, Z || Y(O, B, this.length);
    let le = this[O], ge = 1, we = 0;
    for (; ++we < B && (ge *= 256); )
      le += this[O + we] * ge;
    return ge *= 128, le >= ge && (le -= Math.pow(2, 8 * B)), le;
  }, u.prototype.readIntBE = function(O, B, Z) {
    O = O >>> 0, B = B >>> 0, Z || Y(O, B, this.length);
    let le = B, ge = 1, we = this[O + --le];
    for (; le > 0 && (ge *= 256); )
      we += this[O + --le] * ge;
    return ge *= 128, we >= ge && (we -= Math.pow(2, 8 * B)), we;
  }, u.prototype.readInt8 = function(O, B) {
    return O = O >>> 0, B || Y(O, 1, this.length), this[O] & 128 ? (255 - this[O] + 1) * -1 : this[O];
  }, u.prototype.readInt16LE = function(O, B) {
    O = O >>> 0, B || Y(O, 2, this.length);
    const Z = this[O] | this[O + 1] << 8;
    return Z & 32768 ? Z | 4294901760 : Z;
  }, u.prototype.readInt16BE = function(O, B) {
    O = O >>> 0, B || Y(O, 2, this.length);
    const Z = this[O + 1] | this[O] << 8;
    return Z & 32768 ? Z | 4294901760 : Z;
  }, u.prototype.readInt32LE = function(O, B) {
    return O = O >>> 0, B || Y(O, 4, this.length), this[O] | this[O + 1] << 8 | this[O + 2] << 16 | this[O + 3] << 24;
  }, u.prototype.readInt32BE = function(O, B) {
    return O = O >>> 0, B || Y(O, 4, this.length), this[O] << 24 | this[O + 1] << 16 | this[O + 2] << 8 | this[O + 3];
  }, u.prototype.readBigInt64LE = ke(function(O) {
    O = O >>> 0, re(O, "offset");
    const B = this[O], Z = this[O + 7];
    (B === void 0 || Z === void 0) && W(O, this.length - 8);
    const le = this[O + 4] + this[O + 5] * 2 ** 8 + this[O + 6] * 2 ** 16 + (Z << 24);
    return (BigInt(le) << BigInt(32)) + BigInt(B + this[++O] * 2 ** 8 + this[++O] * 2 ** 16 + this[++O] * 2 ** 24);
  }), u.prototype.readBigInt64BE = ke(function(O) {
    O = O >>> 0, re(O, "offset");
    const B = this[O], Z = this[O + 7];
    (B === void 0 || Z === void 0) && W(O, this.length - 8);
    const le = (B << 24) + // Overflow
    this[++O] * 2 ** 16 + this[++O] * 2 ** 8 + this[++O];
    return (BigInt(le) << BigInt(32)) + BigInt(this[++O] * 2 ** 24 + this[++O] * 2 ** 16 + this[++O] * 2 ** 8 + Z);
  }), u.prototype.readFloatLE = function(O, B) {
    return O = O >>> 0, B || Y(O, 4, this.length), n.read(this, O, !0, 23, 4);
  }, u.prototype.readFloatBE = function(O, B) {
    return O = O >>> 0, B || Y(O, 4, this.length), n.read(this, O, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(O, B) {
    return O = O >>> 0, B || Y(O, 8, this.length), n.read(this, O, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(O, B) {
    return O = O >>> 0, B || Y(O, 8, this.length), n.read(this, O, !1, 52, 8);
  };
  function ne(G, O, B, Z, le, ge) {
    if (!u.isBuffer(G)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (O > le || O < ge) throw new RangeError('"value" argument is out of bounds');
    if (B + Z > G.length) throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(O, B, Z, le) {
    if (O = +O, B = B >>> 0, Z = Z >>> 0, !le) {
      const Je = Math.pow(2, 8 * Z) - 1;
      ne(this, O, B, Z, Je, 0);
    }
    let ge = 1, we = 0;
    for (this[B] = O & 255; ++we < Z && (ge *= 256); )
      this[B + we] = O / ge & 255;
    return B + Z;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(O, B, Z, le) {
    if (O = +O, B = B >>> 0, Z = Z >>> 0, !le) {
      const Je = Math.pow(2, 8 * Z) - 1;
      ne(this, O, B, Z, Je, 0);
    }
    let ge = Z - 1, we = 1;
    for (this[B + ge] = O & 255; --ge >= 0 && (we *= 256); )
      this[B + ge] = O / we & 255;
    return B + Z;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 1, 255, 0), this[B] = O & 255, B + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 2, 65535, 0), this[B] = O & 255, this[B + 1] = O >>> 8, B + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 2, 65535, 0), this[B] = O >>> 8, this[B + 1] = O & 255, B + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 4, 4294967295, 0), this[B + 3] = O >>> 24, this[B + 2] = O >>> 16, this[B + 1] = O >>> 8, this[B] = O & 255, B + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 4, 4294967295, 0), this[B] = O >>> 24, this[B + 1] = O >>> 16, this[B + 2] = O >>> 8, this[B + 3] = O & 255, B + 4;
  };
  function he(G, O, B, Z, le) {
    ce(O, Z, le, G, B, 7);
    let ge = Number(O & BigInt(4294967295));
    G[B++] = ge, ge = ge >> 8, G[B++] = ge, ge = ge >> 8, G[B++] = ge, ge = ge >> 8, G[B++] = ge;
    let we = Number(O >> BigInt(32) & BigInt(4294967295));
    return G[B++] = we, we = we >> 8, G[B++] = we, we = we >> 8, G[B++] = we, we = we >> 8, G[B++] = we, B;
  }
  function X(G, O, B, Z, le) {
    ce(O, Z, le, G, B, 7);
    let ge = Number(O & BigInt(4294967295));
    G[B + 7] = ge, ge = ge >> 8, G[B + 6] = ge, ge = ge >> 8, G[B + 5] = ge, ge = ge >> 8, G[B + 4] = ge;
    let we = Number(O >> BigInt(32) & BigInt(4294967295));
    return G[B + 3] = we, we = we >> 8, G[B + 2] = we, we = we >> 8, G[B + 1] = we, we = we >> 8, G[B] = we, B + 8;
  }
  u.prototype.writeBigUInt64LE = ke(function(O, B = 0) {
    return he(this, O, B, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = ke(function(O, B = 0) {
    return X(this, O, B, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(O, B, Z, le) {
    if (O = +O, B = B >>> 0, !le) {
      const ft = Math.pow(2, 8 * Z - 1);
      ne(this, O, B, Z, ft - 1, -ft);
    }
    let ge = 0, we = 1, Je = 0;
    for (this[B] = O & 255; ++ge < Z && (we *= 256); )
      O < 0 && Je === 0 && this[B + ge - 1] !== 0 && (Je = 1), this[B + ge] = (O / we >> 0) - Je & 255;
    return B + Z;
  }, u.prototype.writeIntBE = function(O, B, Z, le) {
    if (O = +O, B = B >>> 0, !le) {
      const ft = Math.pow(2, 8 * Z - 1);
      ne(this, O, B, Z, ft - 1, -ft);
    }
    let ge = Z - 1, we = 1, Je = 0;
    for (this[B + ge] = O & 255; --ge >= 0 && (we *= 256); )
      O < 0 && Je === 0 && this[B + ge + 1] !== 0 && (Je = 1), this[B + ge] = (O / we >> 0) - Je & 255;
    return B + Z;
  }, u.prototype.writeInt8 = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 1, 127, -128), O < 0 && (O = 255 + O + 1), this[B] = O & 255, B + 1;
  }, u.prototype.writeInt16LE = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 2, 32767, -32768), this[B] = O & 255, this[B + 1] = O >>> 8, B + 2;
  }, u.prototype.writeInt16BE = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 2, 32767, -32768), this[B] = O >>> 8, this[B + 1] = O & 255, B + 2;
  }, u.prototype.writeInt32LE = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 4, 2147483647, -2147483648), this[B] = O & 255, this[B + 1] = O >>> 8, this[B + 2] = O >>> 16, this[B + 3] = O >>> 24, B + 4;
  }, u.prototype.writeInt32BE = function(O, B, Z) {
    return O = +O, B = B >>> 0, Z || ne(this, O, B, 4, 2147483647, -2147483648), O < 0 && (O = 4294967295 + O + 1), this[B] = O >>> 24, this[B + 1] = O >>> 16, this[B + 2] = O >>> 8, this[B + 3] = O & 255, B + 4;
  }, u.prototype.writeBigInt64LE = ke(function(O, B = 0) {
    return he(this, O, B, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = ke(function(O, B = 0) {
    return X(this, O, B, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function z(G, O, B, Z, le, ge) {
    if (B + Z > G.length) throw new RangeError("Index out of range");
    if (B < 0) throw new RangeError("Index out of range");
  }
  function ue(G, O, B, Z, le) {
    return O = +O, B = B >>> 0, le || z(G, O, B, 4), n.write(G, O, B, Z, 23, 4), B + 4;
  }
  u.prototype.writeFloatLE = function(O, B, Z) {
    return ue(this, O, B, !0, Z);
  }, u.prototype.writeFloatBE = function(O, B, Z) {
    return ue(this, O, B, !1, Z);
  };
  function ae(G, O, B, Z, le) {
    return O = +O, B = B >>> 0, le || z(G, O, B, 8), n.write(G, O, B, Z, 52, 8), B + 8;
  }
  u.prototype.writeDoubleLE = function(O, B, Z) {
    return ae(this, O, B, !0, Z);
  }, u.prototype.writeDoubleBE = function(O, B, Z) {
    return ae(this, O, B, !1, Z);
  }, u.prototype.copy = function(O, B, Z, le) {
    if (!u.isBuffer(O)) throw new TypeError("argument should be a Buffer");
    if (Z || (Z = 0), !le && le !== 0 && (le = this.length), B >= O.length && (B = O.length), B || (B = 0), le > 0 && le < Z && (le = Z), le === Z || O.length === 0 || this.length === 0) return 0;
    if (B < 0)
      throw new RangeError("targetStart out of bounds");
    if (Z < 0 || Z >= this.length) throw new RangeError("Index out of range");
    if (le < 0) throw new RangeError("sourceEnd out of bounds");
    le > this.length && (le = this.length), O.length - B < le - Z && (le = O.length - B + Z);
    const ge = le - Z;
    return this === O && typeof i.prototype.copyWithin == "function" ? this.copyWithin(B, Z, le) : i.prototype.set.call(
      O,
      this.subarray(Z, le),
      B
    ), ge;
  }, u.prototype.fill = function(O, B, Z, le) {
    if (typeof O == "string") {
      if (typeof B == "string" ? (le = B, B = 0, Z = this.length) : typeof Z == "string" && (le = Z, Z = this.length), le !== void 0 && typeof le != "string")
        throw new TypeError("encoding must be a string");
      if (typeof le == "string" && !u.isEncoding(le))
        throw new TypeError("Unknown encoding: " + le);
      if (O.length === 1) {
        const we = O.charCodeAt(0);
        (le === "utf8" && we < 128 || le === "latin1") && (O = we);
      }
    } else typeof O == "number" ? O = O & 255 : typeof O == "boolean" && (O = Number(O));
    if (B < 0 || this.length < B || this.length < Z)
      throw new RangeError("Out of range index");
    if (Z <= B)
      return this;
    B = B >>> 0, Z = Z === void 0 ? this.length : Z >>> 0, O || (O = 0);
    let ge;
    if (typeof O == "number")
      for (ge = B; ge < Z; ++ge)
        this[ge] = O;
    else {
      const we = u.isBuffer(O) ? O : u.from(O, le), Je = we.length;
      if (Je === 0)
        throw new TypeError('The value "' + O + '" is invalid for argument "value"');
      for (ge = 0; ge < Z - B; ++ge)
        this[ge + B] = we[ge % Je];
    }
    return this;
  };
  const be = {};
  function de(G, O, B) {
    be[G] = class extends B {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: O.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${G}]`, this.stack, delete this.name;
      }
      get code() {
        return G;
      }
      set code(le) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: le,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${G}]: ${this.message}`;
      }
    };
  }
  de(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(G) {
      return G ? `${G} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), de(
    "ERR_INVALID_ARG_TYPE",
    function(G, O) {
      return `The "${G}" argument must be of type number. Received type ${typeof O}`;
    },
    TypeError
  ), de(
    "ERR_OUT_OF_RANGE",
    function(G, O, B) {
      let Z = `The value of "${G}" is out of range.`, le = B;
      return Number.isInteger(B) && Math.abs(B) > 2 ** 32 ? le = _e(String(B)) : typeof B == "bigint" && (le = String(B), (B > BigInt(2) ** BigInt(32) || B < -(BigInt(2) ** BigInt(32))) && (le = _e(le)), le += "n"), Z += ` It must be ${O}. Received ${le}`, Z;
    },
    RangeError
  );
  function _e(G) {
    let O = "", B = G.length;
    const Z = G[0] === "-" ? 1 : 0;
    for (; B >= Z + 4; B -= 3)
      O = `_${G.slice(B - 3, B)}${O}`;
    return `${G.slice(0, B)}${O}`;
  }
  function $(G, O, B) {
    re(O, "offset"), (G[O] === void 0 || G[O + B] === void 0) && W(O, G.length - (B + 1));
  }
  function ce(G, O, B, Z, le, ge) {
    if (G > B || G < O) {
      const we = typeof O == "bigint" ? "n" : "";
      let Je;
      throw O === 0 || O === BigInt(0) ? Je = `>= 0${we} and < 2${we} ** ${(ge + 1) * 8}${we}` : Je = `>= -(2${we} ** ${(ge + 1) * 8 - 1}${we}) and < 2 ** ${(ge + 1) * 8 - 1}${we}`, new be.ERR_OUT_OF_RANGE("value", Je, G);
    }
    $(Z, le, ge);
  }
  function re(G, O) {
    if (typeof G != "number")
      throw new be.ERR_INVALID_ARG_TYPE(O, "number", G);
  }
  function W(G, O, B) {
    throw Math.floor(G) !== G ? (re(G, B), new be.ERR_OUT_OF_RANGE("offset", "an integer", G)) : O < 0 ? new be.ERR_BUFFER_OUT_OF_BOUNDS() : new be.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${O}`,
      G
    );
  }
  const q = /[^+/0-9A-Za-z-_]/g;
  function ie(G) {
    if (G = G.split("=")[0], G = G.trim().replace(q, ""), G.length < 2) return "";
    for (; G.length % 4 !== 0; )
      G = G + "=";
    return G;
  }
  function ye(G, O) {
    O = O || 1 / 0;
    let B;
    const Z = G.length;
    let le = null;
    const ge = [];
    for (let we = 0; we < Z; ++we) {
      if (B = G.charCodeAt(we), B > 55295 && B < 57344) {
        if (!le) {
          if (B > 56319) {
            (O -= 3) > -1 && ge.push(239, 191, 189);
            continue;
          } else if (we + 1 === Z) {
            (O -= 3) > -1 && ge.push(239, 191, 189);
            continue;
          }
          le = B;
          continue;
        }
        if (B < 56320) {
          (O -= 3) > -1 && ge.push(239, 191, 189), le = B;
          continue;
        }
        B = (le - 55296 << 10 | B - 56320) + 65536;
      } else le && (O -= 3) > -1 && ge.push(239, 191, 189);
      if (le = null, B < 128) {
        if ((O -= 1) < 0) break;
        ge.push(B);
      } else if (B < 2048) {
        if ((O -= 2) < 0) break;
        ge.push(
          B >> 6 | 192,
          B & 63 | 128
        );
      } else if (B < 65536) {
        if ((O -= 3) < 0) break;
        ge.push(
          B >> 12 | 224,
          B >> 6 & 63 | 128,
          B & 63 | 128
        );
      } else if (B < 1114112) {
        if ((O -= 4) < 0) break;
        ge.push(
          B >> 18 | 240,
          B >> 12 & 63 | 128,
          B >> 6 & 63 | 128,
          B & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ge;
  }
  function xe(G) {
    const O = [];
    for (let B = 0; B < G.length; ++B)
      O.push(G.charCodeAt(B) & 255);
    return O;
  }
  function fe(G, O) {
    let B, Z, le;
    const ge = [];
    for (let we = 0; we < G.length && !((O -= 2) < 0); ++we)
      B = G.charCodeAt(we), Z = B >> 8, le = B % 256, ge.push(le), ge.push(Z);
    return ge;
  }
  function Ce(G) {
    return e.toByteArray(ie(G));
  }
  function ve(G, O, B, Z) {
    let le;
    for (le = 0; le < Z && !(le + B >= O.length || le >= G.length); ++le)
      O[le + B] = G[le];
    return le;
  }
  function Ee(G, O) {
    return G instanceof O || G != null && G.constructor != null && G.constructor.name != null && G.constructor.name === O.name;
  }
  function oe(G) {
    return G !== G;
  }
  const Te = function() {
    const G = "0123456789abcdef", O = new Array(256);
    for (let B = 0; B < 16; ++B) {
      const Z = B * 16;
      for (let le = 0; le < 16; ++le)
        O[Z + le] = G[B] + G[le];
    }
    return O;
  }();
  function ke(G) {
    return typeof BigInt > "u" ? Ge : G;
  }
  function Ge() {
    throw new Error("BigInt not supported");
  }
})(pn);
const Me = pn.Buffer, Sre = pn.Blob, xre = pn.BlobOptions, W4 = pn.Buffer, Tre = pn.File, Cre = pn.FileOptions, kre = pn.INSPECT_MAX_BYTES, Are = pn.SlowBuffer, Rre = pn.TranscodeEncoding, Ire = pn.atob, Pre = pn.btoa, Ore = pn.constants, Dre = pn.isAscii, Nre = pn.isUtf8, Lre = pn.kMaxLength, Mre = pn.kStringMaxLength, Bre = pn.resolveObjectURL, Fre = pn.transcode, $re = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Sre,
  BlobOptions: xre,
  Buffer: W4,
  File: Tre,
  FileOptions: Cre,
  INSPECT_MAX_BYTES: kre,
  SlowBuffer: Are,
  TranscodeEncoding: Rre,
  atob: Ire,
  btoa: Pre,
  constants: Ore,
  default: Me,
  isAscii: Dre,
  isUtf8: Nre,
  kMaxLength: Lre,
  kStringMaxLength: Mre,
  resolveObjectURL: Bre,
  transcode: Fre
}, Symbol.toStringTag, { value: "Module" })), Ure = "https://stackblitz.com", jre = new Error();
jre.stack = "";
function Hre() {
  let t, e;
  function n() {
    e = new Promise((r) => t = r);
  }
  return n(), {
    get promise() {
      return e;
    },
    resolve(r) {
      return t(r);
    },
    reset: n
  };
}
let Kp;
const zre = {
  authComplete: Hre(),
  get editorOrigin() {
    return Kp == null && (Kp = new URL(globalThis.WEBCONTAINER_API_IFRAME_URL ?? Ure).origin), Kp;
  },
  set editorOrigin(t) {
    Kp = t;
  }
};
function q4(t) {
  const e = { d: {} };
  for (const n of Object.keys(t)) {
    const r = t[n];
    if ("file" in r) {
      const i = r.file.contents, o = typeof i == "string" ? i : Gre(i), a = typeof i == "string" ? {} : { b: !0 };
      e.d[n] = { f: { c: o, ...a } };
      continue;
    }
    const s = q4(r.directory);
    e.d[n] = s;
  }
  return e;
}
function Gre(t) {
  let e = "";
  for (const n of t)
    e += String.fromCharCode(n);
  return e;
}
var zh;
(function(t) {
  t.UncaughtException = "PREVIEW_UNCAUGHT_EXCEPTION", t.UnhandledRejection = "PREVIEW_UNHANDLED_REJECTION", t.ConsoleError = "PREVIEW_CONSOLE_ERROR";
})(zh || (zh = {}));
var Vre = Object.defineProperty, Wre = (t, e) => {
  for (var n in e)
    Vre(t, n, { get: e[n], enumerable: !0 });
}, Xr = {};
Wre(Xr, {
  createEndpoint: () => K4,
  expose: () => kC,
  proxy: () => t5,
  proxyMarker: () => TC,
  releaseProxy: () => Y4,
  transfer: () => e5,
  transferHandlers: () => CC,
  windowEndpoint: () => Jre,
  wrap: () => X4
});
var TC = Symbol("Comlink.proxy"), K4 = Symbol("Comlink.endpoint"), Y4 = Symbol("Comlink.releaseProxy"), J1 = Symbol("Comlink.thrown"), Z4 = (t) => typeof t == "object" && t !== null || typeof t == "function", qre = {
  canHandle: (t) => Z4(t) && t[TC],
  serialize(t) {
    const { port1: e, port2: n } = new MessageChannel();
    return kC(t, e), [n, [n]];
  },
  deserialize(t) {
    return t.start(), X4(t);
  }
}, Kre = {
  canHandle: (t) => Z4(t) && J1 in t,
  serialize({ value: t }) {
    let e;
    return t instanceof Error ? e = {
      isError: !0,
      value: {
        message: t.message,
        name: t.name,
        stack: t.stack
      }
    } : e = { isError: !1, value: t }, [e, []];
  },
  deserialize(t) {
    throw t.isError ? Object.assign(new Error(t.value.message), t.value) : t.value;
  }
}, CC = /* @__PURE__ */ new Map([
  ["proxy", qre],
  ["throw", Kre]
]);
function kC(t, e = self) {
  e.addEventListener("message", function n(r) {
    if (!r || !r.data)
      return;
    const { id: s, type: i, path: o } = Object.assign({ path: [] }, r.data), a = (r.data.argumentList || []).map(Na);
    let l;
    try {
      const c = o.slice(0, -1).reduce((h, d) => h[d], t), u = o.reduce((h, d) => h[d], t);
      switch (i) {
        case 0:
          l = u;
          break;
        case 1:
          c[o.slice(-1)[0]] = Na(r.data.value), l = !0;
          break;
        case 2:
          l = u.apply(c, a);
          break;
        case 3:
          {
            const h = new u(...a);
            l = t5(h);
          }
          break;
        case 4:
          {
            const { port1: h, port2: d } = new MessageChannel();
            kC(t, d), l = e5(h, [h]);
          }
          break;
        case 5:
          l = void 0;
          break;
      }
    } catch (c) {
      l = { value: c, [J1]: 0 };
    }
    Promise.resolve(l).catch((c) => ({ value: c, [J1]: 0 })).then((c) => {
      const [u, h] = AC(c);
      e.postMessage(Object.assign(Object.assign({}, u), { id: s }), h), i === 5 && (e.removeEventListener("message", n), J4(e));
    });
  }), e.start && e.start();
}
function Yre(t) {
  return t.constructor.name === "MessagePort";
}
function J4(t) {
  Yre(t) && t.close();
}
function X4(t, e) {
  return X1(t, [], e);
}
function Yp(t) {
  if (t)
    throw new Error("Proxy has been released and is not useable");
}
function X1(t, e = [], n = function() {
}) {
  let r = !1;
  const s = new Proxy(n, {
    get(i, o) {
      if (Yp(r), o === Y4)
        return () => Yl(t, {
          type: 5,
          path: e.map((a) => a.toString())
        }).then(() => {
          J4(t), r = !0;
        });
      if (o === "then") {
        if (e.length === 0)
          return { then: () => s };
        const a = Yl(t, {
          type: 0,
          path: e.map((l) => l.toString())
        }).then(Na);
        return a.then.bind(a);
      }
      return X1(t, [...e, o]);
    },
    set(i, o, a) {
      Yp(r);
      const [l, c] = AC(a);
      return Yl(t, {
        type: 1,
        path: [...e, o].map((u) => u.toString()),
        value: l
      }, c).then(Na);
    },
    apply(i, o, a) {
      Yp(r);
      const l = e[e.length - 1];
      if (l === K4)
        return Yl(t, {
          type: 4
        }).then(Na);
      if (l === "bind")
        return X1(t, e.slice(0, -1));
      const [c, u] = pI(a);
      return Yl(t, {
        type: 2,
        path: e.map((h) => h.toString()),
        argumentList: c
      }, u).then(Na);
    },
    construct(i, o) {
      Yp(r);
      const [a, l] = pI(o);
      return Yl(t, {
        type: 3,
        path: e.map((c) => c.toString()),
        argumentList: a
      }, l).then(Na);
    }
  });
  return s;
}
function Zre(t) {
  return Array.prototype.concat.apply([], t);
}
function pI(t) {
  const e = t.map(AC);
  return [e.map((n) => n[0]), Zre(e.map((n) => n[1]))];
}
var Q4 = /* @__PURE__ */ new WeakMap();
function e5(t, e) {
  return Q4.set(t, e), t;
}
function t5(t) {
  return Object.assign(t, { [TC]: !0 });
}
function Jre(t, e = self, n = "*") {
  return {
    postMessage: (r, s) => t.postMessage(r, n, s),
    addEventListener: e.addEventListener.bind(e),
    removeEventListener: e.removeEventListener.bind(e)
  };
}
function AC(t) {
  for (const [e, n] of CC)
    if (n.canHandle(t)) {
      const [r, s] = n.serialize(t);
      return [
        {
          type: 3,
          name: e,
          value: r
        },
        s
      ];
    }
  return [
    {
      type: 0,
      value: t
    },
    Q4.get(t) || []
  ];
}
function Na(t) {
  switch (t.type) {
    case 3:
      return CC.get(t.name).deserialize(t.value);
    case 0:
      return t.value;
  }
}
function Yl(t, e, n) {
  return new Promise((r) => {
    const s = Xre();
    t.addEventListener("message", function i(o) {
      !o.data || !o.data.id || o.data.id !== s || (t.removeEventListener("message", i), r(o.data));
    }), t.start && t.start(), t.postMessage(Object.assign({ id: s }, e), n);
  });
}
function Xre() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}
const Qre = [
  zh.ConsoleError,
  zh.UncaughtException,
  zh.UnhandledRejection
];
function ese(t) {
  return !(t == null || typeof t != "object" || !("type" in t) || !Qre.includes(t.type));
}
let Zp = null, Jp = null, sv = {};
const tse = new TextDecoder(), nse = new TextEncoder();
class ja {
  _instance;
  _runtimeInfo;
  /**
   * Gives access to the underlying file system.
   */
  fs;
  // #region internal
  internal;
  // #endregion
  static _instance = null;
  _tornDown = !1;
  _unsubscribeFromTokenChangedListener = () => {
  };
  /** @internal */
  constructor(e, n, r) {
    this._instance = e, this._runtimeInfo = r, this.fs = new cse(n), this.internal = new rse(e);
  }
  async spawn(e, n, r) {
    let s = [];
    Array.isArray(n) ? s = n : r = n;
    let i, o = new ReadableStream();
    if (r?.output !== !1) {
      const y = ov();
      i = y.push, o = y.stream;
    }
    let a, l, c, u;
    if (l = new ReadableStream(), u = new ReadableStream(), r?.stdout) {
      const y = ov();
      a = y.push, l = y.stream;
    }
    if (r?.stderr) {
      const y = ov();
      c = y.push, u = y.stream;
    }
    const h = pg(iv(i)), d = pg(iv(a)), f = pg(iv(c)), g = await this._instance.run({
      command: e,
      args: s,
      cwd: r?.cwd,
      env: r?.env,
      terminal: r?.terminal
    }, d, f, h);
    return new lse(g, o, l, u);
  }
  on(e, n) {
    if (e === "preview-message") {
      const i = n;
      n = (o) => {
        ese(o) && i(o);
      };
    }
    const { listener: r, subscribe: s } = Q1(n);
    return s(this._instance.on(e, Xr.proxy(r)));
  }
  /**
   * Mounts a tree of files into the filesystem. This can be specified as a tree object ({@link FileSystemTree})
   * or as a binary snapshot generated by [`@webcontainer/snapshot`](https://www.npmjs.com/package/@webcontainer/snapshot).
   *
   * @param snapshotOrTree - A tree of files, or a binary snapshot. Note that binary payloads will be transferred.
   * @param options.mountPoint - Specifies a nested path where the tree should be mounted.
   */
  mount(e, n) {
    const r = e instanceof Uint8Array ? e : e instanceof ArrayBuffer ? new Uint8Array(e) : nse.encode(JSON.stringify(q4(e)));
    return this._instance.loadFiles(Xr.transfer(r, [r.buffer]), {
      mountPoints: n?.mountPoint
    });
  }
  /**
   * The default value of the `PATH` environment variable for processes started through {@link spawn}.
   */
  get path() {
    return this._runtimeInfo.path;
  }
  /**
   * The full path to the working directory (see {@link FileSystemAPI}).
   */
  get workdir() {
    return this._runtimeInfo.cwd;
  }
  /**
   * Destroys the WebContainer instance, turning it unusable, and releases its resources. After this,
   * a new WebContainer instance can be obtained by calling {@link WebContainer.boot | `boot`}.
   *
   * All entities derived from this instance (e.g. processes, the file system, etc.) also become unusable
   * after calling this method.
   */
  teardown() {
    if (this._tornDown)
      throw new Error("WebContainer already torn down");
    this._tornDown = !0, this._unsubscribeFromTokenChangedListener(), this.fs._teardown(), this._instance.teardown(), this._instance[Xr.releaseProxy](), ja._instance === this && (ja._instance = null);
  }
  /**
   * Boots a WebContainer. Only a single instance of WebContainer can be booted concurrently
   * (see {@link WebContainer.teardown | `teardown`}).
   *
   * Booting WebContainer is an expensive operation.
   */
  static async boot(e = {}) {
    const { workdirName: n } = e;
    if (window.crossOriginIsolated && e.coep === "none" && console.warn(`A Cross-Origin-Embedder-Policy header is required in cross origin isolated environments.
Set the 'coep' option to 'require-corp'.`), n?.includes("/") || n === ".." || n === ".")
      throw new Error("workdirName should be a valid folder name");
    for (; Zp; )
      await Zp;
    if (ja._instance)
      throw new Error("Only a single WebContainer instance can be booted");
    const r = use(e);
    Zp = r.catch(() => {
    });
    try {
      const s = await r;
      return ja._instance = s, s;
    } finally {
      Zp = null;
    }
  }
}
class rse {
  _instance;
  constructor(e) {
    this._instance = e;
  }
  watchPaths(e, n) {
    const { listener: r, subscribe: s } = Q1(n);
    return s(this._instance.watchPaths(e, Xr.proxy(r)));
  }
  getProcesses() {
    return this._instance.getProcesses();
  }
  onProcessesRemove(e) {
    const { listener: n, subscribe: r } = Q1(e);
    return r(this._instance.onProcessesRemove(Xr.proxy(n)));
  }
  serialize(e, n) {
    return this._instance.serialize(e, n);
  }
}
const sse = 1, ise = 2;
class ose {
  name;
  _type;
  constructor(e, n) {
    this.name = e, this._type = n;
  }
  isFile() {
    return this._type === sse;
  }
  isDirectory() {
    return this._type === ise;
  }
}
class ase {
  _apiClient;
  _path;
  _options;
  _listener;
  _wrappedListener;
  _watcher;
  _closed = !1;
  constructor(e, n, r, s) {
    this._apiClient = e, this._path = n, this._options = r, this._listener = s, this._apiClient._watchers.add(this), this._wrappedListener = (i, o) => {
      this._listener && !this._closed && this._listener(i, o);
    }, this._apiClient._fs.watch(this._path, this._options, pg(this._wrappedListener)).then((i) => {
      this._watcher = i, this._closed && this._teardown();
    }).catch(console.error);
  }
  close() {
    this._closed || (this._closed = !0, this._apiClient._watchers.delete(this), this._teardown());
  }
  /**
   * @internal
   */
  _teardown() {
    this._watcher?.close().finally(() => {
      this._watcher?.[Xr.releaseProxy]();
    });
  }
}
class lse {
  output;
  input;
  exit;
  _process;
  stdout;
  stderr;
  constructor(e, n, r, s) {
    this.output = n, this._process = e, this.input = new WritableStream({
      write: (i) => {
        this._getProcess()?.write(i).catch(() => {
        });
      }
    }), this.exit = this._onExit(), this.stdout = r, this.stderr = s;
  }
  kill() {
    this._getProcess()?.kill();
  }
  resize(e) {
    this._getProcess()?.resize(e);
  }
  async _onExit() {
    try {
      return await this._process.onExit;
    } finally {
      this._process?.[Xr.releaseProxy](), this._process = null;
    }
  }
  _getProcess() {
    return this._process == null && console.warn("This process already exited"), this._process;
  }
}
class cse {
  _fs;
  _watchers = /* @__PURE__ */ new Set([]);
  constructor(e) {
    this._fs = e;
  }
  rm(...e) {
    return this._fs.rm(...e);
  }
  async readFile(e, n) {
    return await this._fs.readFile(e, n);
  }
  async rename(e, n) {
    return await this._fs.rename(e, n);
  }
  async writeFile(e, n, r) {
    if (n instanceof Uint8Array) {
      const s = n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
      n = Xr.transfer(new Uint8Array(s), [s]);
    }
    await this._fs.writeFile(e, n, r);
  }
  async readdir(e, n) {
    const r = await this._fs.readdir(e, n);
    return dse(r) || fse(r) ? r : r.map((i) => new ose(i.name, i["Symbol(type)"]));
  }
  async mkdir(e, n) {
    return await this._fs.mkdir(e, n);
  }
  watch(e, n, r) {
    return typeof n == "function" && (r = n, n = null), new ase(this, e, n, r);
  }
  /**
   * @internal
   */
  _teardown() {
    this._fs[Xr.releaseProxy]();
    for (const e of this._watchers)
      e.close();
  }
}
async function use(t) {
  const { serverPromise: e } = hse(t), r = await (await e).build({
    host: window.location.host,
    version: "1.3.0-internal.10",
    workdirName: t.workdirName,
    forwardPreviewErrors: t.forwardPreviewErrors
  }), s = await r.fs(), i = await r.runtimeInfo();
  return new ja(r, s, i);
}
function iv(t) {
  if (t != null)
    return (e) => {
      e instanceof Uint8Array ? t(tse.decode(e)) : e == null && t(null);
    };
}
function pg(t) {
  if (t != null)
    return Xr.proxy(t);
}
function hse(t) {
  if (Jp != null)
    return t.coep !== sv.coep && (console.warn(`Attempting to boot WebContainer with 'coep: ${t.coep}'`), console.warn(`First boot had 'coep: ${sv.coep}', new settings will not take effect!`)), { serverPromise: Jp };
  const e = document.createElement("iframe");
  e.style.display = "none", e.setAttribute("allow", "cross-origin-isolated");
  const n = pse();
  t.coep && n.searchParams.set("coep", t.coep), e.src = n.toString();
  const { origin: r } = n;
  return sv = { ...t }, Jp = new Promise((s) => {
    const i = (o) => {
      if (o.origin !== r)
        return;
      const { data: a } = o;
      if (a.type === "init") {
        s(Xr.wrap(o.ports[0]));
        return;
      }
      if (a.type === "warning") {
        console[a.level].call(console, a.message);
        return;
      }
    };
    window.addEventListener("message", i);
  }), document.body.insertBefore(e, null), { serverPromise: Jp };
}
function dse(t) {
  return typeof t[0] == "string";
}
function fse(t) {
  return t[0] instanceof Uint8Array;
}
function pse() {
  const t = new URL(zre.editorOrigin);
  return t.pathname = "/headless", t.searchParams.set("version", "1.3.0-internal.10"), t;
}
function ov() {
  let t = null;
  return { stream: new ReadableStream({
    start(r) {
      t = r;
    }
  }), push: (r) => {
    r != null ? t?.enqueue(r) : (t?.close(), t = null);
  } };
}
function Q1(t) {
  let e = !1, n = () => {
  };
  return {
    subscribe(s) {
      return s.then((i) => {
        n = i, e && n();
      }), () => {
        e = !0, n();
      };
    },
    listener: (...s) => {
      e || t(...s);
    }
  };
}
function Ls(t) {
  if (typeof t != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
}
function mI(t, e) {
  for (var n = "", r = 0, s = -1, i = 0, o, a = 0; a <= t.length; ++a) {
    if (a < t.length)
      o = t.charCodeAt(a);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(s === a - 1 || i === 1)) if (s !== a - 1 && i === 2) {
        if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            var l = n.lastIndexOf("/");
            if (l !== n.length - 1) {
              l === -1 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), s = a, i = 0;
              continue;
            }
          } else if (n.length === 2 || n.length === 1) {
            n = "", r = 0, s = a, i = 0;
            continue;
          }
        }
        e && (n.length > 0 ? n += "/.." : n = "..", r = 2);
      } else
        n.length > 0 ? n += "/" + t.slice(s + 1, a) : n = t.slice(s + 1, a), r = a - s - 1;
      s = a, i = 0;
    } else o === 46 && i !== -1 ? ++i : i = -1;
  }
  return n;
}
function mse(t, e) {
  var n = e.dir || e.root, r = e.base || (e.name || "") + (e.ext || "");
  return n ? n === e.root ? n + r : n + t + r : r;
}
var Ac = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var e = "", n = !1, r, s = arguments.length - 1; s >= -1 && !n; s--) {
      var i;
      s >= 0 ? i = arguments[s] : (r === void 0 && (r = je.cwd()), i = r), Ls(i), i.length !== 0 && (e = i + "/" + e, n = i.charCodeAt(0) === 47);
    }
    return e = mI(e, !n), n ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
  },
  normalize: function(e) {
    if (Ls(e), e.length === 0) return ".";
    var n = e.charCodeAt(0) === 47, r = e.charCodeAt(e.length - 1) === 47;
    return e = mI(e, !n), e.length === 0 && !n && (e = "."), e.length > 0 && r && (e += "/"), n ? "/" + e : e;
  },
  isAbsolute: function(e) {
    return Ls(e), e.length > 0 && e.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var e, n = 0; n < arguments.length; ++n) {
      var r = arguments[n];
      Ls(r), r.length > 0 && (e === void 0 ? e = r : e += "/" + r);
    }
    return e === void 0 ? "." : Ac.normalize(e);
  },
  relative: function(e, n) {
    if (Ls(e), Ls(n), e === n || (e = Ac.resolve(e), n = Ac.resolve(n), e === n)) return "";
    for (var r = 1; r < e.length && e.charCodeAt(r) === 47; ++r)
      ;
    for (var s = e.length, i = s - r, o = 1; o < n.length && n.charCodeAt(o) === 47; ++o)
      ;
    for (var a = n.length, l = a - o, c = i < l ? i : l, u = -1, h = 0; h <= c; ++h) {
      if (h === c) {
        if (l > c) {
          if (n.charCodeAt(o + h) === 47)
            return n.slice(o + h + 1);
          if (h === 0)
            return n.slice(o + h);
        } else i > c && (e.charCodeAt(r + h) === 47 ? u = h : h === 0 && (u = 0));
        break;
      }
      var d = e.charCodeAt(r + h), f = n.charCodeAt(o + h);
      if (d !== f)
        break;
      d === 47 && (u = h);
    }
    var g = "";
    for (h = r + u + 1; h <= s; ++h)
      (h === s || e.charCodeAt(h) === 47) && (g.length === 0 ? g += ".." : g += "/..");
    return g.length > 0 ? g + n.slice(o + u) : (o += u, n.charCodeAt(o) === 47 && ++o, n.slice(o));
  },
  _makeLong: function(e) {
    return e;
  },
  dirname: function(e) {
    if (Ls(e), e.length === 0) return ".";
    for (var n = e.charCodeAt(0), r = n === 47, s = -1, i = !0, o = e.length - 1; o >= 1; --o)
      if (n = e.charCodeAt(o), n === 47) {
        if (!i) {
          s = o;
          break;
        }
      } else
        i = !1;
    return s === -1 ? r ? "/" : "." : r && s === 1 ? "//" : e.slice(0, s);
  },
  basename: function(e, n) {
    if (n !== void 0 && typeof n != "string") throw new TypeError('"ext" argument must be a string');
    Ls(e);
    var r = 0, s = -1, i = !0, o;
    if (n !== void 0 && n.length > 0 && n.length <= e.length) {
      if (n.length === e.length && n === e) return "";
      var a = n.length - 1, l = -1;
      for (o = e.length - 1; o >= 0; --o) {
        var c = e.charCodeAt(o);
        if (c === 47) {
          if (!i) {
            r = o + 1;
            break;
          }
        } else
          l === -1 && (i = !1, l = o + 1), a >= 0 && (c === n.charCodeAt(a) ? --a === -1 && (s = o) : (a = -1, s = l));
      }
      return r === s ? s = l : s === -1 && (s = e.length), e.slice(r, s);
    } else {
      for (o = e.length - 1; o >= 0; --o)
        if (e.charCodeAt(o) === 47) {
          if (!i) {
            r = o + 1;
            break;
          }
        } else s === -1 && (i = !1, s = o + 1);
      return s === -1 ? "" : e.slice(r, s);
    }
  },
  extname: function(e) {
    Ls(e);
    for (var n = -1, r = 0, s = -1, i = !0, o = 0, a = e.length - 1; a >= 0; --a) {
      var l = e.charCodeAt(a);
      if (l === 47) {
        if (!i) {
          r = a + 1;
          break;
        }
        continue;
      }
      s === -1 && (i = !1, s = a + 1), l === 46 ? n === -1 ? n = a : o !== 1 && (o = 1) : n !== -1 && (o = -1);
    }
    return n === -1 || s === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && n === s - 1 && n === r + 1 ? "" : e.slice(n, s);
  },
  format: function(e) {
    if (e === null || typeof e != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
    return mse("/", e);
  },
  parse: function(e) {
    Ls(e);
    var n = { root: "", dir: "", base: "", ext: "", name: "" };
    if (e.length === 0) return n;
    var r = e.charCodeAt(0), s = r === 47, i;
    s ? (n.root = "/", i = 1) : i = 0;
    for (var o = -1, a = 0, l = -1, c = !0, u = e.length - 1, h = 0; u >= i; --u) {
      if (r = e.charCodeAt(u), r === 47) {
        if (!c) {
          a = u + 1;
          break;
        }
        continue;
      }
      l === -1 && (c = !1, l = u + 1), r === 46 ? o === -1 ? o = u : h !== 1 && (h = 1) : o !== -1 && (h = -1);
    }
    return o === -1 || l === -1 || // We saw a non-dot character immediately before the dot
    h === 0 || // The (right-most) trimmed path component is exactly '..'
    h === 1 && o === l - 1 && o === a + 1 ? l !== -1 && (a === 0 && s ? n.base = n.name = e.slice(1, l) : n.base = n.name = e.slice(a, l)) : (a === 0 && s ? (n.name = e.slice(1, o), n.base = e.slice(1, l)) : (n.name = e.slice(a, o), n.base = e.slice(a, l)), n.ext = e.slice(o, l)), a > 0 ? n.dir = e.slice(0, a - 1) : s && (n.dir = "/"), n;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
Ac.posix = Ac;
var rn = Ac;
function ps(t) {
  throw new Error(`Unreachable: ${t}`);
}
const Ms = Sr("ActionRunner");
class mc extends Error {
  _output;
  _header;
  constructor(e, n) {
    const r = `Failed To Execute Shell Command: ${e}

Output:
${n}`;
    super(r), this._header = e, this._output = n, Object.setPrototypeOf(this, mc.prototype), this.name = "ActionCommandError";
  }
  // Optional: Add a method to get just the terminal output
  get output() {
    return this._output;
  }
  get header() {
    return this._header;
  }
}
class gse {
  #t;
  #n = Promise.resolve();
  #e;
  runnerId = nn(`${Date.now()}`);
  actions = Ol({});
  onAlert;
  constructor(e, n, r) {
    this.#t = e, this.#e = n, this.onAlert = r;
  }
  addAction(e) {
    const { actionId: n } = e;
    if (this.actions.get()[n])
      return;
    const i = new AbortController();
    this.actions.setKey(n, {
      ...e.action,
      status: "pending",
      executed: !1,
      abort: () => {
        i.abort(), this.#i(n, { status: "aborted" });
      },
      abortSignal: i.signal
    }), this.#n.then(() => {
      this.#i(n, { status: "running" });
    });
  }
  async runAction(e, n = !1) {
    const { actionId: r } = e, s = this.actions.get()[r];
    s || ps(`Action ${r} not found`), !s.executed && (n && s.type !== "file" || (this.#i(r, { ...s, ...e.action, executed: !n }), this.#n = this.#n.then(() => this.#r(r, n)).catch((i) => {
      console.error("Action failed:", i);
    }), await this.#n));
  }
  async #r(e, n = !1) {
    const r = this.actions.get()[e];
    this.#i(e, { status: "running" });
    try {
      switch (r.type) {
        case "shell": {
          await this.#a(r);
          break;
        }
        case "file": {
          await this.#o(r);
          break;
        }
        case "start": {
          this.#s(r).then(() => this.#i(e, { status: "complete" })).catch((s) => {
            r.abortSignal.aborted || (this.#i(e, { status: "failed", error: "Action failed" }), Ms.error(`[${r.type}]:Action failed

`, s), s instanceof mc && this.onAlert?.({
              type: "error",
              title: "Dev Server Failed",
              description: s.header,
              content: s.output
            }));
          }), await new Promise((s) => setTimeout(s, 2e3));
          return;
        }
      }
      this.#i(e, {
        status: n ? "running" : r.abortSignal.aborted ? "aborted" : "complete"
      });
    } catch (s) {
      if (r.abortSignal.aborted || (this.#i(e, { status: "failed", error: "Action failed" }), Ms.error(`[${r.type}]:Action failed

`, s), !(s instanceof mc)))
        return;
      throw this.onAlert?.({
        type: "error",
        title: "Dev Server Failed",
        description: s.header,
        content: s.output
      }), s;
    }
  }
  async #a(e) {
    e.type !== "shell" && ps("Expected shell action");
    const n = this.#e();
    await n.ready(), (!n || !n.terminal || !n.process) && ps("Shell terminal not found");
    const r = await n.executeCommand(this.runnerId.get(), e.content, () => {
      Ms.debug(`[${e.type}]:Aborting Action

`, e), e.abort();
    });
    if (Ms.debug(`${e.type} Shell Response: [exit code:${r?.exitCode}]`), r?.exitCode != 0)
      throw new mc("Failed To Execute Shell Command", r?.output || "No Output Available");
  }
  async #s(e) {
    e.type !== "start" && ps("Expected shell action"), this.#e || ps("Shell terminal not found");
    const n = this.#e();
    await n.ready(), (!n || !n.terminal || !n.process) && ps("Shell terminal not found");
    const r = await n.executeCommand(this.runnerId.get(), e.content, () => {
      Ms.debug(`[${e.type}]:Aborting Action

`, e), e.abort();
    });
    if (Ms.debug(`${e.type} Shell Response: [exit code:${r?.exitCode}]`), r?.exitCode != 0)
      throw new mc("Failed To Start Application", r?.output || "No Output Available");
    return r;
  }
  async #o(e) {
    e.type !== "file" && ps("Expected file action");
    const n = await this.#t, r = rn.relative(n.workdir, e.filePath);
    let s = rn.dirname(r);
    if (s = s.replace(/\/+$/g, ""), s !== ".")
      try {
        await n.fs.mkdir(s, { recursive: !0 }), Ms.debug("Created folder", s);
      } catch (i) {
        Ms.error(`Failed to create folder

`, i);
      }
    try {
      await n.fs.writeFile(r, e.content), Ms.debug(`File written ${r}`);
    } catch (i) {
      Ms.error(`Failed to write file

`, i);
    }
  }
  #i(e, n) {
    const r = this.actions.get();
    this.actions.setKey(e, { ...r[e], ...n });
  }
}
var n5 = "vercel.ai.error", yse = Symbol.for(n5), r5, bse = class s5 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[r5] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return s5.hasMarker(e, n5);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
};
r5 = yse;
var an = bse, i5 = "AI_APICallError", o5 = `vercel.ai.error.${i5}`, _se = Symbol.for(o5), a5, zi = class extends an {
  constructor({
    message: e,
    url: n,
    requestBodyValues: r,
    statusCode: s,
    responseHeaders: i,
    responseBody: o,
    cause: a,
    isRetryable: l = s != null && (s === 408 || // request timeout
    s === 409 || // conflict
    s === 429 || // too many requests
    s >= 500),
    // server error
    data: c
  }) {
    super({ name: i5, message: e, cause: a }), this[a5] = !0, this.url = n, this.requestBodyValues = r, this.statusCode = s, this.responseHeaders = i, this.responseBody = o, this.isRetryable = l, this.data = c;
  }
  static isInstance(e) {
    return an.hasMarker(e, o5);
  }
};
a5 = _se;
var l5 = "AI_EmptyResponseBodyError", c5 = `vercel.ai.error.${l5}`, vse = Symbol.for(c5), u5, wse = class extends an {
  // used in isInstance
  constructor({ message: e = "Empty response body" } = {}) {
    super({ name: l5, message: e }), this[u5] = !0;
  }
  static isInstance(e) {
    return an.hasMarker(e, c5);
  }
};
u5 = vse;
function h5(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var d5 = "AI_InvalidArgumentError", f5 = `vercel.ai.error.${d5}`, Ese = Symbol.for(f5), p5, Sse = class extends an {
  constructor({
    message: e,
    cause: n,
    argument: r
  }) {
    super({ name: d5, message: e, cause: n }), this[p5] = !0, this.argument = r;
  }
  static isInstance(e) {
    return an.hasMarker(e, f5);
  }
};
p5 = Ese;
var m5 = "AI_InvalidPromptError", g5 = `vercel.ai.error.${m5}`, xse = Symbol.for(g5), y5, Tse = class extends an {
  constructor({
    prompt: e,
    message: n,
    cause: r
  }) {
    super({ name: m5, message: `Invalid prompt: ${n}`, cause: r }), this[y5] = !0, this.prompt = e;
  }
  static isInstance(e) {
    return an.hasMarker(e, g5);
  }
};
y5 = xse;
var b5 = "AI_InvalidResponseDataError", _5 = `vercel.ai.error.${b5}`, Cse = Symbol.for(_5), v5, av = class extends an {
  constructor({
    data: e,
    message: n = `Invalid response data: ${JSON.stringify(e)}.`
  }) {
    super({ name: b5, message: n }), this[v5] = !0, this.data = e;
  }
  static isInstance(e) {
    return an.hasMarker(e, _5);
  }
};
v5 = Cse;
var w5 = "AI_JSONParseError", E5 = `vercel.ai.error.${w5}`, kse = Symbol.for(E5), S5, r0 = class extends an {
  constructor({ text: e, cause: n }) {
    super({
      name: w5,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${h5(n)}`,
      cause: n
    }), this[S5] = !0, this.text = e;
  }
  static isInstance(e) {
    return an.hasMarker(e, E5);
  }
};
S5 = kse;
var x5 = "AI_LoadAPIKeyError", T5 = `vercel.ai.error.${x5}`, Ase = Symbol.for(T5), C5, Xp = class extends an {
  // used in isInstance
  constructor({ message: e }) {
    super({ name: x5, message: e }), this[C5] = !0;
  }
  static isInstance(e) {
    return an.hasMarker(e, T5);
  }
};
C5 = Ase;
var k5 = "AI_TooManyEmbeddingValuesForCallError", A5 = `vercel.ai.error.${k5}`, Rse = Symbol.for(A5), R5, Ise = class extends an {
  constructor(e) {
    super({
      name: k5,
      message: `Too many values for a single embedding call. The ${e.provider} model "${e.modelId}" can only embed up to ${e.maxEmbeddingsPerCall} values per call, but ${e.values.length} values were provided.`
    }), this[R5] = !0, this.provider = e.provider, this.modelId = e.modelId, this.maxEmbeddingsPerCall = e.maxEmbeddingsPerCall, this.values = e.values;
  }
  static isInstance(e) {
    return an.hasMarker(e, A5);
  }
};
R5 = Rse;
var I5 = "AI_TypeValidationError", P5 = `vercel.ai.error.${I5}`, Pse = Symbol.for(P5), O5, Ose = class eE extends an {
  constructor({ value: e, cause: n }) {
    super({
      name: I5,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${h5(n)}`,
      cause: n
    }), this[O5] = !0, this.value = e;
  }
  static isInstance(e) {
    return an.hasMarker(e, P5);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: e,
    cause: n
  }) {
    return eE.isInstance(n) && n.value === e ? n : new eE({ value: e, cause: n });
  }
};
O5 = Pse;
var s0 = Ose, D5 = "AI_UnsupportedFunctionalityError", N5 = `vercel.ai.error.${D5}`, Dse = Symbol.for(N5), L5, pr = class extends an {
  constructor({
    functionality: e,
    message: n = `'${e}' functionality not supported.`
  }) {
    super({ name: D5, message: n }), this[L5] = !0, this.functionality = e;
  }
  static isInstance(e) {
    return an.hasMarker(e, N5);
  }
};
L5 = Dse;
let Cu = (t, e = 21) => (n = e) => {
  let r = "", s = n | 0;
  for (; s--; )
    r += t[Math.random() * t.length | 0];
  return r;
};
var ku = { exports: {} };
const Nse = typeof Me < "u", gI = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, yI = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function M5(t, e, n) {
  n == null && e !== null && typeof e == "object" && (n = e, e = void 0), Nse && Me.isBuffer(t) && (t = t.toString()), t && t.charCodeAt(0) === 65279 && (t = t.slice(1));
  const r = JSON.parse(t, e);
  if (r === null || typeof r != "object")
    return r;
  const s = n && n.protoAction || "error", i = n && n.constructorAction || "error";
  if (s === "ignore" && i === "ignore")
    return r;
  if (s !== "ignore" && i !== "ignore") {
    if (gI.test(t) === !1 && yI.test(t) === !1)
      return r;
  } else if (s !== "ignore" && i === "ignore") {
    if (gI.test(t) === !1)
      return r;
  } else if (yI.test(t) === !1)
    return r;
  return B5(r, { protoAction: s, constructorAction: i, safe: n && n.safe });
}
function B5(t, { protoAction: e = "error", constructorAction: n = "error", safe: r } = {}) {
  let s = [t];
  for (; s.length; ) {
    const i = s;
    s = [];
    for (const o of i) {
      if (e !== "ignore" && Object.prototype.hasOwnProperty.call(o, "__proto__")) {
        if (r === !0)
          return null;
        if (e === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.__proto__;
      }
      if (n !== "ignore" && Object.prototype.hasOwnProperty.call(o, "constructor") && Object.prototype.hasOwnProperty.call(o.constructor, "prototype")) {
        if (r === !0)
          return null;
        if (n === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.constructor;
      }
      for (const a in o) {
        const l = o[a];
        l && typeof l == "object" && s.push(l);
      }
    }
  }
  return t;
}
function RC(t, e, n) {
  const r = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  try {
    return M5(t, e, n);
  } finally {
    Error.stackTraceLimit = r;
  }
}
function Lse(t, e) {
  const n = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  try {
    return M5(t, e, { safe: !0 });
  } catch {
    return null;
  } finally {
    Error.stackTraceLimit = n;
  }
}
ku.exports = RC;
ku.exports.default = RC;
ku.exports.parse = RC;
ku.exports.safeParse = Lse;
ku.exports.scan = B5;
var Mse = ku.exports;
const ln = /* @__PURE__ */ Is(Mse);
var Bse = Object.defineProperty, Fse = (t, e, n) => e in t ? Bse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Qp = (t, e, n) => Fse(t, typeof e != "symbol" ? e + "" : e, n);
let bI = class extends Error {
  constructor(e, n) {
    super(e), Qp(this, "type"), Qp(this, "field"), Qp(this, "value"), Qp(this, "line"), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
};
function lv(t) {
}
function $se(t) {
  const { onEvent: e = lv, onError: n = lv, onRetry: r = lv, onComment: s } = t;
  let i = "", o = !0, a, l = "", c = "";
  function u(y) {
    const p = o ? y.replace(/^\xEF\xBB\xBF/, "") : y, [m, b] = Use(`${i}${p}`);
    for (const _ of m)
      h(_);
    i = b, o = !1;
  }
  function h(y) {
    if (y === "") {
      f();
      return;
    }
    if (y.startsWith(":")) {
      s && s(y.slice(y.startsWith(": ") ? 2 : 1));
      return;
    }
    const p = y.indexOf(":");
    if (p !== -1) {
      const m = y.slice(0, p), b = y[p + 1] === " " ? 2 : 1, _ = y.slice(p + b);
      d(m, _, y);
      return;
    }
    d(y, "", y);
  }
  function d(y, p, m) {
    switch (y) {
      case "event":
        c = p;
        break;
      case "data":
        l = `${l}${p}
`;
        break;
      case "id":
        a = p.includes("\0") ? void 0 : p;
        break;
      case "retry":
        /^\d+$/.test(p) ? r(parseInt(p, 10)) : n(
          new bI(`Invalid \`retry\` value: "${p}"`, {
            type: "invalid-retry",
            value: p,
            line: m
          })
        );
        break;
      default:
        n(
          new bI(
            `Unknown field "${y.length > 20 ? `${y.slice(0, 20)}` : y}"`,
            { type: "unknown-field", field: y, value: p, line: m }
          )
        );
        break;
    }
  }
  function f() {
    l.length > 0 && e({
      id: a,
      event: c || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: l.endsWith(`
`) ? l.slice(0, -1) : l
    }), a = void 0, l = "", c = "";
  }
  function g(y = {}) {
    i && y.consume && h(i), a = void 0, l = "", c = "", i = "";
  }
  return { feed: u, reset: g };
}
function Use(t) {
  const e = [];
  let n = "";
  const r = t.length;
  for (let s = 0; s < r; s++) {
    const i = t[s];
    i === "\r" && t[s + 1] === `
` ? (e.push(n), n = "", s++) : i === "\r" || i === `
` ? (e.push(n), n = "") : n += i;
  }
  return [e, n];
}
let IC = class extends TransformStream {
  constructor({ onError: e, onRetry: n, onComment: r } = {}) {
    let s;
    super({
      start(i) {
        s = $se({
          onEvent: (o) => {
            i.enqueue(o);
          },
          onError(o) {
            e === "terminate" ? i.error(o) : typeof e == "function" && e(o);
          },
          onRetry: n,
          onComment: r
        });
      },
      transform(i) {
        s.feed(i);
      }
    });
  }
};
function Zc(...t) {
  return t.reduce(
    (e, n) => ({
      ...e,
      ...n ?? {}
    }),
    {}
  );
}
function pb(t) {
  const e = {};
  return t.headers.forEach((n, r) => {
    e[r] = n;
  }), e;
}
var jse = ({
  prefix: t,
  size: e = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const s = Cu(n, e);
  if (t == null)
    return s;
  if (n.includes(r))
    throw new Sse({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return (i) => `${t}${r}${s(i)}`;
}, Ju = jse();
function Hse(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n != null)
  );
}
function cv(t) {
  return t instanceof Error && (t.name === "AbortError" || t.name === "TimeoutError");
}
function zse({
  apiKey: t,
  environmentVariableName: e,
  apiKeyParameterName: n = "apiKey",
  description: r
}) {
  if (typeof t == "string")
    return t;
  if (t != null)
    throw new Xp({
      message: `${r} API key must be a string.`
    });
  if (typeof je > "u")
    throw new Xp({
      message: `${r} API key is missing. Pass it using the '${n}' parameter. Environment variables is not supported in this environment.`
    });
  if (t = je.env[e], t == null)
    throw new Xp({
      message: `${r} API key is missing. Pass it using the '${n}' parameter or the ${e} environment variable.`
    });
  if (typeof t != "string")
    throw new Xp({
      message: `${r} API key must be a string. The value of the ${e} environment variable is not a string.`
    });
  return t;
}
var tE = Symbol.for("vercel.ai.validator");
function Gse(t) {
  return { [tE]: !0, validate: t };
}
function Vse(t) {
  return typeof t == "object" && t !== null && tE in t && t[tE] === !0 && "validate" in t;
}
function Wse(t) {
  return Vse(t) ? t : qse(t);
}
function qse(t) {
  return Gse((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function Kse({
  value: t,
  schema: e
}) {
  const n = F5({ value: t, schema: e });
  if (!n.success)
    throw s0.wrap({ value: t, cause: n.error });
  return n.value;
}
function F5({
  value: t,
  schema: e
}) {
  const n = Wse(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: s0.wrap({ value: t, cause: r.error })
    };
  } catch (r) {
    return {
      success: !1,
      error: s0.wrap({ value: t, cause: r })
    };
  }
}
function Yse({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? n : Kse({ value: n, schema: e });
  } catch (n) {
    throw r0.isInstance(n) || s0.isInstance(n) ? n : new r0({ text: t, cause: n });
  }
}
function $5({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    if (e == null)
      return { success: !0, value: n, rawValue: n };
    const r = F5({ value: n, schema: e });
    return r.success ? { ...r, rawValue: n } : r;
  } catch (n) {
    return {
      success: !1,
      error: r0.isInstance(n) ? n : new r0({ text: t, cause: n })
    };
  }
}
function _I(t) {
  try {
    return ln.parse(t), !0;
  } catch {
    return !1;
  }
}
var Zse = () => globalThis.fetch, Jc = async ({
  url: t,
  headers: e,
  body: n,
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}) => Jse({
  url: t,
  headers: {
    "Content-Type": "application/json",
    ...e
  },
  body: {
    content: JSON.stringify(n),
    values: n
  },
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}), Jse = async ({
  url: t,
  headers: e = {},
  body: n,
  successfulResponseHandler: r,
  failedResponseHandler: s,
  abortSignal: i,
  fetch: o = Zse()
}) => {
  try {
    const a = await o(t, {
      method: "POST",
      headers: Hse(e),
      body: n.content,
      signal: i
    }), l = pb(a);
    if (!a.ok) {
      let c;
      try {
        c = await s({
          response: a,
          url: t,
          requestBodyValues: n.values
        });
      } catch (u) {
        throw cv(u) || zi.isInstance(u) ? u : new zi({
          message: "Failed to process error response",
          cause: u,
          statusCode: a.status,
          url: t,
          responseHeaders: l,
          requestBodyValues: n.values
        });
      }
      throw c.value;
    }
    try {
      return await r({
        response: a,
        url: t,
        requestBodyValues: n.values
      });
    } catch (c) {
      throw c instanceof Error && (cv(c) || zi.isInstance(c)) ? c : new zi({
        message: "Failed to process successful response",
        cause: c,
        statusCode: a.status,
        url: t,
        responseHeaders: l,
        requestBodyValues: n.values
      });
    }
  } catch (a) {
    if (cv(a))
      throw a;
    if (a instanceof TypeError && a.message === "fetch failed") {
      const l = a.cause;
      if (l != null)
        throw new zi({
          message: `Cannot connect to API: ${l.message}`,
          cause: l,
          url: t,
          requestBodyValues: n.values,
          isRetryable: !0
          // retry when network error
        });
    }
    throw a;
  }
}, Xse = ({
  errorSchema: t,
  errorToMessage: e,
  isRetryable: n
}) => async ({ response: r, url: s, requestBodyValues: i }) => {
  const o = await r.text(), a = pb(r);
  if (o.trim() === "")
    return {
      responseHeaders: a,
      value: new zi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  try {
    const l = Yse({
      text: o,
      schema: t
    });
    return {
      responseHeaders: a,
      value: new zi({
        message: e(l),
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        data: l,
        isRetryable: n?.(r, l)
      })
    };
  } catch {
    return {
      responseHeaders: a,
      value: new zi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  }
}, U5 = (t) => async ({ response: e }) => {
  const n = pb(e);
  if (e.body == null)
    throw new wse({});
  return {
    responseHeaders: n,
    value: e.body.pipeThrough(new TextDecoderStream()).pipeThrough(new IC()).pipeThrough(
      new TransformStream({
        transform({ data: r }, s) {
          r !== "[DONE]" && s.enqueue(
            $5({
              text: r,
              schema: t
            })
          );
        }
      })
    )
  };
}, mb = (t) => async ({ response: e, url: n, requestBodyValues: r }) => {
  const s = await e.text(), i = $5({
    text: s,
    schema: t
  }), o = pb(e);
  if (!i.success)
    throw new zi({
      message: "Invalid JSON response",
      cause: i.error,
      statusCode: e.status,
      responseHeaders: o,
      responseBody: s,
      url: n,
      requestBodyValues: r
    });
  return {
    responseHeaders: o,
    value: i.value,
    rawValue: i.rawValue
  };
}, { btoa: Qse } = globalThis;
function eie(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCodePoint(t[n]);
  return Qse(e);
}
function tie(t) {
  return t?.replace(/\/$/, "");
}
var gt;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function n(s) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (s) => {
    const i = {};
    for (const o of s)
      i[o] = o;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((a) => typeof s[s[a]] != "number"), o = {};
    for (const a of i)
      o[a] = s[a];
    return t.objectValues(o);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const o in s)
      Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
    return i;
  }, t.find = (s, i) => {
    for (const o of s)
      if (i(o))
        return o;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function r(s, i = " | ") {
    return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(i);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(gt || (gt = {}));
var nE;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
    // second overwrites first
  });
})(nE || (nE = {}));
const Ue = gt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), $i = (t) => {
  switch (typeof t) {
    case "undefined":
      return Ue.undefined;
    case "string":
      return Ue.string;
    case "number":
      return isNaN(t) ? Ue.nan : Ue.number;
    case "boolean":
      return Ue.boolean;
    case "function":
      return Ue.function;
    case "bigint":
      return Ue.bigint;
    case "symbol":
      return Ue.symbol;
    case "object":
      return Array.isArray(t) ? Ue.array : t === null ? Ue.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? Ue.promise : typeof Map < "u" && t instanceof Map ? Ue.map : typeof Set < "u" && t instanceof Set ? Ue.set : typeof Date < "u" && t instanceof Date ? Ue.date : Ue.object;
    default:
      return Ue.unknown;
  }
}, Oe = gt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), nie = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class Nr extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const n = e || function(i) {
      return i.message;
    }, r = { _errors: [] }, s = (i) => {
      for (const o of i.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(s);
        else if (o.code === "invalid_return_type")
          s(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          s(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let a = r, l = 0;
          for (; l < o.path.length; ) {
            const c = o.path[l];
            l === o.path.length - 1 ? (a[c] = a[c] || { _errors: [] }, a[c]._errors.push(n(o))) : a[c] = a[c] || { _errors: [] }, a = a[c], l++;
          }
        }
    };
    return s(this), r;
  }
  static assert(e) {
    if (!(e instanceof Nr))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, gt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, r = [];
    for (const s of this.issues)
      s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(e(s))) : r.push(e(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Nr.create = (t) => new Nr(t);
const Xc = (t, e) => {
  let n;
  switch (t.code) {
    case Oe.invalid_type:
      t.received === Ue.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case Oe.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, gt.jsonStringifyReplacer)}`;
      break;
    case Oe.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${gt.joinValues(t.keys, ", ")}`;
      break;
    case Oe.invalid_union:
      n = "Invalid input";
      break;
    case Oe.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${gt.joinValues(t.options)}`;
      break;
    case Oe.invalid_enum_value:
      n = `Invalid enum value. Expected ${gt.joinValues(t.options)}, received '${t.received}'`;
      break;
    case Oe.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case Oe.invalid_return_type:
      n = "Invalid function return type";
      break;
    case Oe.invalid_date:
      n = "Invalid date";
      break;
    case Oe.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : gt.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case Oe.too_small:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
      break;
    case Oe.too_big:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
      break;
    case Oe.custom:
      n = "Invalid input";
      break;
    case Oe.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case Oe.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Oe.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = e.defaultError, gt.assertNever(t);
  }
  return { message: n };
};
let j5 = Xc;
function rie(t) {
  j5 = t;
}
function i0() {
  return j5;
}
const o0 = (t) => {
  const { data: e, path: n, errorMaps: r, issueData: s } = t, i = [...n, ...s.path || []], o = {
    ...s,
    path: i
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: i,
      message: s.message
    };
  let a = "";
  const l = r.filter((c) => !!c).slice().reverse();
  for (const c of l)
    a = c(o, { data: e, defaultError: a }).message;
  return {
    ...s,
    path: i,
    message: a
  };
}, sie = [];
function Be(t, e) {
  const n = i0(), r = o0({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      // contextual error map is first priority
      t.schemaErrorMap,
      // then schema-bound map if available
      n,
      // then global override map
      n === Xc ? void 0 : Xc
      // then global default map
    ].filter((s) => !!s)
  });
  t.common.issues.push(r);
}
class jn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return Ze;
      s.status === "dirty" && e.dirty(), r.push(s.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const s of n) {
      const i = await s.key, o = await s.value;
      r.push({
        key: i,
        value: o
      });
    }
    return jn.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const s of n) {
      const { key: i, value: o } = s;
      if (i.status === "aborted" || o.status === "aborted")
        return Ze;
      i.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) && (r[i.value] = o.value);
    }
    return { status: e.value, value: r };
  }
}
const Ze = Object.freeze({
  status: "aborted"
}), gc = (t) => ({ status: "dirty", value: t }), tr = (t) => ({ status: "valid", value: t }), rE = (t) => t.status === "aborted", sE = (t) => t.status === "dirty", pl = (t) => t.status === "valid", Rd = (t) => typeof Promise < "u" && t instanceof Promise;
function a0(t, e, n, r) {
  if (typeof e == "function" ? t !== e || !0 : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e.get(t);
}
function H5(t, e, n, r, s) {
  if (typeof e == "function" ? t !== e || !0 : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return e.set(t, n), n;
}
var Ve;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(Ve || (Ve = {}));
var xh, Th;
class xi {
  constructor(e, n, r, s) {
    this._cachedPath = [], this.parent = e, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const vI = (t, e) => {
  if (pl(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Nr(t.common.issues);
      return this._error = n, this._error;
    }
  };
};
function tt(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: r, description: s } = t;
  if (e && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (o, a) => {
    var l, c;
    const { message: u } = t;
    return o.code === "invalid_enum_value" ? { message: u ?? a.defaultError } : typeof a.data > "u" ? { message: (l = u ?? r) !== null && l !== void 0 ? l : a.defaultError } : o.code !== "invalid_type" ? { message: a.defaultError } : { message: (c = u ?? n) !== null && c !== void 0 ? c : a.defaultError };
  }, description: s };
}
class it {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return $i(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: $i(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new jn(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: $i(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Rd(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, n) {
    var r;
    const s = {
      common: {
        issues: [],
        async: (r = n?.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n?.errorMap
      },
      path: n?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: $i(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return vI(s, i);
  }
  "~validate"(e) {
    var n, r;
    const s = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: $i(e)
    };
    if (!this["~standard"].async)
      try {
        const i = this._parseSync({ data: e, path: [], parent: s });
        return pl(i) ? {
          value: i.value
        } : {
          issues: s.common.issues
        };
      } catch (i) {
        !((r = (n = i?.message) === null || n === void 0 ? void 0 : n.toLowerCase()) === null || r === void 0) && r.includes("encountered") && (this["~standard"].async = !0), s.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: s }).then((i) => pl(i) ? {
      value: i.value
    } : {
      issues: s.common.issues
    });
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n?.errorMap,
        async: !0
      },
      path: n?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: $i(e)
    }, s = this._parse({ data: e, path: r.path, parent: r }), i = await (Rd(s) ? s : Promise.resolve(s));
    return vI(r, i);
  }
  refine(e, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, i) => {
      const o = e(s), a = () => i.addIssue({
        code: Oe.custom,
        ...r(s)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((r, s) => e(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1));
  }
  _refinement(e) {
    return new Ts({
      schema: this,
      typeName: Ne.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (n) => this["~validate"](n)
    };
  }
  optional() {
    return ws.create(this, this._def);
  }
  nullable() {
    return ta.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return vs.create(this);
  }
  promise() {
    return eu.create(this, this._def);
  }
  or(e) {
    return Dd.create([this, e], this._def);
  }
  and(e) {
    return Nd.create(this, e, this._def);
  }
  transform(e) {
    return new Ts({
      ...tt(this._def),
      schema: this,
      typeName: Ne.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new $d({
      ...tt(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Ne.ZodDefault
    });
  }
  brand() {
    return new PC({
      typeName: Ne.ZodBranded,
      type: this,
      ...tt(this._def)
    });
  }
  catch(e) {
    const n = typeof e == "function" ? e : () => e;
    return new Ud({
      ...tt(this._def),
      innerType: this,
      catchValue: n,
      typeName: Ne.ZodCatch
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return sp.create(this, e);
  }
  readonly() {
    return jd.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const iie = /^c[^\s-]{8,}$/i, oie = /^[0-9a-z]+$/, aie = /^[0-9A-HJKMNP-TV-Z]{26}$/i, lie = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, cie = /^[a-z0-9_-]{21}$/i, uie = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, hie = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, die = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, fie = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let uv;
const pie = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, mie = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, gie = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, yie = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, bie = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, _ie = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, z5 = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", vie = new RegExp(`^${z5}$`);
function G5(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function wie(t) {
  return new RegExp(`^${G5(t)}$`);
}
function V5(t) {
  let e = `${z5}T${G5(t)}`;
  const n = [];
  return n.push(t.local ? "Z?" : "Z"), t.offset && n.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${n.join("|")})`, new RegExp(`^${e}$`);
}
function Eie(t, e) {
  return !!((e === "v4" || !e) && pie.test(t) || (e === "v6" || !e) && gie.test(t));
}
function Sie(t, e) {
  if (!uie.test(t))
    return !1;
  try {
    const [n] = t.split("."), r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), s = JSON.parse(atob(r));
    return !(typeof s != "object" || s === null || !s.typ || !s.alg || e && s.alg !== e);
  } catch {
    return !1;
  }
}
function xie(t, e) {
  return !!((e === "v4" || !e) && mie.test(t) || (e === "v6" || !e) && yie.test(t));
}
class gs extends it {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== Ue.string) {
      const i = this._getOrReturnCtx(e);
      return Be(i, {
        code: Oe.invalid_type,
        expected: Ue.string,
        received: i.parsedType
      }), Ze;
    }
    const r = new jn();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), Be(s, {
          code: Oe.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), Be(s, {
          code: Oe.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "length") {
        const o = e.data.length > i.value, a = e.data.length < i.value;
        (o || a) && (s = this._getOrReturnCtx(e, s), o ? Be(s, {
          code: Oe.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : a && Be(s, {
          code: Oe.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), r.dirty());
      } else if (i.kind === "email")
        die.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
          validation: "email",
          code: Oe.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "emoji")
        uv || (uv = new RegExp(fie, "u")), uv.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
          validation: "emoji",
          code: Oe.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        lie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
          validation: "uuid",
          code: Oe.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "nanoid")
        cie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
          validation: "nanoid",
          code: Oe.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        iie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
          validation: "cuid",
          code: Oe.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid2")
        oie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
          validation: "cuid2",
          code: Oe.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "ulid")
        aie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
          validation: "ulid",
          code: Oe.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), Be(s, {
            validation: "url",
            code: Oe.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
        validation: "regex",
        code: Oe.invalid_string,
        message: i.message
      }), r.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e, s), Be(s, {
        code: Oe.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), r.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), Be(s, {
        code: Oe.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), r.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), Be(s, {
        code: Oe.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), r.dirty()) : i.kind === "datetime" ? V5(i).test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
        code: Oe.invalid_string,
        validation: "datetime",
        message: i.message
      }), r.dirty()) : i.kind === "date" ? vie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
        code: Oe.invalid_string,
        validation: "date",
        message: i.message
      }), r.dirty()) : i.kind === "time" ? wie(i).test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
        code: Oe.invalid_string,
        validation: "time",
        message: i.message
      }), r.dirty()) : i.kind === "duration" ? hie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
        validation: "duration",
        code: Oe.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "ip" ? Eie(e.data, i.version) || (s = this._getOrReturnCtx(e, s), Be(s, {
        validation: "ip",
        code: Oe.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "jwt" ? Sie(e.data, i.alg) || (s = this._getOrReturnCtx(e, s), Be(s, {
        validation: "jwt",
        code: Oe.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "cidr" ? xie(e.data, i.version) || (s = this._getOrReturnCtx(e, s), Be(s, {
        validation: "cidr",
        code: Oe.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64" ? bie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
        validation: "base64",
        code: Oe.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64url" ? _ie.test(e.data) || (s = this._getOrReturnCtx(e, s), Be(s, {
        validation: "base64url",
        code: Oe.invalid_string,
        message: i.message
      }), r.dirty()) : gt.assertNever(i);
    return { status: r.value, value: e.data };
  }
  _regex(e, n, r) {
    return this.refinement((s) => e.test(s), {
      validation: n,
      code: Oe.invalid_string,
      ...Ve.errToObj(r)
    });
  }
  _addCheck(e) {
    return new gs({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...Ve.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...Ve.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...Ve.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...Ve.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...Ve.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...Ve.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...Ve.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...Ve.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...Ve.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...Ve.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...Ve.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...Ve.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...Ve.errToObj(e) });
  }
  datetime(e) {
    var n, r;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (n = e?.offset) !== null && n !== void 0 ? n : !1,
      local: (r = e?.local) !== null && r !== void 0 ? r : !1,
      ...Ve.errToObj(e?.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      ...Ve.errToObj(e?.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...Ve.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...Ve.errToObj(n)
    });
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n?.position,
      ...Ve.errToObj(n?.message)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...Ve.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...Ve.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...Ve.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...Ve.errToObj(n)
    });
  }
  length(e, n) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...Ve.errToObj(n)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, Ve.errToObj(e));
  }
  trim() {
    return new gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
gs.create = (t) => {
  var e;
  return new gs({
    checks: [],
    typeName: Ne.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...tt(t)
  });
};
function Tie(t, e) {
  const n = (t.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, s = n > r ? n : r, i = parseInt(t.toFixed(s).replace(".", "")), o = parseInt(e.toFixed(s).replace(".", ""));
  return i % o / Math.pow(10, s);
}
class Xo extends it {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== Ue.number) {
      const i = this._getOrReturnCtx(e);
      return Be(i, {
        code: Oe.invalid_type,
        expected: Ue.number,
        received: i.parsedType
      }), Ze;
    }
    let r;
    const s = new jn();
    for (const i of this._def.checks)
      i.kind === "int" ? gt.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), Be(r, {
        code: Oe.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), Be(r, {
        code: Oe.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), Be(r, {
        code: Oe.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? Tie(e.data, i.value) !== 0 && (r = this._getOrReturnCtx(e, r), Be(r, {
        code: Oe.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), Be(r, {
        code: Oe.not_finite,
        message: i.message
      }), s.dirty()) : gt.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, Ve.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, Ve.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, Ve.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, Ve.toString(n));
  }
  setLimit(e, n, r, s) {
    return new Xo({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: Ve.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Xo({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: Ve.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Ve.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Ve.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Ve.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Ve.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Ve.toString(n)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: Ve.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Ve.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Ve.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && gt.isInteger(e.value));
  }
  get isFinite() {
    let e = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(e);
  }
}
Xo.create = (t) => new Xo({
  checks: [],
  typeName: Ne.ZodNumber,
  coerce: t?.coerce || !1,
  ...tt(t)
});
class Qo extends it {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== Ue.bigint)
      return this._getInvalidInput(e);
    let r;
    const s = new jn();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), Be(r, {
        code: Oe.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), Be(r, {
        code: Oe.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), Be(r, {
        code: Oe.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : gt.assertNever(i);
    return { status: s.value, value: e.data };
  }
  _getInvalidInput(e) {
    const n = this._getOrReturnCtx(e);
    return Be(n, {
      code: Oe.invalid_type,
      expected: Ue.bigint,
      received: n.parsedType
    }), Ze;
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, Ve.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, Ve.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, Ve.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, Ve.toString(n));
  }
  setLimit(e, n, r, s) {
    return new Qo({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: Ve.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Qo({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Ve.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Ve.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Ve.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Ve.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Ve.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
Qo.create = (t) => {
  var e;
  return new Qo({
    checks: [],
    typeName: Ne.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...tt(t)
  });
};
class Id extends it {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== Ue.boolean) {
      const r = this._getOrReturnCtx(e);
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.boolean,
        received: r.parsedType
      }), Ze;
    }
    return tr(e.data);
  }
}
Id.create = (t) => new Id({
  typeName: Ne.ZodBoolean,
  coerce: t?.coerce || !1,
  ...tt(t)
});
class ml extends it {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== Ue.date) {
      const i = this._getOrReturnCtx(e);
      return Be(i, {
        code: Oe.invalid_type,
        expected: Ue.date,
        received: i.parsedType
      }), Ze;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return Be(i, {
        code: Oe.invalid_date
      }), Ze;
    }
    const r = new jn();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), Be(s, {
        code: Oe.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), Be(s, {
        code: Oe.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : gt.assertNever(i);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new ml({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: Ve.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: Ve.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
ml.create = (t) => new ml({
  checks: [],
  coerce: t?.coerce || !1,
  typeName: Ne.ZodDate,
  ...tt(t)
});
class l0 extends it {
  _parse(e) {
    if (this._getType(e) !== Ue.symbol) {
      const r = this._getOrReturnCtx(e);
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.symbol,
        received: r.parsedType
      }), Ze;
    }
    return tr(e.data);
  }
}
l0.create = (t) => new l0({
  typeName: Ne.ZodSymbol,
  ...tt(t)
});
class Pd extends it {
  _parse(e) {
    if (this._getType(e) !== Ue.undefined) {
      const r = this._getOrReturnCtx(e);
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.undefined,
        received: r.parsedType
      }), Ze;
    }
    return tr(e.data);
  }
}
Pd.create = (t) => new Pd({
  typeName: Ne.ZodUndefined,
  ...tt(t)
});
class Od extends it {
  _parse(e) {
    if (this._getType(e) !== Ue.null) {
      const r = this._getOrReturnCtx(e);
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.null,
        received: r.parsedType
      }), Ze;
    }
    return tr(e.data);
  }
}
Od.create = (t) => new Od({
  typeName: Ne.ZodNull,
  ...tt(t)
});
class Qc extends it {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return tr(e.data);
  }
}
Qc.create = (t) => new Qc({
  typeName: Ne.ZodAny,
  ...tt(t)
});
class tl extends it {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return tr(e.data);
  }
}
tl.create = (t) => new tl({
  typeName: Ne.ZodUnknown,
  ...tt(t)
});
class co extends it {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return Be(n, {
      code: Oe.invalid_type,
      expected: Ue.never,
      received: n.parsedType
    }), Ze;
  }
}
co.create = (t) => new co({
  typeName: Ne.ZodNever,
  ...tt(t)
});
class c0 extends it {
  _parse(e) {
    if (this._getType(e) !== Ue.undefined) {
      const r = this._getOrReturnCtx(e);
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.void,
        received: r.parsedType
      }), Ze;
    }
    return tr(e.data);
  }
}
c0.create = (t) => new c0({
  typeName: Ne.ZodVoid,
  ...tt(t)
});
class vs extends it {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e), s = this._def;
    if (n.parsedType !== Ue.array)
      return Be(n, {
        code: Oe.invalid_type,
        expected: Ue.array,
        received: n.parsedType
      }), Ze;
    if (s.exactLength !== null) {
      const o = n.data.length > s.exactLength.value, a = n.data.length < s.exactLength.value;
      (o || a) && (Be(n, {
        code: o ? Oe.too_big : Oe.too_small,
        minimum: a ? s.exactLength.value : void 0,
        maximum: o ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), r.dirty());
    }
    if (s.minLength !== null && n.data.length < s.minLength.value && (Be(n, {
      code: Oe.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (Be(n, {
      code: Oe.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, a) => s.type._parseAsync(new xi(n, o, n.path, a)))).then((o) => jn.mergeArray(r, o));
    const i = [...n.data].map((o, a) => s.type._parseSync(new xi(n, o, n.path, a)));
    return jn.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new vs({
      ...this._def,
      minLength: { value: e, message: Ve.toString(n) }
    });
  }
  max(e, n) {
    return new vs({
      ...this._def,
      maxLength: { value: e, message: Ve.toString(n) }
    });
  }
  length(e, n) {
    return new vs({
      ...this._def,
      exactLength: { value: e, message: Ve.toString(n) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
vs.create = (t, e) => new vs({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Ne.ZodArray,
  ...tt(e)
});
function ic(t) {
  if (t instanceof Gt) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = ws.create(ic(r));
    }
    return new Gt({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof vs ? new vs({
    ...t._def,
    type: ic(t.element)
  }) : t instanceof ws ? ws.create(ic(t.unwrap())) : t instanceof ta ? ta.create(ic(t.unwrap())) : t instanceof Ti ? Ti.create(t.items.map((e) => ic(e))) : t;
}
class Gt extends it {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = gt.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== Ue.object) {
      const c = this._getOrReturnCtx(e);
      return Be(c, {
        code: Oe.invalid_type,
        expected: Ue.object,
        received: c.parsedType
      }), Ze;
    }
    const { status: r, ctx: s } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof co && this._def.unknownKeys === "strip"))
      for (const c in s.data)
        o.includes(c) || a.push(c);
    const l = [];
    for (const c of o) {
      const u = i[c], h = s.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new xi(s, h, s.path, c)),
        alwaysSet: c in s.data
      });
    }
    if (this._def.catchall instanceof co) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of a)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: s.data[u] }
          });
      else if (c === "strict")
        a.length > 0 && (Be(s, {
          code: Oe.unrecognized_keys,
          keys: a
        }), r.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of a) {
        const h = s.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new xi(s, h, s.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of l) {
        const h = await u.key, d = await u.value;
        c.push({
          key: h,
          value: d,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => jn.mergeObjectSync(r, c)) : jn.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return Ve.errToObj, new Gt({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, r) => {
          var s, i, o, a;
          const l = (o = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = Ve.errToObj(e).message) !== null && a !== void 0 ? a : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new Gt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Gt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new Gt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new Gt({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: Ne.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new Gt({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return gt.objectKeys(e).forEach((r) => {
      e[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new Gt({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return gt.objectKeys(this.shape).forEach((r) => {
      e[r] || (n[r] = this.shape[r]);
    }), new Gt({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ic(this);
  }
  partial(e) {
    const n = {};
    return gt.objectKeys(this.shape).forEach((r) => {
      const s = this.shape[r];
      e && !e[r] ? n[r] = s : n[r] = s.optional();
    }), new Gt({
      ...this._def,
      shape: () => n
    });
  }
  required(e) {
    const n = {};
    return gt.objectKeys(this.shape).forEach((r) => {
      if (e && !e[r])
        n[r] = this.shape[r];
      else {
        let i = this.shape[r];
        for (; i instanceof ws; )
          i = i._def.innerType;
        n[r] = i;
      }
    }), new Gt({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return W5(gt.objectKeys(this.shape));
  }
}
Gt.create = (t, e) => new Gt({
  shape: () => t,
  unknownKeys: "strip",
  catchall: co.create(),
  typeName: Ne.ZodObject,
  ...tt(e)
});
Gt.strictCreate = (t, e) => new Gt({
  shape: () => t,
  unknownKeys: "strict",
  catchall: co.create(),
  typeName: Ne.ZodObject,
  ...tt(e)
});
Gt.lazycreate = (t, e) => new Gt({
  shape: t,
  unknownKeys: "strip",
  catchall: co.create(),
  typeName: Ne.ZodObject,
  ...tt(e)
});
class Dd extends it {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = this._def.options;
    function s(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((a) => new Nr(a.ctx.common.issues));
      return Be(n, {
        code: Oe.invalid_union,
        unionErrors: o
      }), Ze;
    }
    if (n.common.async)
      return Promise.all(r.map(async (i) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(s);
    {
      let i;
      const o = [];
      for (const l of r) {
        const c = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !i && (i = { result: u, ctx: c }), c.common.issues.length && o.push(c.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const a = o.map((l) => new Nr(l));
      return Be(n, {
        code: Oe.invalid_union,
        unionErrors: a
      }), Ze;
    }
  }
  get options() {
    return this._def.options;
  }
}
Dd.create = (t, e) => new Dd({
  options: t,
  typeName: Ne.ZodUnion,
  ...tt(e)
});
const Fi = (t) => t instanceof Md ? Fi(t.schema) : t instanceof Ts ? Fi(t.innerType()) : t instanceof Bd ? [t.value] : t instanceof ea ? t.options : t instanceof Fd ? gt.objectValues(t.enum) : t instanceof $d ? Fi(t._def.innerType) : t instanceof Pd ? [void 0] : t instanceof Od ? [null] : t instanceof ws ? [void 0, ...Fi(t.unwrap())] : t instanceof ta ? [null, ...Fi(t.unwrap())] : t instanceof PC || t instanceof jd ? Fi(t.unwrap()) : t instanceof Ud ? Fi(t._def.innerType) : [];
class gb extends it {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Ue.object)
      return Be(n, {
        code: Oe.invalid_type,
        expected: Ue.object,
        received: n.parsedType
      }), Ze;
    const r = this.discriminator, s = n.data[r], i = this.optionsMap.get(s);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (Be(n, {
      code: Oe.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), Ze);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, n, r) {
    const s = /* @__PURE__ */ new Map();
    for (const i of n) {
      const o = Fi(i.shape[e]);
      if (!o.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const a of o) {
        if (s.has(a))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
        s.set(a, i);
      }
    }
    return new gb({
      typeName: Ne.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: s,
      ...tt(r)
    });
  }
}
function iE(t, e) {
  const n = $i(t), r = $i(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === Ue.object && r === Ue.object) {
    const s = gt.objectKeys(e), i = gt.objectKeys(t).filter((a) => s.indexOf(a) !== -1), o = { ...t, ...e };
    for (const a of i) {
      const l = iE(t[a], e[a]);
      if (!l.valid)
        return { valid: !1 };
      o[a] = l.data;
    }
    return { valid: !0, data: o };
  } else if (n === Ue.array && r === Ue.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = e[i], l = iE(o, a);
      if (!l.valid)
        return { valid: !1 };
      s.push(l.data);
    }
    return { valid: !0, data: s };
  } else return n === Ue.date && r === Ue.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Nd extends it {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = (i, o) => {
      if (rE(i) || rE(o))
        return Ze;
      const a = iE(i.value, o.value);
      return a.valid ? ((sE(i) || sE(o)) && n.dirty(), { status: n.value, value: a.data }) : (Be(r, {
        code: Oe.invalid_intersection_types
      }), Ze);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, o]) => s(i, o)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Nd.create = (t, e, n) => new Nd({
  left: t,
  right: e,
  typeName: Ne.ZodIntersection,
  ...tt(n)
});
class Ti extends it {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Ue.array)
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.array,
        received: r.parsedType
      }), Ze;
    if (r.data.length < this._def.items.length)
      return Be(r, {
        code: Oe.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Ze;
    !this._def.rest && r.data.length > this._def.items.length && (Be(r, {
      code: Oe.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...r.data].map((o, a) => {
      const l = this._def.items[a] || this._def.rest;
      return l ? l._parse(new xi(r, o, r.path, a)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(i).then((o) => jn.mergeArray(n, o)) : jn.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Ti({
      ...this._def,
      rest: e
    });
  }
}
Ti.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Ti({
    items: t,
    typeName: Ne.ZodTuple,
    rest: null,
    ...tt(e)
  });
};
class Ld extends it {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Ue.object)
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.object,
        received: r.parsedType
      }), Ze;
    const s = [], i = this._def.keyType, o = this._def.valueType;
    for (const a in r.data)
      s.push({
        key: i._parse(new xi(r, a, r.path, a)),
        value: o._parse(new xi(r, r.data[a], r.path, a)),
        alwaysSet: a in r.data
      });
    return r.common.async ? jn.mergeObjectAsync(n, s) : jn.mergeObjectSync(n, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, r) {
    return n instanceof it ? new Ld({
      keyType: e,
      valueType: n,
      typeName: Ne.ZodRecord,
      ...tt(r)
    }) : new Ld({
      keyType: gs.create(),
      valueType: e,
      typeName: Ne.ZodRecord,
      ...tt(n)
    });
  }
}
class u0 extends it {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Ue.map)
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.map,
        received: r.parsedType
      }), Ze;
    const s = this._def.keyType, i = this._def.valueType, o = [...r.data.entries()].map(([a, l], c) => ({
      key: s._parse(new xi(r, a, r.path, [c, "key"])),
      value: i._parse(new xi(r, l, r.path, [c, "value"]))
    }));
    if (r.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const c = await l.key, u = await l.value;
          if (c.status === "aborted" || u.status === "aborted")
            return Ze;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(c.value, u.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const l of o) {
        const c = l.key, u = l.value;
        if (c.status === "aborted" || u.status === "aborted")
          return Ze;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(c.value, u.value);
      }
      return { status: n.value, value: a };
    }
  }
}
u0.create = (t, e, n) => new u0({
  valueType: e,
  keyType: t,
  typeName: Ne.ZodMap,
  ...tt(n)
});
class gl extends it {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Ue.set)
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.set,
        received: r.parsedType
      }), Ze;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (Be(r, {
      code: Oe.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (Be(r, {
      code: Oe.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function o(l) {
      const c = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return Ze;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return { status: n.value, value: c };
    }
    const a = [...r.data.values()].map((l, c) => i._parse(new xi(r, l, r.path, c)));
    return r.common.async ? Promise.all(a).then((l) => o(l)) : o(a);
  }
  min(e, n) {
    return new gl({
      ...this._def,
      minSize: { value: e, message: Ve.toString(n) }
    });
  }
  max(e, n) {
    return new gl({
      ...this._def,
      maxSize: { value: e, message: Ve.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
gl.create = (t, e) => new gl({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: Ne.ZodSet,
  ...tt(e)
});
class Rc extends it {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Ue.function)
      return Be(n, {
        code: Oe.invalid_type,
        expected: Ue.function,
        received: n.parsedType
      }), Ze;
    function r(a, l) {
      return o0({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          i0(),
          Xc
        ].filter((c) => !!c),
        issueData: {
          code: Oe.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function s(a, l) {
      return o0({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          i0(),
          Xc
        ].filter((c) => !!c),
        issueData: {
          code: Oe.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof eu) {
      const a = this;
      return tr(async function(...l) {
        const c = new Nr([]), u = await a._def.args.parseAsync(l, i).catch((f) => {
          throw c.addIssue(r(l, f)), c;
        }), h = await Reflect.apply(o, this, u);
        return await a._def.returns._def.type.parseAsync(h, i).catch((f) => {
          throw c.addIssue(s(h, f)), c;
        });
      });
    } else {
      const a = this;
      return tr(function(...l) {
        const c = a._def.args.safeParse(l, i);
        if (!c.success)
          throw new Nr([r(l, c.error)]);
        const u = Reflect.apply(o, this, c.data), h = a._def.returns.safeParse(u, i);
        if (!h.success)
          throw new Nr([s(u, h.error)]);
        return h.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Rc({
      ...this._def,
      args: Ti.create(e).rest(tl.create())
    });
  }
  returns(e) {
    return new Rc({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, r) {
    return new Rc({
      args: e || Ti.create([]).rest(tl.create()),
      returns: n || tl.create(),
      typeName: Ne.ZodFunction,
      ...tt(r)
    });
  }
}
class Md extends it {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Md.create = (t, e) => new Md({
  getter: t,
  typeName: Ne.ZodLazy,
  ...tt(e)
});
class Bd extends it {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return Be(n, {
        received: n.data,
        code: Oe.invalid_literal,
        expected: this._def.value
      }), Ze;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Bd.create = (t, e) => new Bd({
  value: t,
  typeName: Ne.ZodLiteral,
  ...tt(e)
});
function W5(t, e) {
  return new ea({
    values: t,
    typeName: Ne.ZodEnum,
    ...tt(e)
  });
}
class ea extends it {
  constructor() {
    super(...arguments), xh.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return Be(n, {
        expected: gt.joinValues(r),
        received: n.parsedType,
        code: Oe.invalid_type
      }), Ze;
    }
    if (a0(this, xh) || H5(this, xh, new Set(this._def.values)), !a0(this, xh).has(e.data)) {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return Be(n, {
        received: n.data,
        code: Oe.invalid_enum_value,
        options: r
      }), Ze;
    }
    return tr(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  extract(e, n = this._def) {
    return ea.create(e, {
      ...this._def,
      ...n
    });
  }
  exclude(e, n = this._def) {
    return ea.create(this.options.filter((r) => !e.includes(r)), {
      ...this._def,
      ...n
    });
  }
}
xh = /* @__PURE__ */ new WeakMap();
ea.create = W5;
class Fd extends it {
  constructor() {
    super(...arguments), Th.set(this, void 0);
  }
  _parse(e) {
    const n = gt.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== Ue.string && r.parsedType !== Ue.number) {
      const s = gt.objectValues(n);
      return Be(r, {
        expected: gt.joinValues(s),
        received: r.parsedType,
        code: Oe.invalid_type
      }), Ze;
    }
    if (a0(this, Th) || H5(this, Th, new Set(gt.getValidEnumValues(this._def.values))), !a0(this, Th).has(e.data)) {
      const s = gt.objectValues(n);
      return Be(r, {
        received: r.data,
        code: Oe.invalid_enum_value,
        options: s
      }), Ze;
    }
    return tr(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Th = /* @__PURE__ */ new WeakMap();
Fd.create = (t, e) => new Fd({
  values: t,
  typeName: Ne.ZodNativeEnum,
  ...tt(e)
});
class eu extends it {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Ue.promise && n.common.async === !1)
      return Be(n, {
        code: Oe.invalid_type,
        expected: Ue.promise,
        received: n.parsedType
      }), Ze;
    const r = n.parsedType === Ue.promise ? n.data : Promise.resolve(n.data);
    return tr(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
eu.create = (t, e) => new eu({
  type: t,
  typeName: Ne.ZodPromise,
  ...tt(e)
});
class Ts extends it {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ne.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = this._def.effect || null, i = {
      addIssue: (o) => {
        Be(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "preprocess") {
      const o = s.transform(r.data, i);
      if (r.common.async)
        return Promise.resolve(o).then(async (a) => {
          if (n.value === "aborted")
            return Ze;
          const l = await this._def.schema._parseAsync({
            data: a,
            path: r.path,
            parent: r
          });
          return l.status === "aborted" ? Ze : l.status === "dirty" || n.value === "dirty" ? gc(l.value) : l;
        });
      {
        if (n.value === "aborted")
          return Ze;
        const a = this._def.schema._parseSync({
          data: o,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? Ze : a.status === "dirty" || n.value === "dirty" ? gc(a.value) : a;
      }
    }
    if (s.type === "refinement") {
      const o = (a) => {
        const l = s.refinement(a, i);
        if (r.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? Ze : (a.status === "dirty" && n.dirty(), o(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => a.status === "aborted" ? Ze : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!pl(o))
          return o;
        const a = s.transform(o.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => pl(o) ? Promise.resolve(s.transform(o.value, i)).then((a) => ({ status: n.value, value: a })) : o);
    gt.assertNever(s);
  }
}
Ts.create = (t, e, n) => new Ts({
  schema: t,
  typeName: Ne.ZodEffects,
  effect: e,
  ...tt(n)
});
Ts.createWithPreprocess = (t, e, n) => new Ts({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: Ne.ZodEffects,
  ...tt(n)
});
class ws extends it {
  _parse(e) {
    return this._getType(e) === Ue.undefined ? tr(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ws.create = (t, e) => new ws({
  innerType: t,
  typeName: Ne.ZodOptional,
  ...tt(e)
});
class ta extends it {
  _parse(e) {
    return this._getType(e) === Ue.null ? tr(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ta.create = (t, e) => new ta({
  innerType: t,
  typeName: Ne.ZodNullable,
  ...tt(e)
});
class $d extends it {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let r = n.data;
    return n.parsedType === Ue.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
$d.create = (t, e) => new $d({
  innerType: t,
  typeName: Ne.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...tt(e)
});
class Ud extends it {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Rd(s) ? s.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Nr(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Nr(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Ud.create = (t, e) => new Ud({
  innerType: t,
  typeName: Ne.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...tt(e)
});
class h0 extends it {
  _parse(e) {
    if (this._getType(e) !== Ue.nan) {
      const r = this._getOrReturnCtx(e);
      return Be(r, {
        code: Oe.invalid_type,
        expected: Ue.nan,
        received: r.parsedType
      }), Ze;
    }
    return { status: "valid", value: e.data };
  }
}
h0.create = (t) => new h0({
  typeName: Ne.ZodNaN,
  ...tt(t)
});
const Cie = Symbol("zod_brand");
class PC extends it {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class sp extends it {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? Ze : i.status === "dirty" ? (n.dirty(), gc(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? Ze : s.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(e, n) {
    return new sp({
      in: e,
      out: n,
      typeName: Ne.ZodPipeline
    });
  }
}
class jd extends it {
  _parse(e) {
    const n = this._def.innerType._parse(e), r = (s) => (pl(s) && (s.value = Object.freeze(s.value)), s);
    return Rd(n) ? n.then((s) => r(s)) : r(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
jd.create = (t, e) => new jd({
  innerType: t,
  typeName: Ne.ZodReadonly,
  ...tt(e)
});
function q5(t, e = {}, n) {
  return t ? Qc.create().superRefine((r, s) => {
    var i, o;
    if (!t(r)) {
      const a = typeof e == "function" ? e(r) : typeof e == "string" ? { message: e } : e, l = (o = (i = a.fatal) !== null && i !== void 0 ? i : n) !== null && o !== void 0 ? o : !0, c = typeof a == "string" ? { message: a } : a;
      s.addIssue({ code: "custom", ...c, fatal: l });
    }
  }) : Qc.create();
}
const kie = {
  object: Gt.lazycreate
};
var Ne;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(Ne || (Ne = {}));
const Aie = (t, e = {
  message: `Input not instance of ${t.name}`
}) => q5((n) => n instanceof t, e), K5 = gs.create, Y5 = Xo.create, Rie = h0.create, Iie = Qo.create, Z5 = Id.create, Pie = ml.create, Oie = l0.create, Die = Pd.create, Nie = Od.create, Lie = Qc.create, Mie = tl.create, Bie = co.create, Fie = c0.create, $ie = vs.create, Uie = Gt.create, jie = Gt.strictCreate, Hie = Dd.create, zie = gb.create, Gie = Nd.create, Vie = Ti.create, Wie = Ld.create, qie = u0.create, Kie = gl.create, Yie = Rc.create, Zie = Md.create, Jie = Bd.create, Xie = ea.create, Qie = Fd.create, eoe = eu.create, wI = Ts.create, toe = ws.create, noe = ta.create, roe = Ts.createWithPreprocess, soe = sp.create, ioe = () => K5().optional(), ooe = () => Y5().optional(), aoe = () => Z5().optional(), loe = {
  string: (t) => gs.create({ ...t, coerce: !0 }),
  number: (t) => Xo.create({ ...t, coerce: !0 }),
  boolean: (t) => Id.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => Qo.create({ ...t, coerce: !0 }),
  date: (t) => ml.create({ ...t, coerce: !0 })
}, coe = Ze;
var D = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Xc,
  setErrorMap: rie,
  getErrorMap: i0,
  makeIssue: o0,
  EMPTY_PATH: sie,
  addIssueToContext: Be,
  ParseStatus: jn,
  INVALID: Ze,
  DIRTY: gc,
  OK: tr,
  isAborted: rE,
  isDirty: sE,
  isValid: pl,
  isAsync: Rd,
  get util() {
    return gt;
  },
  get objectUtil() {
    return nE;
  },
  ZodParsedType: Ue,
  getParsedType: $i,
  ZodType: it,
  datetimeRegex: V5,
  ZodString: gs,
  ZodNumber: Xo,
  ZodBigInt: Qo,
  ZodBoolean: Id,
  ZodDate: ml,
  ZodSymbol: l0,
  ZodUndefined: Pd,
  ZodNull: Od,
  ZodAny: Qc,
  ZodUnknown: tl,
  ZodNever: co,
  ZodVoid: c0,
  ZodArray: vs,
  ZodObject: Gt,
  ZodUnion: Dd,
  ZodDiscriminatedUnion: gb,
  ZodIntersection: Nd,
  ZodTuple: Ti,
  ZodRecord: Ld,
  ZodMap: u0,
  ZodSet: gl,
  ZodFunction: Rc,
  ZodLazy: Md,
  ZodLiteral: Bd,
  ZodEnum: ea,
  ZodNativeEnum: Fd,
  ZodPromise: eu,
  ZodEffects: Ts,
  ZodTransformer: Ts,
  ZodOptional: ws,
  ZodNullable: ta,
  ZodDefault: $d,
  ZodCatch: Ud,
  ZodNaN: h0,
  BRAND: Cie,
  ZodBranded: PC,
  ZodPipeline: sp,
  ZodReadonly: jd,
  custom: q5,
  Schema: it,
  ZodSchema: it,
  late: kie,
  get ZodFirstPartyTypeKind() {
    return Ne;
  },
  coerce: loe,
  any: Lie,
  array: $ie,
  bigint: Iie,
  boolean: Z5,
  date: Pie,
  discriminatedUnion: zie,
  effect: wI,
  enum: Xie,
  function: Yie,
  instanceof: Aie,
  intersection: Gie,
  lazy: Zie,
  literal: Jie,
  map: qie,
  nan: Rie,
  nativeEnum: Qie,
  never: Bie,
  null: Nie,
  nullable: noe,
  number: Y5,
  object: Uie,
  oboolean: aoe,
  onumber: ooe,
  optional: toe,
  ostring: ioe,
  pipeline: soe,
  preprocess: roe,
  promise: eoe,
  record: Wie,
  set: Kie,
  strictObject: jie,
  string: K5,
  symbol: Oie,
  transformer: wI,
  tuple: Vie,
  undefined: Die,
  union: Hie,
  unknown: Mie,
  void: Fie,
  NEVER: coe,
  ZodIssueCode: Oe,
  quotelessJson: nie,
  ZodError: Nr
});
function uoe({
  prompt: t,
  useLegacyFunctionCalling: e = !1,
  systemMessageMode: n = "system"
}) {
  const r = [];
  for (const { role: s, content: i } of t)
    switch (s) {
      case "system": {
        switch (n) {
          case "system": {
            r.push({ role: "system", content: i });
            break;
          }
          case "developer": {
            r.push({ role: "developer", content: i });
            break;
          }
          case "remove":
            break;
          default: {
            const o = n;
            throw new Error(
              `Unsupported system message mode: ${o}`
            );
          }
        }
        break;
      }
      case "user": {
        if (i.length === 1 && i[0].type === "text") {
          r.push({ role: "user", content: i[0].text });
          break;
        }
        r.push({
          role: "user",
          content: i.map((o) => {
            var a, l, c;
            switch (o.type) {
              case "text":
                return { type: "text", text: o.text };
              case "image":
                return {
                  type: "image_url",
                  image_url: {
                    url: o.image instanceof URL ? o.image.toString() : `data:${(a = o.mimeType) != null ? a : "image/jpeg"};base64,${eie(o.image)}`,
                    // OpenAI specific extension: image detail
                    detail: (c = (l = o.providerMetadata) == null ? void 0 : l.openai) == null ? void 0 : c.imageDetail
                  }
                };
              case "file": {
                if (o.data instanceof URL)
                  throw new pr({
                    functionality: "'File content parts with URL data' functionality not supported."
                  });
                switch (o.mimeType) {
                  case "audio/wav":
                    return {
                      type: "input_audio",
                      input_audio: { data: o.data, format: "wav" }
                    };
                  case "audio/mp3":
                  case "audio/mpeg":
                    return {
                      type: "input_audio",
                      input_audio: { data: o.data, format: "mp3" }
                    };
                  default:
                    throw new pr({
                      functionality: `File content part type ${o.mimeType} in user messages`
                    });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let o = "";
        const a = [];
        for (const l of i)
          switch (l.type) {
            case "text": {
              o += l.text;
              break;
            }
            case "tool-call": {
              a.push({
                id: l.toolCallId,
                type: "function",
                function: {
                  name: l.toolName,
                  arguments: JSON.stringify(l.args)
                }
              });
              break;
            }
            default: {
              const c = l;
              throw new Error(`Unsupported part: ${c}`);
            }
          }
        if (e) {
          if (a.length > 1)
            throw new pr({
              functionality: "useLegacyFunctionCalling with multiple tool calls in one message"
            });
          r.push({
            role: "assistant",
            content: o,
            function_call: a.length > 0 ? a[0].function : void 0
          });
        } else
          r.push({
            role: "assistant",
            content: o,
            tool_calls: a.length > 0 ? a : void 0
          });
        break;
      }
      case "tool": {
        for (const o of i)
          e ? r.push({
            role: "function",
            name: o.toolName,
            content: JSON.stringify(o.result)
          }) : r.push({
            role: "tool",
            tool_call_id: o.toolCallId,
            content: JSON.stringify(o.result)
          });
        break;
      }
      default: {
        const o = s;
        throw new Error(`Unsupported role: ${o}`);
      }
    }
  return r;
}
function EI(t) {
  var e, n;
  return (n = (e = t?.content) == null ? void 0 : e.map(({ token: r, logprob: s, top_logprobs: i }) => ({
    token: r,
    logprob: s,
    topLogprobs: i ? i.map(({ token: o, logprob: a }) => ({
      token: o,
      logprob: a
    })) : []
  }))) != null ? n : void 0;
}
function d0(t) {
  switch (t) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var OC = D.object({
  error: D.object({
    message: D.string(),
    // The additional information below is handled loosely to support
    // OpenAI-compatible providers that have slightly different error
    // responses:
    type: D.string().nullish(),
    param: D.any().nullish(),
    code: D.union([D.string(), D.number()]).nullish()
  })
}), tu = Xse({
  errorSchema: OC,
  errorToMessage: (t) => t.error.message
});
function f0({
  id: t,
  model: e,
  created: n
}) {
  return {
    id: t ?? void 0,
    modelId: e ?? void 0,
    timestamp: n != null ? new Date(n * 1e3) : void 0
  };
}
function hoe({
  mode: t,
  useLegacyFunctionCalling: e = !1,
  structuredOutputs: n
}) {
  var r;
  const s = (r = t.tools) != null && r.length ? t.tools : void 0, i = [];
  if (s == null)
    return { tools: void 0, tool_choice: void 0, toolWarnings: i };
  const o = t.toolChoice;
  if (e) {
    const c = [];
    for (const h of s)
      h.type === "provider-defined" ? i.push({ type: "unsupported-tool", tool: h }) : c.push({
        name: h.name,
        description: h.description,
        parameters: h.parameters
      });
    if (o == null)
      return {
        functions: c,
        function_call: void 0,
        toolWarnings: i
      };
    switch (o.type) {
      case "auto":
      case "none":
      case void 0:
        return {
          functions: c,
          function_call: void 0,
          toolWarnings: i
        };
      case "required":
        throw new pr({
          functionality: "useLegacyFunctionCalling and toolChoice: required"
        });
      default:
        return {
          functions: c,
          function_call: { name: o.toolName },
          toolWarnings: i
        };
    }
  }
  const a = [];
  for (const c of s)
    c.type === "provider-defined" ? i.push({ type: "unsupported-tool", tool: c }) : a.push({
      type: "function",
      function: {
        name: c.name,
        description: c.description,
        parameters: c.parameters,
        strict: n ? !0 : void 0
      }
    });
  if (o == null)
    return { tools: a, tool_choice: void 0, toolWarnings: i };
  const l = o.type;
  switch (l) {
    case "auto":
    case "none":
    case "required":
      return { tools: a, tool_choice: l, toolWarnings: i };
    case "tool":
      return {
        tools: a,
        tool_choice: {
          type: "function",
          function: {
            name: o.toolName
          }
        },
        toolWarnings: i
      };
    default: {
      const c = l;
      throw new pr({
        functionality: `Unsupported tool choice type: ${c}`
      });
    }
  }
}
var doe = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.modelId = t, this.settings = e, this.config = n;
  }
  get supportsStructuredOutputs() {
    var t;
    return (t = this.settings.structuredOutputs) != null ? t : p0(this.modelId);
  }
  get defaultObjectGenerationMode() {
    return moe(this.modelId) ? "tool" : this.supportsStructuredOutputs ? "json" : "tool";
  }
  get provider() {
    return this.config.provider;
  }
  get supportsImageUrls() {
    return !this.settings.downloadImages;
  }
  getArgs({
    mode: t,
    prompt: e,
    maxTokens: n,
    temperature: r,
    topP: s,
    topK: i,
    frequencyPenalty: o,
    presencePenalty: a,
    stopSequences: l,
    responseFormat: c,
    seed: u,
    providerMetadata: h
  }) {
    var d, f, g, y, p, m, b, _;
    const v = t.type, w = [];
    i != null && w.push({
      type: "unsupported-setting",
      setting: "topK"
    }), c?.type === "json" && c.schema != null && !this.supportsStructuredOutputs && w.push({
      type: "unsupported-setting",
      setting: "responseFormat",
      details: "JSON response format schema is only supported with structuredOutputs"
    });
    const E = this.settings.useLegacyFunctionCalling;
    if (E && this.settings.parallelToolCalls === !0)
      throw new pr({
        functionality: "useLegacyFunctionCalling with parallelToolCalls"
      });
    if (E && this.supportsStructuredOutputs)
      throw new pr({
        functionality: "structuredOutputs with useLegacyFunctionCalling"
      });
    SI(this.modelId) === "remove" && e.some((S) => S.role === "system") && w.push({
      type: "other",
      message: "system messages are removed for this model"
    });
    const x = {
      // model id:
      model: this.modelId,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: this.settings.logprobs === !0 || typeof this.settings.logprobs == "number" ? !0 : void 0,
      top_logprobs: typeof this.settings.logprobs == "number" ? this.settings.logprobs : typeof this.settings.logprobs == "boolean" && this.settings.logprobs ? 0 : void 0,
      user: this.settings.user,
      parallel_tool_calls: this.settings.parallelToolCalls,
      // standardized settings:
      max_tokens: n,
      temperature: r,
      top_p: s,
      frequency_penalty: o,
      presence_penalty: a,
      response_format: c?.type === "json" ? this.supportsStructuredOutputs && c.schema != null ? {
        type: "json_schema",
        json_schema: {
          schema: c.schema,
          strict: !0,
          name: (d = c.name) != null ? d : "response",
          description: c.description
        }
      } : { type: "json_object" } : void 0,
      stop: l,
      seed: u,
      // openai specific settings:
      // TODO remove in next major version; we auto-map maxTokens now
      max_completion_tokens: (f = h?.openai) == null ? void 0 : f.maxCompletionTokens,
      store: (g = h?.openai) == null ? void 0 : g.store,
      metadata: (y = h?.openai) == null ? void 0 : y.metadata,
      prediction: (p = h?.openai) == null ? void 0 : p.prediction,
      reasoning_effort: (b = (m = h?.openai) == null ? void 0 : m.reasoningEffort) != null ? b : this.settings.reasoningEffort,
      // messages:
      messages: uoe({
        prompt: e,
        useLegacyFunctionCalling: E,
        systemMessageMode: SI(this.modelId)
      })
    };
    switch (p0(this.modelId) && (x.temperature != null && (x.temperature = void 0, w.push({
      type: "unsupported-setting",
      setting: "temperature",
      details: "temperature is not supported for reasoning models"
    })), x.top_p != null && (x.top_p = void 0, w.push({
      type: "unsupported-setting",
      setting: "topP",
      details: "topP is not supported for reasoning models"
    })), x.frequency_penalty != null && (x.frequency_penalty = void 0, w.push({
      type: "unsupported-setting",
      setting: "frequencyPenalty",
      details: "frequencyPenalty is not supported for reasoning models"
    })), x.presence_penalty != null && (x.presence_penalty = void 0, w.push({
      type: "unsupported-setting",
      setting: "presencePenalty",
      details: "presencePenalty is not supported for reasoning models"
    })), x.logit_bias != null && (x.logit_bias = void 0, w.push({
      type: "other",
      message: "logitBias is not supported for reasoning models"
    })), x.logprobs != null && (x.logprobs = void 0, w.push({
      type: "other",
      message: "logprobs is not supported for reasoning models"
    })), x.top_logprobs != null && (x.top_logprobs = void 0, w.push({
      type: "other",
      message: "topLogprobs is not supported for reasoning models"
    })), x.max_tokens != null && (x.max_completion_tokens == null && (x.max_completion_tokens = x.max_tokens), x.max_tokens = void 0)), v) {
      case "regular": {
        const { tools: S, tool_choice: T, functions: R, function_call: F, toolWarnings: P } = hoe({
          mode: t,
          useLegacyFunctionCalling: E,
          structuredOutputs: this.supportsStructuredOutputs
        });
        return {
          args: {
            ...x,
            tools: S,
            tool_choice: T,
            functions: R,
            function_call: F
          },
          warnings: [...w, ...P]
        };
      }
      case "object-json":
        return {
          args: {
            ...x,
            response_format: this.supportsStructuredOutputs && t.schema != null ? {
              type: "json_schema",
              json_schema: {
                schema: t.schema,
                strict: !0,
                name: (_ = t.name) != null ? _ : "response",
                description: t.description
              }
            } : { type: "json_object" }
          },
          warnings: w
        };
      case "object-tool":
        return {
          args: E ? {
            ...x,
            function_call: {
              name: t.tool.name
            },
            functions: [
              {
                name: t.tool.name,
                description: t.tool.description,
                parameters: t.tool.parameters
              }
            ]
          } : {
            ...x,
            tool_choice: {
              type: "function",
              function: { name: t.tool.name }
            },
            tools: [
              {
                type: "function",
                function: {
                  name: t.tool.name,
                  description: t.tool.description,
                  parameters: t.tool.parameters,
                  strict: this.supportsStructuredOutputs ? !0 : void 0
                }
              }
            ]
          },
          warnings: w
        };
      default: {
        const S = v;
        throw new Error(`Unsupported type: ${S}`);
      }
    }
  }
  async doGenerate(t) {
    var e, n, r, s, i, o, a, l;
    const { args: c, warnings: u } = this.getArgs(t), { responseHeaders: h, value: d } = await Jc({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: Zc(this.config.headers(), t.headers),
      body: c,
      failedResponseHandler: tu,
      successfulResponseHandler: mb(
        foe
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: f, ...g } = c, y = d.choices[0], p = (e = d.usage) == null ? void 0 : e.completion_tokens_details, m = (n = d.usage) == null ? void 0 : n.prompt_tokens_details, b = { openai: {} };
    return p?.reasoning_tokens != null && (b.openai.reasoningTokens = p?.reasoning_tokens), p?.accepted_prediction_tokens != null && (b.openai.acceptedPredictionTokens = p?.accepted_prediction_tokens), p?.rejected_prediction_tokens != null && (b.openai.rejectedPredictionTokens = p?.rejected_prediction_tokens), m?.cached_tokens != null && (b.openai.cachedPromptTokens = m?.cached_tokens), {
      text: (r = y.message.content) != null ? r : void 0,
      toolCalls: this.settings.useLegacyFunctionCalling && y.message.function_call ? [
        {
          toolCallType: "function",
          toolCallId: Ju(),
          toolName: y.message.function_call.name,
          args: y.message.function_call.arguments
        }
      ] : (s = y.message.tool_calls) == null ? void 0 : s.map((_) => {
        var v;
        return {
          toolCallType: "function",
          toolCallId: (v = _.id) != null ? v : Ju(),
          toolName: _.function.name,
          args: _.function.arguments
        };
      }),
      finishReason: d0(y.finish_reason),
      usage: {
        promptTokens: (o = (i = d.usage) == null ? void 0 : i.prompt_tokens) != null ? o : NaN,
        completionTokens: (l = (a = d.usage) == null ? void 0 : a.completion_tokens) != null ? l : NaN
      },
      rawCall: { rawPrompt: f, rawSettings: g },
      rawResponse: { headers: h },
      request: { body: JSON.stringify(c) },
      response: f0(d),
      warnings: u,
      logprobs: EI(y.logprobs),
      providerMetadata: b
    };
  }
  async doStream(t) {
    var e;
    if ((e = this.settings.simulateStreaming) != null ? e : goe(this.modelId)) {
      const p = await this.doGenerate(t);
      return {
        stream: new ReadableStream({
          start(b) {
            if (b.enqueue({ type: "response-metadata", ...p.response }), p.text && b.enqueue({
              type: "text-delta",
              textDelta: p.text
            }), p.toolCalls)
              for (const _ of p.toolCalls)
                b.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: _.toolCallId,
                  toolName: _.toolName,
                  argsTextDelta: _.args
                }), b.enqueue({
                  type: "tool-call",
                  ..._
                });
            b.enqueue({
              type: "finish",
              finishReason: p.finishReason,
              usage: p.usage,
              logprobs: p.logprobs,
              providerMetadata: p.providerMetadata
            }), b.close();
          }
        }),
        rawCall: p.rawCall,
        rawResponse: p.rawResponse,
        warnings: p.warnings
      };
    }
    const { args: n, warnings: r } = this.getArgs(t), s = {
      ...n,
      stream: !0,
      // only include stream_options when in strict compatibility mode:
      stream_options: this.config.compatibility === "strict" ? { include_usage: !0 } : void 0
    }, { responseHeaders: i, value: o } = await Jc({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: Zc(this.config.headers(), t.headers),
      body: s,
      failedResponseHandler: tu,
      successfulResponseHandler: U5(
        poe
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: a, ...l } = n, c = [];
    let u = "unknown", h = {
      promptTokens: void 0,
      completionTokens: void 0
    }, d, f = !0;
    const { useLegacyFunctionCalling: g } = this.settings, y = { openai: {} };
    return {
      stream: o.pipeThrough(
        new TransformStream({
          transform(p, m) {
            var b, _, v, w, E, x, S, T, R, F, P, M;
            if (!p.success) {
              u = "error", m.enqueue({ type: "error", error: p.error });
              return;
            }
            const A = p.value;
            if ("error" in A) {
              u = "error", m.enqueue({ type: "error", error: A.error });
              return;
            }
            if (f && (f = !1, m.enqueue({
              type: "response-metadata",
              ...f0(A)
            })), A.usage != null) {
              const {
                prompt_tokens: N,
                completion_tokens: L,
                prompt_tokens_details: j,
                completion_tokens_details: H
              } = A.usage;
              h = {
                promptTokens: N ?? void 0,
                completionTokens: L ?? void 0
              }, H?.reasoning_tokens != null && (y.openai.reasoningTokens = H?.reasoning_tokens), H?.accepted_prediction_tokens != null && (y.openai.acceptedPredictionTokens = H?.accepted_prediction_tokens), H?.rejected_prediction_tokens != null && (y.openai.rejectedPredictionTokens = H?.rejected_prediction_tokens), j?.cached_tokens != null && (y.openai.cachedPromptTokens = j?.cached_tokens);
            }
            const V = A.choices[0];
            if (V?.finish_reason != null && (u = d0(V.finish_reason)), V?.delta == null)
              return;
            const ee = V.delta;
            ee.content != null && m.enqueue({
              type: "text-delta",
              textDelta: ee.content
            });
            const K = EI(
              V?.logprobs
            );
            K?.length && (d === void 0 && (d = []), d.push(...K));
            const te = g && ee.function_call != null ? [
              {
                type: "function",
                id: Ju(),
                function: ee.function_call,
                index: 0
              }
            ] : ee.tool_calls;
            if (te != null)
              for (const N of te) {
                const L = N.index;
                if (c[L] == null) {
                  if (N.type !== "function")
                    throw new av({
                      data: N,
                      message: "Expected 'function' type."
                    });
                  if (N.id == null)
                    throw new av({
                      data: N,
                      message: "Expected 'id' to be a string."
                    });
                  if (((b = N.function) == null ? void 0 : b.name) == null)
                    throw new av({
                      data: N,
                      message: "Expected 'function.name' to be a string."
                    });
                  c[L] = {
                    id: N.id,
                    type: "function",
                    function: {
                      name: N.function.name,
                      arguments: (_ = N.function.arguments) != null ? _ : ""
                    },
                    hasFinished: !1
                  };
                  const H = c[L];
                  ((v = H.function) == null ? void 0 : v.name) != null && ((w = H.function) == null ? void 0 : w.arguments) != null && (H.function.arguments.length > 0 && m.enqueue({
                    type: "tool-call-delta",
                    toolCallType: "function",
                    toolCallId: H.id,
                    toolName: H.function.name,
                    argsTextDelta: H.function.arguments
                  }), _I(H.function.arguments) && (m.enqueue({
                    type: "tool-call",
                    toolCallType: "function",
                    toolCallId: (E = H.id) != null ? E : Ju(),
                    toolName: H.function.name,
                    args: H.function.arguments
                  }), H.hasFinished = !0));
                  continue;
                }
                const j = c[L];
                j.hasFinished || (((x = N.function) == null ? void 0 : x.arguments) != null && (j.function.arguments += (T = (S = N.function) == null ? void 0 : S.arguments) != null ? T : ""), m.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: j.id,
                  toolName: j.function.name,
                  argsTextDelta: (R = N.function.arguments) != null ? R : ""
                }), ((F = j.function) == null ? void 0 : F.name) != null && ((P = j.function) == null ? void 0 : P.arguments) != null && _I(j.function.arguments) && (m.enqueue({
                  type: "tool-call",
                  toolCallType: "function",
                  toolCallId: (M = j.id) != null ? M : Ju(),
                  toolName: j.function.name,
                  args: j.function.arguments
                }), j.hasFinished = !0));
              }
          },
          flush(p) {
            var m, b;
            p.enqueue({
              type: "finish",
              finishReason: u,
              logprobs: d,
              usage: {
                promptTokens: (m = h.promptTokens) != null ? m : NaN,
                completionTokens: (b = h.completionTokens) != null ? b : NaN
              },
              ...y != null ? { providerMetadata: y } : {}
            });
          }
        })
      ),
      rawCall: { rawPrompt: a, rawSettings: l },
      rawResponse: { headers: i },
      request: { body: JSON.stringify(s) },
      warnings: r
    };
  }
}, J5 = D.object({
  prompt_tokens: D.number().nullish(),
  completion_tokens: D.number().nullish(),
  prompt_tokens_details: D.object({
    cached_tokens: D.number().nullish()
  }).nullish(),
  completion_tokens_details: D.object({
    reasoning_tokens: D.number().nullish(),
    accepted_prediction_tokens: D.number().nullish(),
    rejected_prediction_tokens: D.number().nullish()
  }).nullish()
}).nullish(), foe = D.object({
  id: D.string().nullish(),
  created: D.number().nullish(),
  model: D.string().nullish(),
  choices: D.array(
    D.object({
      message: D.object({
        role: D.literal("assistant").nullish(),
        content: D.string().nullish(),
        function_call: D.object({
          arguments: D.string(),
          name: D.string()
        }).nullish(),
        tool_calls: D.array(
          D.object({
            id: D.string().nullish(),
            type: D.literal("function"),
            function: D.object({
              name: D.string(),
              arguments: D.string()
            })
          })
        ).nullish()
      }),
      index: D.number(),
      logprobs: D.object({
        content: D.array(
          D.object({
            token: D.string(),
            logprob: D.number(),
            top_logprobs: D.array(
              D.object({
                token: D.string(),
                logprob: D.number()
              })
            )
          })
        ).nullable()
      }).nullish(),
      finish_reason: D.string().nullish()
    })
  ),
  usage: J5
}), poe = D.union([
  D.object({
    id: D.string().nullish(),
    created: D.number().nullish(),
    model: D.string().nullish(),
    choices: D.array(
      D.object({
        delta: D.object({
          role: D.enum(["assistant"]).nullish(),
          content: D.string().nullish(),
          function_call: D.object({
            name: D.string().optional(),
            arguments: D.string().optional()
          }).nullish(),
          tool_calls: D.array(
            D.object({
              index: D.number(),
              id: D.string().nullish(),
              type: D.literal("function").optional(),
              function: D.object({
                name: D.string().nullish(),
                arguments: D.string().nullish()
              })
            })
          ).nullish()
        }).nullish(),
        logprobs: D.object({
          content: D.array(
            D.object({
              token: D.string(),
              logprob: D.number(),
              top_logprobs: D.array(
                D.object({
                  token: D.string(),
                  logprob: D.number()
                })
              )
            })
          ).nullable()
        }).nullish(),
        finish_reason: D.string().nullable().optional(),
        index: D.number()
      })
    ),
    usage: J5
  }),
  OC
]);
function p0(t) {
  return t === "o1" || t.startsWith("o1-") || t === "o3" || t.startsWith("o3-");
}
function moe(t) {
  return t.startsWith("gpt-4o-audio-preview");
}
function SI(t) {
  var e, n;
  return p0(t) ? (n = (e = X5[t]) == null ? void 0 : e.systemMessageMode) != null ? n : "developer" : "system";
}
function goe(t) {
  var e, n;
  return p0(t) ? (n = (e = X5[t]) == null ? void 0 : e.simulateStreamingByDefault) != null ? n : !0 : !1;
}
var X5 = {
  "o1-mini": {
    systemMessageMode: "remove",
    simulateStreamingByDefault: !1
  },
  "o1-mini-2024-09-12": {
    systemMessageMode: "remove",
    simulateStreamingByDefault: !1
  },
  "o1-preview": {
    systemMessageMode: "remove",
    simulateStreamingByDefault: !1
  },
  "o1-preview-2024-09-12": {
    systemMessageMode: "remove",
    simulateStreamingByDefault: !1
  },
  "o3-mini": {
    systemMessageMode: "developer",
    simulateStreamingByDefault: !1
  },
  "o3-mini-2025-01-31": {
    systemMessageMode: "developer",
    simulateStreamingByDefault: !1
  }
};
function yoe({
  prompt: t,
  inputFormat: e,
  user: n = "user",
  assistant: r = "assistant"
}) {
  if (e === "prompt" && t.length === 1 && t[0].role === "user" && t[0].content.length === 1 && t[0].content[0].type === "text")
    return { prompt: t[0].content[0].text };
  let s = "";
  t[0].role === "system" && (s += `${t[0].content}

`, t = t.slice(1));
  for (const { role: i, content: o } of t)
    switch (i) {
      case "system":
        throw new Tse({
          message: "Unexpected system message in prompt: ${content}",
          prompt: t
        });
      case "user": {
        const a = o.map((l) => {
          switch (l.type) {
            case "text":
              return l.text;
            case "image":
              throw new pr({
                functionality: "images"
              });
          }
        }).join("");
        s += `${n}:
${a}

`;
        break;
      }
      case "assistant": {
        const a = o.map((l) => {
          switch (l.type) {
            case "text":
              return l.text;
            case "tool-call":
              throw new pr({
                functionality: "tool-call messages"
              });
          }
        }).join("");
        s += `${r}:
${a}

`;
        break;
      }
      case "tool":
        throw new pr({
          functionality: "tool messages"
        });
      default: {
        const a = i;
        throw new Error(`Unsupported role: ${a}`);
      }
    }
  return s += `${r}:
`, {
    prompt: s,
    stopSequences: [`
${n}:`]
  };
}
function xI(t) {
  return t?.tokens.map((e, n) => ({
    token: e,
    logprob: t.token_logprobs[n],
    topLogprobs: t.top_logprobs ? Object.entries(t.top_logprobs[n]).map(
      ([r, s]) => ({
        token: r,
        logprob: s
      })
    ) : []
  }));
}
var boe = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.defaultObjectGenerationMode = void 0, this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    mode: t,
    inputFormat: e,
    prompt: n,
    maxTokens: r,
    temperature: s,
    topP: i,
    topK: o,
    frequencyPenalty: a,
    presencePenalty: l,
    stopSequences: c,
    responseFormat: u,
    seed: h
  }) {
    var d;
    const f = t.type, g = [];
    o != null && g.push({
      type: "unsupported-setting",
      setting: "topK"
    }), u != null && u.type !== "text" && g.push({
      type: "unsupported-setting",
      setting: "responseFormat",
      details: "JSON response format is not supported."
    });
    const { prompt: y, stopSequences: p } = yoe({ prompt: n, inputFormat: e }), m = [...p ?? [], ...c ?? []], b = {
      // model id:
      model: this.modelId,
      // model specific settings:
      echo: this.settings.echo,
      logit_bias: this.settings.logitBias,
      logprobs: typeof this.settings.logprobs == "number" ? this.settings.logprobs : typeof this.settings.logprobs == "boolean" && this.settings.logprobs ? 0 : void 0,
      suffix: this.settings.suffix,
      user: this.settings.user,
      // standardized settings:
      max_tokens: r,
      temperature: s,
      top_p: i,
      frequency_penalty: a,
      presence_penalty: l,
      seed: h,
      // prompt:
      prompt: y,
      // stop sequences:
      stop: m.length > 0 ? m : void 0
    };
    switch (f) {
      case "regular": {
        if ((d = t.tools) != null && d.length)
          throw new pr({
            functionality: "tools"
          });
        if (t.toolChoice)
          throw new pr({
            functionality: "toolChoice"
          });
        return { args: b, warnings: g };
      }
      case "object-json":
        throw new pr({
          functionality: "object-json mode"
        });
      case "object-tool":
        throw new pr({
          functionality: "object-tool mode"
        });
      default: {
        const _ = f;
        throw new Error(`Unsupported type: ${_}`);
      }
    }
  }
  async doGenerate(t) {
    const { args: e, warnings: n } = this.getArgs(t), { responseHeaders: r, value: s } = await Jc({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: Zc(this.config.headers(), t.headers),
      body: e,
      failedResponseHandler: tu,
      successfulResponseHandler: mb(
        _oe
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { prompt: i, ...o } = e, a = s.choices[0];
    return {
      text: a.text,
      usage: {
        promptTokens: s.usage.prompt_tokens,
        completionTokens: s.usage.completion_tokens
      },
      finishReason: d0(a.finish_reason),
      logprobs: xI(a.logprobs),
      rawCall: { rawPrompt: i, rawSettings: o },
      rawResponse: { headers: r },
      response: f0(s),
      warnings: n,
      request: { body: JSON.stringify(e) }
    };
  }
  async doStream(t) {
    const { args: e, warnings: n } = this.getArgs(t), r = {
      ...e,
      stream: !0,
      // only include stream_options when in strict compatibility mode:
      stream_options: this.config.compatibility === "strict" ? { include_usage: !0 } : void 0
    }, { responseHeaders: s, value: i } = await Jc({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: Zc(this.config.headers(), t.headers),
      body: r,
      failedResponseHandler: tu,
      successfulResponseHandler: U5(
        voe
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { prompt: o, ...a } = e;
    let l = "unknown", c = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    }, u, h = !0;
    return {
      stream: i.pipeThrough(
        new TransformStream({
          transform(d, f) {
            if (!d.success) {
              l = "error", f.enqueue({ type: "error", error: d.error });
              return;
            }
            const g = d.value;
            if ("error" in g) {
              l = "error", f.enqueue({ type: "error", error: g.error });
              return;
            }
            h && (h = !1, f.enqueue({
              type: "response-metadata",
              ...f0(g)
            })), g.usage != null && (c = {
              promptTokens: g.usage.prompt_tokens,
              completionTokens: g.usage.completion_tokens
            });
            const y = g.choices[0];
            y?.finish_reason != null && (l = d0(y.finish_reason)), y?.text != null && f.enqueue({
              type: "text-delta",
              textDelta: y.text
            });
            const p = xI(
              y?.logprobs
            );
            p?.length && (u === void 0 && (u = []), u.push(...p));
          },
          flush(d) {
            d.enqueue({
              type: "finish",
              finishReason: l,
              logprobs: u,
              usage: c
            });
          }
        })
      ),
      rawCall: { rawPrompt: o, rawSettings: a },
      rawResponse: { headers: s },
      warnings: n,
      request: { body: JSON.stringify(r) }
    };
  }
}, _oe = D.object({
  id: D.string().nullish(),
  created: D.number().nullish(),
  model: D.string().nullish(),
  choices: D.array(
    D.object({
      text: D.string(),
      finish_reason: D.string(),
      logprobs: D.object({
        tokens: D.array(D.string()),
        token_logprobs: D.array(D.number()),
        top_logprobs: D.array(D.record(D.string(), D.number())).nullable()
      }).nullish()
    })
  ),
  usage: D.object({
    prompt_tokens: D.number(),
    completion_tokens: D.number()
  })
}), voe = D.union([
  D.object({
    id: D.string().nullish(),
    created: D.number().nullish(),
    model: D.string().nullish(),
    choices: D.array(
      D.object({
        text: D.string(),
        finish_reason: D.string().nullish(),
        index: D.number(),
        logprobs: D.object({
          tokens: D.array(D.string()),
          token_logprobs: D.array(D.number()),
          top_logprobs: D.array(D.record(D.string(), D.number())).nullable()
        }).nullish()
      })
    ),
    usage: D.object({
      prompt_tokens: D.number(),
      completion_tokens: D.number()
    }).nullish()
  }),
  OC
]), woe = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    var t;
    return (t = this.settings.maxEmbeddingsPerCall) != null ? t : 2048;
  }
  get supportsParallelCalls() {
    var t;
    return (t = this.settings.supportsParallelCalls) != null ? t : !0;
  }
  async doEmbed({
    values: t,
    headers: e,
    abortSignal: n
  }) {
    if (t.length > this.maxEmbeddingsPerCall)
      throw new Ise({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values: t
      });
    const { responseHeaders: r, value: s } = await Jc({
      url: this.config.url({
        path: "/embeddings",
        modelId: this.modelId
      }),
      headers: Zc(this.config.headers(), e),
      body: {
        model: this.modelId,
        input: t,
        encoding_format: "float",
        dimensions: this.settings.dimensions,
        user: this.settings.user
      },
      failedResponseHandler: tu,
      successfulResponseHandler: mb(
        Eoe
      ),
      abortSignal: n,
      fetch: this.config.fetch
    });
    return {
      embeddings: s.data.map((i) => i.embedding),
      usage: s.usage ? { tokens: s.usage.prompt_tokens } : void 0,
      rawResponse: { headers: r }
    };
  }
}, Eoe = D.object({
  data: D.array(D.object({ embedding: D.array(D.number()) })),
  usage: D.object({ prompt_tokens: D.number() }).nullish()
}), Soe = {
  "dall-e-3": 1,
  "dall-e-2": 10
}, xoe = class {
  constructor(t, e, n) {
    this.modelId = t, this.settings = e, this.config = n, this.specificationVersion = "v1";
  }
  get maxImagesPerCall() {
    var t, e;
    return (e = (t = this.settings.maxImagesPerCall) != null ? t : Soe[this.modelId]) != null ? e : 1;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt: t,
    n: e,
    size: n,
    aspectRatio: r,
    seed: s,
    providerOptions: i,
    headers: o,
    abortSignal: a
  }) {
    var l, c, u, h;
    const d = [];
    r != null && d.push({
      type: "unsupported-setting",
      setting: "aspectRatio",
      details: "This model does not support aspect ratio. Use `size` instead."
    }), s != null && d.push({ type: "unsupported-setting", setting: "seed" });
    const f = (u = (c = (l = this.config._internal) == null ? void 0 : l.currentDate) == null ? void 0 : c.call(l)) != null ? u : /* @__PURE__ */ new Date(), { value: g, responseHeaders: y } = await Jc({
      url: this.config.url({
        path: "/images/generations",
        modelId: this.modelId
      }),
      headers: Zc(this.config.headers(), o),
      body: {
        model: this.modelId,
        prompt: t,
        n: e,
        size: n,
        ...(h = i.openai) != null ? h : {},
        response_format: "b64_json"
      },
      failedResponseHandler: tu,
      successfulResponseHandler: mb(
        Toe
      ),
      abortSignal: a,
      fetch: this.config.fetch
    });
    return {
      images: g.data.map((p) => p.b64_json),
      warnings: d,
      response: {
        timestamp: f,
        modelId: this.modelId,
        headers: y
      }
    };
  }
}, Toe = D.object({
  data: D.array(D.object({ b64_json: D.string() }))
});
function Pi(t = {}) {
  var e, n, r;
  const s = (e = tie(t.baseURL)) != null ? e : "https://api.openai.com/v1", i = (n = t.compatibility) != null ? n : "compatible", o = (r = t.name) != null ? r : "openai", a = () => ({
    Authorization: `Bearer ${zse({
      apiKey: t.apiKey,
      environmentVariableName: "OPENAI_API_KEY",
      description: "OpenAI"
    })}`,
    "OpenAI-Organization": t.organization,
    "OpenAI-Project": t.project,
    ...t.headers
  }), l = (g, y = {}) => new doe(g, y, {
    provider: `${o}.chat`,
    url: ({ path: p }) => `${s}${p}`,
    headers: a,
    compatibility: i,
    fetch: t.fetch
  }), c = (g, y = {}) => new boe(g, y, {
    provider: `${o}.completion`,
    url: ({ path: p }) => `${s}${p}`,
    headers: a,
    compatibility: i,
    fetch: t.fetch
  }), u = (g, y = {}) => new woe(g, y, {
    provider: `${o}.embedding`,
    url: ({ path: p }) => `${s}${p}`,
    headers: a,
    fetch: t.fetch
  }), h = (g, y = {}) => new xoe(g, y, {
    provider: `${o}.image`,
    url: ({ path: p }) => `${s}${p}`,
    headers: a,
    fetch: t.fetch
  }), d = (g, y) => {
    if (new.target)
      throw new Error(
        "The OpenAI model function cannot be called with the new keyword."
      );
    return g === "gpt-3.5-turbo-instruct" ? c(
      g,
      y
    ) : l(g, y);
  }, f = function(g, y) {
    return d(g, y);
  };
  return f.languageModel = d, f.chat = l, f.completion = c, f.embedding = u, f.textEmbedding = u, f.textEmbeddingModel = u, f.image = h, f.imageModel = h, f;
}
Pi({
  compatibility: "strict"
  // strict for OpenAI API
});
class mn {
  cachedDynamicModels;
  getApiKeyLink;
  labelForGetApiKey;
  icon;
  getProviderBaseUrlAndKey(e) {
    const { apiKeys: n, providerSettings: r, serverEnv: s, defaultBaseUrlKey: i, defaultApiTokenKey: o } = e;
    let a = r?.baseUrl;
    const l = Ha.getInstance();
    a && a.length == 0 && (a = void 0);
    const c = this.config.baseUrlKey || i;
    let u = a || s?.[c] || je?.env?.[c] || l.env?.[c] || this.config.baseUrl;
    u && u.endsWith("/") && (u = u.slice(0, -1));
    const h = this.config.apiTokenKey || o, d = n?.[this.name] || s?.[h] || je?.env?.[h] || l.env?.[h];
    return {
      baseUrl: u,
      apiKey: d
    };
  }
  getModelsFromCache(e) {
    if (!this.cachedDynamicModels)
      return null;
    const n = this.cachedDynamicModels.cacheId, r = this.getDynamicModelsCacheKey(e);
    return n !== r ? (this.cachedDynamicModels = void 0, null) : this.cachedDynamicModels.models;
  }
  getDynamicModelsCacheKey(e) {
    return JSON.stringify({
      apiKeys: e.apiKeys?.[this.name],
      providerSettings: e.providerSettings?.[this.name],
      serverEnv: e.serverEnv
    });
  }
  storeDynamicModels(e, n) {
    const r = this.getDynamicModelsCacheKey(e);
    this.cachedDynamicModels = {
      cacheId: r,
      models: n
    };
  }
}
function Q5(t, e, n) {
  return Pi({
    baseURL: t,
    apiKey: e
  })(n);
}
var eF = "vercel.ai.error", Coe = Symbol.for(eF), tF, koe = class nF extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[tF] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return nF.hasMarker(e, eF);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
  /**
   * Returns a JSON representation of the error.
   * @returns {Object} An object containing the error's name, message, and cause.
   *
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message
    };
  }
};
tF = Coe;
var ss = koe, oE = "AI_APICallError", rF = `vercel.ai.error.${oE}`, Aoe = Symbol.for(rF), sF, Gi = class extends ss {
  constructor({
    message: e,
    url: n,
    requestBodyValues: r,
    statusCode: s,
    responseHeaders: i,
    responseBody: o,
    cause: a,
    isRetryable: l = s != null && (s === 408 || // request timeout
    s === 409 || // conflict
    s === 429 || // too many requests
    s >= 500),
    // server error
    data: c
  }) {
    super({ name: oE, message: e, cause: a }), this[sF] = !0, this.url = n, this.requestBodyValues = r, this.statusCode = s, this.responseHeaders = i, this.responseBody = o, this.isRetryable = l, this.data = c;
  }
  static isInstance(e) {
    return ss.hasMarker(e, rF);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isAPICallError(e) {
    return e instanceof Error && e.name === oE && typeof e.url == "string" && typeof e.requestBodyValues == "object" && (e.statusCode == null || typeof e.statusCode == "number") && (e.responseHeaders == null || typeof e.responseHeaders == "object") && (e.responseBody == null || typeof e.responseBody == "string") && (e.cause == null || typeof e.cause == "object") && typeof e.isRetryable == "boolean" && (e.data == null || typeof e.data == "object");
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      url: this.url,
      requestBodyValues: this.requestBodyValues,
      statusCode: this.statusCode,
      responseHeaders: this.responseHeaders,
      responseBody: this.responseBody,
      cause: this.cause,
      isRetryable: this.isRetryable,
      data: this.data
    };
  }
};
sF = Aoe;
var aE = "AI_EmptyResponseBodyError", iF = `vercel.ai.error.${aE}`, Roe = Symbol.for(iF), oF, Ioe = class extends ss {
  // used in isInstance
  constructor({ message: e = "Empty response body" } = {}) {
    super({ name: aE, message: e }), this[oF] = !0;
  }
  static isInstance(e) {
    return ss.hasMarker(e, iF);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isEmptyResponseBodyError(e) {
    return e instanceof Error && e.name === aE;
  }
};
oF = Roe;
function aF(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var lE = "AI_JSONParseError", lF = `vercel.ai.error.${lE}`, Poe = Symbol.for(lF), cF, m0 = class extends ss {
  constructor({ text: e, cause: n }) {
    super({
      name: lE,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${aF(n)}`,
      cause: n
    }), this[cF] = !0, this.text = e;
  }
  static isInstance(e) {
    return ss.hasMarker(e, lF);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isJSONParseError(e) {
    return e instanceof Error && e.name === lE && typeof e.text == "string" && typeof e.cause == "string";
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      valueText: this.text
    };
  }
};
cF = Poe;
var cE = "AI_LoadAPIKeyError", uF = `vercel.ai.error.${cE}`, Ooe = Symbol.for(uF), hF, em = class extends ss {
  // used in isInstance
  constructor({ message: e }) {
    super({ name: cE, message: e }), this[hF] = !0;
  }
  static isInstance(e) {
    return ss.hasMarker(e, uF);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isLoadAPIKeyError(e) {
    return e instanceof Error && e.name === cE;
  }
};
hF = Ooe;
var uE = "AI_TypeValidationError", dF = `vercel.ai.error.${uE}`, Doe = Symbol.for(dF), fF, Gh = class extends ss {
  constructor({ value: e, cause: n }) {
    super({
      name: uE,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${aF(n)}`,
      cause: n
    }), this[fF] = !0, this.value = e;
  }
  static isInstance(e) {
    return ss.hasMarker(e, dF);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isTypeValidationError(e) {
    return e instanceof Error && e.name === uE;
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      value: this.value
    };
  }
};
fF = Doe;
var hE = "AI_UnsupportedFunctionalityError", pF = `vercel.ai.error.${hE}`, Noe = Symbol.for(pF), mF, dE = class extends ss {
  constructor({ functionality: e }) {
    super({
      name: hE,
      message: `'${e}' functionality not supported.`
    }), this[mF] = !0, this.functionality = e;
  }
  static isInstance(e) {
    return ss.hasMarker(e, pF);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isUnsupportedFunctionalityError(e) {
    return e instanceof Error && e.name === hE && typeof e.functionality == "string";
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      functionality: this.functionality
    };
  }
};
mF = Noe;
function Loe(t) {
  let e, n, r, s, i, o, a;
  return l(), {
    feed: c,
    reset: l
  };
  function l() {
    e = !0, n = "", r = 0, s = -1, i = void 0, o = void 0, a = "";
  }
  function c(h) {
    n = n ? n + h : h, e && Moe(n) && (n = n.slice(gF.length)), e = !1;
    const d = n.length;
    let f = 0, g = !1;
    for (; f < d; ) {
      g && (n[f] === `
` && ++f, g = !1);
      let y = -1, p = s, m;
      for (let b = r; y < 0 && b < d; ++b)
        m = n[b], m === ":" && p < 0 ? p = b - f : m === "\r" ? (g = !0, y = b - f) : m === `
` && (y = b - f);
      if (y < 0) {
        r = d - f, s = p;
        break;
      } else
        r = 0, s = -1;
      u(n, f, p, y), f += y + 1;
    }
    f === d ? n = "" : f > 0 && (n = n.slice(f));
  }
  function u(h, d, f, g) {
    if (g === 0) {
      a.length > 0 && (t({
        type: "event",
        id: i,
        event: o || void 0,
        data: a.slice(0, -1)
        // remove trailing newline
      }), a = "", i = void 0), o = void 0;
      return;
    }
    const y = f < 0, p = h.slice(d, d + (y ? g : f));
    let m = 0;
    y ? m = g : h[d + f + 1] === " " ? m = f + 2 : m = f + 1;
    const b = d + m, _ = g - m, v = h.slice(b, b + _).toString();
    if (p === "data")
      a += v ? "".concat(v, `
`) : `
`;
    else if (p === "event")
      o = v;
    else if (p === "id" && !v.includes("\0"))
      i = v;
    else if (p === "retry") {
      const w = parseInt(v, 10);
      Number.isNaN(w) || t({
        type: "reconnect-interval",
        value: w
      });
    }
  }
}
const gF = [239, 187, 191];
function Moe(t) {
  return gF.every((e, n) => t.charCodeAt(n) === e);
}
let Boe = class extends TransformStream {
  constructor() {
    let e;
    super({
      start(n) {
        e = Loe((r) => {
          r.type === "event" && n.enqueue(r);
        });
      },
      transform(n) {
        e.feed(n);
      }
    });
  }
};
function TI(...t) {
  return t.reduce(
    (e, n) => ({
      ...e,
      ...n ?? {}
    }),
    {}
  );
}
function yb(t) {
  const e = {};
  return t.headers.forEach((n, r) => {
    e[r] = n;
  }), e;
}
function hv(t) {
  return t instanceof Error && (t.name === "AbortError" || t.name === "TimeoutError");
}
function Foe({
  apiKey: t,
  environmentVariableName: e,
  apiKeyParameterName: n = "apiKey",
  description: r
}) {
  if (typeof t == "string")
    return t;
  if (t != null)
    throw new em({
      message: `${r} API key must be a string.`
    });
  if (typeof je > "u")
    throw new em({
      message: `${r} API key is missing. Pass it using the '${n}' parameter. Environment variables is not supported in this environment.`
    });
  if (t = je.env[e], t == null)
    throw new em({
      message: `${r} API key is missing. Pass it using the '${n}' parameter or the ${e} environment variable.`
    });
  if (typeof t != "string")
    throw new em({
      message: `${r} API key must be a string. The value of the ${e} environment variable is not a string.`
    });
  return t;
}
var fE = Symbol.for("vercel.ai.validator");
function $oe(t) {
  return { [fE]: !0, validate: t };
}
function Uoe(t) {
  return typeof t == "object" && t !== null && fE in t && t[fE] === !0 && "validate" in t;
}
function joe(t) {
  return $oe((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function Hoe({
  value: t,
  schema: e
}) {
  const n = yF({ value: t, schema: e });
  if (!n.success)
    throw new Gh({ value: t, cause: n.error });
  return n.value;
}
function yF({
  value: t,
  schema: e
}) {
  const n = Uoe(e) ? e : joe(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: new Gh({
        value: t,
        cause: r.error
      })
    };
  } catch (r) {
    return {
      success: !1,
      error: Gh.isTypeValidationError(r) ? r : new Gh({ value: t, cause: r })
    };
  }
}
function zoe({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? n : Hoe({ value: n, schema: e });
  } catch (n) {
    throw m0.isJSONParseError(n) || Gh.isTypeValidationError(n) ? n : new m0({ text: t, cause: n });
  }
}
function bF({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? {
      success: !0,
      value: n
    } : yF({ value: n, schema: e });
  } catch (n) {
    return {
      success: !1,
      error: m0.isJSONParseError(n) ? n : new m0({ text: t, cause: n })
    };
  }
}
function Goe(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n != null)
  );
}
var Voe = () => fetch, CI = async ({
  url: t,
  headers: e,
  body: n,
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}) => Woe({
  url: t,
  headers: {
    "Content-Type": "application/json",
    ...e
  },
  body: {
    content: JSON.stringify(n),
    values: n
  },
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}), Woe = async ({
  url: t,
  headers: e = {},
  body: n,
  successfulResponseHandler: r,
  failedResponseHandler: s,
  abortSignal: i,
  fetch: o = Voe()
}) => {
  try {
    const a = await o(t, {
      method: "POST",
      headers: Goe(e),
      body: n.content,
      signal: i
    }), l = yb(a);
    if (!a.ok) {
      let c;
      try {
        c = await s({
          response: a,
          url: t,
          requestBodyValues: n.values
        });
      } catch (u) {
        throw hv(u) || Gi.isAPICallError(u) ? u : new Gi({
          message: "Failed to process error response",
          cause: u,
          statusCode: a.status,
          url: t,
          responseHeaders: l,
          requestBodyValues: n.values
        });
      }
      throw c.value;
    }
    try {
      return await r({
        response: a,
        url: t,
        requestBodyValues: n.values
      });
    } catch (c) {
      throw c instanceof Error && (hv(c) || Gi.isAPICallError(c)) ? c : new Gi({
        message: "Failed to process successful response",
        cause: c,
        statusCode: a.status,
        url: t,
        responseHeaders: l,
        requestBodyValues: n.values
      });
    }
  } catch (a) {
    if (hv(a))
      throw a;
    if (a instanceof TypeError && a.message === "fetch failed") {
      const l = a.cause;
      if (l != null)
        throw new Gi({
          message: `Cannot connect to API: ${l.message}`,
          cause: l,
          url: t,
          requestBodyValues: n.values,
          isRetryable: !0
          // retry when network error
        });
    }
    throw a;
  }
}, qoe = ({
  errorSchema: t,
  errorToMessage: e,
  isRetryable: n
}) => async ({ response: r, url: s, requestBodyValues: i }) => {
  const o = await r.text(), a = yb(r);
  if (o.trim() === "")
    return {
      responseHeaders: a,
      value: new Gi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  try {
    const l = zoe({
      text: o,
      schema: t
    });
    return {
      responseHeaders: a,
      value: new Gi({
        message: e(l),
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        data: l,
        isRetryable: n?.(r, l)
      })
    };
  } catch {
    return {
      responseHeaders: a,
      value: new Gi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  }
}, Koe = (t) => async ({ response: e }) => {
  const n = yb(e);
  if (e.body == null)
    throw new Ioe({});
  return {
    responseHeaders: n,
    value: e.body.pipeThrough(new TextDecoderStream()).pipeThrough(new Boe()).pipeThrough(
      new TransformStream({
        transform({ data: r }, s) {
          r !== "[DONE]" && s.enqueue(
            bF({
              text: r,
              schema: t
            })
          );
        }
      })
    )
  };
}, Yoe = (t) => async ({ response: e, url: n, requestBodyValues: r }) => {
  const s = await e.text(), i = bF({
    text: s,
    schema: t
  }), o = yb(e);
  if (!i.success)
    throw new Gi({
      message: "Invalid JSON response",
      cause: i.error,
      statusCode: e.status,
      responseHeaders: o,
      responseBody: s,
      url: n,
      requestBodyValues: r
    });
  return {
    responseHeaders: o,
    value: i.value
  };
};
function Zoe(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCodePoint(t[n]);
  return globalThis.btoa(e);
}
function Joe(t) {
  return t?.replace(/\/$/, "");
}
var Xoe = D.object({
  type: D.literal("error"),
  error: D.object({
    type: D.string(),
    message: D.string()
  })
}), kI = qoe({
  errorSchema: Xoe,
  errorToMessage: (t) => t.error.message
});
function Qoe(t) {
  var e;
  const n = eae(t);
  let r;
  const s = [];
  for (let i = 0; i < n.length; i++) {
    const o = n[i], a = o.type;
    switch (a) {
      case "system": {
        if (r != null)
          throw new dE({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        r = o.messages.map(({ content: l }) => l).join(`
`);
        break;
      }
      case "user": {
        const l = [];
        for (const { role: c, content: u } of o.messages)
          switch (c) {
            case "user": {
              for (const h of u)
                switch (h.type) {
                  case "text": {
                    l.push({ type: "text", text: h.text });
                    break;
                  }
                  case "image": {
                    if (h.image instanceof URL)
                      throw new dE({
                        functionality: "Image URLs in user messages"
                      });
                    l.push({
                      type: "image",
                      source: {
                        type: "base64",
                        media_type: (e = h.mimeType) != null ? e : "image/jpeg",
                        data: Zoe(h.image)
                      }
                    });
                    break;
                  }
                }
              break;
            }
            case "tool": {
              for (const h of u)
                l.push({
                  type: "tool_result",
                  tool_use_id: h.toolCallId,
                  content: JSON.stringify(h.result),
                  is_error: h.isError
                });
              break;
            }
            default: {
              const h = c;
              throw new Error(`Unsupported role: ${h}`);
            }
          }
        s.push({ role: "user", content: l });
        break;
      }
      case "assistant": {
        const l = [];
        for (const { content: c } of o.messages)
          for (let u = 0; u < c.length; u++) {
            const h = c[u];
            switch (h.type) {
              case "text": {
                l.push({
                  type: "text",
                  text: (
                    // trim the last text part if it's the last message in the block
                    // because Anthropic does not allow trailing whitespace
                    // in pre-filled assistant responses
                    i === n.length - 1 && u === o.messages.length - 1 ? h.text.trim() : h.text
                  )
                });
                break;
              }
              case "tool-call": {
                l.push({
                  type: "tool_use",
                  id: h.toolCallId,
                  name: h.toolName,
                  input: h.args
                });
                break;
              }
            }
          }
        s.push({ role: "assistant", content: l });
        break;
      }
      default: {
        const l = a;
        throw new Error(`Unsupported type: ${l}`);
      }
    }
  }
  return {
    system: r,
    messages: s
  };
}
function eae(t) {
  const e = [];
  let n;
  for (const { role: r, content: s } of t)
    switch (r) {
      case "system": {
        n?.type !== "system" && (n = { type: "system", messages: [] }, e.push(n)), n.messages.push({ role: r, content: s });
        break;
      }
      case "assistant": {
        n?.type !== "assistant" && (n = { type: "assistant", messages: [] }, e.push(n)), n.messages.push({ role: r, content: s });
        break;
      }
      case "user": {
        n?.type !== "user" && (n = { type: "user", messages: [] }, e.push(n)), n.messages.push({ role: r, content: s });
        break;
      }
      case "tool": {
        n?.type !== "user" && (n = { type: "user", messages: [] }, e.push(n)), n.messages.push({ role: r, content: s });
        break;
      }
      default: {
        const i = r;
        throw new Error(`Unsupported role: ${i}`);
      }
    }
  return e;
}
function AI(t) {
  switch (t) {
    case "end_turn":
    case "stop_sequence":
      return "stop";
    case "tool_use":
      return "tool-calls";
    case "max_tokens":
      return "length";
    default:
      return "other";
  }
}
var tae = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.defaultObjectGenerationMode = "tool", this.supportsImageUrls = !1, this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    mode: t,
    prompt: e,
    maxTokens: n,
    temperature: r,
    topP: s,
    topK: i,
    frequencyPenalty: o,
    presencePenalty: a,
    stopSequences: l,
    responseFormat: c,
    seed: u
  }) {
    const h = t.type, d = [];
    o != null && d.push({
      type: "unsupported-setting",
      setting: "frequencyPenalty"
    }), a != null && d.push({
      type: "unsupported-setting",
      setting: "presencePenalty"
    }), u != null && d.push({
      type: "unsupported-setting",
      setting: "seed"
    }), c != null && c.type !== "text" && d.push({
      type: "unsupported-setting",
      setting: "responseFormat",
      details: "JSON response format is not supported."
    });
    const f = Qoe(e), g = {
      // model id:
      model: this.modelId,
      // model specific settings:
      top_k: i ?? this.settings.topK,
      // standardized settings:
      max_tokens: n ?? 4096,
      // 4096: max model output tokens
      temperature: r,
      top_p: s,
      stop_sequences: l,
      // prompt:
      system: f.system,
      messages: f.messages
    };
    switch (h) {
      case "regular":
        return {
          args: { ...g, ...sae(t) },
          warnings: d
        };
      case "object-json":
        throw new dE({
          functionality: "json-mode object generation"
        });
      case "object-tool": {
        const { name: y, description: p, parameters: m } = t.tool;
        return {
          args: {
            ...g,
            tools: [{ name: y, description: p, input_schema: m }],
            tool_choice: { type: "tool", name: y }
          },
          warnings: d
        };
      }
      default: {
        const y = h;
        throw new Error(`Unsupported type: ${y}`);
      }
    }
  }
  async doGenerate(t) {
    const { args: e, warnings: n } = await this.getArgs(t), { responseHeaders: r, value: s } = await CI({
      url: `${this.config.baseURL}/messages`,
      headers: TI(this.config.headers(), t.headers),
      body: e,
      failedResponseHandler: kI,
      successfulResponseHandler: Yoe(
        nae
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: i, ...o } = e;
    let a = "";
    for (const c of s.content)
      c.type === "text" && (a += c.text);
    let l;
    if (s.content.some((c) => c.type === "tool_use")) {
      l = [];
      for (const c of s.content)
        c.type === "tool_use" && l.push({
          toolCallType: "function",
          toolCallId: c.id,
          toolName: c.name,
          args: JSON.stringify(c.input)
        });
    }
    return {
      text: a,
      toolCalls: l,
      finishReason: AI(s.stop_reason),
      usage: {
        promptTokens: s.usage.input_tokens,
        completionTokens: s.usage.output_tokens
      },
      rawCall: { rawPrompt: i, rawSettings: o },
      rawResponse: { headers: r },
      warnings: n
    };
  }
  async doStream(t) {
    const { args: e, warnings: n } = await this.getArgs(t), { responseHeaders: r, value: s } = await CI({
      url: `${this.config.baseURL}/messages`,
      headers: TI(this.config.headers(), t.headers),
      body: {
        ...e,
        stream: !0
      },
      failedResponseHandler: kI,
      successfulResponseHandler: Koe(
        rae
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: i, ...o } = e;
    let a = "other";
    const l = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    }, c = {};
    return {
      stream: s.pipeThrough(
        new TransformStream({
          transform(u, h) {
            if (!u.success) {
              h.enqueue({ type: "error", error: u.error });
              return;
            }
            const d = u.value;
            switch (d.type) {
              case "ping":
                return;
              case "content_block_start": {
                const f = d.content_block.type;
                switch (f) {
                  case "text":
                    return;
                  case "tool_use": {
                    c[d.index] = {
                      toolCallId: d.content_block.id,
                      toolName: d.content_block.name,
                      jsonText: ""
                    };
                    return;
                  }
                  default: {
                    const g = f;
                    throw new Error(
                      `Unsupported content block type: ${g}`
                    );
                  }
                }
              }
              case "content_block_stop": {
                if (c[d.index] != null) {
                  const f = c[d.index];
                  h.enqueue({
                    type: "tool-call",
                    toolCallType: "function",
                    toolCallId: f.toolCallId,
                    toolName: f.toolName,
                    args: f.jsonText
                  }), delete c[d.index];
                }
                return;
              }
              case "content_block_delta": {
                const f = d.delta.type;
                switch (f) {
                  case "text_delta": {
                    h.enqueue({
                      type: "text-delta",
                      textDelta: d.delta.text
                    });
                    return;
                  }
                  case "input_json_delta": {
                    const g = c[d.index];
                    h.enqueue({
                      type: "tool-call-delta",
                      toolCallType: "function",
                      toolCallId: g.toolCallId,
                      toolName: g.toolName,
                      argsTextDelta: d.delta.partial_json
                    }), g.jsonText += d.delta.partial_json;
                    return;
                  }
                  default: {
                    const g = f;
                    throw new Error(
                      `Unsupported delta type: ${g}`
                    );
                  }
                }
              }
              case "message_start": {
                l.promptTokens = d.message.usage.input_tokens, l.completionTokens = d.message.usage.output_tokens;
                return;
              }
              case "message_delta": {
                l.completionTokens = d.usage.output_tokens, a = AI(d.delta.stop_reason);
                return;
              }
              case "message_stop": {
                h.enqueue({ type: "finish", finishReason: a, usage: l });
                return;
              }
              case "error": {
                h.enqueue({ type: "error", error: d.error });
                return;
              }
              default: {
                const f = d;
                throw new Error(`Unsupported chunk type: ${f}`);
              }
            }
          }
        })
      ),
      rawCall: { rawPrompt: i, rawSettings: o },
      rawResponse: { headers: r },
      warnings: n
    };
  }
}, nae = D.object({
  type: D.literal("message"),
  content: D.array(
    D.discriminatedUnion("type", [
      D.object({
        type: D.literal("text"),
        text: D.string()
      }),
      D.object({
        type: D.literal("tool_use"),
        id: D.string(),
        name: D.string(),
        input: D.unknown()
      })
    ])
  ),
  stop_reason: D.string().optional().nullable(),
  usage: D.object({
    input_tokens: D.number(),
    output_tokens: D.number()
  })
}), rae = D.discriminatedUnion("type", [
  D.object({
    type: D.literal("message_start"),
    message: D.object({
      usage: D.object({
        input_tokens: D.number(),
        output_tokens: D.number()
      })
    })
  }),
  D.object({
    type: D.literal("content_block_start"),
    index: D.number(),
    content_block: D.discriminatedUnion("type", [
      D.object({
        type: D.literal("text"),
        text: D.string()
      }),
      D.object({
        type: D.literal("tool_use"),
        id: D.string(),
        name: D.string()
      })
    ])
  }),
  D.object({
    type: D.literal("content_block_delta"),
    index: D.number(),
    delta: D.discriminatedUnion("type", [
      D.object({
        type: D.literal("input_json_delta"),
        partial_json: D.string()
      }),
      D.object({
        type: D.literal("text_delta"),
        text: D.string()
      })
    ])
  }),
  D.object({
    type: D.literal("content_block_stop"),
    index: D.number()
  }),
  D.object({
    type: D.literal("error"),
    error: D.object({
      type: D.string(),
      message: D.string()
    })
  }),
  D.object({
    type: D.literal("message_delta"),
    delta: D.object({ stop_reason: D.string().optional().nullable() }),
    usage: D.object({ output_tokens: D.number() })
  }),
  D.object({
    type: D.literal("message_stop")
  }),
  D.object({
    type: D.literal("ping")
  })
]);
function sae(t) {
  var e;
  const n = (e = t.tools) != null && e.length ? t.tools : void 0;
  if (n == null)
    return { tools: void 0, tool_choice: void 0 };
  const r = n.map((o) => ({
    name: o.name,
    description: o.description,
    input_schema: o.parameters
  })), s = t.toolChoice;
  if (s == null)
    return { tools: r, tool_choice: void 0 };
  const i = s.type;
  switch (i) {
    case "auto":
      return { tools: r, tool_choice: { type: "auto" } };
    case "required":
      return { tools: r, tool_choice: { type: "any" } };
    case "none":
      return { tools: void 0, tool_choice: void 0 };
    case "tool":
      return {
        tools: r,
        tool_choice: { type: "tool", name: s.toolName }
      };
    default: {
      const o = i;
      throw new Error(`Unsupported tool choice type: ${o}`);
    }
  }
}
function _F(t = {}) {
  var e, n;
  const r = (n = Joe((e = t.baseURL) != null ? e : t.baseUrl)) != null ? n : "https://api.anthropic.com/v1", s = () => ({
    "anthropic-version": "2023-06-01",
    "x-api-key": Foe({
      apiKey: t.apiKey,
      environmentVariableName: "ANTHROPIC_API_KEY",
      description: "Anthropic"
    }),
    ...t.headers
  }), i = (a, l = {}) => new tae(a, l, {
    provider: "anthropic.messages",
    baseURL: r,
    headers: s,
    fetch: t.fetch
  }), o = function(a, l) {
    if (new.target)
      throw new Error(
        "The Anthropic model function cannot be called with the new keyword."
      );
    return i(a, l);
  };
  return o.languageModel = i, o.chat = i, o.messages = i, o;
}
_F();
class iae extends mn {
  name = "Anthropic";
  getApiKeyLink = "https://console.anthropic.com/settings/keys";
  config = {
    apiTokenKey: "ANTHROPIC_API_KEY"
  };
  staticModels = [
    {
      name: "claude-3-5-sonnet-latest",
      label: "Claude 3.5 Sonnet (new)",
      provider: "Anthropic",
      maxTokenAllowed: 8e3
    },
    {
      name: "claude-3-5-sonnet-20240620",
      label: "Claude 3.5 Sonnet (old)",
      provider: "Anthropic",
      maxTokenAllowed: 8e3
    },
    {
      name: "claude-3-5-haiku-latest",
      label: "Claude 3.5 Haiku (new)",
      provider: "Anthropic",
      maxTokenAllowed: 8e3
    },
    { name: "claude-3-opus-latest", label: "Claude 3 Opus", provider: "Anthropic", maxTokenAllowed: 8e3 },
    { name: "claude-3-sonnet-20240229", label: "Claude 3 Sonnet", provider: "Anthropic", maxTokenAllowed: 8e3 },
    { name: "claude-3-haiku-20240307", label: "Claude 3 Haiku", provider: "Anthropic", maxTokenAllowed: 8e3 }
  ];
  getModelInstance = (e) => {
    const { apiKeys: n, providerSettings: r, serverEnv: s, model: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: n,
      providerSettings: r,
      serverEnv: s,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "ANTHROPIC_API_KEY"
    });
    return _F({
      apiKey: o
    })(i);
  };
}
var vF = "vercel.ai.error", oae = Symbol.for(vF), wF, aae = class EF extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[wF] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return EF.hasMarker(e, vF);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
};
wF = oae;
var Hn = aae, SF = "AI_APICallError", xF = `vercel.ai.error.${SF}`, lae = Symbol.for(xF), TF, Vi = class extends Hn {
  constructor({
    message: e,
    url: n,
    requestBodyValues: r,
    statusCode: s,
    responseHeaders: i,
    responseBody: o,
    cause: a,
    isRetryable: l = s != null && (s === 408 || // request timeout
    s === 409 || // conflict
    s === 429 || // too many requests
    s >= 500),
    // server error
    data: c
  }) {
    super({ name: SF, message: e, cause: a }), this[TF] = !0, this.url = n, this.requestBodyValues = r, this.statusCode = s, this.responseHeaders = i, this.responseBody = o, this.isRetryable = l, this.data = c;
  }
  static isInstance(e) {
    return Hn.hasMarker(e, xF);
  }
};
TF = lae;
var CF = "AI_EmptyResponseBodyError", kF = `vercel.ai.error.${CF}`, cae = Symbol.for(kF), AF, uae = class extends Hn {
  // used in isInstance
  constructor({ message: e = "Empty response body" } = {}) {
    super({ name: CF, message: e }), this[AF] = !0;
  }
  static isInstance(e) {
    return Hn.hasMarker(e, kF);
  }
};
AF = cae;
function RF(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var IF = "AI_InvalidArgumentError", PF = `vercel.ai.error.${IF}`, hae = Symbol.for(PF), OF, dae = class extends Hn {
  constructor({
    message: e,
    cause: n,
    argument: r
  }) {
    super({ name: IF, message: e, cause: n }), this[OF] = !0, this.argument = r;
  }
  static isInstance(e) {
    return Hn.hasMarker(e, PF);
  }
};
OF = hae;
var DF = "AI_JSONParseError", NF = `vercel.ai.error.${DF}`, fae = Symbol.for(NF), LF, g0 = class extends Hn {
  constructor({ text: e, cause: n }) {
    super({
      name: DF,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${RF(n)}`,
      cause: n
    }), this[LF] = !0, this.text = e;
  }
  static isInstance(e) {
    return Hn.hasMarker(e, NF);
  }
};
LF = fae;
var MF = "AI_LoadAPIKeyError", BF = `vercel.ai.error.${MF}`, pae = Symbol.for(BF), FF, tm = class extends Hn {
  // used in isInstance
  constructor({ message: e }) {
    super({ name: MF, message: e }), this[FF] = !0;
  }
  static isInstance(e) {
    return Hn.hasMarker(e, BF);
  }
};
FF = pae;
var $F = "AI_TooManyEmbeddingValuesForCallError", UF = `vercel.ai.error.${$F}`, mae = Symbol.for(UF), jF, gae = class extends Hn {
  constructor(e) {
    super({
      name: $F,
      message: `Too many values for a single embedding call. The ${e.provider} model "${e.modelId}" can only embed up to ${e.maxEmbeddingsPerCall} values per call, but ${e.values.length} values were provided.`
    }), this[jF] = !0, this.provider = e.provider, this.modelId = e.modelId, this.maxEmbeddingsPerCall = e.maxEmbeddingsPerCall, this.values = e.values;
  }
  static isInstance(e) {
    return Hn.hasMarker(e, UF);
  }
};
jF = mae;
var HF = "AI_TypeValidationError", zF = `vercel.ai.error.${HF}`, yae = Symbol.for(zF), GF, bae = class pE extends Hn {
  constructor({ value: e, cause: n }) {
    super({
      name: HF,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${RF(n)}`,
      cause: n
    }), this[GF] = !0, this.value = e;
  }
  static isInstance(e) {
    return Hn.hasMarker(e, zF);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: e,
    cause: n
  }) {
    return pE.isInstance(n) && n.value === e ? n : new pE({ value: e, cause: n });
  }
};
GF = yae;
var y0 = bae, VF = "AI_UnsupportedFunctionalityError", WF = `vercel.ai.error.${VF}`, _ae = Symbol.for(WF), qF, Ic = class extends Hn {
  constructor({
    functionality: e,
    message: n = `'${e}' functionality not supported.`
  }) {
    super({ name: VF, message: n }), this[qF] = !0, this.functionality = e;
  }
  static isInstance(e) {
    return Hn.hasMarker(e, WF);
  }
};
qF = _ae;
function mE(...t) {
  return t.reduce(
    (e, n) => ({
      ...e,
      ...n ?? {}
    }),
    {}
  );
}
function bb(t) {
  const e = {};
  return t.headers.forEach((n, r) => {
    e[r] = n;
  }), e;
}
var vae = ({
  prefix: t,
  size: e = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const s = Cu(n, e);
  if (t == null)
    return s;
  if (n.includes(r))
    throw new dae({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return (i) => `${t}${r}${s(i)}`;
};
vae();
function wae(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n != null)
  );
}
function dv(t) {
  return t instanceof Error && (t.name === "AbortError" || t.name === "TimeoutError");
}
function Eae({
  apiKey: t,
  environmentVariableName: e,
  apiKeyParameterName: n = "apiKey",
  description: r
}) {
  if (typeof t == "string")
    return t;
  if (t != null)
    throw new tm({
      message: `${r} API key must be a string.`
    });
  if (typeof je > "u")
    throw new tm({
      message: `${r} API key is missing. Pass it using the '${n}' parameter. Environment variables is not supported in this environment.`
    });
  if (t = je.env[e], t == null)
    throw new tm({
      message: `${r} API key is missing. Pass it using the '${n}' parameter or the ${e} environment variable.`
    });
  if (typeof t != "string")
    throw new tm({
      message: `${r} API key must be a string. The value of the ${e} environment variable is not a string.`
    });
  return t;
}
var gE = Symbol.for("vercel.ai.validator");
function Sae(t) {
  return { [gE]: !0, validate: t };
}
function xae(t) {
  return typeof t == "object" && t !== null && gE in t && t[gE] === !0 && "validate" in t;
}
function Tae(t) {
  return xae(t) ? t : Cae(t);
}
function Cae(t) {
  return Sae((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function kae({
  value: t,
  schema: e
}) {
  const n = KF({ value: t, schema: e });
  if (!n.success)
    throw y0.wrap({ value: t, cause: n.error });
  return n.value;
}
function KF({
  value: t,
  schema: e
}) {
  const n = Tae(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: y0.wrap({ value: t, cause: r.error })
    };
  } catch (r) {
    return {
      success: !1,
      error: y0.wrap({ value: t, cause: r })
    };
  }
}
function Aae({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? n : kae({ value: n, schema: e });
  } catch (n) {
    throw g0.isInstance(n) || y0.isInstance(n) ? n : new g0({ text: t, cause: n });
  }
}
function YF({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    if (e == null)
      return { success: !0, value: n, rawValue: n };
    const r = KF({ value: n, schema: e });
    return r.success ? { ...r, rawValue: n } : r;
  } catch (n) {
    return {
      success: !1,
      error: g0.isInstance(n) ? n : new g0({ text: t, cause: n })
    };
  }
}
var Rae = () => globalThis.fetch, yE = async ({
  url: t,
  headers: e,
  body: n,
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}) => Iae({
  url: t,
  headers: {
    "Content-Type": "application/json",
    ...e
  },
  body: {
    content: JSON.stringify(n),
    values: n
  },
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}), Iae = async ({
  url: t,
  headers: e = {},
  body: n,
  successfulResponseHandler: r,
  failedResponseHandler: s,
  abortSignal: i,
  fetch: o = Rae()
}) => {
  try {
    const a = await o(t, {
      method: "POST",
      headers: wae(e),
      body: n.content,
      signal: i
    }), l = bb(a);
    if (!a.ok) {
      let c;
      try {
        c = await s({
          response: a,
          url: t,
          requestBodyValues: n.values
        });
      } catch (u) {
        throw dv(u) || Vi.isInstance(u) ? u : new Vi({
          message: "Failed to process error response",
          cause: u,
          statusCode: a.status,
          url: t,
          responseHeaders: l,
          requestBodyValues: n.values
        });
      }
      throw c.value;
    }
    try {
      return await r({
        response: a,
        url: t,
        requestBodyValues: n.values
      });
    } catch (c) {
      throw c instanceof Error && (dv(c) || Vi.isInstance(c)) ? c : new Vi({
        message: "Failed to process successful response",
        cause: c,
        statusCode: a.status,
        url: t,
        responseHeaders: l,
        requestBodyValues: n.values
      });
    }
  } catch (a) {
    if (dv(a))
      throw a;
    if (a instanceof TypeError && a.message === "fetch failed") {
      const l = a.cause;
      if (l != null)
        throw new Vi({
          message: `Cannot connect to API: ${l.message}`,
          cause: l,
          url: t,
          requestBodyValues: n.values,
          isRetryable: !0
          // retry when network error
        });
    }
    throw a;
  }
}, Pae = ({
  errorSchema: t,
  errorToMessage: e,
  isRetryable: n
}) => async ({ response: r, url: s, requestBodyValues: i }) => {
  const o = await r.text(), a = bb(r);
  if (o.trim() === "")
    return {
      responseHeaders: a,
      value: new Vi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  try {
    const l = Aae({
      text: o,
      schema: t
    });
    return {
      responseHeaders: a,
      value: new Vi({
        message: e(l),
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        data: l,
        isRetryable: n?.(r, l)
      })
    };
  } catch {
    return {
      responseHeaders: a,
      value: new Vi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  }
}, Oae = (t) => async ({ response: e }) => {
  const n = bb(e);
  if (e.body == null)
    throw new uae({});
  return {
    responseHeaders: n,
    value: e.body.pipeThrough(new TextDecoderStream()).pipeThrough(new IC()).pipeThrough(
      new TransformStream({
        transform({ data: r }, s) {
          r !== "[DONE]" && s.enqueue(
            YF({
              text: r,
              schema: t
            })
          );
        }
      })
    )
  };
}, ZF = (t) => async ({ response: e, url: n, requestBodyValues: r }) => {
  const s = await e.text(), i = YF({
    text: s,
    schema: t
  }), o = bb(e);
  if (!i.success)
    throw new Vi({
      message: "Invalid JSON response",
      cause: i.error,
      statusCode: e.status,
      responseHeaders: o,
      responseBody: s,
      url: n,
      requestBodyValues: r
    });
  return {
    responseHeaders: o,
    value: i.value,
    rawValue: i.rawValue
  };
};
function Dae(t) {
  return t?.replace(/\/$/, "");
}
var Nae = D.object({
  message: D.string()
}), bE = Pae({
  errorSchema: Nae,
  errorToMessage: (t) => t.message
});
function Lae(t) {
  const e = [];
  for (const { role: n, content: r } of t)
    switch (n) {
      case "system": {
        e.push({ role: "system", content: r });
        break;
      }
      case "user": {
        e.push({
          role: "user",
          content: r.map((s) => {
            switch (s.type) {
              case "text":
                return s.text;
              case "image":
                throw new Ic({
                  functionality: "image-part"
                });
            }
          }).join("")
        });
        break;
      }
      case "assistant": {
        let s = "";
        const i = [];
        for (const o of r)
          switch (o.type) {
            case "text": {
              s += o.text;
              break;
            }
            case "tool-call": {
              i.push({
                id: o.toolCallId,
                type: "function",
                function: {
                  name: o.toolName,
                  arguments: JSON.stringify(o.args)
                }
              });
              break;
            }
            default: {
              const a = o;
              throw new Error(`Unsupported part: ${a}`);
            }
          }
        e.push({
          role: "assistant",
          // note: this is a workaround for a Cohere API bug
          // that requires content to be provided
          // even if there are tool calls
          content: s !== "" ? s : "call tool",
          tool_calls: i.length > 0 ? i : void 0,
          tool_plan: void 0
        });
        break;
      }
      case "tool": {
        e.push(
          ...r.map((s) => ({
            role: "tool",
            content: JSON.stringify(s.result),
            tool_call_id: s.toolCallId
          }))
        );
        break;
      }
      default: {
        const s = n;
        throw new Error(`Unsupported role: ${s}`);
      }
    }
  return e;
}
function RI(t) {
  switch (t) {
    case "COMPLETE":
    case "STOP_SEQUENCE":
      return "stop";
    case "MAX_TOKENS":
      return "length";
    case "ERROR":
    case "ERROR_LIMIT":
      return "error";
    case "ERROR_TOXIC":
      return "content-filter";
    case "USER_CANCEL":
      return "other";
    default:
      return "unknown";
  }
}
function Mae(t) {
  var e;
  const n = (e = t.tools) != null && e.length ? t.tools : void 0, r = [];
  if (n == null)
    return { tools: void 0, tool_choice: void 0, toolWarnings: r };
  const s = [];
  for (const a of n)
    a.type === "provider-defined" ? r.push({ type: "unsupported-tool", tool: a }) : s.push({
      type: "function",
      function: {
        name: a.name,
        description: a.description,
        parameters: a.parameters
      }
    });
  const i = t.toolChoice;
  if (i == null)
    return { tools: s, tool_choice: void 0, toolWarnings: r };
  const o = i.type;
  switch (o) {
    case "auto":
      return { tools: s, tool_choice: o, toolWarnings: r };
    case "none":
      return { tools: void 0, tool_choice: "any", toolWarnings: r };
    case "required":
    case "tool":
      throw new Ic({
        functionality: `Unsupported tool choice type: ${o}`
      });
    default: {
      const a = o;
      throw new Ic({
        functionality: `Unsupported tool choice type: ${a}`
      });
    }
  }
}
var Bae = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.defaultObjectGenerationMode = void 0, this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    mode: t,
    prompt: e,
    maxTokens: n,
    temperature: r,
    topP: s,
    topK: i,
    frequencyPenalty: o,
    presencePenalty: a,
    stopSequences: l,
    responseFormat: c,
    seed: u
  }) {
    const h = t.type, d = Lae(e), f = {
      // model id:
      model: this.modelId,
      // model specific settings:
      // none
      // standardized settings:
      frequency_penalty: o,
      presence_penalty: a,
      max_tokens: n,
      temperature: r,
      p: s,
      k: i,
      seed: u,
      stop_sequences: l,
      // response format:
      response_format: c?.type === "json" ? { type: "json_object", schema: c.schema } : void 0,
      // messages:
      messages: d
    };
    switch (h) {
      case "regular": {
        const { tools: g, tool_choice: y, toolWarnings: p } = Mae(t);
        return {
          ...f,
          tools: g,
          warnings: p
        };
      }
      case "object-json":
        throw new Ic({
          functionality: "object-json mode"
        });
      case "object-tool":
        throw new Ic({
          functionality: "object-tool mode"
        });
      default: {
        const g = h;
        throw new Ic({
          functionality: `Unsupported mode: ${g}`
        });
      }
    }
  }
  concatenateMessageText(t) {
    return t.filter(
      (e) => "content" in e
    ).map((e) => e.content).join("");
  }
  /*
  Remove `additionalProperties` and `$schema` from the `parameters` object of each tool.
  Though these are part of JSON schema, Cohere chokes if we include them in the request.
  */
  // TODO(shaper): Look at defining a type to simplify the params here and a couple of other places.
  removeJsonSchemaExtras(t) {
    return t.map((e) => {
      if (e.type === "function" && e.function.parameters && typeof e.function.parameters == "object") {
        const { additionalProperties: n, $schema: r, ...s } = e.function.parameters;
        return {
          ...e,
          function: {
            ...e.function,
            parameters: s
          }
        };
      }
      return e;
    });
  }
  async doGenerate(t) {
    var e, n, r, s, i;
    const { warnings: o, ...a } = this.getArgs(t);
    a.tools = a.tools && this.removeJsonSchemaExtras(a.tools);
    const { responseHeaders: l, value: c } = await yE({
      url: `${this.config.baseURL}/chat`,
      headers: mE(this.config.headers(), t.headers),
      body: a,
      failedResponseHandler: bE,
      successfulResponseHandler: ZF(
        Fae
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: u, ...h } = a;
    let d = (r = (n = (e = c.message.content) == null ? void 0 : e[0]) == null ? void 0 : n.text) != null ? r : "";
    return d || (d = (s = c.message.tool_plan) != null ? s : ""), {
      text: d,
      toolCalls: c.message.tool_calls ? c.message.tool_calls.map((f) => ({
        toolCallId: f.id,
        toolName: f.function.name,
        args: f.function.arguments,
        toolCallType: "function"
      })) : [],
      finishReason: RI(c.finish_reason),
      usage: {
        promptTokens: c.usage.tokens.input_tokens,
        completionTokens: c.usage.tokens.output_tokens
      },
      rawCall: {
        rawPrompt: {
          messages: u
        },
        rawSettings: h
      },
      response: {
        id: (i = c.generation_id) != null ? i : void 0
      },
      rawResponse: { headers: l },
      warnings: o,
      request: { body: JSON.stringify(a) }
    };
  }
  async doStream(t) {
    const { warnings: e, ...n } = this.getArgs(t);
    n.tools = n.tools && this.removeJsonSchemaExtras(n.tools);
    const r = { ...n, stream: !0 }, { responseHeaders: s, value: i } = await yE({
      url: `${this.config.baseURL}/chat`,
      headers: mE(this.config.headers(), t.headers),
      body: r,
      failedResponseHandler: bE,
      successfulResponseHandler: Oae(
        $ae
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: o, ...a } = n;
    let l = "unknown", c = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    }, u = {
      toolCallId: "",
      toolName: "",
      argsTextDelta: ""
    };
    return {
      stream: i.pipeThrough(
        new TransformStream({
          transform(h, d) {
            var f;
            if (!h.success) {
              l = "error", d.enqueue({ type: "error", error: h.error });
              return;
            }
            const g = h.value;
            switch (g.type) {
              case "content-delta": {
                d.enqueue({
                  type: "text-delta",
                  textDelta: g.delta.message.content.text
                });
                return;
              }
              case "tool-plan-delta": {
                d.enqueue({
                  type: "text-delta",
                  textDelta: g.delta.message.tool_plan
                });
                return;
              }
              case "tool-call-start": {
                u = {
                  toolCallId: g.delta.message.tool_calls.id,
                  toolName: g.delta.message.tool_calls.function.name,
                  argsTextDelta: g.delta.message.tool_calls.function.arguments
                }, d.enqueue({
                  type: "tool-call-delta",
                  toolCallId: u.toolCallId,
                  toolName: u.toolName,
                  toolCallType: "function",
                  argsTextDelta: u.argsTextDelta
                });
                return;
              }
              case "tool-call-delta": {
                u.argsTextDelta += g.delta.message.tool_calls.function.arguments, d.enqueue({
                  type: "tool-call-delta",
                  toolCallId: u.toolCallId,
                  toolName: u.toolName,
                  toolCallType: "function",
                  argsTextDelta: g.delta.message.tool_calls.function.arguments
                });
                return;
              }
              case "tool-call-end": {
                d.enqueue({
                  type: "tool-call",
                  toolCallId: u.toolCallId,
                  toolName: u.toolName,
                  toolCallType: "function",
                  args: JSON.stringify(
                    JSON.parse(u.argsTextDelta)
                  )
                }), u = {
                  toolCallId: "",
                  toolName: "",
                  argsTextDelta: ""
                };
                return;
              }
              case "message-start": {
                d.enqueue({
                  type: "response-metadata",
                  id: (f = g.id) != null ? f : void 0
                });
                return;
              }
              case "message-end": {
                l = RI(g.delta.finish_reason);
                const p = g.delta.usage.tokens;
                c = {
                  promptTokens: p.input_tokens,
                  completionTokens: p.output_tokens
                };
              }
              default:
                return;
            }
          },
          flush(h) {
            h.enqueue({
              type: "finish",
              finishReason: l,
              usage: c
            });
          }
        })
      ),
      rawCall: {
        rawPrompt: {
          messages: o
        },
        rawSettings: a
      },
      rawResponse: { headers: s },
      warnings: e,
      request: { body: JSON.stringify(r) }
    };
  }
}, Fae = D.object({
  generation_id: D.string().nullish(),
  message: D.object({
    role: D.string(),
    content: D.array(
      D.object({
        type: D.string(),
        text: D.string()
      })
    ).nullish(),
    tool_plan: D.string().nullish(),
    tool_calls: D.array(
      D.object({
        id: D.string(),
        type: D.literal("function"),
        function: D.object({
          name: D.string(),
          arguments: D.string()
        })
      })
    ).nullish()
  }),
  finish_reason: D.string(),
  usage: D.object({
    billed_units: D.object({
      input_tokens: D.number(),
      output_tokens: D.number()
    }),
    tokens: D.object({
      input_tokens: D.number(),
      output_tokens: D.number()
    })
  })
}), $ae = D.discriminatedUnion("type", [
  D.object({
    type: D.literal("citation-start")
  }),
  D.object({
    type: D.literal("citation-end")
  }),
  D.object({
    type: D.literal("content-start")
  }),
  D.object({
    type: D.literal("content-delta"),
    delta: D.object({
      message: D.object({
        content: D.object({
          text: D.string()
        })
      })
    })
  }),
  D.object({
    type: D.literal("content-end")
  }),
  D.object({
    type: D.literal("message-start"),
    id: D.string().nullish()
  }),
  D.object({
    type: D.literal("message-end"),
    delta: D.object({
      finish_reason: D.string(),
      usage: D.object({
        tokens: D.object({
          input_tokens: D.number(),
          output_tokens: D.number()
        })
      })
    })
  }),
  // https://docs.cohere.com/v2/docs/streaming#tool-use-stream-events-for-tool-calling
  D.object({
    type: D.literal("tool-plan-delta"),
    delta: D.object({
      message: D.object({
        tool_plan: D.string()
      })
    })
  }),
  D.object({
    type: D.literal("tool-call-start"),
    delta: D.object({
      message: D.object({
        tool_calls: D.object({
          id: D.string(),
          type: D.literal("function"),
          function: D.object({
            name: D.string(),
            arguments: D.string()
          })
        })
      })
    })
  }),
  // A single tool call's `arguments` stream in chunks and must be accumulated
  // in a string and so the full tool object info can only be parsed once we see
  // `tool-call-end`.
  D.object({
    type: D.literal("tool-call-delta"),
    delta: D.object({
      message: D.object({
        tool_calls: D.object({
          function: D.object({
            arguments: D.string()
          })
        })
      })
    })
  }),
  D.object({
    type: D.literal("tool-call-end")
  })
]), Uae = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.maxEmbeddingsPerCall = 96, this.supportsParallelCalls = !0, this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values: t,
    headers: e,
    abortSignal: n
  }) {
    var r;
    if (t.length > this.maxEmbeddingsPerCall)
      throw new gae({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values: t
      });
    const { responseHeaders: s, value: i } = await yE({
      url: `${this.config.baseURL}/embed`,
      headers: mE(this.config.headers(), e),
      body: {
        model: this.modelId,
        // The AI SDK only supports 'float' embeddings which are also the only ones
        // the Cohere API docs state are supported for all models.
        // https://docs.cohere.com/v2/reference/embed#request.body.embedding_types
        embedding_types: ["float"],
        texts: t,
        input_type: (r = this.settings.inputType) != null ? r : "search_query",
        truncate: this.settings.truncate
      },
      failedResponseHandler: bE,
      successfulResponseHandler: ZF(
        jae
      ),
      abortSignal: n,
      fetch: this.config.fetch
    });
    return {
      embeddings: i.embeddings.float,
      usage: { tokens: i.meta.billed_units.input_tokens },
      rawResponse: { headers: s }
    };
  }
}, jae = D.object({
  embeddings: D.object({
    float: D.array(D.array(D.number()))
  }),
  meta: D.object({
    billed_units: D.object({
      input_tokens: D.number()
    })
  })
});
function JF(t = {}) {
  var e;
  const n = (e = Dae(t.baseURL)) != null ? e : "https://api.cohere.com/v2", r = () => ({
    Authorization: `Bearer ${Eae({
      apiKey: t.apiKey,
      environmentVariableName: "COHERE_API_KEY",
      description: "Cohere"
    })}`,
    ...t.headers
  }), s = (a, l = {}) => new Bae(a, l, {
    provider: "cohere.chat",
    baseURL: n,
    headers: r,
    fetch: t.fetch
  }), i = (a, l = {}) => new Uae(a, l, {
    provider: "cohere.textEmbedding",
    baseURL: n,
    headers: r,
    fetch: t.fetch
  }), o = function(a, l) {
    if (new.target)
      throw new Error(
        "The Cohere model function cannot be called with the new keyword."
      );
    return s(a, l);
  };
  return o.languageModel = s, o.embedding = i, o.textEmbeddingModel = i, o;
}
JF();
class Hae extends mn {
  name = "Cohere";
  getApiKeyLink = "https://dashboard.cohere.com/api-keys";
  config = {
    apiTokenKey: "COHERE_API_KEY"
  };
  staticModels = [
    { name: "command-r-plus-08-2024", label: "Command R plus Latest", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "command-r-08-2024", label: "Command R Latest", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "command-r-plus", label: "Command R plus", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "command-r", label: "Command R", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "command", label: "Command", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "command-nightly", label: "Command Nightly", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "command-light", label: "Command Light", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "command-light-nightly", label: "Command Light Nightly", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "c4ai-aya-expanse-8b", label: "c4AI Aya Expanse 8b", provider: "Cohere", maxTokenAllowed: 4096 },
    { name: "c4ai-aya-expanse-32b", label: "c4AI Aya Expanse 32b", provider: "Cohere", maxTokenAllowed: 4096 }
  ];
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "COHERE_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return JF({
      apiKey: o
    })(n);
  }
}
var XF = "vercel.ai.error", zae = Symbol.for(XF), QF, Gae = class e8 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[QF] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return e8.hasMarker(e, XF);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
};
QF = zae;
var _r = Gae, t8 = "AI_APICallError", n8 = `vercel.ai.error.${t8}`, Vae = Symbol.for(n8), r8, Wi = class extends _r {
  constructor({
    message: e,
    url: n,
    requestBodyValues: r,
    statusCode: s,
    responseHeaders: i,
    responseBody: o,
    cause: a,
    isRetryable: l = s != null && (s === 408 || // request timeout
    s === 409 || // conflict
    s === 429 || // too many requests
    s >= 500),
    // server error
    data: c
  }) {
    super({ name: t8, message: e, cause: a }), this[r8] = !0, this.url = n, this.requestBodyValues = r, this.statusCode = s, this.responseHeaders = i, this.responseBody = o, this.isRetryable = l, this.data = c;
  }
  static isInstance(e) {
    return _r.hasMarker(e, n8);
  }
};
r8 = Vae;
var s8 = "AI_EmptyResponseBodyError", i8 = `vercel.ai.error.${s8}`, Wae = Symbol.for(i8), o8, qae = class extends _r {
  // used in isInstance
  constructor({ message: e = "Empty response body" } = {}) {
    super({ name: s8, message: e }), this[o8] = !0;
  }
  static isInstance(e) {
    return _r.hasMarker(e, i8);
  }
};
o8 = Wae;
function a8(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var l8 = "AI_InvalidArgumentError", c8 = `vercel.ai.error.${l8}`, Kae = Symbol.for(c8), u8, Yae = class extends _r {
  constructor({
    message: e,
    cause: n,
    argument: r
  }) {
    super({ name: l8, message: e, cause: n }), this[u8] = !0, this.argument = r;
  }
  static isInstance(e) {
    return _r.hasMarker(e, c8);
  }
};
u8 = Kae;
var h8 = "AI_InvalidResponseDataError", d8 = `vercel.ai.error.${h8}`, Zae = Symbol.for(d8), f8, fv = class extends _r {
  constructor({
    data: e,
    message: n = `Invalid response data: ${JSON.stringify(e)}.`
  }) {
    super({ name: h8, message: n }), this[f8] = !0, this.data = e;
  }
  static isInstance(e) {
    return _r.hasMarker(e, d8);
  }
};
f8 = Zae;
var p8 = "AI_JSONParseError", m8 = `vercel.ai.error.${p8}`, Jae = Symbol.for(m8), g8, b0 = class extends _r {
  constructor({ text: e, cause: n }) {
    super({
      name: p8,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${a8(n)}`,
      cause: n
    }), this[g8] = !0, this.text = e;
  }
  static isInstance(e) {
    return _r.hasMarker(e, m8);
  }
};
g8 = Jae;
var y8 = "AI_TypeValidationError", b8 = `vercel.ai.error.${y8}`, Xae = Symbol.for(b8), _8, Qae = class _E extends _r {
  constructor({ value: e, cause: n }) {
    super({
      name: y8,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${a8(n)}`,
      cause: n
    }), this[_8] = !0, this.value = e;
  }
  static isInstance(e) {
    return _r.hasMarker(e, b8);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: e,
    cause: n
  }) {
    return _E.isInstance(n) && n.value === e ? n : new _E({ value: e, cause: n });
  }
};
_8 = Xae;
var _0 = Qae, v8 = "AI_UnsupportedFunctionalityError", w8 = `vercel.ai.error.${v8}`, ele = Symbol.for(w8), E8, S8 = class extends _r {
  constructor({
    functionality: e,
    message: n = `'${e}' functionality not supported.`
  }) {
    super({ name: v8, message: n }), this[E8] = !0, this.functionality = e;
  }
  static isInstance(e) {
    return _r.hasMarker(e, w8);
  }
};
E8 = ele;
function II(...t) {
  return t.reduce(
    (e, n) => ({
      ...e,
      ...n ?? {}
    }),
    {}
  );
}
function _b(t) {
  const e = {};
  return t.headers.forEach((n, r) => {
    e[r] = n;
  }), e;
}
var tle = ({
  prefix: t,
  size: e = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const s = Cu(n, e);
  if (t == null)
    return s;
  if (n.includes(r))
    throw new Yae({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return (i) => `${t}${r}${s(i)}`;
}, pv = tle();
function nle(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n != null)
  );
}
function mv(t) {
  return t instanceof Error && (t.name === "AbortError" || t.name === "TimeoutError");
}
var vE = Symbol.for("vercel.ai.validator");
function rle(t) {
  return { [vE]: !0, validate: t };
}
function sle(t) {
  return typeof t == "object" && t !== null && vE in t && t[vE] === !0 && "validate" in t;
}
function ile(t) {
  return sle(t) ? t : ole(t);
}
function ole(t) {
  return rle((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function ale({
  value: t,
  schema: e
}) {
  const n = x8({ value: t, schema: e });
  if (!n.success)
    throw _0.wrap({ value: t, cause: n.error });
  return n.value;
}
function x8({
  value: t,
  schema: e
}) {
  const n = ile(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: _0.wrap({ value: t, cause: r.error })
    };
  } catch (r) {
    return {
      success: !1,
      error: _0.wrap({ value: t, cause: r })
    };
  }
}
function lle({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? n : ale({ value: n, schema: e });
  } catch (n) {
    throw b0.isInstance(n) || _0.isInstance(n) ? n : new b0({ text: t, cause: n });
  }
}
function T8({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    if (e == null)
      return { success: !0, value: n, rawValue: n };
    const r = x8({ value: n, schema: e });
    return r.success ? { ...r, rawValue: n } : r;
  } catch (n) {
    return {
      success: !1,
      error: b0.isInstance(n) ? n : new b0({ text: t, cause: n })
    };
  }
}
function PI(t) {
  try {
    return ln.parse(t), !0;
  } catch {
    return !1;
  }
}
var cle = () => globalThis.fetch, OI = async ({
  url: t,
  headers: e,
  body: n,
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}) => ule({
  url: t,
  headers: {
    "Content-Type": "application/json",
    ...e
  },
  body: {
    content: JSON.stringify(n),
    values: n
  },
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}), ule = async ({
  url: t,
  headers: e = {},
  body: n,
  successfulResponseHandler: r,
  failedResponseHandler: s,
  abortSignal: i,
  fetch: o = cle()
}) => {
  try {
    const a = await o(t, {
      method: "POST",
      headers: nle(e),
      body: n.content,
      signal: i
    }), l = _b(a);
    if (!a.ok) {
      let c;
      try {
        c = await s({
          response: a,
          url: t,
          requestBodyValues: n.values
        });
      } catch (u) {
        throw mv(u) || Wi.isInstance(u) ? u : new Wi({
          message: "Failed to process error response",
          cause: u,
          statusCode: a.status,
          url: t,
          responseHeaders: l,
          requestBodyValues: n.values
        });
      }
      throw c.value;
    }
    try {
      return await r({
        response: a,
        url: t,
        requestBodyValues: n.values
      });
    } catch (c) {
      throw c instanceof Error && (mv(c) || Wi.isInstance(c)) ? c : new Wi({
        message: "Failed to process successful response",
        cause: c,
        statusCode: a.status,
        url: t,
        responseHeaders: l,
        requestBodyValues: n.values
      });
    }
  } catch (a) {
    if (mv(a))
      throw a;
    if (a instanceof TypeError && a.message === "fetch failed") {
      const l = a.cause;
      if (l != null)
        throw new Wi({
          message: `Cannot connect to API: ${l.message}`,
          cause: l,
          url: t,
          requestBodyValues: n.values,
          isRetryable: !0
          // retry when network error
        });
    }
    throw a;
  }
}, hle = ({
  errorSchema: t,
  errorToMessage: e,
  isRetryable: n
}) => async ({ response: r, url: s, requestBodyValues: i }) => {
  const o = await r.text(), a = _b(r);
  if (o.trim() === "")
    return {
      responseHeaders: a,
      value: new Wi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  try {
    const l = lle({
      text: o,
      schema: t
    });
    return {
      responseHeaders: a,
      value: new Wi({
        message: e(l),
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        data: l,
        isRetryable: n?.(r, l)
      })
    };
  } catch {
    return {
      responseHeaders: a,
      value: new Wi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  }
}, dle = (t) => async ({ response: e }) => {
  const n = _b(e);
  if (e.body == null)
    throw new qae({});
  return {
    responseHeaders: n,
    value: e.body.pipeThrough(new TextDecoderStream()).pipeThrough(new IC()).pipeThrough(
      new TransformStream({
        transform({ data: r }, s) {
          r !== "[DONE]" && s.enqueue(
            T8({
              text: r,
              schema: t
            })
          );
        }
      })
    )
  };
}, fle = (t) => async ({ response: e, url: n, requestBodyValues: r }) => {
  const s = await e.text(), i = T8({
    text: s,
    schema: t
  }), o = _b(e);
  if (!i.success)
    throw new Wi({
      message: "Invalid JSON response",
      cause: i.error,
      statusCode: e.status,
      responseHeaders: o,
      responseBody: s,
      url: n,
      requestBodyValues: r
    });
  return {
    responseHeaders: o,
    value: i.value,
    rawValue: i.rawValue
  };
}, { btoa: ple } = globalThis;
function mle(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCodePoint(t[n]);
  return ple(e);
}
function Xu(t) {
  var e, n;
  return (n = (e = t?.providerMetadata) == null ? void 0 : e.openaiCompatible) != null ? n : {};
}
function gle(t) {
  const e = [];
  for (const { role: n, content: r, ...s } of t) {
    const i = Xu({ ...s });
    switch (n) {
      case "system": {
        e.push({ role: "system", content: r, ...i });
        break;
      }
      case "user": {
        if (r.length === 1 && r[0].type === "text") {
          e.push({
            role: "user",
            content: r[0].text,
            ...Xu(r[0])
          });
          break;
        }
        e.push({
          role: "user",
          content: r.map((o) => {
            var a;
            const l = Xu(o);
            switch (o.type) {
              case "text":
                return { type: "text", text: o.text, ...l };
              case "image":
                return {
                  type: "image_url",
                  image_url: {
                    url: o.image instanceof URL ? o.image.toString() : `data:${(a = o.mimeType) != null ? a : "image/jpeg"};base64,${mle(o.image)}`
                  },
                  ...l
                };
              case "file":
                throw new S8({
                  functionality: "File content parts in user messages"
                });
            }
          }),
          ...i
        });
        break;
      }
      case "assistant": {
        let o = "";
        const a = [];
        for (const l of r) {
          const c = Xu(l);
          switch (l.type) {
            case "text": {
              o += l.text;
              break;
            }
            case "tool-call": {
              a.push({
                id: l.toolCallId,
                type: "function",
                function: {
                  name: l.toolName,
                  arguments: JSON.stringify(l.args)
                },
                ...c
              });
              break;
            }
            default: {
              const u = l;
              throw new Error(`Unsupported part: ${u}`);
            }
          }
        }
        e.push({
          role: "assistant",
          content: o,
          tool_calls: a.length > 0 ? a : void 0,
          ...i
        });
        break;
      }
      case "tool": {
        for (const o of r) {
          const a = Xu(o);
          e.push({
            role: "tool",
            tool_call_id: o.toolCallId,
            content: JSON.stringify(o.result),
            ...a
          });
        }
        break;
      }
      default: {
        const o = n;
        throw new Error(`Unsupported role: ${o}`);
      }
    }
  }
  return e;
}
function DI({
  id: t,
  model: e,
  created: n
}) {
  return {
    id: t ?? void 0,
    modelId: e ?? void 0,
    timestamp: n != null ? new Date(n * 1e3) : void 0
  };
}
function NI(t) {
  switch (t) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var yle = D.object({
  error: D.object({
    message: D.string(),
    // The additional information below is handled loosely to support
    // OpenAI-compatible providers that have slightly different error
    // responses:
    type: D.string().nullish(),
    param: D.any().nullish(),
    code: D.union([D.string(), D.number()]).nullish()
  })
}), ble = {
  errorSchema: yle
};
function _le({
  mode: t,
  structuredOutputs: e
}) {
  var n;
  const r = (n = t.tools) != null && n.length ? t.tools : void 0, s = [];
  if (r == null)
    return { tools: void 0, tool_choice: void 0, toolWarnings: s };
  const i = t.toolChoice, o = [];
  for (const l of r)
    l.type === "provider-defined" ? s.push({ type: "unsupported-tool", tool: l }) : o.push({
      type: "function",
      function: {
        name: l.name,
        description: l.description,
        parameters: l.parameters
      }
    });
  if (i == null)
    return { tools: o, tool_choice: void 0, toolWarnings: s };
  const a = i.type;
  switch (a) {
    case "auto":
    case "none":
    case "required":
      return { tools: o, tool_choice: a, toolWarnings: s };
    case "tool":
      return {
        tools: o,
        tool_choice: {
          type: "function",
          function: {
            name: i.toolName
          }
        },
        toolWarnings: s
      };
    default: {
      const l = a;
      throw new S8({
        functionality: `Unsupported tool choice type: ${l}`
      });
    }
  }
}
var vle = class {
  // type inferred via constructor
  constructor(t, e, n) {
    this.specificationVersion = "v1";
    var r, s;
    this.modelId = t, this.settings = e, this.config = n;
    const i = (r = n.errorStructure) != null ? r : ble;
    this.chunkSchema = Ele(
      i.errorSchema
    ), this.failedResponseHandler = hle(i), this.supportsStructuredOutputs = (s = n.supportsStructuredOutputs) != null ? s : !1;
  }
  get defaultObjectGenerationMode() {
    return this.config.defaultObjectGenerationMode;
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  getArgs({
    mode: t,
    prompt: e,
    maxTokens: n,
    temperature: r,
    topP: s,
    topK: i,
    frequencyPenalty: o,
    presencePenalty: a,
    providerMetadata: l,
    stopSequences: c,
    responseFormat: u,
    seed: h
  }) {
    var d, f;
    const g = t.type, y = [];
    i != null && y.push({
      type: "unsupported-setting",
      setting: "topK"
    }), u?.type === "json" && u.schema != null && !this.supportsStructuredOutputs && y.push({
      type: "unsupported-setting",
      setting: "responseFormat",
      details: "JSON response format schema is only supported with structuredOutputs"
    });
    const p = {
      // model id:
      model: this.modelId,
      // model specific settings:
      user: this.settings.user,
      // standardized settings:
      max_tokens: n,
      temperature: r,
      top_p: s,
      frequency_penalty: o,
      presence_penalty: a,
      response_format: u?.type === "json" ? this.supportsStructuredOutputs === !0 && u.schema != null ? {
        type: "json_schema",
        json_schema: {
          schema: u.schema,
          name: (d = u.name) != null ? d : "response",
          description: u.description
        }
      } : { type: "json_object" } : void 0,
      stop: c,
      seed: h,
      ...l?.[this.providerOptionsName],
      // messages:
      messages: gle(e)
    };
    switch (g) {
      case "regular": {
        const { tools: m, tool_choice: b, toolWarnings: _ } = _le({
          mode: t,
          structuredOutputs: this.supportsStructuredOutputs
        });
        return {
          args: { ...p, tools: m, tool_choice: b },
          warnings: [...y, ..._]
        };
      }
      case "object-json":
        return {
          args: {
            ...p,
            response_format: this.supportsStructuredOutputs === !0 && t.schema != null ? {
              type: "json_schema",
              json_schema: {
                schema: t.schema,
                name: (f = t.name) != null ? f : "response",
                description: t.description
              }
            } : { type: "json_object" }
          },
          warnings: y
        };
      case "object-tool":
        return {
          args: {
            ...p,
            tool_choice: {
              type: "function",
              function: { name: t.tool.name }
            },
            tools: [
              {
                type: "function",
                function: {
                  name: t.tool.name,
                  description: t.tool.description,
                  parameters: t.tool.parameters
                }
              }
            ]
          },
          warnings: y
        };
      default: {
        const m = g;
        throw new Error(`Unsupported type: ${m}`);
      }
    }
  }
  async doGenerate(t) {
    var e, n, r, s, i, o, a, l, c;
    const { args: u, warnings: h } = this.getArgs({ ...t }), d = JSON.stringify(u), {
      responseHeaders: f,
      value: g,
      rawValue: y
    } = await OI({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: II(this.config.headers(), t.headers),
      body: u,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: fle(
        wle
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: p, ...m } = u, b = g.choices[0], _ = (n = (e = this.config.metadataExtractor) == null ? void 0 : e.extractMetadata) == null ? void 0 : n.call(e, {
      parsedBody: y
    });
    return {
      text: (r = b.message.content) != null ? r : void 0,
      reasoning: (s = b.message.reasoning_content) != null ? s : void 0,
      toolCalls: (i = b.message.tool_calls) == null ? void 0 : i.map((v) => {
        var w;
        return {
          toolCallType: "function",
          toolCallId: (w = v.id) != null ? w : pv(),
          toolName: v.function.name,
          args: v.function.arguments
        };
      }),
      finishReason: NI(b.finish_reason),
      usage: {
        promptTokens: (a = (o = g.usage) == null ? void 0 : o.prompt_tokens) != null ? a : NaN,
        completionTokens: (c = (l = g.usage) == null ? void 0 : l.completion_tokens) != null ? c : NaN
      },
      ..._ && { providerMetadata: _ },
      rawCall: { rawPrompt: p, rawSettings: m },
      rawResponse: { headers: f },
      response: DI(g),
      warnings: h,
      request: { body: d }
    };
  }
  async doStream(t) {
    var e;
    if (this.settings.simulateStreaming) {
      const g = await this.doGenerate(t);
      return {
        stream: new ReadableStream({
          start(p) {
            if (p.enqueue({ type: "response-metadata", ...g.response }), g.reasoning && p.enqueue({
              type: "reasoning",
              textDelta: g.reasoning
            }), g.text && p.enqueue({
              type: "text-delta",
              textDelta: g.text
            }), g.toolCalls)
              for (const m of g.toolCalls)
                p.enqueue({
                  type: "tool-call",
                  ...m
                });
            p.enqueue({
              type: "finish",
              finishReason: g.finishReason,
              usage: g.usage,
              logprobs: g.logprobs,
              providerMetadata: g.providerMetadata
            }), p.close();
          }
        }),
        rawCall: g.rawCall,
        rawResponse: g.rawResponse,
        warnings: g.warnings
      };
    }
    const { args: n, warnings: r } = this.getArgs({ ...t }), s = JSON.stringify({ ...n, stream: !0 }), i = (e = this.config.metadataExtractor) == null ? void 0 : e.createStreamExtractor(), { responseHeaders: o, value: a } = await OI({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: II(this.config.headers(), t.headers),
      body: {
        ...n,
        stream: !0
      },
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: dle(
        this.chunkSchema
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: l, ...c } = n, u = [];
    let h = "unknown", d = {
      promptTokens: void 0,
      completionTokens: void 0
    }, f = !0;
    return {
      stream: a.pipeThrough(
        new TransformStream({
          // TODO we lost type safety on Chunk, most likely due to the error schema. MUST FIX
          transform(g, y) {
            var p, m, b, _, v, w, E, x, S, T, R, F, P, M;
            if (!g.success) {
              h = "error", y.enqueue({ type: "error", error: g.error });
              return;
            }
            const A = g.value;
            if (i?.processChunk(g.rawValue), "error" in A) {
              h = "error", y.enqueue({ type: "error", error: A.error.message });
              return;
            }
            f && (f = !1, y.enqueue({
              type: "response-metadata",
              ...DI(A)
            })), A.usage != null && (d = {
              promptTokens: (p = A.usage.prompt_tokens) != null ? p : void 0,
              completionTokens: (m = A.usage.completion_tokens) != null ? m : void 0
            });
            const V = A.choices[0];
            if (V?.finish_reason != null && (h = NI(
              V.finish_reason
            )), V?.delta == null)
              return;
            const ee = V.delta;
            if (ee.reasoning_content != null && y.enqueue({
              type: "reasoning",
              textDelta: ee.reasoning_content
            }), ee.content != null && y.enqueue({
              type: "text-delta",
              textDelta: ee.content
            }), ee.tool_calls != null)
              for (const K of ee.tool_calls) {
                const te = K.index;
                if (u[te] == null) {
                  if (K.type !== "function")
                    throw new fv({
                      data: K,
                      message: "Expected 'function' type."
                    });
                  if (K.id == null)
                    throw new fv({
                      data: K,
                      message: "Expected 'id' to be a string."
                    });
                  if (((b = K.function) == null ? void 0 : b.name) == null)
                    throw new fv({
                      data: K,
                      message: "Expected 'function.name' to be a string."
                    });
                  u[te] = {
                    id: K.id,
                    type: "function",
                    function: {
                      name: K.function.name,
                      arguments: (_ = K.function.arguments) != null ? _ : ""
                    },
                    hasFinished: !1
                  };
                  const L = u[te];
                  ((v = L.function) == null ? void 0 : v.name) != null && ((w = L.function) == null ? void 0 : w.arguments) != null && (L.function.arguments.length > 0 && y.enqueue({
                    type: "tool-call-delta",
                    toolCallType: "function",
                    toolCallId: L.id,
                    toolName: L.function.name,
                    argsTextDelta: L.function.arguments
                  }), PI(L.function.arguments) && (y.enqueue({
                    type: "tool-call",
                    toolCallType: "function",
                    toolCallId: (E = L.id) != null ? E : pv(),
                    toolName: L.function.name,
                    args: L.function.arguments
                  }), L.hasFinished = !0));
                  continue;
                }
                const N = u[te];
                N.hasFinished || (((x = K.function) == null ? void 0 : x.arguments) != null && (N.function.arguments += (T = (S = K.function) == null ? void 0 : S.arguments) != null ? T : ""), y.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: N.id,
                  toolName: N.function.name,
                  argsTextDelta: (R = K.function.arguments) != null ? R : ""
                }), ((F = N.function) == null ? void 0 : F.name) != null && ((P = N.function) == null ? void 0 : P.arguments) != null && PI(N.function.arguments) && (y.enqueue({
                  type: "tool-call",
                  toolCallType: "function",
                  toolCallId: (M = N.id) != null ? M : pv(),
                  toolName: N.function.name,
                  args: N.function.arguments
                }), N.hasFinished = !0));
              }
          },
          flush(g) {
            var y, p;
            const m = i?.buildMetadata();
            g.enqueue({
              type: "finish",
              finishReason: h,
              usage: {
                promptTokens: (y = d.promptTokens) != null ? y : NaN,
                completionTokens: (p = d.completionTokens) != null ? p : NaN
              },
              ...m && { providerMetadata: m }
            });
          }
        })
      ),
      rawCall: { rawPrompt: l, rawSettings: c },
      rawResponse: { headers: o },
      warnings: r,
      request: { body: s }
    };
  }
}, wle = D.object({
  id: D.string().nullish(),
  created: D.number().nullish(),
  model: D.string().nullish(),
  choices: D.array(
    D.object({
      message: D.object({
        role: D.literal("assistant").nullish(),
        content: D.string().nullish(),
        reasoning_content: D.string().nullish(),
        tool_calls: D.array(
          D.object({
            id: D.string().nullish(),
            type: D.literal("function"),
            function: D.object({
              name: D.string(),
              arguments: D.string()
            })
          })
        ).nullish()
      }),
      finish_reason: D.string().nullish()
    })
  ),
  usage: D.object({
    prompt_tokens: D.number().nullish(),
    completion_tokens: D.number().nullish()
  }).nullish()
}), Ele = (t) => D.union([
  D.object({
    id: D.string().nullish(),
    created: D.number().nullish(),
    model: D.string().nullish(),
    choices: D.array(
      D.object({
        delta: D.object({
          role: D.enum(["assistant"]).nullish(),
          content: D.string().nullish(),
          reasoning_content: D.string().nullish(),
          tool_calls: D.array(
            D.object({
              index: D.number(),
              id: D.string().nullish(),
              type: D.literal("function").optional(),
              function: D.object({
                name: D.string().nullish(),
                arguments: D.string().nullish()
              })
            })
          ).nullish()
        }).nullish(),
        finish_reason: D.string().nullish()
      })
    ),
    usage: D.object({
      prompt_tokens: D.number().nullish(),
      completion_tokens: D.number().nullish()
    }).nullish()
  }),
  t
]);
D.object({
  id: D.string().nullish(),
  created: D.number().nullish(),
  model: D.string().nullish(),
  choices: D.array(
    D.object({
      text: D.string(),
      finish_reason: D.string()
    })
  ),
  usage: D.object({
    prompt_tokens: D.number(),
    completion_tokens: D.number()
  }).nullish()
});
D.object({
  data: D.array(D.object({ embedding: D.array(D.number()) })),
  usage: D.object({ prompt_tokens: D.number() }).nullish()
});
var C8 = "vercel.ai.error", Sle = Symbol.for(C8), k8, xle = class A8 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[k8] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return A8.hasMarker(e, C8);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
};
k8 = Sle;
var na = xle;
function Tle(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var R8 = "AI_InvalidArgumentError", I8 = `vercel.ai.error.${R8}`, Cle = Symbol.for(I8), P8, kle = class extends na {
  constructor({
    message: e,
    cause: n,
    argument: r
  }) {
    super({ name: R8, message: e, cause: n }), this[P8] = !0, this.argument = r;
  }
  static isInstance(e) {
    return na.hasMarker(e, I8);
  }
};
P8 = Cle;
var O8 = "AI_LoadAPIKeyError", D8 = `vercel.ai.error.${O8}`, Ale = Symbol.for(D8), N8, nm = class extends na {
  // used in isInstance
  constructor({ message: e }) {
    super({ name: O8, message: e }), this[N8] = !0;
  }
  static isInstance(e) {
    return na.hasMarker(e, D8);
  }
};
N8 = Ale;
var L8 = "AI_NoSuchModelError", M8 = `vercel.ai.error.${L8}`, Rle = Symbol.for(M8), B8, Ile = class extends na {
  constructor({
    errorName: t = L8,
    modelId: e,
    modelType: n,
    message: r = `No such ${n}: ${e}`
  }) {
    super({ name: t, message: r }), this[B8] = !0, this.modelId = e, this.modelType = n;
  }
  static isInstance(t) {
    return na.hasMarker(t, M8);
  }
};
B8 = Rle;
var F8 = "AI_TypeValidationError", $8 = `vercel.ai.error.${F8}`, Ple = Symbol.for($8), U8, Ole = class wE extends na {
  constructor({ value: e, cause: n }) {
    super({
      name: F8,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${Tle(n)}`,
      cause: n
    }), this[U8] = !0, this.value = e;
  }
  static isInstance(e) {
    return na.hasMarker(e, $8);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: e,
    cause: n
  }) {
    return wE.isInstance(n) && n.value === e ? n : new wE({ value: e, cause: n });
  }
};
U8 = Ple;
var LI = Ole, Dle = ({
  prefix: t,
  size: e = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const s = Cu(n, e);
  if (t == null)
    return s;
  if (n.includes(r))
    throw new kle({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return (i) => `${t}${r}${s(i)}`;
};
Dle();
function Nle({
  apiKey: t,
  environmentVariableName: e,
  apiKeyParameterName: n = "apiKey",
  description: r
}) {
  if (typeof t == "string")
    return t;
  if (t != null)
    throw new nm({
      message: `${r} API key must be a string.`
    });
  if (typeof je > "u")
    throw new nm({
      message: `${r} API key is missing. Pass it using the '${n}' parameter. Environment variables is not supported in this environment.`
    });
  if (t = je.env[e], t == null)
    throw new nm({
      message: `${r} API key is missing. Pass it using the '${n}' parameter or the ${e} environment variable.`
    });
  if (typeof t != "string")
    throw new nm({
      message: `${r} API key must be a string. The value of the ${e} environment variable is not a string.`
    });
  return t;
}
var EE = Symbol.for("vercel.ai.validator");
function Lle(t) {
  return { [EE]: !0, validate: t };
}
function Mle(t) {
  return typeof t == "object" && t !== null && EE in t && t[EE] === !0 && "validate" in t;
}
function Ble(t) {
  return Mle(t) ? t : Fle(t);
}
function Fle(t) {
  return Lle((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function MI({
  value: t,
  schema: e
}) {
  const n = Ble(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: LI.wrap({ value: t, cause: r.error })
    };
  } catch (r) {
    return {
      success: !1,
      error: LI.wrap({ value: t, cause: r })
    };
  }
}
function $le(t) {
  return t?.replace(/\/$/, "");
}
var BI = (t) => {
  var e, n;
  return t == null ? void 0 : {
    deepseek: {
      promptCacheHitTokens: (e = t.prompt_cache_hit_tokens) != null ? e : NaN,
      promptCacheMissTokens: (n = t.prompt_cache_miss_tokens) != null ? n : NaN
    }
  };
}, Ule = {
  extractMetadata: ({ parsedBody: t }) => {
    const e = MI({
      value: t,
      schema: jle
    });
    return !e.success || e.value.usage == null ? void 0 : BI(e.value.usage);
  },
  createStreamExtractor: () => {
    let t;
    return {
      processChunk: (e) => {
        var n, r;
        const s = MI({
          value: e,
          schema: Hle
        });
        s.success && ((r = (n = s.value.choices) == null ? void 0 : n[0]) == null ? void 0 : r.finish_reason) === "stop" && s.value.usage && (t = s.value.usage);
      },
      buildMetadata: () => BI(t)
    };
  }
}, j8 = D.object({
  prompt_cache_hit_tokens: D.number().nullish(),
  prompt_cache_miss_tokens: D.number().nullish()
}), jle = D.object({
  usage: j8.nullish()
}), Hle = D.object({
  choices: D.array(
    D.object({
      finish_reason: D.string().nullish()
    })
  ).nullish(),
  usage: j8.nullish()
});
function H8(t = {}) {
  var e;
  const n = $le(
    (e = t.baseURL) != null ? e : "https://api.deepseek.com/v1"
  ), r = () => ({
    Authorization: `Bearer ${Nle({
      apiKey: t.apiKey,
      environmentVariableName: "DEEPSEEK_API_KEY",
      description: "DeepSeek API key"
    })}`,
    ...t.headers
  }), s = (o, a = {}) => new vle(o, a, {
    provider: "deepseek.chat",
    url: ({ path: l }) => `${n}${l}`,
    headers: r,
    fetch: t.fetch,
    defaultObjectGenerationMode: "json",
    metadataExtractor: Ule
  }), i = (o, a) => s(o, a);
  return i.languageModel = s, i.chat = s, i.textEmbeddingModel = (o) => {
    throw new Ile({ modelId: o, modelType: "textEmbeddingModel" });
  }, i;
}
H8();
class zle extends mn {
  name = "Deepseek";
  getApiKeyLink = "https://platform.deepseek.com/apiKeys";
  config = {
    apiTokenKey: "DEEPSEEK_API_KEY"
  };
  staticModels = [
    { name: "deepseek-coder", label: "Deepseek-Coder", provider: "Deepseek", maxTokenAllowed: 8e3 },
    { name: "deepseek-chat", label: "Deepseek-Chat", provider: "Deepseek", maxTokenAllowed: 8e3 },
    { name: "deepseek-reasoner", label: "Deepseek-Reasoner", provider: "Deepseek", maxTokenAllowed: 8e3 }
  ];
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "DEEPSEEK_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return H8({
      apiKey: o
    })(n, {
      // simulateStreaming: true,
    });
  }
}
let Gle = (t, e = 21) => (n = e) => {
  let r = "", s = n;
  for (; s--; )
    r += t[Math.random() * t.length | 0];
  return r;
};
var z8 = "vercel.ai.error", Vle = Symbol.for(z8), G8, Wle = class V8 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[G8] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return V8.hasMarker(e, z8);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
  /**
   * Returns a JSON representation of the error.
   * @returns {Object} An object containing the error's name, message, and cause.
   *
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message
    };
  }
};
G8 = Vle;
var vr = Wle, SE = "AI_APICallError", W8 = `vercel.ai.error.${SE}`, qle = Symbol.for(W8), q8, qi = class extends vr {
  constructor({
    message: e,
    url: n,
    requestBodyValues: r,
    statusCode: s,
    responseHeaders: i,
    responseBody: o,
    cause: a,
    isRetryable: l = s != null && (s === 408 || // request timeout
    s === 409 || // conflict
    s === 429 || // too many requests
    s >= 500),
    // server error
    data: c
  }) {
    super({ name: SE, message: e, cause: a }), this[q8] = !0, this.url = n, this.requestBodyValues = r, this.statusCode = s, this.responseHeaders = i, this.responseBody = o, this.isRetryable = l, this.data = c;
  }
  static isInstance(e) {
    return vr.hasMarker(e, W8);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isAPICallError(e) {
    return e instanceof Error && e.name === SE && typeof e.url == "string" && typeof e.requestBodyValues == "object" && (e.statusCode == null || typeof e.statusCode == "number") && (e.responseHeaders == null || typeof e.responseHeaders == "object") && (e.responseBody == null || typeof e.responseBody == "string") && (e.cause == null || typeof e.cause == "object") && typeof e.isRetryable == "boolean" && (e.data == null || typeof e.data == "object");
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      url: this.url,
      requestBodyValues: this.requestBodyValues,
      statusCode: this.statusCode,
      responseHeaders: this.responseHeaders,
      responseBody: this.responseBody,
      cause: this.cause,
      isRetryable: this.isRetryable,
      data: this.data
    };
  }
};
q8 = qle;
var xE = "AI_EmptyResponseBodyError", K8 = `vercel.ai.error.${xE}`, Kle = Symbol.for(K8), Y8, Yle = class extends vr {
  // used in isInstance
  constructor({ message: e = "Empty response body" } = {}) {
    super({ name: xE, message: e }), this[Y8] = !0;
  }
  static isInstance(e) {
    return vr.hasMarker(e, K8);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isEmptyResponseBodyError(e) {
    return e instanceof Error && e.name === xE;
  }
};
Y8 = Kle;
function Z8(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var TE = "AI_JSONParseError", J8 = `vercel.ai.error.${TE}`, Zle = Symbol.for(J8), X8, v0 = class extends vr {
  constructor({ text: e, cause: n }) {
    super({
      name: TE,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${Z8(n)}`,
      cause: n
    }), this[X8] = !0, this.text = e;
  }
  static isInstance(e) {
    return vr.hasMarker(e, J8);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isJSONParseError(e) {
    return e instanceof Error && e.name === TE && "text" in e && typeof e.text == "string";
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      valueText: this.text
    };
  }
};
X8 = Zle;
var CE = "AI_LoadAPIKeyError", Q8 = `vercel.ai.error.${CE}`, Jle = Symbol.for(Q8), e$, rm = class extends vr {
  // used in isInstance
  constructor({ message: e }) {
    super({ name: CE, message: e }), this[e$] = !0;
  }
  static isInstance(e) {
    return vr.hasMarker(e, Q8);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isLoadAPIKeyError(e) {
    return e instanceof Error && e.name === CE;
  }
};
e$ = Jle;
var kE = "AI_TooManyEmbeddingValuesForCallError", t$ = `vercel.ai.error.${kE}`, Xle = Symbol.for(t$), n$, Qle = class extends vr {
  constructor(e) {
    super({
      name: kE,
      message: `Too many values for a single embedding call. The ${e.provider} model "${e.modelId}" can only embed up to ${e.maxEmbeddingsPerCall} values per call, but ${e.values.length} values were provided.`
    }), this[n$] = !0, this.provider = e.provider, this.modelId = e.modelId, this.maxEmbeddingsPerCall = e.maxEmbeddingsPerCall, this.values = e.values;
  }
  static isInstance(e) {
    return vr.hasMarker(e, t$);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isTooManyEmbeddingValuesForCallError(e) {
    return e instanceof Error && e.name === kE && "provider" in e && typeof e.provider == "string" && "modelId" in e && typeof e.modelId == "string" && "maxEmbeddingsPerCall" in e && typeof e.maxEmbeddingsPerCall == "number" && "values" in e && Array.isArray(e.values);
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      provider: this.provider,
      modelId: this.modelId,
      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
      values: this.values
    };
  }
};
n$ = Xle;
var AE = "AI_TypeValidationError", r$ = `vercel.ai.error.${AE}`, ece = Symbol.for(r$), s$, tce = class RE extends vr {
  constructor({ value: e, cause: n }) {
    super({
      name: AE,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${Z8(n)}`,
      cause: n
    }), this[s$] = !0, this.value = e;
  }
  static isInstance(e) {
    return vr.hasMarker(e, r$);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: e,
    cause: n
  }) {
    return RE.isInstance(n) && n.value === e ? n : new RE({ value: e, cause: n });
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isTypeValidationError(e) {
    return e instanceof Error && e.name === AE;
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      value: this.value
    };
  }
};
s$ = ece;
var w0 = tce, IE = "AI_UnsupportedFunctionalityError", i$ = `vercel.ai.error.${IE}`, nce = Symbol.for(i$), o$, gv = class extends vr {
  constructor({ functionality: e }) {
    super({
      name: IE,
      message: `'${e}' functionality not supported.`
    }), this[o$] = !0, this.functionality = e;
  }
  static isInstance(e) {
    return vr.hasMarker(e, i$);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isUnsupportedFunctionalityError(e) {
    return e instanceof Error && e.name === IE && typeof e.functionality == "string";
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      functionality: this.functionality
    };
  }
};
o$ = nce;
function rce(t) {
  let e, n, r, s, i, o, a;
  return l(), {
    feed: c,
    reset: l
  };
  function l() {
    e = !0, n = "", r = 0, s = -1, i = void 0, o = void 0, a = "";
  }
  function c(h) {
    n = n ? n + h : h, e && sce(n) && (n = n.slice(a$.length)), e = !1;
    const d = n.length;
    let f = 0, g = !1;
    for (; f < d; ) {
      g && (n[f] === `
` && ++f, g = !1);
      let y = -1, p = s, m;
      for (let b = r; y < 0 && b < d; ++b)
        m = n[b], m === ":" && p < 0 ? p = b - f : m === "\r" ? (g = !0, y = b - f) : m === `
` && (y = b - f);
      if (y < 0) {
        r = d - f, s = p;
        break;
      } else
        r = 0, s = -1;
      u(n, f, p, y), f += y + 1;
    }
    f === d ? n = "" : f > 0 && (n = n.slice(f));
  }
  function u(h, d, f, g) {
    if (g === 0) {
      a.length > 0 && (t({
        type: "event",
        id: i,
        event: o || void 0,
        data: a.slice(0, -1)
        // remove trailing newline
      }), a = "", i = void 0), o = void 0;
      return;
    }
    const y = f < 0, p = h.slice(d, d + (y ? g : f));
    let m = 0;
    y ? m = g : h[d + f + 1] === " " ? m = f + 2 : m = f + 1;
    const b = d + m, _ = g - m, v = h.slice(b, b + _).toString();
    if (p === "data")
      a += v ? "".concat(v, `
`) : `
`;
    else if (p === "event")
      o = v;
    else if (p === "id" && !v.includes("\0"))
      i = v;
    else if (p === "retry") {
      const w = parseInt(v, 10);
      Number.isNaN(w) || t({
        type: "reconnect-interval",
        value: w
      });
    }
  }
}
const a$ = [239, 187, 191];
function sce(t) {
  return a$.every((e, n) => t.charCodeAt(n) === e);
}
let ice = class extends TransformStream {
  constructor() {
    let e;
    super({
      start(n) {
        e = rce((r) => {
          r.type === "event" && n.enqueue(r);
        });
      },
      transform(n) {
        e.feed(n);
      }
    });
  }
};
function PE(...t) {
  return t.reduce(
    (e, n) => ({
      ...e,
      ...n ?? {}
    }),
    {}
  );
}
function vb(t) {
  const e = {};
  return t.headers.forEach((n, r) => {
    e[r] = n;
  }), e;
}
var oce = ({
  prefix: t = "",
  size: e = 7,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
} = {}) => {
  const r = Gle(n, e);
  return (s) => `${t}${r(s)}`;
}, ace = oce();
function yv(t) {
  return t instanceof Error && (t.name === "AbortError" || t.name === "TimeoutError");
}
function lce({
  apiKey: t,
  environmentVariableName: e,
  apiKeyParameterName: n = "apiKey",
  description: r
}) {
  if (typeof t == "string")
    return t;
  if (t != null)
    throw new rm({
      message: `${r} API key must be a string.`
    });
  if (typeof je > "u")
    throw new rm({
      message: `${r} API key is missing. Pass it using the '${n}' parameter. Environment variables is not supported in this environment.`
    });
  if (t = je.env[e], t == null)
    throw new rm({
      message: `${r} API key is missing. Pass it using the '${n}' parameter or the ${e} environment variable.`
    });
  if (typeof t != "string")
    throw new rm({
      message: `${r} API key must be a string. The value of the ${e} environment variable is not a string.`
    });
  return t;
}
var OE = Symbol.for("vercel.ai.validator");
function cce(t) {
  return { [OE]: !0, validate: t };
}
function uce(t) {
  return typeof t == "object" && t !== null && OE in t && t[OE] === !0 && "validate" in t;
}
function hce(t) {
  return uce(t) ? t : dce(t);
}
function dce(t) {
  return cce((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function fce({
  value: t,
  schema: e
}) {
  const n = l$({ value: t, schema: e });
  if (!n.success)
    throw w0.wrap({ value: t, cause: n.error });
  return n.value;
}
function l$({
  value: t,
  schema: e
}) {
  const n = hce(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: w0.wrap({ value: t, cause: r.error })
    };
  } catch (r) {
    return {
      success: !1,
      error: w0.wrap({ value: t, cause: r })
    };
  }
}
function pce({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? n : fce({ value: n, schema: e });
  } catch (n) {
    throw v0.isJSONParseError(n) || w0.isTypeValidationError(n) ? n : new v0({ text: t, cause: n });
  }
}
function c$({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? {
      success: !0,
      value: n
    } : l$({ value: n, schema: e });
  } catch (n) {
    return {
      success: !1,
      error: v0.isJSONParseError(n) ? n : new v0({ text: t, cause: n })
    };
  }
}
function mce(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n != null)
  );
}
var gce = () => globalThis.fetch, DE = async ({
  url: t,
  headers: e,
  body: n,
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}) => yce({
  url: t,
  headers: {
    "Content-Type": "application/json",
    ...e
  },
  body: {
    content: JSON.stringify(n),
    values: n
  },
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}), yce = async ({
  url: t,
  headers: e = {},
  body: n,
  successfulResponseHandler: r,
  failedResponseHandler: s,
  abortSignal: i,
  fetch: o = gce()
}) => {
  try {
    const a = await o(t, {
      method: "POST",
      headers: mce(e),
      body: n.content,
      signal: i
    }), l = vb(a);
    if (!a.ok) {
      let c;
      try {
        c = await s({
          response: a,
          url: t,
          requestBodyValues: n.values
        });
      } catch (u) {
        throw yv(u) || qi.isAPICallError(u) ? u : new qi({
          message: "Failed to process error response",
          cause: u,
          statusCode: a.status,
          url: t,
          responseHeaders: l,
          requestBodyValues: n.values
        });
      }
      throw c.value;
    }
    try {
      return await r({
        response: a,
        url: t,
        requestBodyValues: n.values
      });
    } catch (c) {
      throw c instanceof Error && (yv(c) || qi.isAPICallError(c)) ? c : new qi({
        message: "Failed to process successful response",
        cause: c,
        statusCode: a.status,
        url: t,
        responseHeaders: l,
        requestBodyValues: n.values
      });
    }
  } catch (a) {
    if (yv(a))
      throw a;
    if (a instanceof TypeError && a.message === "fetch failed") {
      const l = a.cause;
      if (l != null)
        throw new qi({
          message: `Cannot connect to API: ${l.message}`,
          cause: l,
          url: t,
          requestBodyValues: n.values,
          isRetryable: !0
          // retry when network error
        });
    }
    throw a;
  }
}, bce = ({
  errorSchema: t,
  errorToMessage: e,
  isRetryable: n
}) => async ({ response: r, url: s, requestBodyValues: i }) => {
  const o = await r.text(), a = vb(r);
  if (o.trim() === "")
    return {
      responseHeaders: a,
      value: new qi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  try {
    const l = pce({
      text: o,
      schema: t
    });
    return {
      responseHeaders: a,
      value: new qi({
        message: e(l),
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        data: l,
        isRetryable: n?.(r, l)
      })
    };
  } catch {
    return {
      responseHeaders: a,
      value: new qi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  }
}, _ce = (t) => async ({ response: e }) => {
  const n = vb(e);
  if (e.body == null)
    throw new Yle({});
  return {
    responseHeaders: n,
    value: e.body.pipeThrough(new TextDecoderStream()).pipeThrough(new ice()).pipeThrough(
      new TransformStream({
        transform({ data: r }, s) {
          r !== "[DONE]" && s.enqueue(
            c$({
              text: r,
              schema: t
            })
          );
        }
      })
    )
  };
}, u$ = (t) => async ({ response: e, url: n, requestBodyValues: r }) => {
  const s = await e.text(), i = c$({
    text: s,
    schema: t
  }), o = vb(e);
  if (!i.success)
    throw new qi({
      message: "Invalid JSON response",
      cause: i.error,
      statusCode: e.status,
      responseHeaders: o,
      responseBody: s,
      url: n,
      requestBodyValues: r
    });
  return {
    responseHeaders: o,
    value: i.value
  };
}, { btoa: vce } = globalThis;
function wce(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCodePoint(t[n]);
  return vce(e);
}
function Ece(t) {
  return t?.replace(/\/$/, "");
}
function ei(t) {
  if (typeof t == "boolean")
    return { type: "boolean", properties: {} };
  const {
    type: e,
    description: n,
    required: r,
    properties: s,
    items: i,
    allOf: o,
    anyOf: a,
    oneOf: l,
    format: c,
    const: u,
    minLength: h
  } = t, d = {};
  return n && (d.description = n), r && (d.required = r), c && (d.format = c), u !== void 0 && (d.enum = [u]), e && (Array.isArray(e) ? e.includes("null") ? (d.type = e.filter((f) => f !== "null")[0], d.nullable = !0) : d.type = e : e === "null" ? d.type = "null" : d.type = e), s && (d.properties = Object.entries(s).reduce(
    (f, [g, y]) => (f[g] = ei(y), f),
    {}
  )), i && (d.items = Array.isArray(i) ? i.map(ei) : ei(i)), o && (d.allOf = o.map(ei)), a && (d.anyOf = a.map(ei)), l && (d.oneOf = l.map(ei)), h !== void 0 && (d.minLength = h), d;
}
function Sce(t) {
  var e;
  const n = [], r = [];
  let s = !0;
  for (const { role: i, content: o } of t)
    switch (i) {
      case "system": {
        if (!s)
          throw new gv({
            functionality: "system messages are only supported at the beginning of the conversation"
          });
        n.push({ text: o });
        break;
      }
      case "user": {
        s = !1;
        const a = [];
        for (const l of o)
          switch (l.type) {
            case "text": {
              a.push({ text: l.text });
              break;
            }
            case "image": {
              if (l.image instanceof URL)
                throw new gv({
                  functionality: "Image URLs in user messages"
                });
              a.push({
                inlineData: {
                  mimeType: (e = l.mimeType) != null ? e : "image/jpeg",
                  data: wce(l.image)
                }
              });
              break;
            }
            case "file": {
              if (l.data instanceof URL)
                throw new gv({
                  functionality: "File URLs in user messages"
                });
              a.push({
                inlineData: { mimeType: l.mimeType, data: l.data }
              });
              break;
            }
          }
        r.push({ role: "user", parts: a });
        break;
      }
      case "assistant": {
        s = !1, r.push({
          role: "model",
          parts: o.map((a) => {
            switch (a.type) {
              case "text":
                return a.text.length === 0 ? void 0 : { text: a.text };
              case "tool-call":
                return {
                  functionCall: {
                    name: a.toolName,
                    args: a.args
                  }
                };
            }
          }).filter(
            (a) => a !== void 0
          )
        });
        break;
      }
      case "tool": {
        s = !1, r.push({
          role: "user",
          parts: o.map((a) => ({
            functionResponse: {
              name: a.toolName,
              response: a.result
            }
          }))
        });
        break;
      }
      default: {
        const a = i;
        throw new Error(`Unsupported role: ${a}`);
      }
    }
  return {
    systemInstruction: n.length > 0 ? { parts: n } : void 0,
    contents: r
  };
}
function FI(t) {
  return t.includes("/") ? t : `models/${t}`;
}
var xce = D.object({
  error: D.object({
    code: D.number().nullable(),
    message: D.string(),
    status: D.string()
  })
}), NE = bce({
  errorSchema: xce,
  errorToMessage: (t) => t.error.message
});
function $I({
  finishReason: t,
  hasToolCalls: e
}) {
  switch (t) {
    case "STOP":
      return e ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "RECITATION":
    case "SAFETY":
      return "content-filter";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
      return "other";
    default:
      return "unknown";
  }
}
var Tce = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.defaultObjectGenerationMode = "json", this.supportsImageUrls = !1, this.modelId = t, this.settings = e, this.config = n;
  }
  get supportsObjectGeneration() {
    return this.settings.structuredOutputs !== !1;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    mode: t,
    prompt: e,
    maxTokens: n,
    temperature: r,
    topP: s,
    topK: i,
    frequencyPenalty: o,
    presencePenalty: a,
    stopSequences: l,
    responseFormat: c,
    seed: u
  }) {
    var h;
    const d = t.type, f = [];
    u != null && f.push({
      type: "unsupported-setting",
      setting: "seed"
    });
    const g = {
      // standardized settings:
      maxOutputTokens: n,
      temperature: r,
      topK: i ?? this.settings.topK,
      topP: s,
      frequencyPenalty: o,
      presencePenalty: a,
      stopSequences: l,
      // response format:
      responseMimeType: c?.type === "json" ? "application/json" : void 0,
      responseSchema: c?.type === "json" && c.schema != null && // Google GenAI does not support all OpenAPI Schema features,
      // so this is needed as an escape hatch:
      this.supportsObjectGeneration ? ei(c.schema) : void 0
    }, { contents: y, systemInstruction: p } = Sce(e);
    switch (d) {
      case "regular":
        return {
          args: {
            generationConfig: g,
            contents: y,
            systemInstruction: p,
            safetySettings: this.settings.safetySettings,
            ...Ace(t),
            cachedContent: this.settings.cachedContent
          },
          warnings: f
        };
      case "object-json":
        return {
          args: {
            generationConfig: {
              ...g,
              responseMimeType: "application/json",
              responseSchema: t.schema != null && // Google GenAI does not support all OpenAPI Schema features,
              // so this is needed as an escape hatch:
              this.supportsObjectGeneration ? ei(t.schema) : void 0
            },
            contents: y,
            systemInstruction: p,
            safetySettings: this.settings.safetySettings,
            cachedContent: this.settings.cachedContent
          },
          warnings: f
        };
      case "object-tool":
        return {
          args: {
            generationConfig: g,
            contents: y,
            tools: {
              functionDeclarations: [
                {
                  name: t.tool.name,
                  description: (h = t.tool.description) != null ? h : "",
                  parameters: ei(
                    t.tool.parameters
                  )
                }
              ]
            },
            toolConfig: { functionCallingConfig: { mode: "ANY" } },
            safetySettings: this.settings.safetySettings,
            cachedContent: this.settings.cachedContent
          },
          warnings: f
        };
      default: {
        const m = d;
        throw new Error(`Unsupported type: ${m}`);
      }
    }
  }
  async doGenerate(t) {
    var e, n;
    const { args: r, warnings: s } = await this.getArgs(t), { responseHeaders: i, value: o } = await DE({
      url: `${this.config.baseURL}/${FI(
        this.modelId
      )}:generateContent`,
      headers: PE(this.config.headers(), t.headers),
      body: r,
      failedResponseHandler: NE,
      successfulResponseHandler: u$(Cce),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { contents: a, ...l } = r, c = o.candidates[0], u = UI({
      parts: c.content.parts,
      generateId: this.config.generateId
    }), h = o.usageMetadata;
    return {
      text: jI(c.content.parts),
      toolCalls: u,
      finishReason: $I({
        finishReason: c.finishReason,
        hasToolCalls: u != null && u.length > 0
      }),
      usage: {
        promptTokens: (e = h?.promptTokenCount) != null ? e : NaN,
        completionTokens: (n = h?.candidatesTokenCount) != null ? n : NaN
      },
      rawCall: { rawPrompt: a, rawSettings: l },
      rawResponse: { headers: i },
      warnings: s
    };
  }
  async doStream(t) {
    const { args: e, warnings: n } = await this.getArgs(t), { responseHeaders: r, value: s } = await DE({
      url: `${this.config.baseURL}/${FI(
        this.modelId
      )}:streamGenerateContent?alt=sse`,
      headers: PE(this.config.headers(), t.headers),
      body: e,
      failedResponseHandler: NE,
      successfulResponseHandler: _ce(kce),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { contents: i, ...o } = e;
    let a = "unknown", l = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    };
    const c = this.config.generateId;
    let u = !1;
    return {
      stream: s.pipeThrough(
        new TransformStream({
          transform(h, d) {
            var f, g;
            if (!h.success) {
              d.enqueue({ type: "error", error: h.error });
              return;
            }
            const y = h.value, p = y.candidates[0];
            p?.finishReason != null && (a = $I({
              finishReason: p.finishReason,
              hasToolCalls: u
            }));
            const m = y.usageMetadata;
            m != null && (l = {
              promptTokens: (f = m.promptTokenCount) != null ? f : NaN,
              completionTokens: (g = m.candidatesTokenCount) != null ? g : NaN
            });
            const b = p.content;
            if (b == null)
              return;
            const _ = jI(b.parts);
            _ != null && d.enqueue({
              type: "text-delta",
              textDelta: _
            });
            const v = UI({
              parts: b.parts,
              generateId: c
            });
            if (v != null)
              for (const w of v)
                d.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: w.toolCallId,
                  toolName: w.toolName,
                  argsTextDelta: w.args
                }), d.enqueue({
                  type: "tool-call",
                  toolCallType: "function",
                  toolCallId: w.toolCallId,
                  toolName: w.toolName,
                  args: w.args
                }), u = !0;
          },
          flush(h) {
            h.enqueue({ type: "finish", finishReason: a, usage: l });
          }
        })
      ),
      rawCall: { rawPrompt: i, rawSettings: o },
      rawResponse: { headers: r },
      warnings: n
    };
  }
};
function UI({
  parts: t,
  generateId: e
}) {
  const n = t.filter(
    (r) => "functionCall" in r
  );
  return n.length === 0 ? void 0 : n.map((r) => ({
    toolCallType: "function",
    toolCallId: e(),
    toolName: r.functionCall.name,
    args: JSON.stringify(r.functionCall.args)
  }));
}
function jI(t) {
  const e = t.filter((n) => "text" in n);
  return e.length === 0 ? void 0 : e.map((n) => n.text).join("");
}
var h$ = D.object({
  role: D.string(),
  parts: D.array(
    D.union([
      D.object({
        text: D.string()
      }),
      D.object({
        functionCall: D.object({
          name: D.string(),
          args: D.unknown()
        })
      })
    ])
  )
}), Cce = D.object({
  candidates: D.array(
    D.object({
      content: h$,
      finishReason: D.string().optional()
    })
  ),
  usageMetadata: D.object({
    promptTokenCount: D.number(),
    candidatesTokenCount: D.number().nullish(),
    totalTokenCount: D.number()
  }).optional()
}), kce = D.object({
  candidates: D.array(
    D.object({
      content: h$.optional(),
      finishReason: D.string().optional()
    })
  ),
  usageMetadata: D.object({
    promptTokenCount: D.number(),
    candidatesTokenCount: D.number().nullish(),
    totalTokenCount: D.number()
  }).optional()
});
function Ace(t) {
  var e;
  const n = (e = t.tools) != null && e.length ? t.tools : void 0;
  if (n == null)
    return { tools: void 0, toolConfig: void 0 };
  const r = {
    functionDeclarations: n.map((o) => {
      var a;
      return {
        name: o.name,
        description: (a = o.description) != null ? a : "",
        parameters: ei(o.parameters)
      };
    })
  }, s = t.toolChoice;
  if (s == null)
    return { tools: r, toolConfig: void 0 };
  const i = s.type;
  switch (i) {
    case "auto":
      return {
        tools: r,
        toolConfig: { functionCallingConfig: { mode: "AUTO" } }
      };
    case "none":
      return {
        tools: r,
        toolConfig: { functionCallingConfig: { mode: "NONE" } }
      };
    case "required":
      return {
        tools: r,
        toolConfig: { functionCallingConfig: { mode: "ANY" } }
      };
    case "tool":
      return {
        tools: r,
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [s.toolName]
          }
        }
      };
    default: {
      const o = i;
      throw new Error(`Unsupported tool choice type: ${o}`);
    }
  }
}
var Rce = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    return 2048;
  }
  get supportsParallelCalls() {
    return !0;
  }
  async doEmbed({
    values: t,
    headers: e,
    abortSignal: n
  }) {
    if (t.length > this.maxEmbeddingsPerCall)
      throw new Qle({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values: t
      });
    const { responseHeaders: r, value: s } = await DE({
      url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
      headers: PE(this.config.headers(), e),
      body: {
        requests: t.map((i) => ({
          model: `models/${this.modelId}`,
          content: { role: "user", parts: [{ text: i }] },
          outputDimensionality: this.settings.outputDimensionality
        }))
      },
      failedResponseHandler: NE,
      successfulResponseHandler: u$(
        Ice
      ),
      abortSignal: n,
      fetch: this.config.fetch
    });
    return {
      embeddings: s.embeddings.map((i) => i.values),
      usage: void 0,
      rawResponse: { headers: r }
    };
  }
}, Ice = D.object({
  embeddings: D.array(D.object({ values: D.array(D.number()) }))
});
function d$(t = {}) {
  var e, n;
  const r = (n = Ece((e = t.baseURL) != null ? e : t.baseUrl)) != null ? n : "https://generativelanguage.googleapis.com/v1beta", s = () => ({
    "x-goog-api-key": lce({
      apiKey: t.apiKey,
      environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
      description: "Google Generative AI"
    }),
    ...t.headers
  }), i = (l, c = {}) => {
    var u;
    return new Tce(l, c, {
      provider: "google.generative-ai",
      baseURL: r,
      headers: s,
      generateId: (u = t.generateId) != null ? u : ace,
      fetch: t.fetch
    });
  }, o = (l, c = {}) => new Rce(l, c, {
    provider: "google.generative-ai",
    baseURL: r,
    headers: s,
    fetch: t.fetch
  }), a = function(l, c) {
    if (new.target)
      throw new Error(
        "The Google Generative AI model function cannot be called with the new keyword."
      );
    return i(l, c);
  };
  return a.languageModel = i, a.chat = i, a.generativeAI = i, a.embedding = o, a.textEmbedding = o, a.textEmbeddingModel = o, a;
}
d$();
class Pce extends mn {
  name = "Google";
  getApiKeyLink = "https://aistudio.google.com/app/apikey";
  config = {
    apiTokenKey: "GOOGLE_GENERATIVE_AI_API_KEY"
  };
  staticModels = [
    { name: "gemini-1.5-flash-latest", label: "Gemini 1.5 Flash", provider: "Google", maxTokenAllowed: 8192 },
    {
      name: "gemini-2.0-flash-thinking-exp-01-21",
      label: "Gemini 2.0 Flash-thinking-exp-01-21",
      provider: "Google",
      maxTokenAllowed: 65536
    },
    { name: "gemini-2.0-flash-exp", label: "Gemini 2.0 Flash", provider: "Google", maxTokenAllowed: 8192 },
    { name: "gemini-1.5-flash-002", label: "Gemini 1.5 Flash-002", provider: "Google", maxTokenAllowed: 8192 },
    { name: "gemini-1.5-flash-8b", label: "Gemini 1.5 Flash-8b", provider: "Google", maxTokenAllowed: 8192 },
    { name: "gemini-1.5-pro-latest", label: "Gemini 1.5 Pro", provider: "Google", maxTokenAllowed: 8192 },
    { name: "gemini-1.5-pro-002", label: "Gemini 1.5 Pro-002", provider: "Google", maxTokenAllowed: 8192 },
    { name: "gemini-exp-1206", label: "Gemini exp-1206", provider: "Google", maxTokenAllowed: 8192 }
  ];
  async getDynamicModels(e, n, r) {
    const { apiKey: s } = this.getProviderBaseUrlAndKey({
      apiKeys: e,
      providerSettings: n,
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "GOOGLE_GENERATIVE_AI_API_KEY"
    });
    if (!s)
      throw `Missing Api Key configuration for ${this.name} provider`;
    return (await (await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${s}`, {
      headers: {
        "Content-Type": "application/json"
      }
    })).json()).models.filter((l) => l.outputTokenLimit > 8e3).map((l) => ({
      name: l.name.replace("models/", ""),
      label: `${l.displayName} - context ${Math.floor((l.inputTokenLimit + l.outputTokenLimit) / 1e3) + "k"}`,
      provider: this.name,
      maxTokenAllowed: l.inputTokenLimit + l.outputTokenLimit || 8e3
    }));
  }
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "GOOGLE_GENERATIVE_AI_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return d$({
      apiKey: o
    })(n);
  }
}
class Oce extends mn {
  name = "Groq";
  getApiKeyLink = "https://console.groq.com/keys";
  config = {
    apiTokenKey: "GROQ_API_KEY"
  };
  staticModels = [
    { name: "llama-3.1-8b-instant", label: "Llama 3.1 8b (Groq)", provider: "Groq", maxTokenAllowed: 8e3 },
    { name: "llama-3.2-11b-vision-preview", label: "Llama 3.2 11b (Groq)", provider: "Groq", maxTokenAllowed: 8e3 },
    { name: "llama-3.2-90b-vision-preview", label: "Llama 3.2 90b (Groq)", provider: "Groq", maxTokenAllowed: 8e3 },
    { name: "llama-3.2-3b-preview", label: "Llama 3.2 3b (Groq)", provider: "Groq", maxTokenAllowed: 8e3 },
    { name: "llama-3.2-1b-preview", label: "Llama 3.2 1b (Groq)", provider: "Groq", maxTokenAllowed: 8e3 },
    { name: "llama-3.3-70b-versatile", label: "Llama 3.3 70b (Groq)", provider: "Groq", maxTokenAllowed: 8e3 },
    {
      name: "deepseek-r1-distill-llama-70b",
      label: "Deepseek R1 Distill Llama 70b (Groq)",
      provider: "Groq",
      maxTokenAllowed: 131072
    }
  ];
  async getDynamicModels(e, n, r) {
    const { apiKey: s } = this.getProviderBaseUrlAndKey({
      apiKeys: e,
      providerSettings: n,
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "GROQ_API_KEY"
    });
    if (!s)
      throw `Missing Api Key configuration for ${this.name} provider`;
    return (await (await fetch("https://api.groq.com/openai/v1/models", {
      headers: {
        Authorization: `Bearer ${s}`
      }
    })).json()).data.filter(
      (l) => l.object === "model" && l.active && l.context_window > 8e3
    ).map((l) => ({
      name: l.id,
      label: `${l.id} - context ${l.context_window ? Math.floor(l.context_window / 1e3) + "k" : "N/A"} [ by ${l.owned_by}]`,
      provider: this.name,
      maxTokenAllowed: l.context_window || 8e3
    }));
  }
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "GROQ_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return Pi({
      baseURL: "https://api.groq.com/openai/v1",
      apiKey: o
    })(n);
  }
}
class Dce extends mn {
  name = "HuggingFace";
  getApiKeyLink = "https://huggingface.co/settings/tokens";
  config = {
    apiTokenKey: "HuggingFace_API_KEY"
  };
  staticModels = [
    {
      name: "Qwen/Qwen2.5-Coder-32B-Instruct",
      label: "Qwen2.5-Coder-32B-Instruct (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "01-ai/Yi-1.5-34B-Chat",
      label: "Yi-1.5-34B-Chat (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "codellama/CodeLlama-34b-Instruct-hf",
      label: "CodeLlama-34b-Instruct (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "NousResearch/Hermes-3-Llama-3.1-8B",
      label: "Hermes-3-Llama-3.1-8B (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "Qwen/Qwen2.5-Coder-32B-Instruct",
      label: "Qwen2.5-Coder-32B-Instruct (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "Qwen/Qwen2.5-72B-Instruct",
      label: "Qwen2.5-72B-Instruct (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "meta-llama/Llama-3.1-70B-Instruct",
      label: "Llama-3.1-70B-Instruct (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "meta-llama/Llama-3.1-405B",
      label: "Llama-3.1-405B (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "01-ai/Yi-1.5-34B-Chat",
      label: "Yi-1.5-34B-Chat (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "codellama/CodeLlama-34b-Instruct-hf",
      label: "CodeLlama-34b-Instruct (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    },
    {
      name: "NousResearch/Hermes-3-Llama-3.1-8B",
      label: "Hermes-3-Llama-3.1-8B (HuggingFace)",
      provider: "HuggingFace",
      maxTokenAllowed: 8e3
    }
  ];
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "HuggingFace_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return Pi({
      baseURL: "https://api-inference.huggingface.co/v1/",
      apiKey: o
    })(n);
  }
}
class Nce extends mn {
  name = "LMStudio";
  getApiKeyLink = "https://lmstudio.ai/";
  labelForGetApiKey = "Get LMStudio";
  icon = "i-ph:cloud-arrow-down";
  config = {
    baseUrlKey: "LMSTUDIO_API_BASE_URL",
    baseUrl: "http://localhost:1234/"
  };
  staticModels = [];
  async getDynamicModels(e, n, r = {}) {
    let { baseUrl: s } = this.getProviderBaseUrlAndKey({
      apiKeys: e,
      providerSettings: n,
      serverEnv: r,
      defaultBaseUrlKey: "LMSTUDIO_API_BASE_URL",
      defaultApiTokenKey: ""
    });
    if (!s)
      throw new Error("No baseUrl found for LMStudio provider");
    if (typeof window > "u") {
      const a = je?.env?.RUNNING_IN_DOCKER === "true" || r?.RUNNING_IN_DOCKER === "true";
      s = a ? s.replace("localhost", "host.docker.internal") : s, s = a ? s.replace("127.0.0.1", "host.docker.internal") : s;
    }
    return (await (await fetch(`${s}/v1/models`)).json()).data.map((a) => ({
      name: a.id,
      label: a.id,
      provider: this.name,
      maxTokenAllowed: 8e3
    }));
  }
  getModelInstance = (e) => {
    const { apiKeys: n, providerSettings: r, serverEnv: s, model: i } = e;
    let { baseUrl: o } = this.getProviderBaseUrlAndKey({
      apiKeys: n,
      providerSettings: r?.[this.name],
      serverEnv: s,
      defaultBaseUrlKey: "LMSTUDIO_API_BASE_URL",
      defaultApiTokenKey: ""
    });
    if (!o)
      throw new Error("No baseUrl found for LMStudio provider");
    const a = je.env.RUNNING_IN_DOCKER === "true" || s?.RUNNING_IN_DOCKER === "true";
    return typeof window > "u" && (o = a ? o.replace("localhost", "host.docker.internal") : o, o = a ? o.replace("127.0.0.1", "host.docker.internal") : o), wB.debug("LMStudio Base Url used: ", o), Pi({
      baseURL: `${o}/v1`,
      apiKey: ""
    })(i);
  };
}
let Lce = (t, e = 21) => (n = e) => {
  let r = "", s = n;
  for (; s--; )
    r += t[Math.random() * t.length | 0];
  return r;
};
var f$ = "vercel.ai.error", Mce = Symbol.for(f$), p$, Bce = class m$ extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[p$] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return m$.hasMarker(e, f$);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
  /**
   * Returns a JSON representation of the error.
   * @returns {Object} An object containing the error's name, message, and cause.
   *
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message
    };
  }
};
p$ = Mce;
var wr = Bce, LE = "AI_APICallError", g$ = `vercel.ai.error.${LE}`, Fce = Symbol.for(g$), y$, Ki = class extends wr {
  constructor({
    message: e,
    url: n,
    requestBodyValues: r,
    statusCode: s,
    responseHeaders: i,
    responseBody: o,
    cause: a,
    isRetryable: l = s != null && (s === 408 || // request timeout
    s === 409 || // conflict
    s === 429 || // too many requests
    s >= 500),
    // server error
    data: c
  }) {
    super({ name: LE, message: e, cause: a }), this[y$] = !0, this.url = n, this.requestBodyValues = r, this.statusCode = s, this.responseHeaders = i, this.responseBody = o, this.isRetryable = l, this.data = c;
  }
  static isInstance(e) {
    return wr.hasMarker(e, g$);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isAPICallError(e) {
    return e instanceof Error && e.name === LE && typeof e.url == "string" && typeof e.requestBodyValues == "object" && (e.statusCode == null || typeof e.statusCode == "number") && (e.responseHeaders == null || typeof e.responseHeaders == "object") && (e.responseBody == null || typeof e.responseBody == "string") && (e.cause == null || typeof e.cause == "object") && typeof e.isRetryable == "boolean" && (e.data == null || typeof e.data == "object");
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      url: this.url,
      requestBodyValues: this.requestBodyValues,
      statusCode: this.statusCode,
      responseHeaders: this.responseHeaders,
      responseBody: this.responseBody,
      cause: this.cause,
      isRetryable: this.isRetryable,
      data: this.data
    };
  }
};
y$ = Fce;
var ME = "AI_EmptyResponseBodyError", b$ = `vercel.ai.error.${ME}`, $ce = Symbol.for(b$), _$, Uce = class extends wr {
  // used in isInstance
  constructor({ message: e = "Empty response body" } = {}) {
    super({ name: ME, message: e }), this[_$] = !0;
  }
  static isInstance(e) {
    return wr.hasMarker(e, b$);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isEmptyResponseBodyError(e) {
    return e instanceof Error && e.name === ME;
  }
};
_$ = $ce;
function v$(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var BE = "AI_JSONParseError", w$ = `vercel.ai.error.${BE}`, jce = Symbol.for(w$), E$, E0 = class extends wr {
  constructor({ text: e, cause: n }) {
    super({
      name: BE,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${v$(n)}`,
      cause: n
    }), this[E$] = !0, this.text = e;
  }
  static isInstance(e) {
    return wr.hasMarker(e, w$);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isJSONParseError(e) {
    return e instanceof Error && e.name === BE && "text" in e && typeof e.text == "string";
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      valueText: this.text
    };
  }
};
E$ = jce;
var FE = "AI_LoadAPIKeyError", S$ = `vercel.ai.error.${FE}`, Hce = Symbol.for(S$), x$, sm = class extends wr {
  // used in isInstance
  constructor({ message: e }) {
    super({ name: FE, message: e }), this[x$] = !0;
  }
  static isInstance(e) {
    return wr.hasMarker(e, S$);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isLoadAPIKeyError(e) {
    return e instanceof Error && e.name === FE;
  }
};
x$ = Hce;
var $E = "AI_TooManyEmbeddingValuesForCallError", T$ = `vercel.ai.error.${$E}`, zce = Symbol.for(T$), C$, Gce = class extends wr {
  constructor(e) {
    super({
      name: $E,
      message: `Too many values for a single embedding call. The ${e.provider} model "${e.modelId}" can only embed up to ${e.maxEmbeddingsPerCall} values per call, but ${e.values.length} values were provided.`
    }), this[C$] = !0, this.provider = e.provider, this.modelId = e.modelId, this.maxEmbeddingsPerCall = e.maxEmbeddingsPerCall, this.values = e.values;
  }
  static isInstance(e) {
    return wr.hasMarker(e, T$);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isTooManyEmbeddingValuesForCallError(e) {
    return e instanceof Error && e.name === $E && "provider" in e && typeof e.provider == "string" && "modelId" in e && typeof e.modelId == "string" && "maxEmbeddingsPerCall" in e && typeof e.maxEmbeddingsPerCall == "number" && "values" in e && Array.isArray(e.values);
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      provider: this.provider,
      modelId: this.modelId,
      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
      values: this.values
    };
  }
};
C$ = zce;
var UE = "AI_TypeValidationError", k$ = `vercel.ai.error.${UE}`, Vce = Symbol.for(k$), A$, Wce = class jE extends wr {
  constructor({ value: e, cause: n }) {
    super({
      name: UE,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${v$(n)}`,
      cause: n
    }), this[A$] = !0, this.value = e;
  }
  static isInstance(e) {
    return wr.hasMarker(e, k$);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: e,
    cause: n
  }) {
    return jE.isInstance(n) && n.value === e ? n : new jE({ value: e, cause: n });
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isTypeValidationError(e) {
    return e instanceof Error && e.name === UE;
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      value: this.value
    };
  }
};
A$ = Vce;
var S0 = Wce, HE = "AI_UnsupportedFunctionalityError", R$ = `vercel.ai.error.${HE}`, qce = Symbol.for(R$), I$, Kce = class extends wr {
  constructor({ functionality: e }) {
    super({
      name: HE,
      message: `'${e}' functionality not supported.`
    }), this[I$] = !0, this.functionality = e;
  }
  static isInstance(e) {
    return wr.hasMarker(e, R$);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isUnsupportedFunctionalityError(e) {
    return e instanceof Error && e.name === HE && typeof e.functionality == "string";
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      functionality: this.functionality
    };
  }
};
I$ = qce;
function Yce(t) {
  let e, n, r, s, i, o, a;
  return l(), {
    feed: c,
    reset: l
  };
  function l() {
    e = !0, n = "", r = 0, s = -1, i = void 0, o = void 0, a = "";
  }
  function c(h) {
    n = n ? n + h : h, e && Zce(n) && (n = n.slice(P$.length)), e = !1;
    const d = n.length;
    let f = 0, g = !1;
    for (; f < d; ) {
      g && (n[f] === `
` && ++f, g = !1);
      let y = -1, p = s, m;
      for (let b = r; y < 0 && b < d; ++b)
        m = n[b], m === ":" && p < 0 ? p = b - f : m === "\r" ? (g = !0, y = b - f) : m === `
` && (y = b - f);
      if (y < 0) {
        r = d - f, s = p;
        break;
      } else
        r = 0, s = -1;
      u(n, f, p, y), f += y + 1;
    }
    f === d ? n = "" : f > 0 && (n = n.slice(f));
  }
  function u(h, d, f, g) {
    if (g === 0) {
      a.length > 0 && (t({
        type: "event",
        id: i,
        event: o || void 0,
        data: a.slice(0, -1)
        // remove trailing newline
      }), a = "", i = void 0), o = void 0;
      return;
    }
    const y = f < 0, p = h.slice(d, d + (y ? g : f));
    let m = 0;
    y ? m = g : h[d + f + 1] === " " ? m = f + 2 : m = f + 1;
    const b = d + m, _ = g - m, v = h.slice(b, b + _).toString();
    if (p === "data")
      a += v ? "".concat(v, `
`) : `
`;
    else if (p === "event")
      o = v;
    else if (p === "id" && !v.includes("\0"))
      i = v;
    else if (p === "retry") {
      const w = parseInt(v, 10);
      Number.isNaN(w) || t({
        type: "reconnect-interval",
        value: w
      });
    }
  }
}
const P$ = [239, 187, 191];
function Zce(t) {
  return P$.every((e, n) => t.charCodeAt(n) === e);
}
let Jce = class extends TransformStream {
  constructor() {
    let e;
    super({
      start(n) {
        e = Yce((r) => {
          r.type === "event" && n.enqueue(r);
        });
      },
      transform(n) {
        e.feed(n);
      }
    });
  }
};
function zE(...t) {
  return t.reduce(
    (e, n) => ({
      ...e,
      ...n ?? {}
    }),
    {}
  );
}
function wb(t) {
  const e = {};
  return t.headers.forEach((n, r) => {
    e[r] = n;
  }), e;
}
var Xce = ({
  prefix: t = "",
  size: e = 7,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
} = {}) => {
  const r = Lce(n, e);
  return (s) => `${t}${r(s)}`;
};
Xce();
function bv(t) {
  return t instanceof Error && (t.name === "AbortError" || t.name === "TimeoutError");
}
function Qce({
  apiKey: t,
  environmentVariableName: e,
  apiKeyParameterName: n = "apiKey",
  description: r
}) {
  if (typeof t == "string")
    return t;
  if (t != null)
    throw new sm({
      message: `${r} API key must be a string.`
    });
  if (typeof je > "u")
    throw new sm({
      message: `${r} API key is missing. Pass it using the '${n}' parameter. Environment variables is not supported in this environment.`
    });
  if (t = je.env[e], t == null)
    throw new sm({
      message: `${r} API key is missing. Pass it using the '${n}' parameter or the ${e} environment variable.`
    });
  if (typeof t != "string")
    throw new sm({
      message: `${r} API key must be a string. The value of the ${e} environment variable is not a string.`
    });
  return t;
}
var GE = Symbol.for("vercel.ai.validator");
function eue(t) {
  return { [GE]: !0, validate: t };
}
function tue(t) {
  return typeof t == "object" && t !== null && GE in t && t[GE] === !0 && "validate" in t;
}
function nue(t) {
  return tue(t) ? t : rue(t);
}
function rue(t) {
  return eue((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function sue({
  value: t,
  schema: e
}) {
  const n = O$({ value: t, schema: e });
  if (!n.success)
    throw S0.wrap({ value: t, cause: n.error });
  return n.value;
}
function O$({
  value: t,
  schema: e
}) {
  const n = nue(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: S0.wrap({ value: t, cause: r.error })
    };
  } catch (r) {
    return {
      success: !1,
      error: S0.wrap({ value: t, cause: r })
    };
  }
}
function iue({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? n : sue({ value: n, schema: e });
  } catch (n) {
    throw E0.isJSONParseError(n) || S0.isTypeValidationError(n) ? n : new E0({ text: t, cause: n });
  }
}
function D$({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? {
      success: !0,
      value: n
    } : O$({ value: n, schema: e });
  } catch (n) {
    return {
      success: !1,
      error: E0.isJSONParseError(n) ? n : new E0({ text: t, cause: n })
    };
  }
}
function oue(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n != null)
  );
}
var aue = () => globalThis.fetch, VE = async ({
  url: t,
  headers: e,
  body: n,
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}) => lue({
  url: t,
  headers: {
    "Content-Type": "application/json",
    ...e
  },
  body: {
    content: JSON.stringify(n),
    values: n
  },
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}), lue = async ({
  url: t,
  headers: e = {},
  body: n,
  successfulResponseHandler: r,
  failedResponseHandler: s,
  abortSignal: i,
  fetch: o = aue()
}) => {
  try {
    const a = await o(t, {
      method: "POST",
      headers: oue(e),
      body: n.content,
      signal: i
    }), l = wb(a);
    if (!a.ok) {
      let c;
      try {
        c = await s({
          response: a,
          url: t,
          requestBodyValues: n.values
        });
      } catch (u) {
        throw bv(u) || Ki.isAPICallError(u) ? u : new Ki({
          message: "Failed to process error response",
          cause: u,
          statusCode: a.status,
          url: t,
          responseHeaders: l,
          requestBodyValues: n.values
        });
      }
      throw c.value;
    }
    try {
      return await r({
        response: a,
        url: t,
        requestBodyValues: n.values
      });
    } catch (c) {
      throw c instanceof Error && (bv(c) || Ki.isAPICallError(c)) ? c : new Ki({
        message: "Failed to process successful response",
        cause: c,
        statusCode: a.status,
        url: t,
        responseHeaders: l,
        requestBodyValues: n.values
      });
    }
  } catch (a) {
    if (bv(a))
      throw a;
    if (a instanceof TypeError && a.message === "fetch failed") {
      const l = a.cause;
      if (l != null)
        throw new Ki({
          message: `Cannot connect to API: ${l.message}`,
          cause: l,
          url: t,
          requestBodyValues: n.values,
          isRetryable: !0
          // retry when network error
        });
    }
    throw a;
  }
}, cue = ({
  errorSchema: t,
  errorToMessage: e,
  isRetryable: n
}) => async ({ response: r, url: s, requestBodyValues: i }) => {
  const o = await r.text(), a = wb(r);
  if (o.trim() === "")
    return {
      responseHeaders: a,
      value: new Ki({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  try {
    const l = iue({
      text: o,
      schema: t
    });
    return {
      responseHeaders: a,
      value: new Ki({
        message: e(l),
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        data: l,
        isRetryable: n?.(r, l)
      })
    };
  } catch {
    return {
      responseHeaders: a,
      value: new Ki({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  }
}, uue = (t) => async ({ response: e }) => {
  const n = wb(e);
  if (e.body == null)
    throw new Uce({});
  return {
    responseHeaders: n,
    value: e.body.pipeThrough(new TextDecoderStream()).pipeThrough(new Jce()).pipeThrough(
      new TransformStream({
        transform({ data: r }, s) {
          r !== "[DONE]" && s.enqueue(
            D$({
              text: r,
              schema: t
            })
          );
        }
      })
    )
  };
}, N$ = (t) => async ({ response: e, url: n, requestBodyValues: r }) => {
  const s = await e.text(), i = D$({
    text: s,
    schema: t
  }), o = wb(e);
  if (!i.success)
    throw new Ki({
      message: "Invalid JSON response",
      cause: i.error,
      statusCode: e.status,
      responseHeaders: o,
      responseBody: s,
      url: n,
      requestBodyValues: r
    });
  return {
    responseHeaders: o,
    value: i.value
  };
}, { btoa: hue } = globalThis;
function due(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCodePoint(t[n]);
  return hue(e);
}
function fue(t) {
  return t?.replace(/\/$/, "");
}
function pue(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const { role: r, content: s } = t[n], i = n === t.length - 1;
    switch (r) {
      case "system": {
        e.push({ role: "system", content: s });
        break;
      }
      case "user": {
        e.push({
          role: "user",
          content: s.map((o) => {
            var a;
            switch (o.type) {
              case "text":
                return { type: "text", text: o.text };
              case "image":
                return {
                  type: "image_url",
                  image_url: o.image instanceof URL ? o.image.toString() : `data:${(a = o.mimeType) != null ? a : "image/jpeg"};base64,${due(o.image)}`
                };
              case "file":
                throw new Kce({
                  functionality: "File content parts in user messages"
                });
            }
          })
        });
        break;
      }
      case "assistant": {
        let o = "";
        const a = [];
        for (const l of s)
          switch (l.type) {
            case "text": {
              o += l.text;
              break;
            }
            case "tool-call": {
              a.push({
                id: l.toolCallId,
                type: "function",
                function: {
                  name: l.toolName,
                  arguments: JSON.stringify(l.args)
                }
              });
              break;
            }
            default: {
              const c = l;
              throw new Error(`Unsupported part: ${c}`);
            }
          }
        e.push({
          role: "assistant",
          content: o,
          prefix: i ? !0 : void 0,
          tool_calls: a.length > 0 ? a : void 0
        });
        break;
      }
      case "tool": {
        for (const o of s)
          e.push({
            role: "tool",
            name: o.toolName,
            content: JSON.stringify(o.result),
            tool_call_id: o.toolCallId
          });
        break;
      }
      default: {
        const o = r;
        throw new Error(`Unsupported role: ${o}`);
      }
    }
  }
  return e;
}
function HI(t) {
  switch (t) {
    case "stop":
      return "stop";
    case "length":
    case "model_length":
      return "length";
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var mue = D.object({
  object: D.literal("error"),
  message: D.string(),
  type: D.string(),
  param: D.string().nullable(),
  code: D.string().nullable()
}), WE = cue({
  errorSchema: mue,
  errorToMessage: (t) => t.message
});
function zI({
  id: t,
  model: e,
  created: n
}) {
  return {
    id: t ?? void 0,
    modelId: e ?? void 0,
    timestamp: n != null ? new Date(n * 1e3) : void 0
  };
}
var gue = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.defaultObjectGenerationMode = "json", this.supportsImageUrls = !1, this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    mode: t,
    prompt: e,
    maxTokens: n,
    temperature: r,
    topP: s,
    topK: i,
    frequencyPenalty: o,
    presencePenalty: a,
    stopSequences: l,
    responseFormat: c,
    seed: u
  }) {
    const h = t.type, d = [];
    i != null && d.push({
      type: "unsupported-setting",
      setting: "topK"
    }), o != null && d.push({
      type: "unsupported-setting",
      setting: "frequencyPenalty"
    }), a != null && d.push({
      type: "unsupported-setting",
      setting: "presencePenalty"
    }), l != null && d.push({
      type: "unsupported-setting",
      setting: "stopSequences"
    }), c != null && c.type === "json" && c.schema != null && d.push({
      type: "unsupported-setting",
      setting: "responseFormat",
      details: "JSON response format schema is not supported"
    });
    const f = {
      // model id:
      model: this.modelId,
      // model specific settings:
      safe_prompt: this.settings.safePrompt,
      // standardized settings:
      max_tokens: n,
      temperature: r,
      top_p: s,
      random_seed: u,
      // response format:
      response_format: c?.type === "json" ? { type: "json_object" } : void 0,
      // messages:
      messages: pue(e)
    };
    switch (h) {
      case "regular":
        return {
          args: { ...f, ..._ue(t) },
          warnings: d
        };
      case "object-json":
        return {
          args: {
            ...f,
            response_format: { type: "json_object" }
          },
          warnings: d
        };
      case "object-tool":
        return {
          args: {
            ...f,
            tool_choice: "any",
            tools: [{ type: "function", function: t.tool }]
          },
          warnings: d
        };
      default: {
        const g = h;
        throw new Error(`Unsupported type: ${g}`);
      }
    }
  }
  async doGenerate(t) {
    var e, n;
    const { args: r, warnings: s } = this.getArgs(t), { responseHeaders: i, value: o } = await VE({
      url: `${this.config.baseURL}/chat/completions`,
      headers: zE(this.config.headers(), t.headers),
      body: r,
      failedResponseHandler: WE,
      successfulResponseHandler: N$(
        yue
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: a, ...l } = r, c = o.choices[0];
    let u = (e = c.message.content) != null ? e : void 0;
    const h = a[a.length - 1];
    return h.role === "assistant" && u?.startsWith(h.content) && (u = u.slice(h.content.length)), {
      text: u,
      toolCalls: (n = c.message.tool_calls) == null ? void 0 : n.map((d) => ({
        toolCallType: "function",
        toolCallId: d.id,
        toolName: d.function.name,
        args: d.function.arguments
      })),
      finishReason: HI(c.finish_reason),
      usage: {
        promptTokens: o.usage.prompt_tokens,
        completionTokens: o.usage.completion_tokens
      },
      rawCall: { rawPrompt: a, rawSettings: l },
      rawResponse: { headers: i },
      response: zI(o),
      warnings: s
    };
  }
  async doStream(t) {
    const { args: e, warnings: n } = this.getArgs(t), { responseHeaders: r, value: s } = await VE({
      url: `${this.config.baseURL}/chat/completions`,
      headers: zE(this.config.headers(), t.headers),
      body: { ...e, stream: !0 },
      failedResponseHandler: WE,
      successfulResponseHandler: uue(
        bue
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), { messages: i, ...o } = e;
    let a = "unknown", l = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    }, c = 0, u = !1;
    return {
      stream: s.pipeThrough(
        new TransformStream({
          transform(h, d) {
            if (!h.success) {
              d.enqueue({ type: "error", error: h.error });
              return;
            }
            c++;
            const f = h.value;
            c === 1 && d.enqueue({
              type: "response-metadata",
              ...zI(f)
            }), f.usage != null && (l = {
              promptTokens: f.usage.prompt_tokens,
              completionTokens: f.usage.completion_tokens
            });
            const g = f.choices[0];
            if (g?.finish_reason != null && (a = HI(g.finish_reason)), g?.delta == null)
              return;
            const y = g.delta;
            if (c <= 2) {
              const p = i[i.length - 1];
              if (p.role === "assistant" && y.content === p.content.trimEnd()) {
                y.content.length < p.content.length && (u = !0);
                return;
              }
            }
            if (y.content != null && (d.enqueue({
              type: "text-delta",
              textDelta: u ? y.content.trimStart() : y.content
            }), u = !1), y.tool_calls != null)
              for (const p of y.tool_calls)
                d.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: p.id,
                  toolName: p.function.name,
                  argsTextDelta: p.function.arguments
                }), d.enqueue({
                  type: "tool-call",
                  toolCallType: "function",
                  toolCallId: p.id,
                  toolName: p.function.name,
                  args: p.function.arguments
                });
          },
          flush(h) {
            h.enqueue({ type: "finish", finishReason: a, usage: l });
          }
        })
      ),
      rawCall: { rawPrompt: i, rawSettings: o },
      rawResponse: { headers: r },
      warnings: n
    };
  }
}, yue = D.object({
  id: D.string().nullish(),
  created: D.number().nullish(),
  model: D.string().nullish(),
  choices: D.array(
    D.object({
      message: D.object({
        role: D.literal("assistant"),
        content: D.string().nullable(),
        tool_calls: D.array(
          D.object({
            id: D.string(),
            function: D.object({ name: D.string(), arguments: D.string() })
          })
        ).nullish()
      }),
      index: D.number(),
      finish_reason: D.string().nullish()
    })
  ),
  object: D.literal("chat.completion"),
  usage: D.object({
    prompt_tokens: D.number(),
    completion_tokens: D.number()
  })
}), bue = D.object({
  id: D.string().nullish(),
  created: D.number().nullish(),
  model: D.string().nullish(),
  choices: D.array(
    D.object({
      delta: D.object({
        role: D.enum(["assistant"]).optional(),
        content: D.string().nullish(),
        tool_calls: D.array(
          D.object({
            id: D.string(),
            function: D.object({ name: D.string(), arguments: D.string() })
          })
        ).nullish()
      }),
      finish_reason: D.string().nullish(),
      index: D.number()
    })
  ),
  usage: D.object({
    prompt_tokens: D.number(),
    completion_tokens: D.number()
  }).nullish()
});
function _ue(t) {
  var e;
  const n = (e = t.tools) != null && e.length ? t.tools : void 0;
  if (n == null)
    return { tools: void 0, tool_choice: void 0 };
  const r = n.map((o) => ({
    type: "function",
    function: {
      name: o.name,
      description: o.description,
      parameters: o.parameters
    }
  })), s = t.toolChoice;
  if (s == null)
    return { tools: r, tool_choice: void 0 };
  const i = s.type;
  switch (i) {
    case "auto":
    case "none":
      return { tools: r, tool_choice: i };
    case "required":
      return { tools: r, tool_choice: "any" };
    case "tool":
      return {
        tools: r.filter(
          (o) => o.function.name === s.toolName
        ),
        tool_choice: "any"
      };
    default: {
      const o = i;
      throw new Error(`Unsupported tool choice type: ${o}`);
    }
  }
}
var vue = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    var t;
    return (t = this.settings.maxEmbeddingsPerCall) != null ? t : 32;
  }
  get supportsParallelCalls() {
    var t;
    return (t = this.settings.supportsParallelCalls) != null ? t : !1;
  }
  async doEmbed({
    values: t,
    abortSignal: e,
    headers: n
  }) {
    if (t.length > this.maxEmbeddingsPerCall)
      throw new Gce({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values: t
      });
    const { responseHeaders: r, value: s } = await VE({
      url: `${this.config.baseURL}/embeddings`,
      headers: zE(this.config.headers(), n),
      body: {
        model: this.modelId,
        input: t,
        encoding_format: "float"
      },
      failedResponseHandler: WE,
      successfulResponseHandler: N$(
        wue
      ),
      abortSignal: e,
      fetch: this.config.fetch
    });
    return {
      embeddings: s.data.map((i) => i.embedding),
      usage: s.usage ? { tokens: s.usage.prompt_tokens } : void 0,
      rawResponse: { headers: r }
    };
  }
}, wue = D.object({
  data: D.array(D.object({ embedding: D.array(D.number()) })),
  usage: D.object({ prompt_tokens: D.number() }).nullish()
});
function L$(t = {}) {
  var e, n;
  const r = (n = fue((e = t.baseURL) != null ? e : t.baseUrl)) != null ? n : "https://api.mistral.ai/v1", s = () => ({
    Authorization: `Bearer ${Qce({
      apiKey: t.apiKey,
      environmentVariableName: "MISTRAL_API_KEY",
      description: "Mistral"
    })}`,
    ...t.headers
  }), i = (l, c = {}) => new gue(l, c, {
    provider: "mistral.chat",
    baseURL: r,
    headers: s,
    fetch: t.fetch
  }), o = (l, c = {}) => new vue(l, c, {
    provider: "mistral.embedding",
    baseURL: r,
    headers: s,
    fetch: t.fetch
  }), a = function(l, c) {
    if (new.target)
      throw new Error(
        "The Mistral model function cannot be called with the new keyword."
      );
    return i(l, c);
  };
  return a.languageModel = i, a.chat = i, a.embedding = o, a.textEmbedding = o, a.textEmbeddingModel = o, a;
}
L$();
class Eue extends mn {
  name = "Mistral";
  getApiKeyLink = "https://console.mistral.ai/api-keys/";
  config = {
    apiTokenKey: "MISTRAL_API_KEY"
  };
  staticModels = [
    { name: "open-mistral-7b", label: "Mistral 7B", provider: "Mistral", maxTokenAllowed: 8e3 },
    { name: "open-mixtral-8x7b", label: "Mistral 8x7B", provider: "Mistral", maxTokenAllowed: 8e3 },
    { name: "open-mixtral-8x22b", label: "Mistral 8x22B", provider: "Mistral", maxTokenAllowed: 8e3 },
    { name: "open-codestral-mamba", label: "Codestral Mamba", provider: "Mistral", maxTokenAllowed: 8e3 },
    { name: "open-mistral-nemo", label: "Mistral Nemo", provider: "Mistral", maxTokenAllowed: 8e3 },
    { name: "ministral-8b-latest", label: "Mistral 8B", provider: "Mistral", maxTokenAllowed: 8e3 },
    { name: "mistral-small-latest", label: "Mistral Small", provider: "Mistral", maxTokenAllowed: 8e3 },
    { name: "codestral-latest", label: "Codestral", provider: "Mistral", maxTokenAllowed: 8e3 },
    { name: "mistral-large-latest", label: "Mistral Large Latest", provider: "Mistral", maxTokenAllowed: 8e3 }
  ];
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "MISTRAL_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return L$({
      apiKey: o
    })(n);
  }
}
let Sue = (t, e = 21) => (n = e) => {
  let r = "", s = n;
  for (; s--; )
    r += t[Math.random() * t.length | 0];
  return r;
};
var M$ = "vercel.ai.error", xue = Symbol.for(M$), B$, Tue = class F$ extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[B$] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return F$.hasMarker(e, M$);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
  /**
   * Returns a JSON representation of the error.
   * @returns {Object} An object containing the error's name, message, and cause.
   *
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message
    };
  }
};
B$ = xue;
var is = Tue, qE = "AI_APICallError", $$ = `vercel.ai.error.${qE}`, Cue = Symbol.for($$), U$, Yi = class extends is {
  constructor({
    message: e,
    url: n,
    requestBodyValues: r,
    statusCode: s,
    responseHeaders: i,
    responseBody: o,
    cause: a,
    isRetryable: l = s != null && (s === 408 || // request timeout
    s === 409 || // conflict
    s === 429 || // too many requests
    s >= 500),
    // server error
    data: c
  }) {
    super({ name: qE, message: e, cause: a }), this[U$] = !0, this.url = n, this.requestBodyValues = r, this.statusCode = s, this.responseHeaders = i, this.responseBody = o, this.isRetryable = l, this.data = c;
  }
  static isInstance(e) {
    return is.hasMarker(e, $$);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isAPICallError(e) {
    return e instanceof Error && e.name === qE && typeof e.url == "string" && typeof e.requestBodyValues == "object" && (e.statusCode == null || typeof e.statusCode == "number") && (e.responseHeaders == null || typeof e.responseHeaders == "object") && (e.responseBody == null || typeof e.responseBody == "string") && (e.cause == null || typeof e.cause == "object") && typeof e.isRetryable == "boolean" && (e.data == null || typeof e.data == "object");
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      url: this.url,
      requestBodyValues: this.requestBodyValues,
      statusCode: this.statusCode,
      responseHeaders: this.responseHeaders,
      responseBody: this.responseBody,
      cause: this.cause,
      isRetryable: this.isRetryable,
      data: this.data
    };
  }
};
U$ = Cue;
var KE = "AI_EmptyResponseBodyError", j$ = `vercel.ai.error.${KE}`, kue = Symbol.for(j$), H$, Aue = class extends is {
  // used in isInstance
  constructor({ message: e = "Empty response body" } = {}) {
    super({ name: KE, message: e }), this[H$] = !0;
  }
  static isInstance(e) {
    return is.hasMarker(e, j$);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isEmptyResponseBodyError(e) {
    return e instanceof Error && e.name === KE;
  }
};
H$ = kue;
function z$(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var YE = "AI_JSONParseError", G$ = `vercel.ai.error.${YE}`, Rue = Symbol.for(G$), V$, x0 = class extends is {
  constructor({ text: e, cause: n }) {
    super({
      name: YE,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${z$(n)}`,
      cause: n
    }), this[V$] = !0, this.text = e;
  }
  static isInstance(e) {
    return is.hasMarker(e, G$);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isJSONParseError(e) {
    return e instanceof Error && e.name === YE && "text" in e && typeof e.text == "string";
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      valueText: this.text
    };
  }
};
V$ = Rue;
var ZE = "AI_TooManyEmbeddingValuesForCallError", W$ = `vercel.ai.error.${ZE}`, Iue = Symbol.for(W$), q$, Pue = class extends is {
  constructor(t) {
    super({
      name: ZE,
      message: `Too many values for a single embedding call. The ${t.provider} model "${t.modelId}" can only embed up to ${t.maxEmbeddingsPerCall} values per call, but ${t.values.length} values were provided.`
    }), this[q$] = !0, this.provider = t.provider, this.modelId = t.modelId, this.maxEmbeddingsPerCall = t.maxEmbeddingsPerCall, this.values = t.values;
  }
  static isInstance(t) {
    return is.hasMarker(t, W$);
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isTooManyEmbeddingValuesForCallError(t) {
    return t instanceof Error && t.name === ZE && "provider" in t && typeof t.provider == "string" && "modelId" in t && typeof t.modelId == "string" && "maxEmbeddingsPerCall" in t && typeof t.maxEmbeddingsPerCall == "number" && "values" in t && Array.isArray(t.values);
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      provider: this.provider,
      modelId: this.modelId,
      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
      values: this.values
    };
  }
};
q$ = Iue;
var JE = "AI_TypeValidationError", K$ = `vercel.ai.error.${JE}`, Oue = Symbol.for(K$), Y$, Due = class XE extends is {
  constructor({ value: e, cause: n }) {
    super({
      name: JE,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${z$(n)}`,
      cause: n
    }), this[Y$] = !0, this.value = e;
  }
  static isInstance(e) {
    return is.hasMarker(e, K$);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: e,
    cause: n
  }) {
    return XE.isInstance(n) && n.value === e ? n : new XE({ value: e, cause: n });
  }
  /**
   * @deprecated use `isInstance` instead
   */
  static isTypeValidationError(e) {
    return e instanceof Error && e.name === JE;
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      value: this.value
    };
  }
};
Y$ = Oue;
var T0 = Due, QE = "AI_UnsupportedFunctionalityError", Z$ = `vercel.ai.error.${QE}`, Nue = Symbol.for(Z$), J$, Lue = class extends is {
  constructor({ functionality: e }) {
    super({
      name: QE,
      message: `'${e}' functionality not supported.`
    }), this[J$] = !0, this.functionality = e;
  }
  static isInstance(e) {
    return is.hasMarker(e, Z$);
  }
  /**
   * @deprecated Use isInstance instead.
   */
  static isUnsupportedFunctionalityError(e) {
    return e instanceof Error && e.name === QE && typeof e.functionality == "string";
  }
  /**
   * @deprecated Do not use this method. It will be removed in the next major version.
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      functionality: this.functionality
    };
  }
};
J$ = Nue;
function GI(...t) {
  return t.reduce(
    (e, n) => ({
      ...e,
      ...n ?? {}
    }),
    {}
  );
}
function Eb(t) {
  const e = {};
  return t.headers.forEach((n, r) => {
    e[r] = n;
  }), e;
}
var Mue = ({
  prefix: t = "",
  size: e = 7,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
} = {}) => {
  const r = Sue(n, e);
  return (s) => `${t}${r(s)}`;
}, X$ = Mue();
function _v(t) {
  return t instanceof Error && (t.name === "AbortError" || t.name === "TimeoutError");
}
var eS = Symbol.for("vercel.ai.validator");
function Bue(t) {
  return { [eS]: !0, validate: t };
}
function Fue(t) {
  return typeof t == "object" && t !== null && eS in t && t[eS] === !0 && "validate" in t;
}
function $ue(t) {
  return Fue(t) ? t : Uue(t);
}
function Uue(t) {
  return Bue((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function jue({
  value: t,
  schema: e
}) {
  const n = Q$({ value: t, schema: e });
  if (!n.success)
    throw T0.wrap({ value: t, cause: n.error });
  return n.value;
}
function Q$({
  value: t,
  schema: e
}) {
  const n = $ue(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: T0.wrap({ value: t, cause: r.error })
    };
  } catch (r) {
    return {
      success: !1,
      error: T0.wrap({ value: t, cause: r })
    };
  }
}
function Hue({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? n : jue({ value: n, schema: e });
  } catch (n) {
    throw x0.isJSONParseError(n) || T0.isTypeValidationError(n) ? n : new x0({ text: t, cause: n });
  }
}
function eU({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? {
      success: !0,
      value: n
    } : Q$({ value: n, schema: e });
  } catch (n) {
    return {
      success: !1,
      error: x0.isJSONParseError(n) ? n : new x0({ text: t, cause: n })
    };
  }
}
function zue(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n != null)
  );
}
var Gue = () => globalThis.fetch, tS = async ({
  url: t,
  headers: e,
  body: n,
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}) => Vue({
  url: t,
  headers: {
    "Content-Type": "application/json",
    ...e
  },
  body: {
    content: JSON.stringify(n),
    values: n
  },
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}), Vue = async ({
  url: t,
  headers: e = {},
  body: n,
  successfulResponseHandler: r,
  failedResponseHandler: s,
  abortSignal: i,
  fetch: o = Gue()
}) => {
  try {
    const a = await o(t, {
      method: "POST",
      headers: zue(e),
      body: n.content,
      signal: i
    }), l = Eb(a);
    if (!a.ok) {
      let c;
      try {
        c = await s({
          response: a,
          url: t,
          requestBodyValues: n.values
        });
      } catch (u) {
        throw _v(u) || Yi.isAPICallError(u) ? u : new Yi({
          message: "Failed to process error response",
          cause: u,
          statusCode: a.status,
          url: t,
          responseHeaders: l,
          requestBodyValues: n.values
        });
      }
      throw c.value;
    }
    try {
      return await r({
        response: a,
        url: t,
        requestBodyValues: n.values
      });
    } catch (c) {
      throw c instanceof Error && (_v(c) || Yi.isAPICallError(c)) ? c : new Yi({
        message: "Failed to process successful response",
        cause: c,
        statusCode: a.status,
        url: t,
        responseHeaders: l,
        requestBodyValues: n.values
      });
    }
  } catch (a) {
    if (_v(a))
      throw a;
    if (a instanceof TypeError && a.message === "fetch failed") {
      const l = a.cause;
      if (l != null)
        throw new Yi({
          message: `Cannot connect to API: ${l.message}`,
          cause: l,
          url: t,
          requestBodyValues: n.values,
          isRetryable: !0
          // retry when network error
        });
    }
    throw a;
  }
}, Wue = ({
  errorSchema: t,
  errorToMessage: e,
  isRetryable: n
}) => async ({ response: r, url: s, requestBodyValues: i }) => {
  const o = await r.text(), a = Eb(r);
  if (o.trim() === "")
    return {
      responseHeaders: a,
      value: new Yi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  try {
    const l = Hue({
      text: o,
      schema: t
    });
    return {
      responseHeaders: a,
      value: new Yi({
        message: e(l),
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        data: l,
        isRetryable: n?.(r, l)
      })
    };
  } catch {
    return {
      responseHeaders: a,
      value: new Yi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  }
}, tU = (t) => async ({ response: e, url: n, requestBodyValues: r }) => {
  const s = await e.text(), i = eU({
    text: s,
    schema: t
  }), o = Eb(e);
  if (!i.success)
    throw new Yi({
      message: "Invalid JSON response",
      cause: i.error,
      statusCode: e.status,
      responseHeaders: o,
      responseBody: s,
      url: n,
      requestBodyValues: r
    });
  return {
    responseHeaders: o,
    value: i.value
  };
}, { btoa: que } = globalThis;
function Kue(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCodePoint(t[n]);
  return que(e);
}
function Yue(t) {
  return t?.replace(/\/$/, "");
}
var nU = {}, nS = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Allow = t.ALL = t.COLLECTION = t.ATOM = t.SPECIAL = t.INF = t._INFINITY = t.INFINITY = t.NAN = t.BOOL = t.NULL = t.OBJ = t.ARR = t.NUM = t.STR = void 0, t.STR = 1, t.NUM = 2, t.ARR = 4, t.OBJ = 8, t.NULL = 16, t.BOOL = 32, t.NAN = 64, t.INFINITY = 128, t._INFINITY = 256, t.INF = t.INFINITY | t._INFINITY, t.SPECIAL = t.NULL | t.BOOL | t.INF | t.NAN, t.ATOM = t.STR | t.NUM | t.SPECIAL, t.COLLECTION = t.ARR | t.OBJ, t.ALL = t.ATOM | t.COLLECTION, t.Allow = { STR: t.STR, NUM: t.NUM, ARR: t.ARR, OBJ: t.OBJ, NULL: t.NULL, BOOL: t.BOOL, NAN: t.NAN, INFINITY: t.INFINITY, _INFINITY: t._INFINITY, INF: t.INF, SPECIAL: t.SPECIAL, ATOM: t.ATOM, COLLECTION: t.COLLECTION, ALL: t.ALL }, t.default = t.Allow;
})(nS);
(function(t) {
  var e = Jn && Jn.__createBinding || (Object.create ? function(c, u, h, d) {
    d === void 0 && (d = h);
    var f = Object.getOwnPropertyDescriptor(u, h);
    (!f || ("get" in f ? !u.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return u[h];
    } }), Object.defineProperty(c, d, f);
  } : function(c, u, h, d) {
    d === void 0 && (d = h), c[d] = u[h];
  }), n = Jn && Jn.__exportStar || function(c, u) {
    for (var h in c) h !== "default" && !Object.prototype.hasOwnProperty.call(u, h) && e(u, c, h);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Allow = t.MalformedJSON = t.PartialJSON = t.parseJSON = t.parse = void 0;
  const r = nS;
  Object.defineProperty(t, "Allow", { enumerable: !0, get: function() {
    return r.Allow;
  } }), n(nS, t);
  class s extends Error {
  }
  t.PartialJSON = s;
  class i extends Error {
  }
  t.MalformedJSON = i;
  function o(c, u = r.Allow.ALL) {
    if (typeof c != "string")
      throw new TypeError(`expecting str, got ${typeof c}`);
    if (!c.trim())
      throw new Error(`${c} is empty`);
    return a(c.trim(), u);
  }
  t.parseJSON = o;
  const a = (c, u) => {
    const h = c.length;
    let d = 0;
    const f = (w) => {
      throw new s(`${w} at position ${d}`);
    }, g = (w) => {
      throw new i(`${w} at position ${d}`);
    }, y = () => (v(), d >= h && f("Unexpected end of input"), c[d] === '"' ? p() : c[d] === "{" ? m() : c[d] === "[" ? b() : c.substring(d, d + 4) === "null" || r.Allow.NULL & u && h - d < 4 && "null".startsWith(c.substring(d)) ? (d += 4, null) : c.substring(d, d + 4) === "true" || r.Allow.BOOL & u && h - d < 4 && "true".startsWith(c.substring(d)) ? (d += 4, !0) : c.substring(d, d + 5) === "false" || r.Allow.BOOL & u && h - d < 5 && "false".startsWith(c.substring(d)) ? (d += 5, !1) : c.substring(d, d + 8) === "Infinity" || r.Allow.INFINITY & u && h - d < 8 && "Infinity".startsWith(c.substring(d)) ? (d += 8, 1 / 0) : c.substring(d, d + 9) === "-Infinity" || r.Allow._INFINITY & u && 1 < h - d && h - d < 9 && "-Infinity".startsWith(c.substring(d)) ? (d += 9, -1 / 0) : c.substring(d, d + 3) === "NaN" || r.Allow.NAN & u && h - d < 3 && "NaN".startsWith(c.substring(d)) ? (d += 3, NaN) : _()), p = () => {
      const w = d;
      let E = !1;
      for (d++; d < h && (c[d] !== '"' || E && c[d - 1] === "\\"); )
        E = c[d] === "\\" ? !E : !1, d++;
      if (c.charAt(d) == '"')
        try {
          return JSON.parse(c.substring(w, ++d - Number(E)));
        } catch (x) {
          g(String(x));
        }
      else if (r.Allow.STR & u)
        try {
          return JSON.parse(c.substring(w, d - Number(E)) + '"');
        } catch {
          return JSON.parse(c.substring(w, c.lastIndexOf("\\")) + '"');
        }
      f("Unterminated string literal");
    }, m = () => {
      d++, v();
      const w = {};
      try {
        for (; c[d] !== "}"; ) {
          if (v(), d >= h && r.Allow.OBJ & u)
            return w;
          const E = p();
          v(), d++;
          try {
            const x = y();
            w[E] = x;
          } catch (x) {
            if (r.Allow.OBJ & u)
              return w;
            throw x;
          }
          v(), c[d] === "," && d++;
        }
      } catch {
        if (r.Allow.OBJ & u)
          return w;
        f("Expected '}' at end of object");
      }
      return d++, w;
    }, b = () => {
      d++;
      const w = [];
      try {
        for (; c[d] !== "]"; )
          w.push(y()), v(), c[d] === "," && d++;
      } catch {
        if (r.Allow.ARR & u)
          return w;
        f("Expected ']' at end of array");
      }
      return d++, w;
    }, _ = () => {
      if (d === 0) {
        c === "-" && g("Not sure what '-' is");
        try {
          return JSON.parse(c);
        } catch (E) {
          if (r.Allow.NUM & u)
            try {
              return JSON.parse(c.substring(0, c.lastIndexOf("e")));
            } catch {
            }
          g(String(E));
        }
      }
      const w = d;
      for (c[d] === "-" && d++; c[d] && ",]}".indexOf(c[d]) === -1; )
        d++;
      d == h && !(r.Allow.NUM & u) && f("Unterminated number literal");
      try {
        return JSON.parse(c.substring(w, d));
      } catch {
        c.substring(w, d) === "-" && f("Not sure what '-' is");
        try {
          return JSON.parse(c.substring(w, c.lastIndexOf("e")));
        } catch (x) {
          g(String(x));
        }
      }
    }, v = () => {
      for (; d < h && ` 
\r	`.includes(c[d]); )
        d++;
    };
    return y();
  }, l = o;
  t.parse = l;
})(nU);
function vv(t) {
  const e = [];
  for (const { content: n, role: r } of t)
    switch (r) {
      case "system": {
        e.push({ content: n, role: "system" });
        break;
      }
      case "user": {
        e.push({
          ...n.reduce(
            (s, i) => {
              if (i.type === "text")
                s.content += i.text;
              else {
                if (i.type === "image" && i.image instanceof URL)
                  throw new Lue({
                    functionality: "Image URLs in user messages"
                  });
                i.type === "image" && i.image instanceof Uint8Array && (s.images = s.images || [], s.images.push(Kue(i.image)));
              }
              return s;
            },
            { content: "" }
          ),
          role: "user"
        });
        break;
      }
      case "assistant": {
        const s = [], i = [];
        for (const o of n)
          switch (o.type) {
            case "text": {
              s.push(o.text);
              break;
            }
            case "tool-call": {
              i.push({
                function: {
                  arguments: o.args,
                  name: o.toolName
                },
                id: o.toolCallId,
                type: "function"
              });
              break;
            }
            default: {
              const a = o;
              throw new Error(`Unsupported part: ${a}`);
            }
          }
        e.push({
          content: s.join(","),
          role: "assistant",
          tool_calls: i.length > 0 ? i : void 0
        });
        break;
      }
      case "tool": {
        e.push(
          ...n.map((s) => ({
            // Non serialized contents are not accepted by ollama, triggering the following error:
            // "json: cannot unmarshal array into Go struct field ChatRequest.messages of type string"
            content: typeof s.result == "object" ? JSON.stringify(s.result) : `${s.result}`,
            role: "tool",
            tool_call_id: s.toolCallId
          }))
        );
        break;
      }
      default: {
        const s = r;
        throw new Error(`Unsupported role: ${s}`);
      }
    }
  return e;
}
var Zue = class {
  constructor({
    tools: t,
    type: e
  }) {
    this._firstMessage = !0, this._tools = t, this._toolPartial = "", this._toolCalls = [], this._type = e, this._detectedToolCall = !1;
  }
  get toolCalls() {
    return this._toolCalls;
  }
  get detectedToolCall() {
    return this._detectedToolCall;
  }
  parse({
    controller: t,
    delta: e
  }) {
    var n;
    if (this.detectToolCall(e), !this._detectedToolCall)
      return !1;
    this._toolPartial += e;
    let r = nU.parse(this._toolPartial);
    Array.isArray(r) || (r = [r]);
    for (const [s, i] of r.entries()) {
      const o = (n = JSON.stringify(i?.parameters)) != null ? n : "";
      if (o === "")
        continue;
      this._toolCalls[s] || (this._toolCalls[s] = {
        function: {
          arguments: "",
          name: i.name
        },
        id: X$(),
        type: "function"
      });
      const a = this._toolCalls[s];
      a.function.arguments = o, t.enqueue({
        argsTextDelta: e,
        toolCallId: a.id,
        toolCallType: "function",
        toolName: a.function.name,
        type: "tool-call-delta"
      });
    }
    return !0;
  }
  finish({
    controller: t
  }) {
    for (const e of this.toolCalls)
      t.enqueue({
        args: e.function.arguments,
        toolCallId: e.id,
        toolCallType: "function",
        toolName: e.function.name,
        type: "tool-call"
      });
    return this.finishReason();
  }
  detectToolCall(t) {
    !this._tools || this._tools.length === 0 || this._firstMessage && (this._type === "object-tool" ? this._detectedToolCall = !0 : this._type === "regular" && (t.trim().startsWith("{") || t.trim().startsWith("[")) && (this._detectedToolCall = !0), this._firstMessage = !1);
  }
  finishReason() {
    return this.detectedToolCall ? this._type === "object-tool" ? "stop" : "tool-calls" : "stop";
  }
};
function Jue({
  finishReason: t,
  hasToolCalls: e
}) {
  switch (t) {
    case "stop":
      return e ? "tool-calls" : "stop";
    default:
      return "other";
  }
}
var Xue = D.object({
  error: D.object({
    code: D.string().nullable(),
    message: D.string(),
    param: D.any().nullable(),
    type: D.string()
  })
}), rS = Wue({
  errorSchema: Xue,
  errorToMessage: (t) => t.error.message
});
function Que(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([, e]) => e !== void 0)
  );
}
var ehe = class extends TransformStream {
  constructor() {
    super({
      flush: (t) => {
        this.buffer.length !== 0 && t.enqueue(this.buffer);
      },
      transform: (t, e) => {
        for (t = this.buffer + t; ; ) {
          const n = t.indexOf(`
`);
          if (n === -1) break;
          e.enqueue(t.slice(0, n)), t = t.slice(n + 1);
        }
        this.buffer = t;
      }
    }), this.buffer = "";
  }
}, the = (t) => async ({ response: e }) => {
  const n = Eb(e);
  if (e.body === null)
    throw new Aue({});
  return {
    responseHeaders: n,
    value: e.body.pipeThrough(new TextDecoderStream()).pipeThrough(new ehe()).pipeThrough(
      new TransformStream({
        transform(r, s) {
          s.enqueue(
            eU({
              schema: t,
              text: r
            })
          );
        }
      })
    )
  };
}, nhe = class {
  constructor(t, e, n) {
    this.modelId = t, this.settings = e, this.config = n, this.specificationVersion = "v1", this.defaultObjectGenerationMode = "json", this.supportsImageUrls = !1;
  }
  get provider() {
    return this.config.provider;
  }
  getArguments({
    frequencyPenalty: t,
    maxTokens: e,
    mode: n,
    presencePenalty: r,
    prompt: s,
    responseFormat: i,
    seed: o,
    stopSequences: a,
    temperature: l,
    topK: c,
    topP: u
  }) {
    var h, d, f;
    const g = n.type, y = [];
    i !== void 0 && i.type === "json" && i.schema !== void 0 && y.push({
      details: "JSON response format schema is not supported",
      setting: "responseFormat",
      type: "unsupported-setting"
    });
    const p = {
      format: i?.type,
      model: this.modelId,
      options: Que({
        f16_kv: this.settings.f16Kv,
        frequency_penalty: t,
        low_vram: this.settings.lowVram,
        main_gpu: this.settings.mainGpu,
        min_p: this.settings.minP,
        mirostat: this.settings.mirostat,
        mirostat_eta: this.settings.mirostatEta,
        mirostat_tau: this.settings.mirostatTau,
        num_batch: this.settings.numBatch,
        num_ctx: this.settings.numCtx,
        num_gpu: this.settings.numGpu,
        num_keep: this.settings.numKeep,
        num_predict: e,
        num_thread: this.settings.numThread,
        numa: this.settings.numa,
        penalize_newline: this.settings.penalizeNewline,
        presence_penalty: r,
        repeat_last_n: this.settings.repeatLastN,
        repeat_penalty: this.settings.repeatPenalty,
        seed: o,
        stop: (h = this.settings.stop) != null ? h : a,
        temperature: l,
        tfs_z: this.settings.tfsZ,
        top_k: (d = this.settings.topK) != null ? d : c,
        top_p: u,
        typical_p: this.settings.typicalP,
        use_mlock: this.settings.useMlock,
        use_mmap: this.settings.useMmap,
        vocab_only: this.settings.vocabOnly
      })
    };
    switch (g) {
      case "regular": {
        const m = (f = n.tools) != null && f.length ? n.tools : void 0;
        return {
          args: {
            ...p,
            messages: vv(s),
            tools: m?.map((b) => ({
              function: {
                description: b.description,
                name: b.name,
                parameters: b.parameters
              },
              type: "function"
            }))
          },
          type: g,
          warnings: y
        };
      }
      case "object-json":
        return {
          args: {
            ...p,
            format: "json",
            messages: vv(s)
          },
          type: g,
          warnings: y
        };
      case "object-tool":
        return {
          args: {
            ...p,
            messages: vv(s),
            tool_choice: {
              function: { name: n.tool.name },
              type: "function"
            },
            tools: [
              {
                function: {
                  description: n.tool.description,
                  name: n.tool.name,
                  parameters: n.tool.parameters
                },
                type: "function"
              }
            ]
          },
          type: g,
          warnings: y
        };
      default: {
        const m = g;
        throw new Error(`Unsupported type: ${m}`);
      }
    }
  }
  async doGenerate(t) {
    var e, n;
    const { args: r, warnings: s } = this.getArguments(t), { responseHeaders: i, value: o } = await tS({
      abortSignal: t.abortSignal,
      body: {
        ...r,
        stream: !1
      },
      failedResponseHandler: rS,
      fetch: this.config.fetch,
      headers: GI(this.config.headers(), t.headers),
      successfulResponseHandler: tU(
        rhe
      ),
      url: `${this.config.baseURL}/chat`
    }), { messages: a, ...l } = r, c = (e = o.message.tool_calls) == null ? void 0 : e.map((u) => {
      var h;
      return {
        args: JSON.stringify(u.function.arguments),
        toolCallId: (h = u.id) != null ? h : X$(),
        toolCallType: "function",
        toolName: u.function.name
      };
    });
    return {
      finishReason: Jue({
        finishReason: o.done_reason,
        hasToolCalls: c !== void 0 && c.length > 0
      }),
      rawCall: { rawPrompt: a, rawSettings: l },
      rawResponse: { headers: i },
      text: (n = o.message.content) != null ? n : void 0,
      toolCalls: c,
      usage: {
        completionTokens: o.eval_count || 0,
        promptTokens: o.prompt_eval_count || 0
      },
      warnings: s
    };
  }
  async doStream(t) {
    const { args: e, type: n, warnings: r } = this.getArguments(t), { responseHeaders: s, value: i } = await tS({
      abortSignal: t.abortSignal,
      body: e,
      failedResponseHandler: rS,
      fetch: this.config.fetch,
      headers: GI(this.config.headers(), t.headers),
      successfulResponseHandler: the(
        she
      ),
      url: `${this.config.baseURL}/chat`
    }), { messages: o, ...a } = e, l = t.mode.type === "regular" ? t.mode.tools : t.mode.type === "object-tool" ? [t.mode.tool] : void 0, c = new Zue({
      tools: l,
      type: n
    });
    let u = "other", h = {
      completionTokens: Number.NaN,
      promptTokens: Number.NaN
    };
    const { experimentalStreamTools: d = !0 } = this.settings;
    return {
      rawCall: { rawPrompt: o, rawSettings: a },
      rawResponse: { headers: s },
      stream: i.pipeThrough(
        new TransformStream({
          async flush(f) {
            f.enqueue({
              finishReason: u,
              type: "finish",
              usage: h
            });
          },
          async transform(f, g) {
            if (!f.success) {
              g.enqueue({ error: f.error, type: "error" });
              return;
            }
            const y = f.value;
            if (y.done) {
              u = c.finish({ controller: g }), h = {
                completionTokens: y.eval_count,
                promptTokens: y.prompt_eval_count || 0
              };
              return;
            }
            d && c.parse({
              controller: g,
              delta: y.message.content
            }) || y.message.content !== null && g.enqueue({
              textDelta: y.message.content,
              type: "text-delta"
            });
          }
        })
      ),
      warnings: r
    };
  }
}, rhe = D.object({
  created_at: D.string(),
  done: D.literal(!0),
  done_reason: D.string().optional().nullable(),
  eval_count: D.number(),
  eval_duration: D.number(),
  load_duration: D.number().optional(),
  message: D.object({
    content: D.string(),
    role: D.string(),
    tool_calls: D.array(
      D.object({
        function: D.object({
          arguments: D.record(D.any()),
          name: D.string()
        }),
        id: D.string().optional()
      })
    ).optional().nullable()
  }),
  model: D.string(),
  prompt_eval_count: D.number().optional(),
  prompt_eval_duration: D.number().optional(),
  total_duration: D.number()
}), she = D.discriminatedUnion("done", [
  D.object({
    created_at: D.string(),
    done: D.literal(!1),
    message: D.object({
      content: D.string(),
      role: D.string()
    }),
    model: D.string()
  }),
  D.object({
    created_at: D.string(),
    done: D.literal(!0),
    eval_count: D.number(),
    eval_duration: D.number(),
    load_duration: D.number().optional(),
    model: D.string(),
    prompt_eval_count: D.number().optional(),
    prompt_eval_duration: D.number().optional(),
    total_duration: D.number()
  })
]), ihe = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    var t;
    return (t = this.settings.maxEmbeddingsPerCall) != null ? t : 2048;
  }
  get supportsParallelCalls() {
    return !1;
  }
  async doEmbed({
    abortSignal: t,
    values: e
  }) {
    if (e.length > this.maxEmbeddingsPerCall)
      throw new Pue({
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        modelId: this.modelId,
        provider: this.provider,
        values: e
      });
    const { responseHeaders: n, value: r } = await tS({
      abortSignal: t,
      body: {
        input: e,
        model: this.modelId
      },
      failedResponseHandler: rS,
      fetch: this.config.fetch,
      headers: this.config.headers(),
      successfulResponseHandler: tU(
        ohe
      ),
      url: `${this.config.baseURL}/embed`
    });
    return {
      embeddings: r.embeddings,
      rawResponse: { headers: n },
      usage: r.prompt_eval_count ? { tokens: r.prompt_eval_count } : void 0
    };
  }
}, ohe = D.object({
  embeddings: D.array(D.array(D.number())),
  prompt_eval_count: D.number().nullable()
});
function ahe(t = {}) {
  var e;
  const n = (e = Yue(t.baseURL)) != null ? e : "http://127.0.0.1:11434/api", r = () => ({
    ...t.headers
  }), s = (a, l = {}) => new nhe(a, l, {
    baseURL: n,
    fetch: t.fetch,
    headers: r,
    provider: "ollama.chat"
  }), i = (a, l = {}) => new ihe(a, l, {
    baseURL: n,
    fetch: t.fetch,
    headers: r,
    provider: "ollama.embedding"
  }), o = function(a, l) {
    if (new.target)
      throw new Error(
        "The Ollama model function cannot be called with the new keyword."
      );
    return s(a, l);
  };
  return o.chat = s, o.embedding = i, o.languageModel = s, o.textEmbedding = i, o.textEmbeddingModel = i, o;
}
var lhe = ahe();
const che = je?.env?.DEFAULT_NUM_CTX ? parseInt(je.env.DEFAULT_NUM_CTX, 10) : 32768;
class uhe extends mn {
  name = "Ollama";
  getApiKeyLink = "https://ollama.com/download";
  labelForGetApiKey = "Download Ollama";
  icon = "i-ph:cloud-arrow-down";
  config = {
    baseUrlKey: "OLLAMA_API_BASE_URL"
  };
  staticModels = [];
  async getDynamicModels(e, n, r = {}) {
    let { baseUrl: s } = this.getProviderBaseUrlAndKey({
      apiKeys: e,
      providerSettings: n,
      serverEnv: r,
      defaultBaseUrlKey: "OLLAMA_API_BASE_URL",
      defaultApiTokenKey: ""
    });
    if (!s)
      throw new Error("No baseUrl found for OLLAMA provider");
    if (typeof window > "u") {
      const a = je?.env?.RUNNING_IN_DOCKER === "true" || r?.RUNNING_IN_DOCKER === "true";
      s = a ? s.replace("localhost", "host.docker.internal") : s, s = a ? s.replace("127.0.0.1", "host.docker.internal") : s;
    }
    return (await (await fetch(`${s}/api/tags`)).json()).models.map((a) => ({
      name: a.name,
      label: `${a.name} (${a.details.parameter_size})`,
      provider: this.name,
      maxTokenAllowed: 8e3
    }));
  }
  getModelInstance = (e) => {
    const { apiKeys: n, providerSettings: r, serverEnv: s, model: i } = e;
    let { baseUrl: o } = this.getProviderBaseUrlAndKey({
      apiKeys: n,
      providerSettings: r?.[this.name],
      serverEnv: s,
      defaultBaseUrlKey: "OLLAMA_API_BASE_URL",
      defaultApiTokenKey: ""
    });
    if (!o)
      throw new Error("No baseUrl found for OLLAMA provider");
    const a = je?.env?.RUNNING_IN_DOCKER === "true" || s?.RUNNING_IN_DOCKER === "true";
    o = a ? o.replace("localhost", "host.docker.internal") : o, o = a ? o.replace("127.0.0.1", "host.docker.internal") : o, wB.debug("Ollama Base Url used: ", o);
    const l = lhe(i, {
      numCtx: che
    });
    return l.config.baseURL = `${o}/api`, l;
  };
}
var Zi = class extends Error {
  constructor({
    message: t,
    url: e,
    requestBodyValues: n,
    statusCode: r,
    responseHeaders: s,
    responseBody: i,
    cause: o,
    isRetryable: a = r != null && (r === 408 || // request timeout
    r === 409 || // conflict
    r === 429 || // too many requests
    r >= 500),
    // server error
    data: l
  }) {
    super(t), this.name = "AI_APICallError", this.url = e, this.requestBodyValues = n, this.statusCode = r, this.responseHeaders = s, this.responseBody = i, this.cause = o, this.isRetryable = a, this.data = l;
  }
  static isAPICallError(t) {
    return t instanceof Error && t.name === "AI_APICallError" && typeof t.url == "string" && typeof t.requestBodyValues == "object" && (t.statusCode == null || typeof t.statusCode == "number") && (t.responseHeaders == null || typeof t.responseHeaders == "object") && (t.responseBody == null || typeof t.responseBody == "string") && (t.cause == null || typeof t.cause == "object") && typeof t.isRetryable == "boolean" && (t.data == null || typeof t.data == "object");
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      url: this.url,
      requestBodyValues: this.requestBodyValues,
      statusCode: this.statusCode,
      responseHeaders: this.responseHeaders,
      responseBody: this.responseBody,
      cause: this.cause,
      isRetryable: this.isRetryable,
      data: this.data
    };
  }
}, hhe = class extends Error {
  constructor({ message: t = "Empty response body" } = {}) {
    super(t), this.name = "AI_EmptyResponseBodyError";
  }
  static isEmptyResponseBodyError(t) {
    return t instanceof Error && t.name === "AI_EmptyResponseBodyError";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack
    };
  }
}, dhe = class extends Error {
  constructor({ prompt: t, message: e }) {
    super(`Invalid prompt: ${e}`), this.name = "AI_InvalidPromptError", this.prompt = t;
  }
  static isInvalidPromptError(t) {
    return t instanceof Error && t.name === "AI_InvalidPromptError" && prompt != null;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      prompt: this.prompt
    };
  }
}, wv = class extends Error {
  constructor({
    data: t,
    message: e = `Invalid response data: ${JSON.stringify(t)}.`
  }) {
    super(e), this.name = "AI_InvalidResponseDataError", this.data = t;
  }
  static isInvalidResponseDataError(t) {
    return t instanceof Error && t.name === "AI_InvalidResponseDataError" && t.data != null;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      data: this.data
    };
  }
};
function rU(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var C0 = class extends Error {
  constructor({ text: e, cause: n }) {
    super(
      `JSON parsing failed: Text: ${e}.
Error message: ${rU(n)}`
    ), this.name = "AI_JSONParseError", this.cause = n, this.text = e;
  }
  static isJSONParseError(e) {
    return e instanceof Error && e.name === "AI_JSONParseError" && typeof e.text == "string" && typeof e.cause == "string";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      valueText: this.text
    };
  }
}, im = class extends Error {
  constructor({ message: t }) {
    super(t), this.name = "AI_LoadAPIKeyError";
  }
  static isLoadAPIKeyError(t) {
    return t instanceof Error && t.name === "AI_LoadAPIKeyError";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message
    };
  }
}, Vh = class extends Error {
  constructor({ value: e, cause: n }) {
    super(
      `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${rU(n)}`
    ), this.name = "AI_TypeValidationError", this.cause = n, this.value = e;
  }
  static isTypeValidationError(e) {
    return e instanceof Error && e.name === "AI_TypeValidationError";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      value: this.value
    };
  }
}, Ji = class extends Error {
  constructor({ functionality: e }) {
    super(`'${e}' functionality not supported.`), this.name = "AI_UnsupportedFunctionalityError", this.functionality = e;
  }
  static isUnsupportedFunctionalityError(e) {
    return e instanceof Error && e.name === "AI_UnsupportedFunctionalityError" && typeof e.functionality == "string";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      functionality: this.functionality
    };
  }
};
let fhe = (t, e = 21) => (n = e) => {
  let r = "", s = n;
  for (; s--; )
    r += t[Math.random() * t.length | 0];
  return r;
};
function phe(t) {
  let e, n, r, s, i, o, a;
  return l(), {
    feed: c,
    reset: l
  };
  function l() {
    e = !0, n = "", r = 0, s = -1, i = void 0, o = void 0, a = "";
  }
  function c(h) {
    n = n ? n + h : h, e && mhe(n) && (n = n.slice(sU.length)), e = !1;
    const d = n.length;
    let f = 0, g = !1;
    for (; f < d; ) {
      g && (n[f] === `
` && ++f, g = !1);
      let y = -1, p = s, m;
      for (let b = r; y < 0 && b < d; ++b)
        m = n[b], m === ":" && p < 0 ? p = b - f : m === "\r" ? (g = !0, y = b - f) : m === `
` && (y = b - f);
      if (y < 0) {
        r = d - f, s = p;
        break;
      } else
        r = 0, s = -1;
      u(n, f, p, y), f += y + 1;
    }
    f === d ? n = "" : f > 0 && (n = n.slice(f));
  }
  function u(h, d, f, g) {
    if (g === 0) {
      a.length > 0 && (t({
        type: "event",
        id: i,
        event: o || void 0,
        data: a.slice(0, -1)
        // remove trailing newline
      }), a = "", i = void 0), o = void 0;
      return;
    }
    const y = f < 0, p = h.slice(d, d + (y ? g : f));
    let m = 0;
    y ? m = g : h[d + f + 1] === " " ? m = f + 2 : m = f + 1;
    const b = d + m, _ = g - m, v = h.slice(b, b + _).toString();
    if (p === "data")
      a += v ? "".concat(v, `
`) : `
`;
    else if (p === "event")
      o = v;
    else if (p === "id" && !v.includes("\0"))
      i = v;
    else if (p === "retry") {
      const w = parseInt(v, 10);
      Number.isNaN(w) || t({
        type: "reconnect-interval",
        value: w
      });
    }
  }
}
const sU = [239, 187, 191];
function mhe(t) {
  return sU.every((e, n) => t.charCodeAt(n) === e);
}
class ghe extends TransformStream {
  constructor() {
    let e;
    super({
      start(n) {
        e = phe((r) => {
          r.type === "event" && n.enqueue(r);
        });
      },
      transform(n) {
        e.feed(n);
      }
    });
  }
}
function k0(...t) {
  return t.reduce(
    (e, n) => ({
      ...e,
      ...n ?? {}
    }),
    {}
  );
}
function Sb(t) {
  const e = {};
  return t.headers.forEach((n, r) => {
    e[r] = n;
  }), e;
}
var Ev = fhe(
  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  7
);
function Sv(t) {
  return t instanceof Error && (t.name === "AbortError" || t.name === "TimeoutError");
}
function yhe({
  apiKey: t,
  environmentVariableName: e,
  apiKeyParameterName: n = "apiKey",
  description: r
}) {
  if (typeof t == "string")
    return t;
  if (t != null)
    throw new im({
      message: `${r} API key must be a string.`
    });
  if (typeof je > "u")
    throw new im({
      message: `${r} API key is missing. Pass it using the '${n}' parameter. Environment variables is not supported in this environment.`
    });
  if (t = je.env[e], t == null)
    throw new im({
      message: `${r} API key is missing. Pass it using the '${n}' parameter or the ${e} environment variable.`
    });
  if (typeof t != "string")
    throw new im({
      message: `${r} API key must be a string. The value of the ${e} environment variable is not a string.`
    });
  return t;
}
function bhe({
  value: t,
  schema: e
}) {
  try {
    return e.parse(t);
  } catch (n) {
    throw new Vh({ value: t, cause: n });
  }
}
function _he({
  value: t,
  schema: e
}) {
  try {
    const n = e.safeParse(t);
    return n.success ? {
      success: !0,
      value: n.data
    } : {
      success: !1,
      error: new Vh({
        value: t,
        cause: n.error
      })
    };
  } catch (n) {
    return {
      success: !1,
      error: Vh.isTypeValidationError(n) ? n : new Vh({ value: t, cause: n })
    };
  }
}
function vhe({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? n : bhe({ value: n, schema: e });
  } catch (n) {
    throw C0.isJSONParseError(n) || Vh.isTypeValidationError(n) ? n : new C0({ text: t, cause: n });
  }
}
function iU({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    return e == null ? {
      success: !0,
      value: n
    } : _he({ value: n, schema: e });
  } catch (n) {
    return {
      success: !1,
      error: C0.isJSONParseError(n) ? n : new C0({ text: t, cause: n })
    };
  }
}
function VI(t) {
  try {
    return ln.parse(t), !0;
  } catch {
    return !1;
  }
}
function whe(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n != null)
  );
}
var Ehe = () => fetch, A0 = async ({
  url: t,
  headers: e,
  body: n,
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}) => She({
  url: t,
  headers: {
    "Content-Type": "application/json",
    ...e
  },
  body: {
    content: JSON.stringify(n),
    values: n
  },
  failedResponseHandler: r,
  successfulResponseHandler: s,
  abortSignal: i,
  fetch: o
}), She = async ({
  url: t,
  headers: e = {},
  body: n,
  successfulResponseHandler: r,
  failedResponseHandler: s,
  abortSignal: i,
  fetch: o = Ehe()
}) => {
  try {
    const a = await o(t, {
      method: "POST",
      headers: whe(e),
      body: n.content,
      signal: i
    }), l = Sb(a);
    if (!a.ok) {
      let c;
      try {
        c = await s({
          response: a,
          url: t,
          requestBodyValues: n.values
        });
      } catch (u) {
        throw Sv(u) || Zi.isAPICallError(u) ? u : new Zi({
          message: "Failed to process error response",
          cause: u,
          statusCode: a.status,
          url: t,
          responseHeaders: l,
          requestBodyValues: n.values
        });
      }
      throw c.value;
    }
    try {
      return await r({
        response: a,
        url: t,
        requestBodyValues: n.values
      });
    } catch (c) {
      throw c instanceof Error && (Sv(c) || Zi.isAPICallError(c)) ? c : new Zi({
        message: "Failed to process successful response",
        cause: c,
        statusCode: a.status,
        url: t,
        responseHeaders: l,
        requestBodyValues: n.values
      });
    }
  } catch (a) {
    if (Sv(a))
      throw a;
    if (a instanceof TypeError && a.message === "fetch failed") {
      const l = a.cause;
      if (l != null)
        throw new Zi({
          message: `Cannot connect to API: ${l.message}`,
          cause: l,
          url: t,
          requestBodyValues: n.values,
          isRetryable: !0
          // retry when network error
        });
    }
    throw a;
  }
}, xhe = ({
  errorSchema: t,
  errorToMessage: e,
  isRetryable: n
}) => async ({ response: r, url: s, requestBodyValues: i }) => {
  const o = await r.text(), a = Sb(r);
  if (o.trim() === "")
    return {
      responseHeaders: a,
      value: new Zi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  try {
    const l = vhe({
      text: o,
      schema: t
    });
    return {
      responseHeaders: a,
      value: new Zi({
        message: e(l),
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        data: l,
        isRetryable: n?.(r, l)
      })
    };
  } catch {
    return {
      responseHeaders: a,
      value: new Zi({
        message: r.statusText,
        url: s,
        requestBodyValues: i,
        statusCode: r.status,
        responseHeaders: a,
        responseBody: o,
        isRetryable: n?.(r)
      })
    };
  }
}, oU = (t) => async ({ response: e }) => {
  const n = Sb(e);
  if (e.body == null)
    throw new hhe({});
  return {
    responseHeaders: n,
    value: e.body.pipeThrough(new TextDecoderStream()).pipeThrough(new ghe()).pipeThrough(
      new TransformStream({
        transform({ data: r }, s) {
          r !== "[DONE]" && s.enqueue(
            iU({
              text: r,
              schema: t
            })
          );
        }
      })
    )
  };
}, aU = (t) => async ({ response: e, url: n, requestBodyValues: r }) => {
  const s = await e.text(), i = iU({
    text: s,
    schema: t
  }), o = Sb(e);
  if (!i.success)
    throw new Zi({
      message: "Invalid JSON response",
      cause: i.error,
      statusCode: e.status,
      responseHeaders: o,
      responseBody: s,
      url: n,
      requestBodyValues: r
    });
  return {
    responseHeaders: o,
    value: i.value
  };
};
function The(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCodePoint(t[n]);
  return globalThis.btoa(e);
}
function Che(t) {
  return t?.replace(/\/$/, "");
}
var khe = Object.defineProperty, Ahe = Object.defineProperties, Rhe = Object.getOwnPropertyDescriptors, R0 = Object.getOwnPropertySymbols, lU = Object.prototype.hasOwnProperty, cU = Object.prototype.propertyIsEnumerable, WI = (t, e, n) => e in t ? khe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Ui = (t, e) => {
  for (var n in e || (e = {}))
    lU.call(e, n) && WI(t, n, e[n]);
  if (R0)
    for (var n of R0(e))
      cU.call(e, n) && WI(t, n, e[n]);
  return t;
}, mg = (t, e) => Ahe(t, Rhe(e)), I0 = (t, e) => {
  var n = {};
  for (var r in t)
    lU.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && R0)
    for (var r of R0(t))
      e.indexOf(r) < 0 && cU.call(t, r) && (n[r] = t[r]);
  return n;
};
function Ihe(t) {
  var e;
  const n = [];
  for (const { role: r, content: s } of t)
    switch (r) {
      case "system": {
        n.push({ role: "system", content: s });
        break;
      }
      case "user": {
        if (s.length === 1 && ((e = s[0]) == null ? void 0 : e.type) === "text") {
          n.push({ role: "user", content: s[0].text });
          break;
        }
        n.push({
          role: "user",
          content: s.map((i) => {
            var o;
            switch (i.type) {
              case "text":
                return { type: "text", text: i.text };
              case "image":
                return {
                  type: "image_url",
                  image_url: {
                    url: i.image instanceof URL ? i.image.toString() : `data:${(o = i.mimeType) != null ? o : "image/jpeg"};base64,${The(i.image)}`
                  }
                };
            }
          })
        });
        break;
      }
      case "assistant": {
        let i = "";
        const o = [];
        for (const a of s)
          switch (a.type) {
            case "text": {
              i += a.text;
              break;
            }
            case "tool-call": {
              o.push({
                id: a.toolCallId,
                type: "function",
                function: {
                  name: a.toolName,
                  arguments: JSON.stringify(a.args)
                }
              });
              break;
            }
            default: {
              const l = a;
              throw new Error(`Unsupported part: ${l}`);
            }
          }
        n.push({
          role: "assistant",
          content: i,
          tool_calls: o.length > 0 ? o : void 0
        });
        break;
      }
      case "tool": {
        for (const i of s)
          n.push({
            role: "tool",
            tool_call_id: i.toolCallId,
            content: JSON.stringify(i.result)
          });
        break;
      }
      default: {
        const i = r;
        throw new Error(`Unsupported role: ${i}`);
      }
    }
  return n;
}
function qI(t) {
  var e, n;
  return (n = (e = t?.content) == null ? void 0 : e.map(({ token: r, logprob: s, top_logprobs: i }) => ({
    token: r,
    logprob: s,
    topLogprobs: i ? i.map(({ token: o, logprob: a }) => ({
      token: o,
      logprob: a
    })) : []
  }))) != null ? n : void 0;
}
function P0(t) {
  switch (t) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var DC = D.object({
  error: D.object({
    message: D.string(),
    type: D.string(),
    param: D.any().nullable(),
    code: D.string().nullable()
  })
}), O0 = xhe({
  errorSchema: DC,
  errorToMessage: (t) => t.error.message
}), Phe = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.defaultObjectGenerationMode = "tool", this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    mode: t,
    prompt: e,
    maxTokens: n,
    temperature: r,
    topP: s,
    frequencyPenalty: i,
    presencePenalty: o,
    seed: a
  }) {
    const l = t.type, c = Ui({
      // model id:
      model: this.modelId,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: this.settings.logprobs === !0 || typeof this.settings.logprobs == "number" ? !0 : void 0,
      top_logprobs: typeof this.settings.logprobs == "number" ? this.settings.logprobs : typeof this.settings.logprobs == "boolean" && this.settings.logprobs ? 0 : void 0,
      user: this.settings.user,
      parallel_tool_calls: this.settings.parallelToolCalls,
      // standardized settings:
      max_tokens: n,
      temperature: r,
      top_p: s,
      frequency_penalty: i,
      presence_penalty: o,
      seed: a,
      // messages:
      messages: Ihe(e)
    }, this.config.extraBody);
    switch (l) {
      case "regular":
        return Ui(Ui({}, c), Nhe(t));
      case "object-json":
        return mg(Ui({}, c), {
          response_format: { type: "json_object" }
        });
      case "object-tool":
        return mg(Ui({}, c), {
          tool_choice: { type: "function", function: { name: t.tool.name } },
          tools: [
            {
              type: "function",
              function: {
                name: t.tool.name,
                description: t.tool.description,
                parameters: t.tool.parameters
              }
            }
          ]
        });
      case "object-grammar":
        throw new Ji({
          functionality: "object-grammar mode"
        });
      default: {
        const u = l;
        throw new Error(`Unsupported type: ${u}`);
      }
    }
  }
  async doGenerate(t) {
    var e, n;
    const r = this.getArgs(t), { responseHeaders: s, value: i } = await A0({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: k0(this.config.headers(), t.headers),
      body: r,
      failedResponseHandler: O0,
      successfulResponseHandler: aU(
        Ohe
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), o = r, { messages: a } = o, l = I0(o, ["messages"]), c = i.choices[0];
    if (c == null)
      throw new Error("No choice in response");
    return {
      text: (e = c.message.content) != null ? e : void 0,
      toolCalls: (n = c.message.tool_calls) == null ? void 0 : n.map((u) => {
        var h;
        return {
          toolCallType: "function",
          toolCallId: (h = u.id) != null ? h : Ev(),
          toolName: u.function.name,
          args: u.function.arguments
        };
      }),
      finishReason: P0(c.finish_reason),
      usage: {
        promptTokens: i.usage.prompt_tokens,
        completionTokens: i.usage.completion_tokens
      },
      rawCall: { rawPrompt: a, rawSettings: l },
      rawResponse: { headers: s },
      warnings: [],
      logprobs: qI(c.logprobs)
    };
  }
  async doStream(t) {
    const e = this.getArgs(t), { responseHeaders: n, value: r } = await A0({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: k0(this.config.headers(), t.headers),
      body: mg(Ui({}, e), {
        stream: !0,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.compatibility === "strict" ? { include_usage: !0 } : void 0
      }),
      failedResponseHandler: O0,
      successfulResponseHandler: oU(
        Dhe
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), s = e, { messages: i } = s, o = I0(s, ["messages"]), a = [];
    let l = "other", c = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    }, u;
    return {
      stream: r.pipeThrough(
        new TransformStream({
          transform(h, d) {
            var f, g, y, p, m, b, _, v, w, E, x, S;
            if (!h.success) {
              l = "error", d.enqueue({ type: "error", error: h.error });
              return;
            }
            const T = h.value;
            if ("error" in T) {
              l = "error", d.enqueue({ type: "error", error: T.error });
              return;
            }
            T.usage != null && (c = {
              promptTokens: T.usage.prompt_tokens,
              completionTokens: T.usage.completion_tokens
            });
            const R = T.choices[0];
            if (R?.finish_reason != null && (l = P0(R.finish_reason)), R?.delta == null)
              return;
            const F = R.delta;
            F.content != null && d.enqueue({
              type: "text-delta",
              textDelta: F.content
            });
            const P = qI(
              R?.logprobs
            );
            if (P?.length && (u === void 0 && (u = []), u.push(...P)), F.tool_calls != null)
              for (const M of F.tool_calls) {
                const A = M.index;
                if (a[A] == null) {
                  if (M.type !== "function")
                    throw new wv({
                      data: M,
                      message: "Expected 'function' type."
                    });
                  if (M.id == null)
                    throw new wv({
                      data: M,
                      message: "Expected 'id' to be a string."
                    });
                  if (((f = M.function) == null ? void 0 : f.name) == null)
                    throw new wv({
                      data: M,
                      message: "Expected 'function.name' to be a string."
                    });
                  a[A] = {
                    id: M.id,
                    type: "function",
                    function: {
                      name: M.function.name,
                      arguments: (g = M.function.arguments) != null ? g : ""
                    }
                  };
                  const ee = a[A];
                  if (ee == null)
                    throw new Error("Tool call is missing");
                  ((y = ee.function) == null ? void 0 : y.name) != null && ((p = ee.function) == null ? void 0 : p.arguments) != null && VI(ee.function.arguments) && (d.enqueue({
                    type: "tool-call-delta",
                    toolCallType: "function",
                    toolCallId: ee.id,
                    toolName: ee.function.name,
                    argsTextDelta: ee.function.arguments
                  }), d.enqueue({
                    type: "tool-call",
                    toolCallType: "function",
                    toolCallId: (m = ee.id) != null ? m : Ev(),
                    toolName: ee.function.name,
                    args: ee.function.arguments
                  }));
                  continue;
                }
                const V = a[A];
                if (V == null)
                  throw new Error("Tool call is missing");
                ((b = M.function) == null ? void 0 : b.arguments) != null && (V.function.arguments += (v = (_ = M.function) == null ? void 0 : _.arguments) != null ? v : ""), d.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: V.id,
                  toolName: V.function.name,
                  argsTextDelta: (w = M.function.arguments) != null ? w : ""
                }), ((E = V.function) == null ? void 0 : E.name) != null && ((x = V.function) == null ? void 0 : x.arguments) != null && VI(V.function.arguments) && d.enqueue({
                  type: "tool-call",
                  toolCallType: "function",
                  toolCallId: (S = V.id) != null ? S : Ev(),
                  toolName: V.function.name,
                  args: V.function.arguments
                });
              }
          },
          flush(h) {
            h.enqueue({
              type: "finish",
              finishReason: l,
              logprobs: u,
              usage: c
            });
          }
        })
      ),
      rawCall: { rawPrompt: i, rawSettings: o },
      rawResponse: { headers: n },
      warnings: []
    };
  }
}, Ohe = D.object({
  choices: D.array(
    D.object({
      message: D.object({
        role: D.literal("assistant"),
        content: D.string().nullable().optional(),
        tool_calls: D.array(
          D.object({
            id: D.string().optional().nullable(),
            type: D.literal("function"),
            function: D.object({
              name: D.string(),
              arguments: D.string()
            })
          })
        ).optional()
      }),
      index: D.number(),
      logprobs: D.object({
        content: D.array(
          D.object({
            token: D.string(),
            logprob: D.number(),
            top_logprobs: D.array(
              D.object({
                token: D.string(),
                logprob: D.number()
              })
            )
          })
        ).nullable()
      }).nullable().optional(),
      finish_reason: D.string().optional().nullable()
    })
  ),
  usage: D.object({
    prompt_tokens: D.number(),
    completion_tokens: D.number()
  })
}), Dhe = D.union([
  D.object({
    choices: D.array(
      D.object({
        delta: D.object({
          role: D.enum(["assistant"]).optional(),
          content: D.string().nullish(),
          tool_calls: D.array(
            D.object({
              index: D.number(),
              id: D.string().nullish(),
              type: D.literal("function").optional(),
              function: D.object({
                name: D.string().nullish(),
                arguments: D.string().nullish()
              })
            })
          ).nullish()
        }).nullish(),
        logprobs: D.object({
          content: D.array(
            D.object({
              token: D.string(),
              logprob: D.number(),
              top_logprobs: D.array(
                D.object({
                  token: D.string(),
                  logprob: D.number()
                })
              )
            })
          ).nullable()
        }).nullish(),
        finish_reason: D.string().nullable().optional(),
        index: D.number()
      })
    ),
    usage: D.object({
      prompt_tokens: D.number(),
      completion_tokens: D.number()
    }).nullish()
  }),
  DC
]);
function Nhe(t) {
  var e;
  const n = (e = t.tools) != null && e.length ? t.tools : void 0;
  if (n == null)
    return { tools: void 0, tool_choice: void 0 };
  const r = n.map((o) => ({
    type: "function",
    function: {
      name: o.name,
      description: o.description,
      parameters: o.parameters
    }
  })), s = t.toolChoice;
  if (s == null)
    return { tools: r, tool_choice: void 0 };
  const i = s.type;
  switch (i) {
    case "auto":
    case "none":
    case "required":
      return { tools: r, tool_choice: i };
    case "tool":
      return {
        tools: r,
        tool_choice: {
          type: "function",
          function: {
            name: s.toolName
          }
        }
      };
    default: {
      const o = i;
      throw new Error(`Unsupported tool choice type: ${o}`);
    }
  }
}
function Lhe({
  prompt: t,
  inputFormat: e,
  user: n = "user",
  assistant: r = "assistant"
}) {
  if (e === "prompt" && t.length === 1 && t[0] && t[0].role === "user" && t[0].content.length === 1 && t[0].content[0] && t[0].content[0].type === "text")
    return { prompt: t[0].content[0].text };
  let s = "";
  t[0] && t[0].role === "system" && (s += `${t[0].content}

`, t = t.slice(1));
  for (const { role: i, content: o } of t)
    switch (i) {
      case "system":
        throw new dhe({
          message: "Unexpected system message in prompt: ${content}",
          prompt: t
        });
      case "user": {
        const a = o.map((l) => {
          switch (l.type) {
            case "text":
              return l.text;
            case "image":
              throw new Ji({
                functionality: "images"
              });
          }
        }).join("");
        s += `${n}:
${a}

`;
        break;
      }
      case "assistant": {
        const a = o.map((l) => {
          switch (l.type) {
            case "text":
              return l.text;
            case "tool-call":
              throw new Ji({
                functionality: "tool-call messages"
              });
          }
        }).join("");
        s += `${r}:
${a}

`;
        break;
      }
      case "tool":
        throw new Ji({
          functionality: "tool messages"
        });
      default: {
        const a = i;
        throw new Error(`Unsupported role: ${a}`);
      }
    }
  return s += `${r}:
`, {
    prompt: s,
    stopSequences: [`
${n}:`]
  };
}
function KI(t) {
  return t?.tokens.map((e, n) => {
    var r, s;
    return {
      token: e,
      logprob: (r = t.token_logprobs[n]) != null ? r : 0,
      topLogprobs: t.top_logprobs ? Object.entries((s = t.top_logprobs[n]) != null ? s : {}).map(
        ([i, o]) => ({
          token: i,
          logprob: o
        })
      ) : []
    };
  });
}
var Mhe = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.defaultObjectGenerationMode = void 0, this.modelId = t, this.settings = e, this.config = n;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    mode: t,
    inputFormat: e,
    prompt: n,
    maxTokens: r,
    temperature: s,
    topP: i,
    frequencyPenalty: o,
    presencePenalty: a,
    seed: l
  }) {
    var c;
    const u = t.type, { prompt: h, stopSequences: d } = Lhe({ prompt: n, inputFormat: e }), f = Ui({
      // model id:
      model: this.modelId,
      // model specific settings:
      echo: this.settings.echo,
      logit_bias: this.settings.logitBias,
      logprobs: typeof this.settings.logprobs == "number" ? this.settings.logprobs : typeof this.settings.logprobs == "boolean" && this.settings.logprobs ? 0 : void 0,
      suffix: this.settings.suffix,
      user: this.settings.user,
      // standardized settings:
      max_tokens: r,
      temperature: s,
      top_p: i,
      frequency_penalty: o,
      presence_penalty: a,
      seed: l,
      // prompt:
      prompt: h,
      // stop sequences:
      stop: d
    }, this.config.extraBody);
    switch (u) {
      case "regular": {
        if ((c = t.tools) != null && c.length)
          throw new Ji({
            functionality: "tools"
          });
        if (t.toolChoice)
          throw new Ji({
            functionality: "toolChoice"
          });
        return f;
      }
      case "object-json":
        throw new Ji({
          functionality: "object-json mode"
        });
      case "object-tool":
        throw new Ji({
          functionality: "object-tool mode"
        });
      case "object-grammar":
        throw new Ji({
          functionality: "object-grammar mode"
        });
      default: {
        const g = u;
        throw new Error(`Unsupported type: ${g}`);
      }
    }
  }
  async doGenerate(t) {
    const e = this.getArgs(t), { responseHeaders: n, value: r } = await A0({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: k0(this.config.headers(), t.headers),
      body: e,
      failedResponseHandler: O0,
      successfulResponseHandler: aU(
        Bhe
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), s = e, { prompt: i } = s, o = I0(s, ["prompt"]), a = r.choices[0];
    if (!a)
      throw new Error("No choice in OpenRouter completion response");
    return {
      text: a.text,
      usage: {
        promptTokens: r.usage.prompt_tokens,
        completionTokens: r.usage.completion_tokens
      },
      finishReason: P0(a.finish_reason),
      logprobs: KI(a.logprobs),
      rawCall: { rawPrompt: i, rawSettings: o },
      rawResponse: { headers: n },
      warnings: []
    };
  }
  async doStream(t) {
    const e = this.getArgs(t), { responseHeaders: n, value: r } = await A0({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: k0(this.config.headers(), t.headers),
      body: mg(Ui({}, this.getArgs(t)), {
        stream: !0,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.compatibility === "strict" ? { include_usage: !0 } : void 0
      }),
      failedResponseHandler: O0,
      successfulResponseHandler: oU(
        Fhe
      ),
      abortSignal: t.abortSignal,
      fetch: this.config.fetch
    }), s = e, { prompt: i } = s, o = I0(s, ["prompt"]);
    let a = "other", l = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    }, c;
    return {
      stream: r.pipeThrough(
        new TransformStream({
          transform(u, h) {
            if (!u.success) {
              a = "error", h.enqueue({ type: "error", error: u.error });
              return;
            }
            const d = u.value;
            if ("error" in d) {
              a = "error", h.enqueue({ type: "error", error: d.error });
              return;
            }
            d.usage != null && (l = {
              promptTokens: d.usage.prompt_tokens,
              completionTokens: d.usage.completion_tokens
            });
            const f = d.choices[0];
            f?.finish_reason != null && (a = P0(f.finish_reason)), f?.text != null && h.enqueue({
              type: "text-delta",
              textDelta: f.text
            });
            const g = KI(
              f?.logprobs
            );
            g?.length && (c === void 0 && (c = []), c.push(...g));
          },
          flush(u) {
            u.enqueue({
              type: "finish",
              finishReason: a,
              logprobs: c,
              usage: l
            });
          }
        })
      ),
      rawCall: { rawPrompt: i, rawSettings: o },
      rawResponse: { headers: n },
      warnings: []
    };
  }
}, Bhe = D.object({
  choices: D.array(
    D.object({
      text: D.string(),
      finish_reason: D.string(),
      logprobs: D.object({
        tokens: D.array(D.string()),
        token_logprobs: D.array(D.number()),
        top_logprobs: D.array(D.record(D.string(), D.number())).nullable()
      }).nullable().optional()
    })
  ),
  usage: D.object({
    prompt_tokens: D.number(),
    completion_tokens: D.number()
  })
}), Fhe = D.union([
  D.object({
    choices: D.array(
      D.object({
        text: D.string(),
        finish_reason: D.string().nullish(),
        index: D.number(),
        logprobs: D.object({
          tokens: D.array(D.string()),
          token_logprobs: D.array(D.number()),
          top_logprobs: D.array(D.record(D.string(), D.number())).nullable()
        }).nullable().optional()
      })
    ),
    usage: D.object({
      prompt_tokens: D.number(),
      completion_tokens: D.number()
    }).optional().nullable()
  }),
  DC
]);
function uU(t = {}) {
  var e, n, r;
  const s = (n = Che((e = t.baseURL) != null ? e : t.baseUrl)) != null ? n : "https://openrouter.ai/api/v1", i = (r = t.compatibility) != null ? r : "compatible", o = () => Ui({
    Authorization: `Bearer ${yhe({
      apiKey: t.apiKey,
      environmentVariableName: "OPENROUTER_API_KEY",
      description: "OpenRouter"
    })}`
  }, t.headers), a = (h, d = {}) => new Phe(h, d, {
    provider: "openrouter.chat",
    url: ({ path: f }) => `${s}${f}`,
    headers: o,
    compatibility: i,
    fetch: t.fetch,
    extraBody: t.extraBody
  }), l = (h, d = {}) => new Mhe(h, d, {
    provider: "openrouter.completion",
    url: ({ path: f }) => `${s}${f}`,
    headers: o,
    compatibility: i,
    fetch: t.fetch,
    extraBody: t.extraBody
  }), c = (h, d) => {
    if (new.target)
      throw new Error(
        "The OpenRouter model function cannot be called with the new keyword."
      );
    return h === "openai/gpt-3.5-turbo-instruct" ? l(
      h,
      d
    ) : a(h, d);
  }, u = function(h, d) {
    return c(h, d);
  };
  return u.languageModel = c, u.chat = a, u.completion = l, u;
}
uU({
  compatibility: "strict"
  // strict for OpenRouter API
});
class $he extends mn {
  name = "OpenRouter";
  getApiKeyLink = "https://openrouter.ai/settings/keys";
  config = {
    apiTokenKey: "OPEN_ROUTER_API_KEY"
  };
  staticModels = [
    {
      name: "anthropic/claude-3.5-sonnet",
      label: "Anthropic: Claude 3.5 Sonnet (OpenRouter)",
      provider: "OpenRouter",
      maxTokenAllowed: 8e3
    },
    {
      name: "anthropic/claude-3-haiku",
      label: "Anthropic: Claude 3 Haiku (OpenRouter)",
      provider: "OpenRouter",
      maxTokenAllowed: 8e3
    },
    {
      name: "deepseek/deepseek-coder",
      label: "Deepseek-Coder V2 236B (OpenRouter)",
      provider: "OpenRouter",
      maxTokenAllowed: 8e3
    },
    {
      name: "google/gemini-flash-1.5",
      label: "Google Gemini Flash 1.5 (OpenRouter)",
      provider: "OpenRouter",
      maxTokenAllowed: 8e3
    },
    {
      name: "google/gemini-pro-1.5",
      label: "Google Gemini Pro 1.5 (OpenRouter)",
      provider: "OpenRouter",
      maxTokenAllowed: 8e3
    },
    { name: "x-ai/grok-beta", label: "xAI Grok Beta (OpenRouter)", provider: "OpenRouter", maxTokenAllowed: 8e3 },
    {
      name: "mistralai/mistral-nemo",
      label: "OpenRouter Mistral Nemo (OpenRouter)",
      provider: "OpenRouter",
      maxTokenAllowed: 8e3
    },
    {
      name: "qwen/qwen-110b-chat",
      label: "OpenRouter Qwen 110b Chat (OpenRouter)",
      provider: "OpenRouter",
      maxTokenAllowed: 8e3
    },
    { name: "cohere/command", label: "Cohere Command (OpenRouter)", provider: "OpenRouter", maxTokenAllowed: 4096 }
  ];
  async getDynamicModels(e, n, r = {}) {
    try {
      return (await (await fetch("https://openrouter.ai/api/v1/models", {
        headers: {
          "Content-Type": "application/json"
        }
      })).json()).data.sort((o, a) => o.name.localeCompare(a.name)).map((o) => ({
        name: o.id,
        label: `${o.name} - in:$${(o.pricing.prompt * 1e6).toFixed(2)} out:$${(o.pricing.completion * 1e6).toFixed(2)} - context ${Math.floor(o.context_length / 1e3)}k`,
        provider: this.name,
        maxTokenAllowed: 8e3
      }));
    } catch (s) {
      return console.error("Error getting OpenRouter models:", s), [];
    }
  }
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "OPEN_ROUTER_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return uU({
      apiKey: o
    }).chat(n);
  }
}
class Uhe extends mn {
  name = "OpenAILike";
  getApiKeyLink = void 0;
  config = {
    baseUrlKey: "OPENAI_LIKE_API_BASE_URL",
    apiTokenKey: "OPENAI_LIKE_API_KEY"
  };
  staticModels = [];
  async getDynamicModels(e, n, r = {}) {
    const { baseUrl: s, apiKey: i } = this.getProviderBaseUrlAndKey({
      apiKeys: e,
      providerSettings: n,
      serverEnv: r,
      defaultBaseUrlKey: "OPENAI_LIKE_API_BASE_URL",
      defaultApiTokenKey: "OPENAI_LIKE_API_KEY"
    });
    return !s || !i ? [] : (await (await fetch(`${s}/models`, {
      headers: {
        Authorization: `Bearer ${i}`
      }
    })).json()).data.map((l) => ({
      name: l.id,
      label: l.id,
      provider: this.name,
      maxTokenAllowed: 8e3
    }));
  }
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { baseUrl: o, apiKey: a } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "OPENAI_LIKE_API_BASE_URL",
      defaultApiTokenKey: "OPENAI_LIKE_API_KEY"
    });
    if (!o || !a)
      throw new Error(`Missing configuration for ${this.name} provider`);
    return Q5(o, a, n);
  }
}
class jhe extends mn {
  name = "OpenAI";
  getApiKeyLink = "https://platform.openai.com/api-keys";
  config = {
    apiTokenKey: "OPENAI_API_KEY"
  };
  staticModels = [
    { name: "gpt-4o", label: "GPT-4o", provider: "OpenAI", maxTokenAllowed: 8e3 },
    { name: "gpt-4o-mini", label: "GPT-4o Mini", provider: "OpenAI", maxTokenAllowed: 8e3 },
    { name: "gpt-4-turbo", label: "GPT-4 Turbo", provider: "OpenAI", maxTokenAllowed: 8e3 },
    { name: "gpt-4", label: "GPT-4", provider: "OpenAI", maxTokenAllowed: 8e3 },
    { name: "gpt-3.5-turbo", label: "GPT-3.5 Turbo", provider: "OpenAI", maxTokenAllowed: 8e3 }
  ];
  async getDynamicModels(e, n, r) {
    const { apiKey: s } = this.getProviderBaseUrlAndKey({
      apiKeys: e,
      providerSettings: n,
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "OPENAI_API_KEY"
    });
    if (!s)
      throw `Missing Api Key configuration for ${this.name} provider`;
    const o = await (await fetch("https://api.openai.com/v1/models", {
      headers: {
        Authorization: `Bearer ${s}`
      }
    })).json(), a = this.staticModels.map((c) => c.name);
    return o.data.filter(
      (c) => c.object === "model" && (c.id.startsWith("gpt-") || c.id.startsWith("o") || c.id.startsWith("chatgpt-")) && !a.includes(c.id)
    ).map((c) => ({
      name: c.id,
      label: `${c.id}`,
      provider: this.name,
      maxTokenAllowed: c.context_window || 32e3
    }));
  }
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "OPENAI_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return Pi({
      apiKey: o
    })(n);
  }
}
class Hhe extends mn {
  name = "Perplexity";
  getApiKeyLink = "https://www.perplexity.ai/settings/api";
  config = {
    apiTokenKey: "PERPLEXITY_API_KEY"
  };
  staticModels = [
    {
      name: "llama-3.1-sonar-small-128k-online",
      label: "Sonar Small Online",
      provider: "Perplexity",
      maxTokenAllowed: 8192
    },
    {
      name: "llama-3.1-sonar-large-128k-online",
      label: "Sonar Large Online",
      provider: "Perplexity",
      maxTokenAllowed: 8192
    },
    {
      name: "llama-3.1-sonar-huge-128k-online",
      label: "Sonar Huge Online",
      provider: "Perplexity",
      maxTokenAllowed: 8192
    }
  ];
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "PERPLEXITY_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return Pi({
      baseURL: "https://api.perplexity.ai/",
      apiKey: o
    })(n);
  }
}
class zhe extends mn {
  name = "Together";
  getApiKeyLink = "https://api.together.xyz/settings/api-keys";
  config = {
    baseUrlKey: "TOGETHER_API_BASE_URL",
    apiTokenKey: "TOGETHER_API_KEY"
  };
  staticModels = [
    {
      name: "Qwen/Qwen2.5-Coder-32B-Instruct",
      label: "Qwen/Qwen2.5-Coder-32B-Instruct",
      provider: "Together",
      maxTokenAllowed: 8e3
    },
    {
      name: "meta-llama/Llama-3.2-90B-Vision-Instruct-Turbo",
      label: "meta-llama/Llama-3.2-90B-Vision-Instruct-Turbo",
      provider: "Together",
      maxTokenAllowed: 8e3
    },
    {
      name: "mistralai/Mixtral-8x7B-Instruct-v0.1",
      label: "Mixtral 8x7B Instruct",
      provider: "Together",
      maxTokenAllowed: 8192
    }
  ];
  async getDynamicModels(e, n, r = {}) {
    const { baseUrl: s, apiKey: i } = this.getProviderBaseUrlAndKey({
      apiKeys: e,
      providerSettings: n,
      serverEnv: r,
      defaultBaseUrlKey: "TOGETHER_API_BASE_URL",
      defaultApiTokenKey: "TOGETHER_API_KEY"
    }), o = s || "https://api.together.xyz/v1";
    return i ? (await (await fetch(`${o}/models`, {
      headers: {
        Authorization: `Bearer ${i}`
      }
    })).json() || []).filter((u) => u.type === "chat").map((u) => ({
      name: u.id,
      label: `${u.display_name} - in:$${u.pricing.input.toFixed(2)} out:$${u.pricing.output.toFixed(2)} - context ${Math.floor(u.context_length / 1e3)}k`,
      provider: this.name,
      maxTokenAllowed: 8e3
    })) : [];
  }
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { baseUrl: o, apiKey: a } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "TOGETHER_API_BASE_URL",
      defaultApiTokenKey: "TOGETHER_API_KEY"
    });
    if (!o || !a)
      throw new Error(`Missing configuration for ${this.name} provider`);
    return Q5(o, a, n);
  }
}
class Ghe extends mn {
  name = "xAI";
  getApiKeyLink = "https://docs.x.ai/docs/quickstart#creating-an-api-key";
  config = {
    apiTokenKey: "XAI_API_KEY"
  };
  staticModels = [
    { name: "grok-beta", label: "xAI Grok Beta", provider: "xAI", maxTokenAllowed: 8e3 },
    { name: "grok-2-1212", label: "xAI Grok2 1212", provider: "xAI", maxTokenAllowed: 8e3 }
  ];
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "XAI_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return Pi({
      baseURL: "https://api.x.ai/v1",
      apiKey: o
    })(n);
  }
}
class Vhe extends mn {
  name = "Hyperbolic";
  getApiKeyLink = "https://app.hyperbolic.xyz/settings";
  config = {
    apiTokenKey: "HYPERBOLIC_API_KEY"
  };
  staticModels = [
    {
      name: "Qwen/Qwen2.5-Coder-32B-Instruct",
      label: "Qwen 2.5 Coder 32B Instruct",
      provider: "Hyperbolic",
      maxTokenAllowed: 8192
    },
    {
      name: "Qwen/Qwen2.5-72B-Instruct",
      label: "Qwen2.5-72B-Instruct",
      provider: "Hyperbolic",
      maxTokenAllowed: 8192
    },
    {
      name: "deepseek-ai/DeepSeek-V2.5",
      label: "DeepSeek-V2.5",
      provider: "Hyperbolic",
      maxTokenAllowed: 8192
    },
    {
      name: "Qwen/QwQ-32B-Preview",
      label: "QwQ-32B-Preview",
      provider: "Hyperbolic",
      maxTokenAllowed: 8192
    },
    {
      name: "Qwen/Qwen2-VL-72B-Instruct",
      label: "Qwen2-VL-72B-Instruct",
      provider: "Hyperbolic",
      maxTokenAllowed: 8192
    }
  ];
  async getDynamicModels(e, n, r = {}) {
    const { baseUrl: s, apiKey: i } = this.getProviderBaseUrlAndKey({
      apiKeys: e,
      providerSettings: n,
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "HYPERBOLIC_API_KEY"
    }), o = s || "https://api.hyperbolic.xyz/v1";
    if (!i)
      throw `Missing Api Key configuration for ${this.name} provider`;
    return (await (await fetch(`${o}/models`, {
      headers: {
        Authorization: `Bearer ${i}`
      }
    })).json()).data.filter((u) => u.object === "model" && u.supports_chat).map((u) => ({
      name: u.id,
      label: `${u.id} - context ${u.context_length ? Math.floor(u.context_length / 1e3) + "k" : "N/A"}`,
      provider: this.name,
      maxTokenAllowed: u.context_length || 8e3
    }));
  }
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "HYPERBOLIC_API_KEY"
    });
    if (!o)
      throw `Missing Api Key configuration for ${this.name} provider`;
    return Pi({
      baseURL: "https://api.hyperbolic.xyz/v1/",
      apiKey: o
    })(n);
  }
}
var hU = "vercel.ai.error", Whe = Symbol.for(hU), dU, qhe = class fU extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[dU] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return fU.hasMarker(e, hU);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
};
dU = Whe;
var nu = qhe, pU = "AI_InvalidArgumentError", mU = `vercel.ai.error.${pU}`, Khe = Symbol.for(mU), gU, Yhe = class extends nu {
  constructor({
    message: e,
    cause: n,
    argument: r
  }) {
    super({ name: pU, message: e, cause: n }), this[gU] = !0, this.argument = r;
  }
  static isInstance(e) {
    return nu.hasMarker(e, mU);
  }
};
gU = Khe;
var yU = "AI_LoadSettingError", bU = `vercel.ai.error.${yU}`, Zhe = Symbol.for(bU), _U, om = class extends nu {
  // used in isInstance
  constructor({ message: t }) {
    super({ name: yU, message: t }), this[_U] = !0;
  }
  static isInstance(t) {
    return nu.hasMarker(t, bU);
  }
};
_U = Zhe;
var vU = "AI_UnsupportedFunctionalityError", wU = `vercel.ai.error.${vU}`, Jhe = Symbol.for(wU), EU, Wh = class extends nu {
  constructor({ functionality: t }) {
    super({
      name: vU,
      message: `'${t}' functionality not supported.`
    }), this[EU] = !0, this.functionality = t;
  }
  static isInstance(t) {
    return nu.hasMarker(t, wU);
  }
};
EU = Jhe;
var SU = ({
  prefix: t,
  size: e = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const s = Cu(n, e);
  if (t == null)
    return s;
  if (n.includes(r))
    throw new Yhe({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return (i) => `${t}${r}${s(i)}`;
}, Xhe = SU();
function Qhe({
  settingValue: t,
  environmentVariableName: e
}) {
  if (typeof t == "string")
    return t;
  if (!(t != null || typeof je > "u") && (t = je.env[e], !(t == null || typeof t != "string")))
    return t;
}
function xv({
  settingValue: t,
  environmentVariableName: e,
  settingName: n,
  description: r
}) {
  if (typeof t == "string")
    return t;
  if (t != null)
    throw new om({
      message: `${r} setting must be a string.`
    });
  if (typeof je > "u")
    throw new om({
      message: `${r} setting is missing. Pass it using the '${n}' parameter. Environment variables is not supported in this environment.`
    });
  if (t = je.env[e], t == null)
    throw new om({
      message: `${r} setting is missing. Pass it using the '${n}' parameter or the ${e} environment variable.`
    });
  if (typeof t != "string")
    throw new om({
      message: `${r} setting must be a string. The value of the ${e} environment variable is not a string.`
    });
  return t;
}
const ede = (t) => {
  let e = t.httpHandler;
  return {
    setHttpHandler(n) {
      e = n;
    },
    httpHandler() {
      return e;
    },
    updateHttpClientConfig(n, r) {
      e.updateHttpClientConfig(n, r);
    },
    httpHandlerConfigs() {
      return e.httpHandlerConfigs();
    }
  };
}, tde = (t) => ({
  httpHandler: t.httpHandler()
});
var YI;
(function(t) {
  t.HEADER = "header", t.QUERY = "query";
})(YI || (YI = {}));
var ZI;
(function(t) {
  t.HEADER = "header", t.QUERY = "query";
})(ZI || (ZI = {}));
var Hd;
(function(t) {
  t.HTTP = "http", t.HTTPS = "https";
})(Hd || (Hd = {}));
var D0;
(function(t) {
  t.MD5 = "md5", t.CRC32 = "crc32", t.CRC32C = "crc32c", t.SHA1 = "sha1", t.SHA256 = "sha256";
})(D0 || (D0 = {}));
var JI;
(function(t) {
  t[t.HEADER = 0] = "HEADER", t[t.TRAILER = 1] = "TRAILER";
})(JI || (JI = {}));
const sS = "__smithy_context";
var XI;
(function(t) {
  t.PROFILE = "profile", t.SSO_SESSION = "sso-session", t.SERVICES = "services";
})(XI || (XI = {}));
var QI;
(function(t) {
  t.HTTP_0_9 = "http/0.9", t.HTTP_1_0 = "http/1.0", t.TDS_8_0 = "tds/8.0";
})(QI || (QI = {}));
class Br {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static clone(e) {
    const n = new Br({
      ...e,
      headers: { ...e.headers }
    });
    return n.query && (n.query = nde(n.query)), n;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    return Br.clone(this);
  }
}
function nde(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
class N0 {
  constructor(e) {
    this.statusCode = e.statusCode, this.reason = e.reason, this.headers = e.headers || {}, this.body = e.body;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return typeof n.statusCode == "number" && typeof n.headers == "object";
  }
}
const rde = (t) => (e) => async (n) => {
  if (!Br.isInstance(n.request))
    return e(n);
  const { request: r } = n, { handlerProtocol: s = "" } = t.requestHandler.metadata || {};
  if (s.indexOf("h2") >= 0 && !r.headers[":authority"])
    delete r.headers.host, r.headers[":authority"] = r.hostname + (r.port ? ":" + r.port : "");
  else if (!r.headers.host) {
    let i = r.hostname;
    r.port != null && (i += `:${r.port}`), r.headers.host = i;
  }
  return e(n);
}, sde = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: !0
}, ide = (t) => ({
  applyToStack: (e) => {
    e.add(rde(t), sde);
  }
}), ode = () => (t, e) => async (n) => {
  try {
    const r = await t(n), { clientName: s, commandName: i, logger: o, dynamoDbDocumentClientOptions: a = {} } = e, { overrideInputFilterSensitiveLog: l, overrideOutputFilterSensitiveLog: c } = a, u = l ?? e.inputFilterSensitiveLog, h = c ?? e.outputFilterSensitiveLog, { $metadata: d, ...f } = r.output;
    return o?.info?.({
      clientName: s,
      commandName: i,
      input: u(n.input),
      output: h(f),
      metadata: d
    }), r;
  } catch (r) {
    const { clientName: s, commandName: i, logger: o, dynamoDbDocumentClientOptions: a = {} } = e, { overrideInputFilterSensitiveLog: l } = a, c = l ?? e.inputFilterSensitiveLog;
    throw o?.error?.({
      clientName: s,
      commandName: i,
      input: c(n.input),
      error: r,
      metadata: r.$metadata
    }), r;
  }
}, ade = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: !0
}, lde = (t) => ({
  applyToStack: (e) => {
    e.add(ode(), ade);
  }
}), eP = "X-Amzn-Trace-Id", cde = "AWS_LAMBDA_FUNCTION_NAME", ude = "_X_AMZN_TRACE_ID", hde = (t) => (e) => async (n) => {
  const { request: r } = n;
  if (!Br.isInstance(r) || t.runtime !== "node" || r.headers.hasOwnProperty(eP))
    return e(n);
  const s = je.env[cde], i = je.env[ude], o = (a) => typeof a == "string" && a.length > 0;
  return o(s) && o(i) && (r.headers[eP] = i), e({
    ...n,
    request: r
  });
}, dde = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: !0,
  priority: "low"
}, fde = (t) => ({
  applyToStack: (e) => {
    e.add(hde(t), dde);
  }
}), xb = (t) => t[sS] || (t[sS] = {}), qo = (t) => {
  if (typeof t == "function")
    return t;
  const e = Promise.resolve(t);
  return () => e;
};
function pde(t) {
  const e = /* @__PURE__ */ new Map();
  for (const n of t)
    e.set(n.schemeId, n);
  return e;
}
const mde = (t, e) => (n, r) => async (s) => {
  const i = t.httpAuthSchemeProvider(await e.httpAuthSchemeParametersProvider(t, r, s.input)), o = pde(t.httpAuthSchemes), a = xb(r), l = [];
  for (const c of i) {
    const u = o.get(c.schemeId);
    if (!u) {
      l.push(`HttpAuthScheme \`${c.schemeId}\` was not enabled for this service.`);
      continue;
    }
    const h = u.identityProvider(await e.identityProviderConfigProvider(t));
    if (!h) {
      l.push(`HttpAuthScheme \`${c.schemeId}\` did not have an IdentityProvider configured.`);
      continue;
    }
    const { identityProperties: d = {}, signingProperties: f = {} } = c.propertiesExtractor?.(t, r) || {};
    c.identityProperties = Object.assign(c.identityProperties || {}, d), c.signingProperties = Object.assign(c.signingProperties || {}, f), a.selectedHttpAuthScheme = {
      httpAuthOption: c,
      identity: await h(c.identityProperties),
      signer: u.signer
    };
    break;
  }
  if (!a.selectedHttpAuthScheme)
    throw new Error(l.join(`
`));
  return n(s);
}, gde = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: !0,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
}, yde = (t, { httpAuthSchemeParametersProvider: e, identityProviderConfigProvider: n }) => ({
  applyToStack: (r) => {
    r.addRelativeTo(mde(t, {
      httpAuthSchemeParametersProvider: e,
      identityProviderConfigProvider: n
    }), gde);
  }
}), bde = (t, e) => (n, r) => async (s) => {
  const { response: i } = await n(s);
  try {
    const o = await e(i, t);
    return {
      response: i,
      output: o
    };
  } catch (o) {
    if (Object.defineProperty(o, "$response", {
      value: i
    }), !("$metadata" in o)) {
      const a = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
      try {
        o.message += `
  ` + a;
      } catch {
        !r.logger || r.logger?.constructor?.name === "NoOpLogger" ? console.warn(a) : r.logger?.warn?.(a);
      }
      typeof o.$responseBodyText < "u" && o.$response && (o.$response.body = o.$responseBodyText);
    }
    throw o;
  }
}, _de = (t, e) => (n, r) => async (s) => {
  const i = r.endpointV2?.url && t.urlParser ? async () => t.urlParser(r.endpointV2.url) : t.endpoint;
  if (!i)
    throw new Error("No valid endpoint provider available.");
  const o = await e(s.input, { ...t, endpoint: i });
  return n({
    ...s,
    request: o
  });
}, vde = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: !0
}, NC = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: !0
};
function LC(t, e, n) {
  return {
    applyToStack: (r) => {
      r.add(bde(t, n), vde), r.add(_de(t, e), NC);
    }
  };
}
NC.name;
const wde = (t) => (e) => {
  throw e;
}, Ede = (t, e) => {
}, Sde = (t) => (e, n) => async (r) => {
  if (!Br.isInstance(r.request))
    return e(r);
  const i = xb(n).selectedHttpAuthScheme;
  if (!i)
    throw new Error("No HttpAuthScheme was selected: unable to sign request");
  const { httpAuthOption: { signingProperties: o = {} }, identity: a, signer: l } = i, c = await e({
    ...r,
    request: await l.sign(r.request, a, o)
  }).catch((l.errorHandler || wde)(o));
  return (l.successHandler || Ede)(c.response, o), c;
}, xde = {
  step: "finalizeRequest",
  tags: ["HTTP_SIGNING"],
  name: "httpSigningMiddleware",
  aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
  override: !0,
  relation: "after",
  toMiddleware: "retryMiddleware"
}, Tde = (t) => ({
  applyToStack: (e) => {
    e.addRelativeTo(Sde(), xde);
  }
}), Ch = (t) => {
  if (typeof t == "function")
    return t;
  const e = Promise.resolve(t);
  return () => e;
}, ra = {}, Au = new Array(64);
for (let t = 0, e = 65, n = 90; t + e <= n; t++) {
  const r = String.fromCharCode(t + e);
  ra[r] = t, Au[t] = r;
}
for (let t = 0, e = 97, n = 122; t + e <= n; t++) {
  const r = String.fromCharCode(t + e), s = t + 26;
  ra[r] = s, Au[s] = r;
}
for (let t = 0; t < 10; t++) {
  ra[t.toString(10)] = t + 52;
  const e = t.toString(10), n = t + 52;
  ra[e] = n, Au[n] = e;
}
ra["+"] = 62;
Au[62] = "+";
ra["/"] = 63;
Au[63] = "/";
const Pc = 6, qh = 8, Cde = 63, MC = (t) => {
  let e = t.length / 4 * 3;
  t.slice(-2) === "==" ? e -= 2 : t.slice(-1) === "=" && e--;
  const n = new ArrayBuffer(e), r = new DataView(n);
  for (let s = 0; s < t.length; s += 4) {
    let i = 0, o = 0;
    for (let c = s, u = s + 3; c <= u; c++)
      if (t[c] !== "=") {
        if (!(t[c] in ra))
          throw new TypeError(`Invalid character ${t[c]} in base64 string.`);
        i |= ra[t[c]] << (u - c) * Pc, o += Pc;
      } else
        i >>= Pc;
    const a = s / 4 * 3;
    i >>= o % qh;
    const l = Math.floor(o / qh);
    for (let c = 0; c < l; c++) {
      const u = (l - c - 1) * qh;
      r.setUint8(a + c, (i & 255 << u) >> u);
    }
  }
  return new Uint8Array(n);
}, ru = (t) => new TextEncoder().encode(t), Kh = (t) => typeof t == "string" ? ru(t) : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(t), xU = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number")
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  return new TextDecoder("utf-8").decode(t);
};
function TU(t) {
  let e;
  typeof t == "string" ? e = ru(t) : e = t;
  const n = typeof e == "object" && typeof e.length == "number", r = typeof e == "object" && typeof e.byteOffset == "number" && typeof e.byteLength == "number";
  if (!n && !r)
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  let s = "";
  for (let i = 0; i < e.length; i += 3) {
    let o = 0, a = 0;
    for (let c = i, u = Math.min(i + 3, e.length); c < u; c++)
      o |= e[c] << (u - c - 1) * qh, a += qh;
    const l = Math.ceil(a / Pc);
    o <<= l * Pc - a;
    for (let c = 1; c <= l; c++) {
      const u = (l - c) * Pc;
      s += Au[(o & Cde << u) >> u];
    }
    s += "==".slice(0, 4 - l);
  }
  return s;
}
function kde(t, e = "utf-8") {
  return e === "base64" ? TU(t) : xU(t);
}
function Ade(t, e) {
  return e === "base64" ? nl.mutate(MC(t)) : nl.mutate(ru(t));
}
class nl extends Uint8Array {
  static fromString(e, n = "utf-8") {
    switch (typeof e) {
      case "string":
        return Ade(e, n);
      default:
        throw new Error(`Unsupported conversion from ${typeof e} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(e) {
    return Object.setPrototypeOf(e, nl.prototype), e;
  }
  transformToString(e = "utf-8") {
    return kde(this, e);
  }
}
const rl = (t) => encodeURIComponent(t).replace(/[!'()*]/g, Rde), Rde = (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`;
function Ide(t) {
  const e = [];
  for (let n of Object.keys(t).sort()) {
    const r = t[n];
    if (n = rl(n), Array.isArray(r))
      for (let s = 0, i = r.length; s < i; s++)
        e.push(`${n}=${rl(r[s])}`);
    else {
      let s = n;
      (r || typeof r == "string") && (s += `=${rl(r)}`), e.push(s);
    }
  }
  return e.join("&");
}
function tP(t, e) {
  return new Request(t, e);
}
function Pde(t = 0) {
  return new Promise((e, n) => {
    t && setTimeout(() => {
      const r = new Error(`Request did not complete within ${t} ms`);
      r.name = "TimeoutError", n(r);
    }, t);
  });
}
const Tv = {
  supported: void 0
};
class BC {
  static create(e) {
    return typeof e?.handle == "function" ? e : new BC(e);
  }
  constructor(e) {
    typeof e == "function" ? this.configProvider = e().then((n) => n || {}) : (this.config = e ?? {}, this.configProvider = Promise.resolve(this.config)), Tv.supported === void 0 && (Tv.supported = typeof Request < "u" && "keepalive" in tP("https://[::1]"));
  }
  destroy() {
  }
  async handle(e, { abortSignal: n } = {}) {
    this.config || (this.config = await this.configProvider);
    const r = this.config.requestTimeout, s = this.config.keepAlive === !0, i = this.config.credentials;
    if (n?.aborted) {
      const m = new Error("Request aborted");
      return m.name = "AbortError", Promise.reject(m);
    }
    let o = e.path;
    const a = Ide(e.query || {});
    a && (o += `?${a}`), e.fragment && (o += `#${e.fragment}`);
    let l = "";
    if (e.username != null || e.password != null) {
      const m = e.username ?? "", b = e.password ?? "";
      l = `${m}:${b}@`;
    }
    const { port: c, method: u } = e, h = `${e.protocol}//${l}${e.hostname}${c ? `:${c}` : ""}${o}`, d = u === "GET" || u === "HEAD" ? void 0 : e.body, f = {
      body: d,
      headers: new Headers(e.headers),
      method: u,
      credentials: i
    };
    this.config?.cache && (f.cache = this.config.cache), d && (f.duplex = "half"), typeof AbortController < "u" && (f.signal = n), Tv.supported && (f.keepalive = s), typeof this.config.requestInit == "function" && Object.assign(f, this.config.requestInit(e));
    let g = () => {
    };
    const y = tP(h, f), p = [
      fetch(y).then((m) => {
        const b = m.headers, _ = {};
        for (const w of b.entries())
          _[w[0]] = w[1];
        return m.body != null ? {
          response: new N0({
            headers: _,
            reason: m.statusText,
            statusCode: m.status,
            body: m.body
          })
        } : m.blob().then((w) => ({
          response: new N0({
            headers: _,
            reason: m.statusText,
            statusCode: m.status,
            body: w
          })
        }));
      }),
      Pde(r)
    ];
    return n && p.push(new Promise((m, b) => {
      const _ = () => {
        const v = new Error("Request aborted");
        v.name = "AbortError", b(v);
      };
      if (typeof n.addEventListener == "function") {
        const v = n;
        v.addEventListener("abort", _, { once: !0 }), g = () => v.removeEventListener("abort", _);
      } else
        n.onabort = _;
    })), Promise.race(p).finally(g);
  }
  updateHttpClientConfig(e, n) {
    this.config = void 0, this.configProvider = this.configProvider.then((r) => (r[e] = n, r));
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
const Ode = async (t) => typeof Blob == "function" && t instanceof Blob || t.constructor?.name === "Blob" ? Blob.prototype.arrayBuffer !== void 0 ? new Uint8Array(await t.arrayBuffer()) : Dde(t) : Nde(t);
async function Dde(t) {
  const e = await Lde(t), n = MC(e);
  return new Uint8Array(n);
}
async function Nde(t) {
  const e = [], n = t.getReader();
  let r = !1, s = 0;
  for (; !r; ) {
    const { done: a, value: l } = await n.read();
    l && (e.push(l), s += l.length), r = a;
  }
  const i = new Uint8Array(s);
  let o = 0;
  for (const a of e)
    i.set(a, o), o += a.length;
  return i;
}
function Lde(t) {
  return new Promise((e, n) => {
    const r = new FileReader();
    r.onloadend = () => {
      if (r.readyState !== 2)
        return n(new Error("Reader aborted too early"));
      const s = r.result ?? "", i = s.indexOf(","), o = i > -1 ? i + 1 : s.length;
      e(s.substring(o));
    }, r.onabort = () => n(new Error("Read aborted")), r.onerror = () => n(r.error), r.readAsDataURL(t);
  });
}
const CU = {}, iS = {};
for (let t = 0; t < 256; t++) {
  let e = t.toString(16).toLowerCase();
  e.length === 1 && (e = `0${e}`), CU[t] = e, iS[e] = t;
}
function kU(t) {
  if (t.length % 2 !== 0)
    throw new Error("Hex encoded strings must have an even number length");
  const e = new Uint8Array(t.length / 2);
  for (let n = 0; n < t.length; n += 2) {
    const r = t.slice(n, n + 2).toLowerCase();
    if (r in iS)
      e[n / 2] = iS[r];
    else
      throw new Error(`Cannot decode unrecognized sequence ${r} as hexadecimal`);
  }
  return e;
}
function Rr(t) {
  let e = "";
  for (let n = 0; n < t.byteLength; n++)
    e += CU[t[n]];
  return e;
}
const AU = async (t = new Uint8Array(), e) => {
  if (t instanceof Uint8Array)
    return nl.mutate(t);
  if (!t)
    return nl.mutate(new Uint8Array());
  const n = e.streamCollector(t);
  return nl.mutate(await n);
};
function nP(t) {
  return encodeURIComponent(t).replace(/[!'()*]/g, function(e) {
    return "%" + e.charCodeAt(0).toString(16).toUpperCase();
  });
}
const Mde = (t, e, n, r, s, i) => {
  if (e != null && e[n] !== void 0) {
    const o = r();
    if (o.length <= 0)
      throw new Error("Empty value provided for input HTTP label: " + n + ".");
    t = t.replace(s, i ? o.split("/").map((a) => nP(a)).join("/") : nP(o));
  } else
    throw new Error("No value provided for input HTTP label: " + n + ".");
  return t;
};
function FC(t, e) {
  return new Bde(t, e);
}
class Bde {
  constructor(e, n) {
    this.input = e, this.context = n, this.query = {}, this.method = "", this.headers = {}, this.path = "", this.body = null, this.hostname = "", this.resolvePathStack = [];
  }
  async build() {
    const { hostname: e, protocol: n = "https", port: r, path: s } = await this.context.endpoint();
    this.path = s;
    for (const i of this.resolvePathStack)
      i(this.path);
    return new Br({
      protocol: n,
      hostname: this.hostname || e,
      port: r,
      method: this.method,
      path: this.path,
      query: this.query,
      body: this.body,
      headers: this.headers
    });
  }
  hn(e) {
    return this.hostname = e, this;
  }
  bp(e) {
    return this.resolvePathStack.push((n) => {
      this.path = `${n?.endsWith("/") ? n.slice(0, -1) : n || ""}` + e;
    }), this;
  }
  p(e, n, r, s) {
    return this.resolvePathStack.push((i) => {
      this.path = Mde(i, this.input, e, n, r, s);
    }), this;
  }
  h(e) {
    return this.headers = e, this;
  }
  q(e) {
    return this.query = e, this;
  }
  b(e) {
    return this.body = e, this;
  }
  m(e) {
    return this.method = e, this;
  }
}
function Fde(t, e, n) {
  t.__smithy_context ? t.__smithy_context.features || (t.__smithy_context.features = {}) : t.__smithy_context = {
    features: {}
  }, t.__smithy_context.features[e] = n;
}
class $de {
  constructor(e) {
    this.authSchemes = /* @__PURE__ */ new Map();
    for (const [n, r] of Object.entries(e))
      r !== void 0 && this.authSchemes.set(n, r);
  }
  getIdentityProvider(e) {
    return this.authSchemes.get(e);
  }
}
const Ude = (t) => (e) => RU(e) && e.expiration.getTime() - Date.now() < t, jde = 3e5, Hde = Ude(jde), RU = (t) => t.expiration !== void 0, zde = (t, e, n) => {
  if (t === void 0)
    return;
  const r = typeof t != "function" ? async () => Promise.resolve(t) : t;
  let s, i, o, a = !1;
  const l = async (c) => {
    i || (i = r(c));
    try {
      s = await i, o = !0, a = !1;
    } finally {
      i = void 0;
    }
    return s;
  };
  return e === void 0 ? async (c) => ((!o || c?.forceRefresh) && (s = await l(c)), s) : async (c) => ((!o || c?.forceRefresh) && (s = await l(c)), a ? s : n(s) ? (e(s) && await l(c), s) : (a = !0, s));
}, Gde = void 0;
function Vde(t) {
  return t === void 0 ? !0 : typeof t == "string" && t.length <= 50;
}
function Wde(t) {
  const e = Ch(t.userAgentAppId ?? Gde);
  return {
    ...t,
    customUserAgent: typeof t.customUserAgent == "string" ? [[t.customUserAgent]] : t.customUserAgent,
    userAgentAppId: async () => {
      const n = await e();
      if (!Vde(n)) {
        const r = t.logger?.constructor?.name === "NoOpLogger" || !t.logger ? console : t.logger;
        typeof n != "string" ? r?.warn("userAgentAppId must be a string or undefined.") : n.length > 50 && r?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
      }
      return n;
    }
  };
}
class qde {
  constructor({ size: e, params: n }) {
    this.data = /* @__PURE__ */ new Map(), this.parameters = [], this.capacity = e ?? 50, n && (this.parameters = n);
  }
  get(e, n) {
    const r = this.hash(e);
    if (r === !1)
      return n();
    if (!this.data.has(r)) {
      if (this.data.size > this.capacity + 10) {
        const s = this.data.keys();
        let i = 0;
        for (; ; ) {
          const { value: o, done: a } = s.next();
          if (this.data.delete(o), a || ++i > 10)
            break;
        }
      }
      this.data.set(r, n());
    }
    return this.data.get(r);
  }
  size() {
    return this.data.size;
  }
  hash(e) {
    let n = "";
    const { parameters: r } = this;
    if (r.length === 0)
      return !1;
    for (const s of r) {
      const i = String(e[s] ?? "");
      if (i.includes("|;"))
        return !1;
      n += i + "|;";
    }
    return n;
  }
}
const Kde = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"), IU = (t) => Kde.test(t) || t.startsWith("[") && t.endsWith("]"), Yde = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"), $C = (t, e = !1) => {
  if (!e)
    return Yde.test(t);
  const n = t.split(".");
  for (const r of n)
    if (!$C(r))
      return !1;
  return !0;
}, L0 = {}, zd = "endpoints";
function sa(t) {
  return typeof t != "object" || t == null ? t : "ref" in t ? `$${sa(t.ref)}` : "fn" in t ? `${t.fn}(${(t.argv || []).map(sa).join(", ")})` : JSON.stringify(t, null, 2);
}
class Fr extends Error {
  constructor(e) {
    super(e), this.name = "EndpointError";
  }
}
const Zde = (t, e) => t === e, Jde = (t) => {
  const e = t.split("."), n = [];
  for (const r of e) {
    const s = r.indexOf("[");
    if (s !== -1) {
      if (r.indexOf("]") !== r.length - 1)
        throw new Fr(`Path: '${t}' does not end with ']'`);
      const i = r.slice(s + 1, -1);
      if (Number.isNaN(parseInt(i)))
        throw new Fr(`Invalid array index: '${i}' in path: '${t}'`);
      s !== 0 && n.push(r.slice(0, s)), n.push(i);
    } else
      n.push(r);
  }
  return n;
}, PU = (t, e) => Jde(e).reduce((n, r) => {
  if (typeof n != "object")
    throw new Fr(`Index '${r}' in '${e}' not found in '${JSON.stringify(t)}'`);
  return Array.isArray(n) ? n[parseInt(r)] : n[r];
}, t), Xde = (t) => t != null, Qde = (t) => !t, Cv = {
  [Hd.HTTP]: 80,
  [Hd.HTTPS]: 443
}, efe = (t) => {
  const e = (() => {
    try {
      if (t instanceof URL)
        return t;
      if (typeof t == "object" && "hostname" in t) {
        const { hostname: d, port: f, protocol: g = "", path: y = "", query: p = {} } = t, m = new URL(`${g}//${d}${f ? `:${f}` : ""}${y}`);
        return m.search = Object.entries(p).map(([b, _]) => `${b}=${_}`).join("&"), m;
      }
      return new URL(t);
    } catch {
      return null;
    }
  })();
  if (!e)
    return console.error(`Unable to parse ${JSON.stringify(t)} as a whatwg URL.`), null;
  const n = e.href, { host: r, hostname: s, pathname: i, protocol: o, search: a } = e;
  if (a)
    return null;
  const l = o.slice(0, -1);
  if (!Object.values(Hd).includes(l))
    return null;
  const c = IU(s), u = n.includes(`${r}:${Cv[l]}`) || typeof t == "string" && t.includes(`${r}:${Cv[l]}`), h = `${r}${u ? `:${Cv[l]}` : ""}`;
  return {
    scheme: l,
    authority: h,
    path: i,
    normalizedPath: i.endsWith("/") ? i : `${i}/`,
    isIp: c
  };
}, tfe = (t, e) => t === e, nfe = (t, e, n, r) => e >= n || t.length < n ? null : r ? t.substring(t.length - n, t.length - e) : t.substring(e, n), rfe = (t) => encodeURIComponent(t).replace(/[!*'()]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), sfe = {
  booleanEquals: Zde,
  getAttr: PU,
  isSet: Xde,
  isValidHostLabel: $C,
  not: Qde,
  parseURL: efe,
  stringEquals: tfe,
  substring: nfe,
  uriEncode: rfe
}, OU = (t, e) => {
  const n = [], r = {
    ...e.endpointParams,
    ...e.referenceRecord
  };
  let s = 0;
  for (; s < t.length; ) {
    const i = t.indexOf("{", s);
    if (i === -1) {
      n.push(t.slice(s));
      break;
    }
    n.push(t.slice(s, i));
    const o = t.indexOf("}", i);
    if (o === -1) {
      n.push(t.slice(i));
      break;
    }
    t[i + 1] === "{" && t[o + 1] === "}" && (n.push(t.slice(i + 1, o)), s = o + 2);
    const a = t.substring(i + 1, o);
    if (a.includes("#")) {
      const [l, c] = a.split("#");
      n.push(PU(r[l], c));
    } else
      n.push(r[a]);
    s = o + 1;
  }
  return n.join("");
}, ife = ({ ref: t }, e) => ({
  ...e.endpointParams,
  ...e.referenceRecord
})[t], Tb = (t, e, n) => {
  if (typeof t == "string")
    return OU(t, n);
  if (t.fn)
    return DU(t, n);
  if (t.ref)
    return ife(t, n);
  throw new Fr(`'${e}': ${String(t)} is not a string, function or reference.`);
}, DU = ({ fn: t, argv: e }, n) => {
  const r = e.map((i) => ["boolean", "number"].includes(typeof i) ? i : Tb(i, "arg", n)), s = t.split(".");
  return s[0] in L0 && s[1] != null ? L0[s[0]][s[1]](...r) : sfe[t](...r);
}, ofe = ({ assign: t, ...e }, n) => {
  if (t && t in n.referenceRecord)
    throw new Fr(`'${t}' is already defined in Reference Record.`);
  const r = DU(e, n);
  return n.logger?.debug?.(`${zd} evaluateCondition: ${sa(e)} = ${sa(r)}`), {
    result: r === "" ? !0 : !!r,
    ...t != null && { toAssign: { name: t, value: r } }
  };
}, UC = (t = [], e) => {
  const n = {};
  for (const r of t) {
    const { result: s, toAssign: i } = ofe(r, {
      ...e,
      referenceRecord: {
        ...e.referenceRecord,
        ...n
      }
    });
    if (!s)
      return { result: s };
    i && (n[i.name] = i.value, e.logger?.debug?.(`${zd} assign: ${i.name} := ${sa(i.value)}`));
  }
  return { result: !0, referenceRecord: n };
}, afe = (t, e) => Object.entries(t).reduce((n, [r, s]) => ({
  ...n,
  [r]: s.map((i) => {
    const o = Tb(i, "Header value entry", e);
    if (typeof o != "string")
      throw new Fr(`Header '${r}' value '${o}' is not a string`);
    return o;
  })
}), {}), NU = (t, e) => {
  if (Array.isArray(t))
    return t.map((n) => NU(n, e));
  switch (typeof t) {
    case "string":
      return OU(t, e);
    case "object":
      if (t === null)
        throw new Fr(`Unexpected endpoint property: ${t}`);
      return LU(t, e);
    case "boolean":
      return t;
    default:
      throw new Fr(`Unexpected endpoint property type: ${typeof t}`);
  }
}, LU = (t, e) => Object.entries(t).reduce((n, [r, s]) => ({
  ...n,
  [r]: NU(s, e)
}), {}), lfe = (t, e) => {
  const n = Tb(t, "Endpoint URL", e);
  if (typeof n == "string")
    try {
      return new URL(n);
    } catch (r) {
      throw console.error(`Failed to construct URL with ${n}`, r), r;
    }
  throw new Fr(`Endpoint URL must be a string, got ${typeof n}`);
}, cfe = (t, e) => {
  const { conditions: n, endpoint: r } = t, { result: s, referenceRecord: i } = UC(n, e);
  if (!s)
    return;
  const o = {
    ...e,
    referenceRecord: { ...e.referenceRecord, ...i }
  }, { url: a, properties: l, headers: c } = r;
  return e.logger?.debug?.(`${zd} Resolving endpoint from template: ${sa(r)}`), {
    ...c != null && {
      headers: afe(c, o)
    },
    ...l != null && {
      properties: LU(l, o)
    },
    url: lfe(a, o)
  };
}, ufe = (t, e) => {
  const { conditions: n, error: r } = t, { result: s, referenceRecord: i } = UC(n, e);
  if (s)
    throw new Fr(Tb(r, "Error", {
      ...e,
      referenceRecord: { ...e.referenceRecord, ...i }
    }));
}, hfe = (t, e) => {
  const { conditions: n, rules: r } = t, { result: s, referenceRecord: i } = UC(n, e);
  if (s)
    return MU(r, {
      ...e,
      referenceRecord: { ...e.referenceRecord, ...i }
    });
}, MU = (t, e) => {
  for (const n of t)
    if (n.type === "endpoint") {
      const r = cfe(n, e);
      if (r)
        return r;
    } else if (n.type === "error")
      ufe(n, e);
    else if (n.type === "tree") {
      const r = hfe(n, e);
      if (r)
        return r;
    } else
      throw new Fr(`Unknown endpoint rule: ${n}`);
  throw new Fr("Rules evaluation failed");
}, dfe = (t, e) => {
  const { endpointParams: n, logger: r } = e, { parameters: s, rules: i } = t;
  e.logger?.debug?.(`${zd} Initial EndpointParams: ${sa(n)}`);
  const o = Object.entries(s).filter(([, c]) => c.default != null).map(([c, u]) => [c, u.default]);
  if (o.length > 0)
    for (const [c, u] of o)
      n[c] = n[c] ?? u;
  const a = Object.entries(s).filter(([, c]) => c.required).map(([c]) => c);
  for (const c of a)
    if (n[c] == null)
      throw new Fr(`Missing required parameter: '${c}'`);
  const l = MU(i, { endpointParams: n, logger: r, referenceRecord: {} });
  return e.logger?.debug?.(`${zd} Resolved endpoint: ${sa(l)}`), l;
}, BU = (t, e = !1) => {
  if (e) {
    for (const n of t.split("."))
      if (!BU(n))
        return !1;
    return !0;
  }
  return !(!$C(t) || t.length < 3 || t.length > 63 || t !== t.toLowerCase() || IU(t));
}, rP = ":", ffe = "/", pfe = (t) => {
  const e = t.split(rP);
  if (e.length < 6)
    return null;
  const [n, r, s, i, o, ...a] = e;
  if (n !== "arn" || r === "" || s === "" || a.join(rP) === "")
    return null;
  const l = a.map((c) => c.split(ffe)).flat();
  return {
    partition: r,
    service: s,
    region: i,
    accountId: o,
    resourceId: l
  };
}, mfe = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "ap-southeast-5": {
        description: "Asia Pacific (Malaysia)"
      },
      "ap-southeast-7": {
        description: "Asia Pacific (Thailand)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "mx-central-1": {
        description: "Mexico (Central)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {
      "eu-isoe-west-1": {
        description: "EU ISOE West"
      }
    }
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }
], gfe = {
  partitions: mfe
};
let yfe = gfe;
const bfe = (t) => {
  const { partitions: e } = yfe;
  for (const r of e) {
    const { regions: s, outputs: i } = r;
    for (const [o, a] of Object.entries(s))
      if (o === t)
        return {
          ...i,
          ...a
        };
  }
  for (const r of e) {
    const { regionRegex: s, outputs: i } = r;
    if (new RegExp(s).test(t))
      return {
        ...i
      };
  }
  const n = e.find((r) => r.id === "aws");
  if (!n)
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  return {
    ...n.outputs
  };
}, FU = {
  isVirtualHostableS3Bucket: BU,
  parseArn: pfe,
  partition: bfe
};
L0.aws = FU;
function _fe(t, e, n) {
  return t.$source || (t.$source = {}), t.$source[e] = n, t;
}
function Bs(t, e, n) {
  t.__aws_sdk_context ? t.__aws_sdk_context.features || (t.__aws_sdk_context.features = {}) : t.__aws_sdk_context = {
    features: {}
  }, t.__aws_sdk_context.features[e] = n;
}
const sP = (t) => N0.isInstance(t) ? t.headers?.date ?? t.headers?.Date : void 0, $U = (t) => new Date(Date.now() + t), vfe = (t, e) => Math.abs($U(e).getTime() - t) >= 3e5, iP = (t, e) => {
  const n = Date.parse(t);
  return vfe(n, e) ? n - Date.now() : e;
}, Yh = (t, e) => {
  if (!e)
    throw new Error(`Property \`${t}\` is not resolved for AWS SDK SigV4Auth`);
  return e;
}, wfe = async (t) => {
  const e = Yh("context", t.context), n = Yh("config", t.config), r = e.endpointV2?.properties?.authSchemes?.[0], i = await Yh("signer", n.signer)(r), o = t?.signingRegion, a = t?.signingRegionSet, l = t?.signingName;
  return {
    config: n,
    signer: i,
    signingRegion: o,
    signingRegionSet: a,
    signingName: l
  };
};
class Efe {
  async sign(e, n, r) {
    if (!Br.isInstance(e))
      throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
    const s = await wfe(r), { config: i, signer: o } = s;
    let { signingRegion: a, signingName: l } = s;
    const c = r.context;
    if (c?.authSchemes?.length ?? !1) {
      const [h, d] = c.authSchemes;
      h?.name === "sigv4a" && d?.name === "sigv4" && (a = d?.signingRegion ?? a, l = d?.signingName ?? l);
    }
    return await o.sign(e, {
      signingDate: $U(i.systemClockOffset),
      signingRegion: a,
      signingService: l
    });
  }
  errorHandler(e) {
    return (n) => {
      const r = n.ServerTime ?? sP(n.$response);
      if (r) {
        const s = Yh("config", e.config), i = s.systemClockOffset;
        s.systemClockOffset = iP(r, s.systemClockOffset), s.systemClockOffset !== i && n.$metadata && (n.$metadata.clockSkewCorrected = !0);
      }
      throw n;
    };
  }
  successHandler(e, n) {
    const r = sP(e);
    if (r) {
      const s = Yh("config", n.config);
      s.systemClockOffset = iP(r, s.systemClockOffset);
    }
  }
}
const Sfe = (t, e, n) => {
  let r, s, i, o = !1;
  const a = async () => {
    s || (s = t());
    try {
      r = await s, i = !0, o = !1;
    } finally {
      s = void 0;
    }
    return r;
  };
  return async (l) => ((!i || l?.forceRefresh) && (r = await a()), r);
}, xfe = "X-Amz-Algorithm", Tfe = "X-Amz-Credential", UU = "X-Amz-Date", Cfe = "X-Amz-SignedHeaders", kfe = "X-Amz-Expires", jU = "X-Amz-Signature", HU = "X-Amz-Security-Token", zU = "authorization", GU = UU.toLowerCase(), Afe = "date", Rfe = [zU, GU, Afe], Ife = jU.toLowerCase(), oS = "x-amz-content-sha256", Pfe = HU.toLowerCase(), Ofe = {
  authorization: !0,
  "cache-control": !0,
  connection: !0,
  expect: !0,
  from: !0,
  "keep-alive": !0,
  "max-forwards": !0,
  pragma: !0,
  referer: !0,
  te: !0,
  trailer: !0,
  "transfer-encoding": !0,
  upgrade: !0,
  "user-agent": !0,
  "x-amzn-trace-id": !0
}, Dfe = /^proxy-/, Nfe = /^sec-/, kv = "AWS4-HMAC-SHA256", Lfe = "AWS4-HMAC-SHA256-PAYLOAD", Mfe = "UNSIGNED-PAYLOAD", Bfe = 50, VU = "aws4_request", Ffe = 60 * 60 * 24 * 7, am = {}, Av = [], Rv = (t, e, n) => `${t}/${e}/${n}/${VU}`, $fe = async (t, e, n, r, s) => {
  const i = await oP(t, e.secretAccessKey, e.accessKeyId), o = `${n}:${r}:${s}:${Rr(i)}:${e.sessionToken}`;
  if (o in am)
    return am[o];
  for (Av.push(o); Av.length > Bfe; )
    delete am[Av.shift()];
  let a = `AWS4${e.secretAccessKey}`;
  for (const l of [n, r, s, VU])
    a = await oP(t, a, l);
  return am[o] = a;
}, oP = (t, e, n) => {
  const r = new t(e);
  return r.update(Kh(n)), r.digest();
}, aP = ({ headers: t }, e, n) => {
  const r = {};
  for (const s of Object.keys(t).sort()) {
    if (t[s] == null)
      continue;
    const i = s.toLowerCase();
    (i in Ofe || e?.has(i) || Dfe.test(i) || Nfe.test(i)) && (!n || n && !n.has(i)) || (r[i] = t[s].trim().replace(/\s+/g, " "));
  }
  return r;
}, Ufe = ({ query: t = {} }) => {
  const e = [], n = {};
  for (const r of Object.keys(t)) {
    if (r.toLowerCase() === Ife)
      continue;
    const s = rl(r);
    e.push(s);
    const i = t[r];
    typeof i == "string" ? n[s] = `${s}=${rl(i)}` : Array.isArray(i) && (n[s] = i.slice(0).reduce((o, a) => o.concat([`${s}=${rl(a)}`]), []).sort().join("&"));
  }
  return e.sort().map((r) => n[r]).filter((r) => r).join("&");
}, jfe = (t) => typeof ArrayBuffer == "function" && t instanceof ArrayBuffer || Object.prototype.toString.call(t) === "[object ArrayBuffer]", Iv = async ({ headers: t, body: e }, n) => {
  for (const r of Object.keys(t))
    if (r.toLowerCase() === oS)
      return t[r];
  if (e == null)
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  if (typeof e == "string" || ArrayBuffer.isView(e) || jfe(e)) {
    const r = new n();
    return r.update(Kh(e)), Rr(await r.digest());
  }
  return Mfe;
};
class Hfe {
  format(e) {
    const n = [];
    for (const i of Object.keys(e)) {
      const o = ru(i);
      n.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(e[i]));
    }
    const r = new Uint8Array(n.reduce((i, o) => i + o.byteLength, 0));
    let s = 0;
    for (const i of n)
      r.set(i, s), s += i.byteLength;
    return r;
  }
  formatHeaderValue(e) {
    switch (e.type) {
      case "boolean":
        return Uint8Array.from([e.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, e.value]);
      case "short":
        const n = new DataView(new ArrayBuffer(3));
        return n.setUint8(0, 3), n.setInt16(1, e.value, !1), new Uint8Array(n.buffer);
      case "integer":
        const r = new DataView(new ArrayBuffer(5));
        return r.setUint8(0, 4), r.setInt32(1, e.value, !1), new Uint8Array(r.buffer);
      case "long":
        const s = new Uint8Array(9);
        return s[0] = 5, s.set(e.value.bytes, 1), s;
      case "binary":
        const i = new DataView(new ArrayBuffer(3 + e.value.byteLength));
        i.setUint8(0, 6), i.setUint16(1, e.value.byteLength, !1);
        const o = new Uint8Array(i.buffer);
        return o.set(e.value, 3), o;
      case "string":
        const a = ru(e.value), l = new DataView(new ArrayBuffer(3 + a.byteLength));
        l.setUint8(0, 7), l.setUint16(1, a.byteLength, !1);
        const c = new Uint8Array(l.buffer);
        return c.set(a, 3), c;
      case "timestamp":
        const u = new Uint8Array(9);
        return u[0] = 8, u.set(Gfe.fromNumber(e.value.valueOf()).bytes, 1), u;
      case "uuid":
        if (!zfe.test(e.value))
          throw new Error(`Invalid UUID received: ${e.value}`);
        const h = new Uint8Array(17);
        return h[0] = 9, h.set(kU(e.value.replace(/\-/g, "")), 1), h;
    }
  }
}
var lP;
(function(t) {
  t[t.boolTrue = 0] = "boolTrue", t[t.boolFalse = 1] = "boolFalse", t[t.byte = 2] = "byte", t[t.short = 3] = "short", t[t.integer = 4] = "integer", t[t.long = 5] = "long", t[t.byteArray = 6] = "byteArray", t[t.string = 7] = "string", t[t.timestamp = 8] = "timestamp", t[t.uuid = 9] = "uuid";
})(lP || (lP = {}));
const zfe = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
let Gfe = class WU {
  constructor(e) {
    if (this.bytes = e, e.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(e) {
    if (e > 9223372036854776e3 || e < -9223372036854776e3)
      throw new Error(`${e} is too large (or, if negative, too small) to represent as an Int64`);
    const n = new Uint8Array(8);
    for (let r = 7, s = Math.abs(Math.round(e)); r > -1 && s > 0; r--, s /= 256)
      n[r] = s;
    return e < 0 && cP(n), new WU(n);
  }
  valueOf() {
    const e = this.bytes.slice(0), n = e[0] & 128;
    return n && cP(e), parseInt(Rr(e), 16) * (n ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function cP(t) {
  for (let e = 0; e < 8; e++)
    t[e] ^= 255;
  for (let e = 7; e > -1 && (t[e]++, t[e] === 0); e--)
    ;
}
const Vfe = (t, e) => {
  t = t.toLowerCase();
  for (const n of Object.keys(e))
    if (t === n.toLowerCase())
      return !0;
  return !1;
}, Wfe = (t, e = {}) => {
  const { headers: n, query: r = {} } = Br.clone(t);
  for (const s of Object.keys(n)) {
    const i = s.toLowerCase();
    (i.slice(0, 6) === "x-amz-" && !e.unhoistableHeaders?.has(i) || e.hoistableHeaders?.has(i)) && (r[s] = n[s], delete n[s]);
  }
  return {
    ...t,
    headers: n,
    query: r
  };
}, uP = (t) => {
  t = Br.clone(t);
  for (const e of Object.keys(t.headers))
    Rfe.indexOf(e.toLowerCase()) > -1 && delete t.headers[e];
  return t;
}, qfe = (t) => Kfe(t).toISOString().replace(/\.\d{3}Z$/, "Z"), Kfe = (t) => typeof t == "number" ? new Date(t * 1e3) : typeof t == "string" ? Number(t) ? new Date(Number(t) * 1e3) : new Date(t) : t;
class hP {
  constructor({ applyChecksum: e, credentials: n, region: r, service: s, sha256: i, uriEscapePath: o = !0 }) {
    this.headerFormatter = new Hfe(), this.service = s, this.sha256 = i, this.uriEscapePath = o, this.applyChecksum = typeof e == "boolean" ? e : !0, this.regionProvider = qo(r), this.credentialProvider = qo(n);
  }
  async presign(e, n = {}) {
    const { signingDate: r = /* @__PURE__ */ new Date(), expiresIn: s = 3600, unsignableHeaders: i, unhoistableHeaders: o, signableHeaders: a, hoistableHeaders: l, signingRegion: c, signingService: u } = n, h = await this.credentialProvider();
    this.validateResolvedCredentials(h);
    const d = c ?? await this.regionProvider(), { longDate: f, shortDate: g } = lm(r);
    if (s > Ffe)
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    const y = Rv(g, d, u ?? this.service), p = Wfe(uP(e), { unhoistableHeaders: o, hoistableHeaders: l });
    h.sessionToken && (p.query[HU] = h.sessionToken), p.query[xfe] = kv, p.query[Tfe] = `${h.accessKeyId}/${y}`, p.query[UU] = f, p.query[kfe] = s.toString(10);
    const m = aP(p, i, a);
    return p.query[Cfe] = dP(m), p.query[jU] = await this.getSignature(f, y, this.getSigningKey(h, d, g, u), this.createCanonicalRequest(p, m, await Iv(e, this.sha256))), p;
  }
  async sign(e, n) {
    return typeof e == "string" ? this.signString(e, n) : e.headers && e.payload ? this.signEvent(e, n) : e.message ? this.signMessage(e, n) : this.signRequest(e, n);
  }
  async signEvent({ headers: e, payload: n }, { signingDate: r = /* @__PURE__ */ new Date(), priorSignature: s, signingRegion: i, signingService: o }) {
    const a = i ?? await this.regionProvider(), { shortDate: l, longDate: c } = lm(r), u = Rv(l, a, o ?? this.service), h = await Iv({ headers: {}, body: n }, this.sha256), d = new this.sha256();
    d.update(e);
    const f = Rr(await d.digest()), g = [
      Lfe,
      c,
      u,
      s,
      f,
      h
    ].join(`
`);
    return this.signString(g, { signingDate: r, signingRegion: a, signingService: o });
  }
  async signMessage(e, { signingDate: n = /* @__PURE__ */ new Date(), signingRegion: r, signingService: s }) {
    return this.signEvent({
      headers: this.headerFormatter.format(e.message.headers),
      payload: e.message.body
    }, {
      signingDate: n,
      signingRegion: r,
      signingService: s,
      priorSignature: e.priorSignature
    }).then((o) => ({ message: e.message, signature: o }));
  }
  async signString(e, { signingDate: n = /* @__PURE__ */ new Date(), signingRegion: r, signingService: s } = {}) {
    const i = await this.credentialProvider();
    this.validateResolvedCredentials(i);
    const o = r ?? await this.regionProvider(), { shortDate: a } = lm(n), l = new this.sha256(await this.getSigningKey(i, o, a, s));
    return l.update(Kh(e)), Rr(await l.digest());
  }
  async signRequest(e, { signingDate: n = /* @__PURE__ */ new Date(), signableHeaders: r, unsignableHeaders: s, signingRegion: i, signingService: o } = {}) {
    const a = await this.credentialProvider();
    this.validateResolvedCredentials(a);
    const l = i ?? await this.regionProvider(), c = uP(e), { longDate: u, shortDate: h } = lm(n), d = Rv(h, l, o ?? this.service);
    c.headers[GU] = u, a.sessionToken && (c.headers[Pfe] = a.sessionToken);
    const f = await Iv(c, this.sha256);
    !Vfe(oS, c.headers) && this.applyChecksum && (c.headers[oS] = f);
    const g = aP(c, s, r), y = await this.getSignature(u, d, this.getSigningKey(a, l, h, o), this.createCanonicalRequest(c, g, f));
    return c.headers[zU] = `${kv} Credential=${a.accessKeyId}/${d}, SignedHeaders=${dP(g)}, Signature=${y}`, c;
  }
  createCanonicalRequest(e, n, r) {
    const s = Object.keys(n).sort();
    return `${e.method}
${this.getCanonicalPath(e)}
${Ufe(e)}
${s.map((i) => `${i}:${n[i]}`).join(`
`)}

${s.join(";")}
${r}`;
  }
  async createStringToSign(e, n, r) {
    const s = new this.sha256();
    s.update(Kh(r));
    const i = await s.digest();
    return `${kv}
${e}
${n}
${Rr(i)}`;
  }
  getCanonicalPath({ path: e }) {
    if (this.uriEscapePath) {
      const n = [];
      for (const i of e.split("/"))
        i?.length !== 0 && i !== "." && (i === ".." ? n.pop() : n.push(i));
      const r = `${e?.startsWith("/") ? "/" : ""}${n.join("/")}${n.length > 0 && e?.endsWith("/") ? "/" : ""}`;
      return rl(r).replace(/%2F/g, "/");
    }
    return e;
  }
  async getSignature(e, n, r, s) {
    const i = await this.createStringToSign(e, n, s), o = new this.sha256(await r);
    return o.update(Kh(i)), Rr(await o.digest());
  }
  getSigningKey(e, n, r, s) {
    return $fe(this.sha256, e, r, n, s || this.service);
  }
  validateResolvedCredentials(e) {
    if (typeof e != "object" || typeof e.accessKeyId != "string" || typeof e.secretAccessKey != "string")
      throw new Error("Resolved credential object is not valid");
  }
}
const lm = (t) => {
  const e = qfe(t).replace(/[\-:]/g, "");
  return {
    longDate: e,
    shortDate: e.slice(0, 8)
  };
}, dP = (t) => Object.keys(t).sort().join(";"), Yfe = (t) => {
  let e = !1, n;
  t.credentials && (e = !0, n = zde(t.credentials, Hde, RU)), n || (t.credentialDefaultProvider ? n = Ch(t.credentialDefaultProvider(Object.assign({}, t, {
    parentClientConfig: t
  }))) : n = async () => {
    throw new Error("`credentials` is missing");
  });
  const r = async () => n({ callerClientConfig: t }), { signingEscapePath: s = !0, systemClockOffset: i = t.systemClockOffset || 0, sha256: o } = t;
  let a;
  return t.signer ? a = Ch(t.signer) : t.regionInfoProvider ? a = () => Ch(t.region)().then(async (l) => [
    await t.regionInfoProvider(l, {
      useFipsEndpoint: await t.useFipsEndpoint(),
      useDualstackEndpoint: await t.useDualstackEndpoint()
    }) || {},
    l
  ]).then(([l, c]) => {
    const { signingRegion: u, signingService: h } = l;
    t.signingRegion = t.signingRegion || u || c, t.signingName = t.signingName || h || t.serviceId;
    const d = {
      ...t,
      credentials: r,
      region: t.signingRegion,
      service: t.signingName,
      sha256: o,
      uriEscapePath: s
    }, f = t.signerConstructor || hP;
    return new f(d);
  }) : a = async (l) => {
    l = Object.assign({}, {
      name: "sigv4",
      signingName: t.signingName || t.defaultSigningName,
      signingRegion: await Ch(t.region)(),
      properties: {}
    }, l);
    const c = l.signingRegion, u = l.signingName;
    t.signingRegion = t.signingRegion || c, t.signingName = t.signingName || u || t.serviceId;
    const h = {
      ...t,
      credentials: r,
      region: t.signingRegion,
      service: t.signingName,
      sha256: o,
      uriEscapePath: s
    }, d = t.signerConstructor || hP;
    return new d(h);
  }, {
    ...t,
    systemClockOffset: i,
    signingEscapePath: s,
    credentials: e ? async () => r().then((l) => _fe(l, "CREDENTIALS_CODE", "e")) : r,
    signer: a
  };
}, xa = (t, e) => {
  const n = [];
  if (t && n.push(t), e)
    for (const r of e)
      n.push(r);
  return n;
}, vo = (t, e) => `${t || "anonymous"}${e && e.length > 0 ? ` (a.k.a. ${e.join(",")})` : ""}`, M0 = () => {
  let t = [], e = [], n = !1;
  const r = /* @__PURE__ */ new Set(), s = (h) => h.sort((d, f) => fP[f.step] - fP[d.step] || pP[f.priority || "normal"] - pP[d.priority || "normal"]), i = (h) => {
    let d = !1;
    const f = (g) => {
      const y = xa(g.name, g.aliases);
      if (y.includes(h)) {
        d = !0;
        for (const p of y)
          r.delete(p);
        return !1;
      }
      return !0;
    };
    return t = t.filter(f), e = e.filter(f), d;
  }, o = (h) => {
    let d = !1;
    const f = (g) => {
      if (g.middleware === h) {
        d = !0;
        for (const y of xa(g.name, g.aliases))
          r.delete(y);
        return !1;
      }
      return !0;
    };
    return t = t.filter(f), e = e.filter(f), d;
  }, a = (h) => (t.forEach((d) => {
    h.add(d.middleware, { ...d });
  }), e.forEach((d) => {
    h.addRelativeTo(d.middleware, { ...d });
  }), h.identifyOnResolve?.(u.identifyOnResolve()), h), l = (h) => {
    const d = [];
    return h.before.forEach((f) => {
      f.before.length === 0 && f.after.length === 0 ? d.push(f) : d.push(...l(f));
    }), d.push(h), h.after.reverse().forEach((f) => {
      f.before.length === 0 && f.after.length === 0 ? d.push(f) : d.push(...l(f));
    }), d;
  }, c = (h = !1) => {
    const d = [], f = [], g = {};
    return t.forEach((p) => {
      const m = {
        ...p,
        before: [],
        after: []
      };
      for (const b of xa(m.name, m.aliases))
        g[b] = m;
      d.push(m);
    }), e.forEach((p) => {
      const m = {
        ...p,
        before: [],
        after: []
      };
      for (const b of xa(m.name, m.aliases))
        g[b] = m;
      f.push(m);
    }), f.forEach((p) => {
      if (p.toMiddleware) {
        const m = g[p.toMiddleware];
        if (m === void 0) {
          if (h)
            return;
          throw new Error(`${p.toMiddleware} is not found when adding ${vo(p.name, p.aliases)} middleware ${p.relation} ${p.toMiddleware}`);
        }
        p.relation === "after" && m.after.push(p), p.relation === "before" && m.before.push(p);
      }
    }), s(d).map(l).reduce((p, m) => (p.push(...m), p), []);
  }, u = {
    add: (h, d = {}) => {
      const { name: f, override: g, aliases: y } = d, p = {
        step: "initialize",
        priority: "normal",
        middleware: h,
        ...d
      }, m = xa(f, y);
      if (m.length > 0) {
        if (m.some((b) => r.has(b))) {
          if (!g)
            throw new Error(`Duplicate middleware name '${vo(f, y)}'`);
          for (const b of m) {
            const _ = t.findIndex((w) => w.name === b || w.aliases?.some((E) => E === b));
            if (_ === -1)
              continue;
            const v = t[_];
            if (v.step !== p.step || p.priority !== v.priority)
              throw new Error(`"${vo(v.name, v.aliases)}" middleware with ${v.priority} priority in ${v.step} step cannot be overridden by "${vo(f, y)}" middleware with ${p.priority} priority in ${p.step} step.`);
            t.splice(_, 1);
          }
        }
        for (const b of m)
          r.add(b);
      }
      t.push(p);
    },
    addRelativeTo: (h, d) => {
      const { name: f, override: g, aliases: y } = d, p = {
        middleware: h,
        ...d
      }, m = xa(f, y);
      if (m.length > 0) {
        if (m.some((b) => r.has(b))) {
          if (!g)
            throw new Error(`Duplicate middleware name '${vo(f, y)}'`);
          for (const b of m) {
            const _ = e.findIndex((w) => w.name === b || w.aliases?.some((E) => E === b));
            if (_ === -1)
              continue;
            const v = e[_];
            if (v.toMiddleware !== p.toMiddleware || v.relation !== p.relation)
              throw new Error(`"${vo(v.name, v.aliases)}" middleware ${v.relation} "${v.toMiddleware}" middleware cannot be overridden by "${vo(f, y)}" middleware ${p.relation} "${p.toMiddleware}" middleware.`);
            e.splice(_, 1);
          }
        }
        for (const b of m)
          r.add(b);
      }
      e.push(p);
    },
    clone: () => a(M0()),
    use: (h) => {
      h.applyToStack(u);
    },
    remove: (h) => typeof h == "string" ? i(h) : o(h),
    removeByTag: (h) => {
      let d = !1;
      const f = (g) => {
        const { tags: y, name: p, aliases: m } = g;
        if (y && y.includes(h)) {
          const b = xa(p, m);
          for (const _ of b)
            r.delete(_);
          return d = !0, !1;
        }
        return !0;
      };
      return t = t.filter(f), e = e.filter(f), d;
    },
    concat: (h) => {
      const d = a(M0());
      return d.use(h), d.identifyOnResolve(n || d.identifyOnResolve() || (h.identifyOnResolve?.() ?? !1)), d;
    },
    applyToStack: a,
    identify: () => c(!0).map((h) => {
      const d = h.step ?? h.relation + " " + h.toMiddleware;
      return vo(h.name, h.aliases) + " - " + d;
    }),
    identifyOnResolve(h) {
      return typeof h == "boolean" && (n = h), n;
    },
    resolve: (h, d) => {
      for (const f of c().map((g) => g.middleware).reverse())
        h = f(h, d);
      return n && console.log(u.identify()), h;
    }
  };
  return u;
}, fP = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
}, pP = {
  high: 3,
  normal: 2,
  low: 1
};
class Zfe {
  constructor(e) {
    this.config = e, this.middlewareStack = M0();
  }
  send(e, n, r) {
    const s = typeof n != "function" ? n : void 0, i = typeof n == "function" ? n : r, o = s === void 0 && this.config.cacheMiddleware === !0;
    let a;
    if (o) {
      this.handlers || (this.handlers = /* @__PURE__ */ new WeakMap());
      const l = this.handlers;
      l.has(e.constructor) ? a = l.get(e.constructor) : (a = e.resolveMiddleware(this.middlewareStack, this.config, s), l.set(e.constructor, a));
    } else
      delete this.handlers, a = e.resolveMiddleware(this.middlewareStack, this.config, s);
    if (i)
      a(e).then((l) => i(null, l.output), (l) => i(l)).catch(() => {
      });
    else
      return a(e).then((l) => l.output);
  }
  destroy() {
    this.config?.requestHandler?.destroy?.(), delete this.handlers;
  }
}
class Cb {
  constructor() {
    this.middlewareStack = M0();
  }
  static classBuilder() {
    return new Jfe();
  }
  resolveMiddlewareWithContext(e, n, r, { middlewareFn: s, clientName: i, commandName: o, inputFilterSensitiveLog: a, outputFilterSensitiveLog: l, smithyContext: c, additionalContext: u, CommandCtor: h }) {
    for (const p of s.bind(this)(h, e, n, r))
      this.middlewareStack.use(p);
    const d = e.concat(this.middlewareStack), { logger: f } = n, g = {
      logger: f,
      clientName: i,
      commandName: o,
      inputFilterSensitiveLog: a,
      outputFilterSensitiveLog: l,
      [sS]: {
        commandInstance: this,
        ...c
      },
      ...u
    }, { requestHandler: y } = n;
    return d.resolve((p) => y.handle(p.request, r || {}), g);
  }
}
class Jfe {
  constructor() {
    this._init = () => {
    }, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (e) => e, this._outputFilterSensitiveLog = (e) => e, this._serializer = null, this._deserializer = null;
  }
  init(e) {
    this._init = e;
  }
  ep(e) {
    return this._ep = e, this;
  }
  m(e) {
    return this._middlewareFn = e, this;
  }
  s(e, n, r = {}) {
    return this._smithyContext = {
      service: e,
      operation: n,
      ...r
    }, this;
  }
  c(e = {}) {
    return this._additionalContext = e, this;
  }
  n(e, n) {
    return this._clientName = e, this._commandName = n, this;
  }
  f(e = (r) => r, n = (r) => r) {
    return this._inputFilterSensitiveLog = e, this._outputFilterSensitiveLog = n, this;
  }
  ser(e) {
    return this._serializer = e, this;
  }
  de(e) {
    return this._deserializer = e, this;
  }
  build() {
    const e = this;
    let n;
    return n = class extends Cb {
      static getEndpointParameterInstructions() {
        return e._ep;
      }
      constructor(...[r]) {
        super(), this.serialize = e._serializer, this.deserialize = e._deserializer, this.input = r ?? {}, e._init(this);
      }
      resolveMiddleware(r, s, i) {
        return this.resolveMiddlewareWithContext(r, s, i, {
          CommandCtor: n,
          middlewareFn: e._middlewareFn,
          clientName: e._clientName,
          commandName: e._commandName,
          inputFilterSensitiveLog: e._inputFilterSensitiveLog,
          outputFilterSensitiveLog: e._outputFilterSensitiveLog,
          smithyContext: e._smithyContext,
          additionalContext: e._additionalContext
        });
      }
    };
  }
}
const yl = "***SensitiveInformation***", Xfe = (t) => {
  if (t != null) {
    if (typeof t == "string") {
      const e = parseFloat(t);
      if (!Number.isNaN(e))
        return String(e) !== String(t) && ZU.warn(YU(`Expected number but observed string: ${t}`)), e;
    }
    if (typeof t == "number")
      return t;
    throw new TypeError(`Expected number, got ${typeof t}: ${t}`);
  }
}, Qfe = (t) => {
  if (t != null) {
    if (Number.isInteger(t) && !Number.isNaN(t))
      return t;
    throw new TypeError(`Expected integer, got ${typeof t}: ${t}`);
  }
}, qU = (t) => epe(t, 32), epe = (t, e) => {
  const n = Qfe(t);
  if (n !== void 0 && tpe(n, e) !== n)
    throw new TypeError(`Expected ${e}-bit integer, got ${t}`);
  return n;
}, tpe = (t, e) => {
  switch (e) {
    case 32:
      return Int32Array.of(t)[0];
    case 16:
      return Int16Array.of(t)[0];
    case 8:
      return Int8Array.of(t)[0];
  }
}, npe = (t, e) => {
  if (t == null)
    throw new TypeError(`Expected a non-null value for ${e}`);
  return t;
}, KU = (t) => {
  if (t == null)
    return;
  if (typeof t == "object" && !Array.isArray(t))
    return t;
  const e = Array.isArray(t) ? "array" : typeof t;
  throw new TypeError(`Expected object, got ${e}: ${t}`);
}, xt = (t) => {
  if (t != null) {
    if (typeof t == "string")
      return t;
    if (["boolean", "number", "bigint"].includes(typeof t))
      return ZU.warn(YU(`Expected string, got ${typeof t}: ${t}`)), String(t);
    throw new TypeError(`Expected string, got ${typeof t}: ${t}`);
  }
}, rpe = (t) => {
  if (t == null)
    return;
  const e = KU(t), n = Object.entries(e).filter(([, r]) => r != null).map(([r]) => r);
  if (n.length === 0)
    throw new TypeError("Unions must have exactly one non-null member. None were found.");
  if (n.length > 1)
    throw new TypeError(`Unions must have exactly one non-null member. Keys ${n} were not null.`);
  return e;
}, mP = (t) => typeof t == "string" ? spe(t) : Xfe(t), spe = (t) => {
  switch (t) {
    case "NaN":
      return NaN;
    case "Infinity":
      return 1 / 0;
    case "-Infinity":
      return -1 / 0;
    default:
      throw new Error(`Unable to parse float value: ${t}`);
  }
}, YU = (t) => String(new TypeError(t).stack || t).split(`
`).slice(0, 5).filter((e) => !e.includes("stackTraceWarning")).join(`
`), ZU = {
  warn: console.warn
};
class yc extends Error {
  constructor(e) {
    super(e.message), Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = e.name, this.$fault = e.$fault, this.$metadata = e.$metadata;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return yc.prototype.isPrototypeOf(n) || !!n.$fault && !!n.$metadata && (n.$fault === "client" || n.$fault === "server");
  }
  static [Symbol.hasInstance](e) {
    if (!e)
      return !1;
    const n = e;
    return this === yc ? yc.isInstance(e) : yc.isInstance(e) ? n.name && this.name ? this.prototype.isPrototypeOf(e) || n.name === this.name : this.prototype.isPrototypeOf(e) : !1;
  }
}
const $r = (t, e = {}) => {
  Object.entries(e).filter(([, r]) => r !== void 0).forEach(([r, s]) => {
    (t[r] == null || t[r] === "") && (t[r] = s);
  });
  const n = t.message || t.Message || "UnknownError";
  return t.message = n, delete t.Message, t;
}, ipe = ({ output: t, parsedBody: e, exceptionCtor: n, errorCode: r }) => {
  const s = ape(t), i = s.httpStatusCode ? s.httpStatusCode + "" : void 0, o = new n({
    name: e?.code || e?.Code || r || i || "UnknownError",
    $fault: "client",
    $metadata: s
  });
  throw $r(o, e);
}, ope = (t) => ({ output: e, parsedBody: n, errorCode: r }) => {
  ipe({ output: e, parsedBody: n, exceptionCtor: t, errorCode: r });
}, ape = (t) => ({
  httpStatusCode: t.statusCode,
  requestId: t.headers["x-amzn-requestid"] ?? t.headers["x-amzn-request-id"] ?? t.headers["x-amz-request-id"],
  extendedRequestId: t.headers["x-amz-id-2"],
  cfId: t.headers["x-amz-cf-id"]
}), lpe = (t) => {
  switch (t) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
}, cpe = (t) => {
  const e = [];
  for (const n in D0) {
    const r = D0[n];
    t[r] !== void 0 && e.push({
      algorithmId: () => r,
      checksumConstructor: () => t[r]
    });
  }
  return {
    _checksumAlgorithms: e,
    addChecksumAlgorithm(n) {
      this._checksumAlgorithms.push(n);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
}, upe = (t) => {
  const e = {};
  return t.checksumAlgorithms().forEach((n) => {
    e[n.algorithmId()] = n.checksumConstructor();
  }), e;
}, hpe = (t) => {
  let e = t.retryStrategy;
  return {
    setRetryStrategy(n) {
      e = n;
    },
    retryStrategy() {
      return e;
    }
  };
}, dpe = (t) => {
  const e = {};
  return e.retryStrategy = t.retryStrategy(), e;
}, fpe = (t) => ({
  ...cpe(t),
  ...hpe(t)
}), ppe = (t) => ({
  ...upe(t),
  ...dpe(t)
}), mpe = (t) => t != null;
class JU {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}
function On(t, e, n) {
  let r, s, i;
  if (typeof e > "u" && typeof n > "u")
    r = {}, i = t;
  else {
    if (r = t, typeof e == "function")
      return s = e, i = n, gpe(r, s, i);
    i = e;
  }
  for (const o of Object.keys(i)) {
    if (!Array.isArray(i[o])) {
      r[o] = i[o];
      continue;
    }
    XU(r, null, i, o);
  }
  return r;
}
const ot = (t, e) => {
  const n = {};
  for (const r in e)
    XU(n, t, e, r);
  return n;
}, gpe = (t, e, n) => On(t, Object.entries(n).reduce((r, [s, i]) => (Array.isArray(i) ? r[s] = i : typeof i == "function" ? r[s] = [e, i()] : r[s] = [e, i], r), {})), XU = (t, e, n, r) => {
  if (e !== null) {
    let o = n[r];
    typeof o == "function" && (o = [, o]);
    const [a = ype, l = bpe, c = r] = o;
    (typeof a == "function" && a(e[c]) || typeof a != "function" && a) && (t[r] = l(e[c]));
    return;
  }
  let [s, i] = n[r];
  if (typeof i == "function") {
    let o;
    const a = s === void 0 && (o = i()) != null, l = typeof s == "function" && !!s(void 0) || typeof s != "function" && !!s;
    a ? t[r] = o : l && (t[r] = i());
  } else {
    const o = s === void 0 && i != null, a = typeof s == "function" && !!s(i) || typeof s != "function" && !!s;
    (o || a) && (t[r] = i);
  }
}, ype = (t) => t != null, bpe = (t) => t, gP = (t) => {
  if (t !== t)
    return "NaN";
  switch (t) {
    case 1 / 0:
      return "Infinity";
    case -1 / 0:
      return "-Infinity";
    default:
      return t;
  }
}, ut = (t) => {
  if (t == null)
    return {};
  if (Array.isArray(t))
    return t.filter((e) => e != null).map(ut);
  if (typeof t == "object") {
    const e = {};
    for (const n of Object.keys(t))
      t[n] != null && (e[n] = ut(t[n]));
    return e;
  }
  return t;
}, ya = (t) => {
  if (t != null)
    return typeof t == "object" && "__type" in t && delete t.__type, rpe(t);
}, _pe = (t, e) => AU(t, e).then((n) => e.utf8Encoder(n)), Ur = (t, e) => _pe(t, e).then((n) => {
  if (n.length)
    try {
      return JSON.parse(n);
    } catch (r) {
      throw r?.name === "SyntaxError" && Object.defineProperty(r, "$responseBodyText", {
        value: n
      }), r;
    }
  return {};
}), vpe = async (t, e) => {
  const n = await Ur(t, e);
  return n.message = n.message ?? n.Message, n;
}, wpe = (t, e) => {
  const n = (i, o) => Object.keys(i).find((a) => a.toLowerCase() === o.toLowerCase()), r = (i) => {
    let o = i;
    return typeof o == "number" && (o = o.toString()), o.indexOf(",") >= 0 && (o = o.split(",")[0]), o.indexOf(":") >= 0 && (o = o.split(":")[0]), o.indexOf("#") >= 0 && (o = o.split("#")[1]), o;
  }, s = n(t.headers, "x-amzn-errortype");
  if (s !== void 0)
    return r(t.headers[s]);
  if (e.code !== void 0)
    return r(e.code);
  if (e.__type !== void 0)
    return r(e.__type);
}, Epe = /\d{12}\.ddb/;
async function Spe(t, e, n) {
  if (n.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" && Bs(t, "PROTOCOL_RPC_V2_CBOR", "M"), typeof e.retryStrategy == "function") {
    const i = await e.retryStrategy();
    typeof i.acquireInitialRetryToken == "function" ? i.constructor?.name?.includes("Adaptive") ? Bs(t, "RETRY_MODE_ADAPTIVE", "F") : Bs(t, "RETRY_MODE_STANDARD", "E") : Bs(t, "RETRY_MODE_LEGACY", "D");
  }
  if (typeof e.accountIdEndpointMode == "function") {
    const i = t.endpointV2;
    switch (String(i?.url?.hostname).match(Epe) && Bs(t, "ACCOUNT_ID_ENDPOINT", "O"), await e.accountIdEndpointMode?.()) {
      case "disabled":
        Bs(t, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        Bs(t, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        Bs(t, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  const s = t.__smithy_context?.selectedHttpAuthScheme?.identity;
  if (s?.$source) {
    const i = s;
    i.accountId && Bs(t, "RESOLVED_ACCOUNT_ID", "T");
    for (const [o, a] of Object.entries(i.$source ?? {}))
      Bs(t, o, a);
  }
}
const yP = "user-agent", Pv = "x-amz-user-agent", bP = " ", Ov = "/", xpe = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g, Tpe = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g, _P = "-", Cpe = 1024;
function kpe(t) {
  let e = "";
  for (const n in t) {
    const r = t[n];
    if (e.length + r.length + 1 <= Cpe) {
      e.length ? e += "," + r : e += r;
      continue;
    }
    break;
  }
  return e;
}
const Ape = (t) => (e, n) => async (r) => {
  const { request: s } = r;
  if (!Br.isInstance(s))
    return e(r);
  const { headers: i } = s, o = n?.userAgent?.map(cm) || [], a = (await t.defaultUserAgentProvider()).map(cm);
  await Spe(n, t, r);
  const l = n;
  a.push(`m/${kpe(Object.assign({}, n.__smithy_context?.features, l.__aws_sdk_context?.features))}`);
  const c = t?.customUserAgent?.map(cm) || [], u = await t.userAgentAppId();
  u && a.push(cm([`app/${u}`]));
  const h = [].concat([...a, ...o, ...c]).join(bP), d = [
    ...a.filter((f) => f.startsWith("aws-sdk-")),
    ...c
  ].join(bP);
  return t.runtime !== "browser" ? (d && (i[Pv] = i[Pv] ? `${i[yP]} ${d}` : d), i[yP] = h) : i[Pv] = h, e({
    ...r,
    request: s
  });
}, cm = (t) => {
  const e = t[0].split(Ov).map((o) => o.replace(xpe, _P)).join(Ov), n = t[1]?.replace(Tpe, _P), r = e.indexOf(Ov), s = e.substring(0, r);
  let i = e.substring(r + 1);
  return s === "api" && (i = i.toLowerCase()), [s, i, n].filter((o) => o && o.length > 0).reduce((o, a, l) => {
    switch (l) {
      case 0:
        return a;
      case 1:
        return `${o}/${a}`;
      default:
        return `${o}#${a}`;
    }
  }, "");
}, Rpe = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: !0
}, Ipe = (t) => ({
  applyToStack: (e) => {
    e.add(Ape(t), Rpe);
  }
});
var vP;
(function(t) {
  t.ENV = "env", t.CONFIG = "shared config entry";
})(vP || (vP = {}));
const Ppe = !1, Ope = !1, QU = (t) => typeof t == "string" && (t.startsWith("fips-") || t.endsWith("-fips")), wP = (t) => QU(t) ? ["fips-aws-global", "aws-fips"].includes(t) ? "us-east-1" : t.replace(/fips-(dkr-|prod-)?|-fips/, "") : t, Dpe = (t) => {
  const { region: e, useFipsEndpoint: n } = t;
  if (!e)
    throw new Error("Region is missing");
  return {
    ...t,
    region: async () => {
      if (typeof e == "string")
        return wP(e);
      const r = await e();
      return wP(r);
    },
    useFipsEndpoint: async () => {
      const r = typeof e == "string" ? e : await e();
      return QU(r) ? !0 : typeof n != "function" ? Promise.resolve(!!n) : n();
    }
  };
}, Npe = (t) => ({
  ...t,
  eventStreamMarshaller: t.eventStreamSerdeProvider(t)
}), EP = "content-length";
function Lpe(t) {
  return (e) => async (n) => {
    const r = n.request;
    if (Br.isInstance(r)) {
      const { body: s, headers: i } = r;
      if (s && Object.keys(i).map((o) => o.toLowerCase()).indexOf(EP) === -1)
        try {
          const o = t(s);
          r.headers = {
            ...r.headers,
            [EP]: String(o)
          };
        } catch {
        }
    }
    return e({
      ...n,
      request: r
    });
  };
}
const Mpe = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: !0
}, Bpe = (t) => ({
  applyToStack: (e) => {
    e.add(Lpe(t.bodyLengthChecker), Mpe);
  }
}), Fpe = async (t) => {
  const e = t?.Bucket || "";
  if (typeof t.Bucket == "string" && (t.Bucket = e.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), zpe(e)) {
    if (t.ForcePathStyle === !0)
      throw new Error("Path-style addressing cannot be used with ARN buckets");
  } else (!Hpe(e) || e.indexOf(".") !== -1 && !String(t.Endpoint).startsWith("http:") || e.toLowerCase() !== e || e.length < 3) && (t.ForcePathStyle = !0);
  return t.DisableMultiRegionAccessPoints && (t.disableMultiRegionAccessPoints = !0, t.DisableMRAP = !0), t;
}, $pe = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, Upe = /(\d+\.){3}\d+/, jpe = /\.\./, Hpe = (t) => $pe.test(t) && !Upe.test(t) && !jpe.test(t), zpe = (t) => {
  const [e, n, r, , , s] = t.split(":"), i = e === "arn" && t.split(":").length >= 6, o = !!(i && n && r && s);
  if (i && !o)
    throw new Error(`Invalid ARN: ${t} was an invalid ARN.`);
  return o;
}, Gpe = (t, e, n) => {
  const r = async () => {
    const s = n[t] ?? n[e];
    return typeof s == "function" ? s() : s;
  };
  return t === "credentialScope" || e === "CredentialScope" ? async () => {
    const s = typeof n.credentials == "function" ? await n.credentials() : n.credentials;
    return s?.credentialScope ?? s?.CredentialScope;
  } : t === "accountId" || e === "AccountId" ? async () => {
    const s = typeof n.credentials == "function" ? await n.credentials() : n.credentials;
    return s?.accountId ?? s?.AccountId;
  } : t === "endpoint" || e === "endpoint" ? async () => {
    const s = await r();
    if (s && typeof s == "object") {
      if ("url" in s)
        return s.url.href;
      if ("hostname" in s) {
        const { protocol: i, hostname: o, port: a, path: l } = s;
        return `${i}//${o}${a ? ":" + a : ""}${l}`;
      }
    }
    return s;
  } : r;
}, ej = async (t) => {
};
function Vpe(t) {
  const e = {};
  if (t = t.replace(/^\?/, ""), t)
    for (const n of t.split("&")) {
      let [r, s = null] = n.split("=");
      r = decodeURIComponent(r), s && (s = decodeURIComponent(s)), r in e ? Array.isArray(e[r]) ? e[r].push(s) : e[r] = [e[r], s] : e[r] = s;
    }
  return e;
}
const B0 = (t) => {
  if (typeof t == "string")
    return B0(new URL(t));
  const { hostname: e, pathname: n, port: r, protocol: s, search: i } = t;
  let o;
  return i && (o = Vpe(i)), {
    hostname: e,
    port: r ? parseInt(r) : void 0,
    protocol: s,
    path: n,
    query: o
  };
}, tj = (t) => typeof t == "object" ? "url" in t ? B0(t.url) : t : B0(t), Wpe = async (t, e, n, r) => {
  if (!n.endpoint) {
    let o;
    n.serviceConfiguredEndpoint ? o = await n.serviceConfiguredEndpoint() : o = await ej(n.serviceId), o && (n.endpoint = () => Promise.resolve(tj(o)));
  }
  const s = await qpe(t, e, n);
  if (typeof n.endpointProvider != "function")
    throw new Error("config.endpointProvider is not set.");
  return n.endpointProvider(s, r);
}, qpe = async (t, e, n) => {
  const r = {}, s = e?.getEndpointParameterInstructions?.() || {};
  for (const [i, o] of Object.entries(s))
    switch (o.type) {
      case "staticContextParams":
        r[i] = o.value;
        break;
      case "contextParams":
        r[i] = t[o.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        r[i] = await Gpe(o.name, i, n)();
        break;
      case "operationContextParams":
        r[i] = o.get(t);
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(o));
    }
  return Object.keys(s).length === 0 && Object.assign(r, n), String(n.serviceId).toLowerCase() === "s3" && await Fpe(r), r;
}, Kpe = ({ config: t, instructions: e }) => (n, r) => async (s) => {
  t.endpoint && Fde(r, "ENDPOINT_OVERRIDE", "N");
  const i = await Wpe(s.input, {
    getEndpointParameterInstructions() {
      return e;
    }
  }, { ...t }, r);
  r.endpointV2 = i, r.authSchemes = i.properties?.authSchemes;
  const o = r.authSchemes?.[0];
  if (o) {
    r.signing_region = o.signingRegion, r.signing_service = o.signingName;
    const l = xb(r)?.selectedHttpAuthScheme?.httpAuthOption;
    l && (l.signingProperties = Object.assign(l.signingProperties || {}, {
      signing_region: o.signingRegion,
      signingRegion: o.signingRegion,
      signing_service: o.signingName,
      signingName: o.signingName,
      signingRegionSet: o.signingRegionSet
    }, o.properties));
  }
  return n({
    ...s
  });
}, Ype = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: !0,
  relation: "before",
  toMiddleware: NC.name
}, jC = (t, e) => ({
  applyToStack: (n) => {
    n.addRelativeTo(Kpe({
      config: t,
      instructions: e
    }), Ype);
  }
}), Zpe = (t) => {
  const e = t.tls ?? !0, { endpoint: n } = t, r = n != null ? async () => tj(await qo(n)()) : void 0, i = {
    ...t,
    endpoint: r,
    tls: e,
    isCustomEndpoint: !!n,
    useDualstackEndpoint: qo(t.useDualstackEndpoint ?? !1),
    useFipsEndpoint: qo(t.useFipsEndpoint ?? !1)
  };
  let o;
  return i.serviceConfiguredEndpoint = async () => (t.serviceId && !o && (o = ej(t.serviceId)), o), i;
};
var su;
(function(t) {
  t.STANDARD = "standard", t.ADAPTIVE = "adaptive";
})(su || (su = {}));
const F0 = 3, Jpe = su.STANDARD, Xpe = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
], Qpe = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], eme = [500, 502, 503, 504], tme = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], nme = (t) => t.$metadata?.clockSkewCorrected, nj = (t) => t.$metadata?.httpStatusCode === 429 || Xpe.includes(t.name) || t.$retryable?.throttling == !0, HC = (t, e = 0) => nme(t) || Qpe.includes(t.name) || tme.includes(t?.code || "") || eme.includes(t.$metadata?.httpStatusCode || 0) || t.cause !== void 0 && e <= 10 && HC(t.cause, e + 1), rme = (t) => {
  if (t.$metadata?.httpStatusCode !== void 0) {
    const e = t.$metadata.httpStatusCode;
    return 500 <= e && e <= 599 && !HC(t);
  }
  return !1;
};
class kb {
  constructor(e) {
    this.currentCapacity = 0, this.enabled = !1, this.lastMaxRate = 0, this.measuredTxRate = 0, this.requestCount = 0, this.lastTimestamp = 0, this.timeWindow = 0, this.beta = e?.beta ?? 0.7, this.minCapacity = e?.minCapacity ?? 1, this.minFillRate = e?.minFillRate ?? 0.5, this.scaleConstant = e?.scaleConstant ?? 0.4, this.smooth = e?.smooth ?? 0.8;
    const n = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = n, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(e) {
    if (this.enabled) {
      if (this.refillTokenBucket(), e > this.currentCapacity) {
        const n = (e - this.currentCapacity) / this.fillRate * 1e3;
        await new Promise((r) => kb.setTimeoutFn(r, n));
      }
      this.currentCapacity = this.currentCapacity - e;
    }
  }
  refillTokenBucket() {
    const e = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = e;
      return;
    }
    const n = (e - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + n), this.lastTimestamp = e;
  }
  updateClientSendingRate(e) {
    let n;
    if (this.updateMeasuredRate(), nj(e)) {
      const s = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate;
      this.lastMaxRate = s, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), n = this.cubicThrottle(s), this.enableTokenBucket();
    } else
      this.calculateTimeWindow(), n = this.cubicSuccess(this.getCurrentTimeInSeconds());
    const r = Math.min(n, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(r);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(e) {
    return this.getPrecise(e * this.beta);
  }
  cubicSuccess(e) {
    return this.getPrecise(this.scaleConstant * Math.pow(e - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = !0;
  }
  updateTokenBucketRate(e) {
    this.refillTokenBucket(), this.fillRate = Math.max(e, this.minFillRate), this.maxCapacity = Math.max(e, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const e = this.getCurrentTimeInSeconds(), n = Math.floor(e * 2) / 2;
    if (this.requestCount++, n > this.lastTxRateBucket) {
      const r = this.requestCount / (n - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(r * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = n;
    }
  }
  getPrecise(e) {
    return parseFloat(e.toFixed(8));
  }
}
kb.setTimeoutFn = setTimeout;
const aS = 100, rj = 20 * 1e3, sme = 500, SP = 500, ime = 5, ome = 10, ame = 1, lme = "amz-sdk-invocation-id", cme = "amz-sdk-request", ume = () => {
  let t = aS;
  return {
    computeNextBackoffDelay: (r) => Math.floor(Math.min(rj, Math.random() * 2 ** r * t)),
    setDelayBase: (r) => {
      t = r;
    }
  };
}, xP = ({ retryDelay: t, retryCount: e, retryCost: n }) => ({
  getRetryCount: () => e,
  getRetryDelay: () => Math.min(rj, t),
  getRetryCost: () => n
});
class sj {
  constructor(e) {
    this.maxAttempts = e, this.mode = su.STANDARD, this.capacity = SP, this.retryBackoffStrategy = ume(), this.maxAttemptsProvider = typeof e == "function" ? e : async () => e;
  }
  async acquireInitialRetryToken(e) {
    return xP({
      retryDelay: aS,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(e, n) {
    const r = await this.getMaxAttempts();
    if (this.shouldRetry(e, n, r)) {
      const s = n.errorType;
      this.retryBackoffStrategy.setDelayBase(s === "THROTTLING" ? sme : aS);
      const i = this.retryBackoffStrategy.computeNextBackoffDelay(e.getRetryCount()), o = n.retryAfterHint ? Math.max(n.retryAfterHint.getTime() - Date.now() || 0, i) : i, a = this.getCapacityCost(s);
      return this.capacity -= a, xP({
        retryDelay: o,
        retryCount: e.getRetryCount() + 1,
        retryCost: a
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(e) {
    this.capacity = Math.max(SP, this.capacity + (e.getRetryCost() ?? ame));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch {
      return console.warn(`Max attempts provider could not resolve. Using default of ${F0}`), F0;
    }
  }
  shouldRetry(e, n, r) {
    return e.getRetryCount() + 1 < r && this.capacity >= this.getCapacityCost(n.errorType) && this.isRetryableError(n.errorType);
  }
  getCapacityCost(e) {
    return e === "TRANSIENT" ? ome : ime;
  }
  isRetryableError(e) {
    return e === "THROTTLING" || e === "TRANSIENT";
  }
}
class hme {
  constructor(e, n) {
    this.maxAttemptsProvider = e, this.mode = su.ADAPTIVE;
    const { rateLimiter: r } = n ?? {};
    this.rateLimiter = r ?? new kb(), this.standardRetryStrategy = new sj(e);
  }
  async acquireInitialRetryToken(e) {
    return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(e);
  }
  async refreshRetryTokenForRetry(e, n) {
    return this.rateLimiter.updateClientSendingRate(n), this.standardRetryStrategy.refreshRetryTokenForRetry(e, n);
  }
  recordSuccess(e) {
    this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(e);
  }
}
let um;
const dme = new Uint8Array(16);
function fme() {
  if (!um && (um = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !um))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return um(dme);
}
const Sn = [];
for (let t = 0; t < 256; ++t)
  Sn.push((t + 256).toString(16).slice(1));
function pme(t, e = 0) {
  return Sn[t[e + 0]] + Sn[t[e + 1]] + Sn[t[e + 2]] + Sn[t[e + 3]] + "-" + Sn[t[e + 4]] + Sn[t[e + 5]] + "-" + Sn[t[e + 6]] + Sn[t[e + 7]] + "-" + Sn[t[e + 8]] + Sn[t[e + 9]] + "-" + Sn[t[e + 10]] + Sn[t[e + 11]] + Sn[t[e + 12]] + Sn[t[e + 13]] + Sn[t[e + 14]] + Sn[t[e + 15]];
}
const mme = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), TP = {
  randomUUID: mme
};
function gme(t, e, n) {
  if (TP.randomUUID && !t)
    return TP.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || fme)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, pme(r);
}
const yme = (t) => t instanceof Error ? t : t instanceof Object ? Object.assign(new Error(), t) : typeof t == "string" ? new Error(t) : new Error(`AWS SDK error wrapper for ${t}`), bme = (t) => {
  const { retryStrategy: e } = t, n = qo(t.maxAttempts ?? F0);
  return {
    ...t,
    maxAttempts: n,
    retryStrategy: async () => e || (await qo(t.retryMode)() === su.ADAPTIVE ? new hme(n) : new sj(n))
  };
}, _me = (t) => t?.body instanceof ReadableStream, vme = (t) => (e, n) => async (r) => {
  let s = await t.retryStrategy();
  const i = await t.maxAttempts();
  if (wme(s)) {
    s = s;
    let o = await s.acquireInitialRetryToken(n.partition_id), a = new Error(), l = 0, c = 0;
    const { request: u } = r, h = Br.isInstance(u);
    for (h && (u.headers[lme] = gme()); ; )
      try {
        h && (u.headers[cme] = `attempt=${l + 1}; max=${i}`);
        const { response: d, output: f } = await e(r);
        return s.recordSuccess(o), f.$metadata.attempts = l + 1, f.$metadata.totalRetryDelay = c, { response: d, output: f };
      } catch (d) {
        const f = Eme(d);
        if (a = yme(d), h && _me(u))
          throw (n.logger instanceof JU ? console : n.logger)?.warn("An error was encountered in a non-retryable streaming request."), a;
        try {
          o = await s.refreshRetryTokenForRetry(o, f);
        } catch {
          throw a.$metadata || (a.$metadata = {}), a.$metadata.attempts = l + 1, a.$metadata.totalRetryDelay = c, a;
        }
        l = o.getRetryCount();
        const g = o.getRetryDelay();
        c += g, await new Promise((y) => setTimeout(y, g));
      }
  } else
    return s = s, s?.mode && (n.userAgent = [...n.userAgent || [], ["cfg/retry-mode", s.mode]]), s.retry(e, r);
}, wme = (t) => typeof t.acquireInitialRetryToken < "u" && typeof t.refreshRetryTokenForRetry < "u" && typeof t.recordSuccess < "u", Eme = (t) => {
  const e = {
    error: t,
    errorType: Sme(t)
  }, n = Cme(t.$response);
  return n && (e.retryAfterHint = n), e;
}, Sme = (t) => nj(t) ? "THROTTLING" : HC(t) ? "TRANSIENT" : rme(t) ? "SERVER_ERROR" : "CLIENT_ERROR", xme = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: !0
}, Tme = (t) => ({
  applyToStack: (e) => {
    e.add(vme(t), xme);
  }
}), Cme = (t) => {
  if (!N0.isInstance(t))
    return;
  const e = Object.keys(t.headers).find((i) => i.toLowerCase() === "retry-after");
  if (!e)
    return;
  const n = t.headers[e], r = Number(n);
  return Number.isNaN(r) ? new Date(n) : new Date(r * 1e3);
}, kme = async (t, e, n) => ({
  operation: xb(e).operation,
  region: await qo(t.region)() || (() => {
    throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
  })()
});
function Ame(t) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "bedrock",
      region: t.region
    },
    propertiesExtractor: (e, n) => ({
      signingProperties: {
        config: e,
        context: n
      }
    })
  };
}
const Rme = (t) => {
  const e = [];
  switch (t.operation) {
    default:
      e.push(Ame(t));
  }
  return e;
}, Ime = (t) => ({
  ...Yfe(t)
}), Pme = (t) => ({
  ...t,
  useDualstackEndpoint: t.useDualstackEndpoint ?? !1,
  useFipsEndpoint: t.useFipsEndpoint ?? !1,
  defaultSigningName: "bedrock"
}), zC = {
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
}, Ome = "3.741.0", Dme = {
  version: Ome
}, Nme = (t) => new TextEncoder().encode(t);
var Lme = typeof Me < "u" && Me.from ? function(t) {
  return Me.from(t, "utf8");
} : Nme;
function Gd(t) {
  return t instanceof Uint8Array ? t : typeof t == "string" ? Lme(t) : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(t);
}
function lS(t) {
  return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
}
function Mme(t) {
  if (!Uint32Array.from) {
    for (var e = new Uint32Array(t.length), n = 0; n < t.length; )
      e[n] = t[n], n += 1;
    return e;
  }
  return Uint32Array.from(t);
}
var ij = { name: "SHA-256" }, CP = {
  name: "HMAC",
  hash: ij
}, Bme = new Uint8Array([
  227,
  176,
  196,
  66,
  152,
  252,
  28,
  20,
  154,
  251,
  244,
  200,
  153,
  111,
  185,
  36,
  39,
  174,
  65,
  228,
  100,
  155,
  147,
  76,
  164,
  149,
  153,
  27,
  120,
  82,
  184,
  85
]);
const Fme = {};
function gg() {
  return typeof window < "u" ? window : typeof self < "u" ? self : Fme;
}
var $me = (
  /** @class */
  function() {
    function t(e) {
      this.toHash = new Uint8Array(0), this.secret = e, this.reset();
    }
    return t.prototype.update = function(e) {
      if (!lS(e)) {
        var n = Gd(e), r = new Uint8Array(this.toHash.byteLength + n.byteLength);
        r.set(this.toHash, 0), r.set(n, this.toHash.byteLength), this.toHash = r;
      }
    }, t.prototype.digest = function() {
      var e = this;
      return this.key ? this.key.then(function(n) {
        return gg().crypto.subtle.sign(CP, n, e.toHash).then(function(r) {
          return new Uint8Array(r);
        });
      }) : lS(this.toHash) ? Promise.resolve(Bme) : Promise.resolve().then(function() {
        return gg().crypto.subtle.digest(ij, e.toHash);
      }).then(function(n) {
        return Promise.resolve(new Uint8Array(n));
      });
    }, t.prototype.reset = function() {
      var e = this;
      this.toHash = new Uint8Array(0), this.secret && this.secret !== void 0 && (this.key = new Promise(function(n, r) {
        gg().crypto.subtle.importKey("raw", Gd(e.secret), CP, !1, ["sign"]).then(n, r);
      }), this.key.catch(function() {
      }));
    }, t;
  }()
), Vr = 64, Ume = 32, jme = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Hme = [
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
], zme = Math.pow(2, 53) - 1, yg = (
  /** @class */
  function() {
    function t() {
      this.state = Int32Array.from(Hme), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1;
    }
    return t.prototype.update = function(e) {
      if (this.finished)
        throw new Error("Attempted to update an already finished hash.");
      var n = 0, r = e.byteLength;
      if (this.bytesHashed += r, this.bytesHashed * 8 > zme)
        throw new Error("Cannot hash more than 2^53 - 1 bits");
      for (; r > 0; )
        this.buffer[this.bufferLength++] = e[n++], r--, this.bufferLength === Vr && (this.hashBuffer(), this.bufferLength = 0);
    }, t.prototype.digest = function() {
      if (!this.finished) {
        var e = this.bytesHashed * 8, n = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength), r = this.bufferLength;
        if (n.setUint8(this.bufferLength++, 128), r % Vr >= Vr - 8) {
          for (var s = this.bufferLength; s < Vr; s++)
            n.setUint8(s, 0);
          this.hashBuffer(), this.bufferLength = 0;
        }
        for (var s = this.bufferLength; s < Vr - 8; s++)
          n.setUint8(s, 0);
        n.setUint32(Vr - 8, Math.floor(e / 4294967296), !0), n.setUint32(Vr - 4, e), this.hashBuffer(), this.finished = !0;
      }
      for (var i = new Uint8Array(Ume), s = 0; s < 8; s++)
        i[s * 4] = this.state[s] >>> 24 & 255, i[s * 4 + 1] = this.state[s] >>> 16 & 255, i[s * 4 + 2] = this.state[s] >>> 8 & 255, i[s * 4 + 3] = this.state[s] >>> 0 & 255;
      return i;
    }, t.prototype.hashBuffer = function() {
      for (var e = this, n = e.buffer, r = e.state, s = r[0], i = r[1], o = r[2], a = r[3], l = r[4], c = r[5], u = r[6], h = r[7], d = 0; d < Vr; d++) {
        if (d < 16)
          this.temp[d] = (n[d * 4] & 255) << 24 | (n[d * 4 + 1] & 255) << 16 | (n[d * 4 + 2] & 255) << 8 | n[d * 4 + 3] & 255;
        else {
          var f = this.temp[d - 2], g = (f >>> 17 | f << 15) ^ (f >>> 19 | f << 13) ^ f >>> 10;
          f = this.temp[d - 15];
          var y = (f >>> 7 | f << 25) ^ (f >>> 18 | f << 14) ^ f >>> 3;
          this.temp[d] = (g + this.temp[d - 7] | 0) + (y + this.temp[d - 16] | 0);
        }
        var p = (((l >>> 6 | l << 26) ^ (l >>> 11 | l << 21) ^ (l >>> 25 | l << 7)) + (l & c ^ ~l & u) | 0) + (h + (jme[d] + this.temp[d] | 0) | 0) | 0, m = ((s >>> 2 | s << 30) ^ (s >>> 13 | s << 19) ^ (s >>> 22 | s << 10)) + (s & i ^ s & o ^ i & o) | 0;
        h = u, u = c, c = l, l = a + p | 0, a = o, o = i, i = s, s = p + m | 0;
      }
      r[0] += s, r[1] += i, r[2] += o, r[3] += a, r[4] += l, r[5] += c, r[6] += u, r[7] += h;
    }, t;
  }()
), Gme = (
  /** @class */
  function() {
    function t(e) {
      this.secret = e, this.hash = new yg(), this.reset();
    }
    return t.prototype.update = function(e) {
      if (!(lS(e) || this.error))
        try {
          this.hash.update(Gd(e));
        } catch (n) {
          this.error = n;
        }
    }, t.prototype.digestSync = function() {
      if (this.error)
        throw this.error;
      return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest()) : this.hash.digest();
    }, t.prototype.digest = function() {
      return nne(this, void 0, void 0, function() {
        return rne(this, function(e) {
          return [2, this.digestSync()];
        });
      });
    }, t.prototype.reset = function() {
      if (this.hash = new yg(), this.secret) {
        this.outer = new yg();
        var e = Vme(this.secret), n = new Uint8Array(Vr);
        n.set(e);
        for (var r = 0; r < Vr; r++)
          e[r] ^= 54, n[r] ^= 92;
        this.hash.update(e), this.outer.update(n);
        for (var r = 0; r < e.byteLength; r++)
          e[r] = 0;
      }
    }, t;
  }()
);
function Vme(t) {
  var e = Gd(t);
  if (e.byteLength > Vr) {
    var n = new yg();
    n.update(e), e = n.digest();
  }
  var r = new Uint8Array(Vr);
  return r.set(e), r;
}
var Wme = [
  "decrypt",
  "digest",
  "encrypt",
  "exportKey",
  "generateKey",
  "importKey",
  "sign",
  "verify"
];
function qme(t) {
  if (Kme(t) && typeof t.crypto.subtle == "object") {
    var e = t.crypto.subtle;
    return Yme(e);
  }
  return !1;
}
function Kme(t) {
  if (typeof t == "object" && typeof t.crypto == "object") {
    var e = t.crypto.getRandomValues;
    return typeof e == "function";
  }
  return !1;
}
function Yme(t) {
  return t && Wme.every(function(e) {
    return typeof t[e] == "function";
  });
}
var Zme = (
  /** @class */
  function() {
    function t(e) {
      qme(gg()) ? this.hash = new $me(e) : this.hash = new Gme(e);
    }
    return t.prototype.update = function(e, n) {
      this.hash.update(Gd(e));
    }, t.prototype.digest = function() {
      return this.hash.digest();
    }, t.prototype.reset = function() {
      this.hash.reset();
    }, t;
  }()
);
const Jme = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, oj = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, Zt = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, qn = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, Co = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Re {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(e, n) {
    const r = n.match(e);
    return r && r.length > 0 && r[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(e, n) {
    const r = n.match(e);
    return r && r.length > 1 && r[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(e, n, r) {
    if (e.test(n))
      return r;
  }
  static getWindowsVersionName(e) {
    switch (e) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(e) {
    const n = e.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), n[0] === 10)
      switch (n[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(e) {
    const n = e.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), !(n[0] === 1 && n[1] < 5)) {
      if (n[0] === 1 && n[1] < 6) return "Cupcake";
      if (n[0] === 1 && n[1] >= 6) return "Donut";
      if (n[0] === 2 && n[1] < 2) return "Eclair";
      if (n[0] === 2 && n[1] === 2) return "Froyo";
      if (n[0] === 2 && n[1] > 2) return "Gingerbread";
      if (n[0] === 3) return "Honeycomb";
      if (n[0] === 4 && n[1] < 1) return "Ice Cream Sandwich";
      if (n[0] === 4 && n[1] < 4) return "Jelly Bean";
      if (n[0] === 4 && n[1] >= 4) return "KitKat";
      if (n[0] === 5) return "Lollipop";
      if (n[0] === 6) return "Marshmallow";
      if (n[0] === 7) return "Nougat";
      if (n[0] === 8) return "Oreo";
      if (n[0] === 9) return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(e) {
    return e.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(e, n, r = !1) {
    const s = Re.getVersionPrecision(e), i = Re.getVersionPrecision(n);
    let o = Math.max(s, i), a = 0;
    const l = Re.map([e, n], (c) => {
      const u = o - Re.getVersionPrecision(c), h = c + new Array(u + 1).join(".0");
      return Re.map(h.split("."), (d) => new Array(20 - d.length).join("0") + d).reverse();
    });
    for (r && (a = o - Math.min(s, i)), o -= 1; o >= a; ) {
      if (l[0][o] > l[1][o])
        return 1;
      if (l[0][o] === l[1][o]) {
        if (o === a)
          return 0;
        o -= 1;
      } else if (l[0][o] < l[1][o])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(e, n) {
    const r = [];
    let s;
    if (Array.prototype.map)
      return Array.prototype.map.call(e, n);
    for (s = 0; s < e.length; s += 1)
      r.push(n(e[s]));
    return r;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(e, n) {
    let r, s;
    if (Array.prototype.find)
      return Array.prototype.find.call(e, n);
    for (r = 0, s = e.length; r < s; r += 1) {
      const i = e[r];
      if (n(i, r))
        return i;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(e, ...n) {
    const r = e;
    let s, i;
    if (Object.assign)
      return Object.assign(e, ...n);
    for (s = 0, i = n.length; s < i; s += 1) {
      const o = n[s];
      typeof o == "object" && o !== null && Object.keys(o).forEach((l) => {
        r[l] = o[l];
      });
    }
    return e;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(e) {
    return Jme[e];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(e) {
    return oj[e] || "";
  }
}
const At = /version\/(\d+(\.?_?\d+)+)/i, Xme = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(t) {
      const e = {
        name: "Googlebot"
      }, n = Re.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, n = Re.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(t) {
      const e = {
        name: "Samsung Internet for Android"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/Whale/i],
    describe(t) {
      const e = {
        name: "NAVER Whale Browser"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(t) {
      const e = {
        name: "MZ Browser"
      }, n = Re.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/focus/i],
    describe(t) {
      const e = {
        name: "Focus"
      }, n = Re.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/swing/i],
    describe(t) {
      const e = {
        name: "Swing"
      }, n = Re.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/coast/i],
    describe(t) {
      const e = {
        name: "Opera Coast"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(t) {
      const e = {
        name: "Opera Touch"
      }, n = Re.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/yabrowser/i],
    describe(t) {
      const e = {
        name: "Yandex Browser"
      }, n = Re.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(t) {
      const e = {
        name: "UC Browser"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(t) {
      const e = {
        name: "Maxthon"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/epiphany/i],
    describe(t) {
      const e = {
        name: "Epiphany"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/puffin/i],
    describe(t) {
      const e = {
        name: "Puffin"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/sleipnir/i],
    describe(t) {
      const e = {
        name: "Sleipnir"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/k-meleon/i],
    describe(t) {
      const e = {
        name: "K-Meleon"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/micromessenger/i],
    describe(t) {
      const e = {
        name: "WeChat"
      }, n = Re.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(t) {
      const e = {
        name: /qqbrowserlite/i.test(t) ? "QQ Browser Lite" : "QQ Browser"
      }, n = Re.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/msie|trident/i],
    describe(t) {
      const e = {
        name: "Internet Explorer"
      }, n = Re.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/\sedg\//i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, n = Re.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, n = Re.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/vivaldi/i],
    describe(t) {
      const e = {
        name: "Vivaldi"
      }, n = Re.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/seamonkey/i],
    describe(t) {
      const e = {
        name: "SeaMonkey"
      }, n = Re.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/sailfish/i],
    describe(t) {
      const e = {
        name: "Sailfish"
      }, n = Re.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/silk/i],
    describe(t) {
      const e = {
        name: "Amazon Silk"
      }, n = Re.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/phantom/i],
    describe(t) {
      const e = {
        name: "PhantomJS"
      }, n = Re.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/slimerjs/i],
    describe(t) {
      const e = {
        name: "SlimerJS"
      }, n = Re.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = {
        name: "BlackBerry"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = {
        name: "WebOS Browser"
      }, n = Re.getFirstMatch(At, t) || Re.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/bada/i],
    describe(t) {
      const e = {
        name: "Bada"
      }, n = Re.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/tizen/i],
    describe(t) {
      const e = {
        name: "Tizen"
      }, n = Re.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/qupzilla/i],
    describe(t) {
      const e = {
        name: "QupZilla"
      }, n = Re.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(t) {
      const e = {
        name: "Firefox"
      }, n = Re.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/electron/i],
    describe(t) {
      const e = {
        name: "Electron"
      }, n = Re.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(t) {
      const e = {
        name: "Miui"
      }, n = Re.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/chromium/i],
    describe(t) {
      const e = {
        name: "Chromium"
      }, n = Re.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t) || Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(t) {
      const e = {
        name: "Chrome"
      }, n = Re.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/GSA/i],
    describe(t) {
      const e = {
        name: "Google Search"
      }, n = Re.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Android Browser */
  {
    test(t) {
      const e = !t.test(/like android/i), n = t.test(/android/i);
      return e && n;
    },
    describe(t) {
      const e = {
        name: "Android Browser"
      }, n = Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(t) {
      const e = {
        name: "PlayStation 4"
      }, n = Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(t) {
      const e = {
        name: "Safari"
      }, n = Re.getFirstMatch(At, t);
      return n && (e.version = n), e;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(t) {
      const e = /^(.*)\/(.*) /, n = /^(.*)\/(.*)[ \t]\((.*)/, s = t.search("\\(") !== -1 ? n : e;
      return {
        name: Re.getFirstMatch(s, t),
        version: Re.getSecondMatch(s, t)
      };
    }
  }
], Qme = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(t) {
      const e = Re.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t);
      return {
        name: qn.Roku,
        version: e
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(t) {
      const e = Re.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t);
      return {
        name: qn.WindowsPhone,
        version: e
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(t) {
      const e = Re.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t), n = Re.getWindowsVersionName(e);
      return {
        name: qn.Windows,
        version: e,
        versionName: n
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(t) {
      const e = {
        name: qn.iOS
      }, n = Re.getSecondMatch(/(Version\/)(\d[\d.]+)/, t);
      return n && (e.version = n), e;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(t) {
      const e = Re.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t).replace(/[_\s]/g, "."), n = Re.getMacOSVersionName(e), r = {
        name: qn.MacOS,
        version: e
      };
      return n && (r.versionName = n), r;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(t) {
      const e = Re.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, t).replace(/[_\s]/g, ".");
      return {
        name: qn.iOS,
        version: e
      };
    }
  },
  /* Android */
  {
    test(t) {
      const e = !t.test(/like android/i), n = t.test(/android/i);
      return e && n;
    },
    describe(t) {
      const e = Re.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t), n = Re.getAndroidVersionName(e), r = {
        name: qn.Android,
        version: e
      };
      return n && (r.versionName = n), r;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = Re.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t), n = {
        name: qn.WebOS
      };
      return e && e.length && (n.version = e), n;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = Re.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t) || Re.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t) || Re.getFirstMatch(/\bbb(\d+)/i, t);
      return {
        name: qn.BlackBerry,
        version: e
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(t) {
      const e = Re.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t);
      return {
        name: qn.Bada,
        version: e
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(t) {
      const e = Re.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: qn.Tizen,
        version: e
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: qn.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: qn.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(t) {
      const e = Re.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: qn.PlayStation4,
        version: e
      };
    }
  }
], ege = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(t) {
      const e = Re.getFirstMatch(/(can-l01)/i, t) && "Nova", n = {
        type: Zt.mobile,
        vendor: "Huawei"
      };
      return e && (n.model = e), n;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: Zt.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: Zt.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: Zt.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: Zt.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: Zt.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: Zt.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(t) {
      const e = t.test(/ipod|iphone/i), n = t.test(/like (ipod|iphone)/i);
      return e && !n;
    },
    describe(t) {
      const e = Re.getFirstMatch(/(ipod|iphone)/i, t);
      return {
        type: Zt.mobile,
        vendor: "Apple",
        model: e
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: Zt.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: Zt.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(t) {
      return t.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: Zt.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(t) {
      return t.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: Zt.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(t) {
      return t.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: Zt.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(t) {
      const e = Number(String(t.getOSVersion()).split(".")[0]);
      return t.getOSName(!0) === "android" && e >= 3;
    },
    describe() {
      return {
        type: Zt.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(t) {
      return t.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: Zt.mobile
      };
    }
  },
  /* desktop */
  {
    test(t) {
      return t.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: Zt.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(t) {
      return t.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: Zt.desktop
      };
    }
  },
  /* Linux */
  {
    test(t) {
      return t.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: Zt.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(t) {
      return t.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: Zt.tv
      };
    }
  },
  /* Roku */
  {
    test(t) {
      return t.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: Zt.tv
      };
    }
  }
], tge = [
  /* EdgeHTML */
  {
    test(t) {
      return t.getBrowserName(!0) === "microsoft edge";
    },
    describe(t) {
      if (/\sedg\//i.test(t))
        return {
          name: Co.Blink
        };
      const n = Re.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t);
      return {
        name: Co.EdgeHTML,
        version: n
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(t) {
      const e = {
        name: Co.Trident
      }, n = Re.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Presto */
  {
    test(t) {
      return t.test(/presto/i);
    },
    describe(t) {
      const e = {
        name: Co.Presto
      }, n = Re.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Gecko */
  {
    test(t) {
      const e = t.test(/gecko/i), n = t.test(/like gecko/i);
      return e && !n;
    },
    describe(t) {
      const e = {
        name: Co.Gecko
      }, n = Re.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: Co.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(t) {
      const e = {
        name: Co.WebKit
      }, n = Re.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  }
];
let kP = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(e, n = !1) {
    if (e == null || e === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e, this.parsedResult = {}, n !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(e) {
    return e.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const e = Re.find(Xme, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.browser = e.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(e) {
    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const e = Re.find(Qme, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.os = e.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(e) {
    const { name: n } = this.getOS();
    return e ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(e = !1) {
    const { type: n } = this.getPlatform();
    return e ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const e = Re.find(ege, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.platform = e.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(e) {
    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const e = Re.find(tge, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.engine = e.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Re.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(e) {
    const n = {};
    let r = 0;
    const s = {};
    let i = 0;
    if (Object.keys(e).forEach((a) => {
      const l = e[a];
      typeof l == "string" ? (s[a] = l, i += 1) : typeof l == "object" && (n[a] = l, r += 1);
    }), r > 0) {
      const a = Object.keys(n), l = Re.find(a, (u) => this.isOS(u));
      if (l) {
        const u = this.satisfies(n[l]);
        if (u !== void 0)
          return u;
      }
      const c = Re.find(
        a,
        (u) => this.isPlatform(u)
      );
      if (c) {
        const u = this.satisfies(n[c]);
        if (u !== void 0)
          return u;
      }
    }
    if (i > 0) {
      const a = Object.keys(s), l = Re.find(a, (c) => this.isBrowser(c, !0));
      if (l !== void 0)
        return this.compareVersion(s[l]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(e, n = !1) {
    const r = this.getBrowserName().toLowerCase();
    let s = e.toLowerCase();
    const i = Re.getBrowserTypeByAlias(s);
    return n && i && (s = i.toLowerCase()), s === r;
  }
  compareVersion(e) {
    let n = [0], r = e, s = !1;
    const i = this.getBrowserVersion();
    if (typeof i == "string")
      return e[0] === ">" || e[0] === "<" ? (r = e.substr(1), e[1] === "=" ? (s = !0, r = e.substr(2)) : n = [], e[0] === ">" ? n.push(1) : n.push(-1)) : e[0] === "=" ? r = e.substr(1) : e[0] === "~" && (s = !0, r = e.substr(1)), n.indexOf(
        Re.compareVersions(i, r, s)
      ) > -1;
  }
  isOS(e) {
    return this.getOSName(!0) === String(e).toLowerCase();
  }
  isPlatform(e) {
    return this.getPlatformType(!0) === String(e).toLowerCase();
  }
  isEngine(e) {
    return this.getEngineName(!0) === String(e).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(e, n = !1) {
    return this.isBrowser(e, n) || this.isOS(e) || this.isPlatform(e);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(e = []) {
    return e.some((n) => this.is(n));
  }
};
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class aj {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(e, n = !1) {
    if (typeof e != "string")
      throw new Error("UserAgent should be a string");
    return new kP(e, n);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(e) {
    return new kP(e).getResult();
  }
  static get BROWSER_MAP() {
    return oj;
  }
  static get ENGINE_MAP() {
    return Co;
  }
  static get OS_MAP() {
    return qn;
  }
  static get PLATFORMS_MAP() {
    return Zt;
  }
}
const nge = ({ serviceId: t, clientVersion: e }) => async (n) => {
  const r = typeof window < "u" && window?.navigator?.userAgent ? aj.parse(window.navigator.userAgent) : void 0, s = [
    ["aws-sdk-js", e],
    ["ua", "2.1"],
    [`os/${r?.os?.name || "other"}`, r?.os?.version],
    ["lang/js"],
    ["md/browser", `${r?.browser?.name ?? "unknown"}_${r?.browser?.version ?? "unknown"}`]
  ];
  t && s.push([`api/${t}`, e]);
  const i = await n?.userAgentAppId?.();
  return i && s.push([`app/${i}`]), s;
};
var lj = (
  /** @class */
  function() {
    function t() {
      this.checksum = 4294967295;
    }
    return t.prototype.update = function(e) {
      var n, r;
      try {
        for (var s = sne(e), i = s.next(); !i.done; i = s.next()) {
          var o = i.value;
          this.checksum = this.checksum >>> 8 ^ sge[(this.checksum ^ o) & 255];
        }
      } catch (a) {
        n = { error: a };
      } finally {
        try {
          i && !i.done && (r = s.return) && r.call(s);
        } finally {
          if (n) throw n.error;
        }
      }
      return this;
    }, t.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0;
    }, t;
  }()
), rge = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
], sge = Mme(rge);
class Zh {
  constructor(e) {
    if (this.bytes = e, e.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(e) {
    if (e > 9223372036854776e3 || e < -9223372036854776e3)
      throw new Error(`${e} is too large (or, if negative, too small) to represent as an Int64`);
    const n = new Uint8Array(8);
    for (let r = 7, s = Math.abs(Math.round(e)); r > -1 && s > 0; r--, s /= 256)
      n[r] = s;
    return e < 0 && AP(n), new Zh(n);
  }
  valueOf() {
    const e = this.bytes.slice(0), n = e[0] & 128;
    return n && AP(e), parseInt(Rr(e), 16) * (n ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function AP(t) {
  for (let e = 0; e < 8; e++)
    t[e] ^= 255;
  for (let e = 7; e > -1 && (t[e]++, t[e] === 0); e--)
    ;
}
class ige {
  constructor(e, n) {
    this.toUtf8 = e, this.fromUtf8 = n;
  }
  format(e) {
    const n = [];
    for (const i of Object.keys(e)) {
      const o = this.fromUtf8(i);
      n.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(e[i]));
    }
    const r = new Uint8Array(n.reduce((i, o) => i + o.byteLength, 0));
    let s = 0;
    for (const i of n)
      r.set(i, s), s += i.byteLength;
    return r;
  }
  formatHeaderValue(e) {
    switch (e.type) {
      case "boolean":
        return Uint8Array.from([e.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, e.value]);
      case "short":
        const n = new DataView(new ArrayBuffer(3));
        return n.setUint8(0, 3), n.setInt16(1, e.value, !1), new Uint8Array(n.buffer);
      case "integer":
        const r = new DataView(new ArrayBuffer(5));
        return r.setUint8(0, 4), r.setInt32(1, e.value, !1), new Uint8Array(r.buffer);
      case "long":
        const s = new Uint8Array(9);
        return s[0] = 5, s.set(e.value.bytes, 1), s;
      case "binary":
        const i = new DataView(new ArrayBuffer(3 + e.value.byteLength));
        i.setUint8(0, 6), i.setUint16(1, e.value.byteLength, !1);
        const o = new Uint8Array(i.buffer);
        return o.set(e.value, 3), o;
      case "string":
        const a = this.fromUtf8(e.value), l = new DataView(new ArrayBuffer(3 + a.byteLength));
        l.setUint8(0, 7), l.setUint16(1, a.byteLength, !1);
        const c = new Uint8Array(l.buffer);
        return c.set(a, 3), c;
      case "timestamp":
        const u = new Uint8Array(9);
        return u[0] = 8, u.set(Zh.fromNumber(e.value.valueOf()).bytes, 1), u;
      case "uuid":
        if (!pge.test(e.value))
          throw new Error(`Invalid UUID received: ${e.value}`);
        const h = new Uint8Array(17);
        return h[0] = 9, h.set(kU(e.value.replace(/\-/g, "")), 1), h;
    }
  }
  parse(e) {
    const n = {};
    let r = 0;
    for (; r < e.byteLength; ) {
      const s = e.getUint8(r++), i = this.toUtf8(new Uint8Array(e.buffer, e.byteOffset + r, s));
      switch (r += s, e.getUint8(r++)) {
        case 0:
          n[i] = {
            type: IP,
            value: !0
          };
          break;
        case 1:
          n[i] = {
            type: IP,
            value: !1
          };
          break;
        case 2:
          n[i] = {
            type: oge,
            value: e.getInt8(r++)
          };
          break;
        case 3:
          n[i] = {
            type: age,
            value: e.getInt16(r, !1)
          }, r += 2;
          break;
        case 4:
          n[i] = {
            type: lge,
            value: e.getInt32(r, !1)
          }, r += 4;
          break;
        case 5:
          n[i] = {
            type: cge,
            value: new Zh(new Uint8Array(e.buffer, e.byteOffset + r, 8))
          }, r += 8;
          break;
        case 6:
          const o = e.getUint16(r, !1);
          r += 2, n[i] = {
            type: uge,
            value: new Uint8Array(e.buffer, e.byteOffset + r, o)
          }, r += o;
          break;
        case 7:
          const a = e.getUint16(r, !1);
          r += 2, n[i] = {
            type: hge,
            value: this.toUtf8(new Uint8Array(e.buffer, e.byteOffset + r, a))
          }, r += a;
          break;
        case 8:
          n[i] = {
            type: dge,
            value: new Date(new Zh(new Uint8Array(e.buffer, e.byteOffset + r, 8)).valueOf())
          }, r += 8;
          break;
        case 9:
          const l = new Uint8Array(e.buffer, e.byteOffset + r, 16);
          r += 16, n[i] = {
            type: fge,
            value: `${Rr(l.subarray(0, 4))}-${Rr(l.subarray(4, 6))}-${Rr(l.subarray(6, 8))}-${Rr(l.subarray(8, 10))}-${Rr(l.subarray(10))}`
          };
          break;
        default:
          throw new Error("Unrecognized header type tag");
      }
    }
    return n;
  }
}
var RP;
(function(t) {
  t[t.boolTrue = 0] = "boolTrue", t[t.boolFalse = 1] = "boolFalse", t[t.byte = 2] = "byte", t[t.short = 3] = "short", t[t.integer = 4] = "integer", t[t.long = 5] = "long", t[t.byteArray = 6] = "byteArray", t[t.string = 7] = "string", t[t.timestamp = 8] = "timestamp", t[t.uuid = 9] = "uuid";
})(RP || (RP = {}));
const IP = "boolean", oge = "byte", age = "short", lge = "integer", cge = "long", uge = "binary", hge = "string", dge = "timestamp", fge = "uuid", pge = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/, cj = 4, ko = cj * 2, Oa = 4, mge = ko + Oa * 2;
function gge({ byteLength: t, byteOffset: e, buffer: n }) {
  if (t < mge)
    throw new Error("Provided message too short to accommodate event stream message overhead");
  const r = new DataView(n, e, t), s = r.getUint32(0, !1);
  if (t !== s)
    throw new Error("Reported message length does not match received message length");
  const i = r.getUint32(cj, !1), o = r.getUint32(ko, !1), a = r.getUint32(t - Oa, !1), l = new lj().update(new Uint8Array(n, e, ko));
  if (o !== l.digest())
    throw new Error(`The prelude checksum specified in the message (${o}) does not match the calculated CRC32 checksum (${l.digest()})`);
  if (l.update(new Uint8Array(n, e + ko, t - (ko + Oa))), a !== l.digest())
    throw new Error(`The message checksum (${l.digest()}) did not match the expected value of ${a}`);
  return {
    headers: new DataView(n, e + ko + Oa, i),
    body: new Uint8Array(n, e + ko + Oa + i, s - i - (ko + Oa + Oa))
  };
}
class yge {
  constructor(e, n) {
    this.headerMarshaller = new ige(e, n), this.messageBuffer = [], this.isEndOfStream = !1;
  }
  feed(e) {
    this.messageBuffer.push(this.decode(e));
  }
  endOfStream() {
    this.isEndOfStream = !0;
  }
  getMessage() {
    const e = this.messageBuffer.pop(), n = this.isEndOfStream;
    return {
      getMessage() {
        return e;
      },
      isEndOfStream() {
        return n;
      }
    };
  }
  getAvailableMessages() {
    const e = this.messageBuffer;
    this.messageBuffer = [];
    const n = this.isEndOfStream;
    return {
      getMessages() {
        return e;
      },
      isEndOfStream() {
        return n;
      }
    };
  }
  encode({ headers: e, body: n }) {
    const r = this.headerMarshaller.format(e), s = r.byteLength + n.byteLength + 16, i = new Uint8Array(s), o = new DataView(i.buffer, i.byteOffset, i.byteLength), a = new lj();
    return o.setUint32(0, s, !1), o.setUint32(4, r.byteLength, !1), o.setUint32(8, a.update(i.subarray(0, 8)).digest(), !1), i.set(r, 12), i.set(n, r.byteLength + 12), o.setUint32(s - 4, a.update(i.subarray(8, s - 4)).digest(), !1), i;
  }
  decode(e) {
    const { headers: n, body: r } = gge(e);
    return { headers: this.headerMarshaller.parse(n), body: r };
  }
  formatHeaders(e) {
    return this.headerMarshaller.format(e);
  }
}
class bge {
  constructor(e) {
    this.options = e;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const e of this.options.inputStream)
      yield this.options.decoder.decode(e);
  }
}
class _ge {
  constructor(e) {
    this.options = e;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const e of this.options.messageStream)
      yield this.options.encoder.encode(e);
    this.options.includeEndFrame && (yield new Uint8Array(0));
  }
}
class vge {
  constructor(e) {
    this.options = e;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const e of this.options.messageStream) {
      const n = await this.options.deserializer(e);
      n !== void 0 && (yield n);
    }
  }
}
class wge {
  constructor(e) {
    this.options = e;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const e of this.options.inputStream)
      yield this.options.serializer(e);
  }
}
function Ege(t) {
  let e = 0, n = 0, r = null, s = null;
  const i = (a) => {
    if (typeof a != "number")
      throw new Error("Attempted to allocate an event message where size was not a number: " + a);
    e = a, n = 4, r = new Uint8Array(a), new DataView(r.buffer).setUint32(0, a, !1);
  }, o = async function* () {
    const a = t[Symbol.asyncIterator]();
    for (; ; ) {
      const { value: l, done: c } = await a.next();
      if (c) {
        if (e)
          if (e === n)
            yield r;
          else
            throw new Error("Truncated event message received.");
        else return;
        return;
      }
      const u = l.length;
      let h = 0;
      for (; h < u; ) {
        if (!r) {
          const f = u - h;
          s || (s = new Uint8Array(4));
          const g = Math.min(4 - n, f);
          if (s.set(l.slice(h, h + g), n), n += g, h += g, n < 4)
            break;
          i(new DataView(s.buffer).getUint32(0, !1)), s = null;
        }
        const d = Math.min(e - n, u - h);
        r.set(l.slice(h, h + d), n), n += d, h += d, e && e === n && (yield r, r = null, e = 0, n = 0);
      }
    }
  };
  return {
    [Symbol.asyncIterator]: o
  };
}
function Sge(t, e) {
  return async function(n) {
    const { value: r } = n.headers[":message-type"];
    if (r === "error") {
      const s = new Error(n.headers[":error-message"].value || "UnknownError");
      throw s.name = n.headers[":error-code"].value, s;
    } else if (r === "exception") {
      const s = n.headers[":exception-type"].value, i = { [s]: n }, o = await t(i);
      if (o.$unknown) {
        const a = new Error(e(n.body));
        throw a.name = s, a;
      }
      throw o[s];
    } else if (r === "event") {
      const s = {
        [n.headers[":event-type"].value]: n
      }, i = await t(s);
      return i.$unknown ? void 0 : i;
    } else
      throw Error(`Unrecognizable event type: ${n.headers[":event-type"].value}`);
  };
}
let xge = class {
  constructor({ utf8Encoder: e, utf8Decoder: n }) {
    this.eventStreamCodec = new yge(e, n), this.utfEncoder = e;
  }
  deserialize(e, n) {
    const r = Ege(e);
    return new vge({
      messageStream: new bge({ inputStream: r, decoder: this.eventStreamCodec }),
      deserializer: Sge(n, this.utfEncoder)
    });
  }
  serialize(e, n) {
    return new _ge({
      messageStream: new wge({ inputStream: e, serializer: n }),
      encoder: this.eventStreamCodec,
      includeEndFrame: !0
    });
  }
};
const Tge = (t) => ({
  [Symbol.asyncIterator]: async function* () {
    const e = t.getReader();
    try {
      for (; ; ) {
        const { done: n, value: r } = await e.read();
        if (n)
          return;
        yield r;
      }
    } finally {
      e.releaseLock();
    }
  }
}), Cge = (t) => {
  const e = t[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(n) {
      const { done: r, value: s } = await e.next();
      if (r)
        return n.close();
      n.enqueue(s);
    }
  });
};
class kge {
  constructor({ utf8Encoder: e, utf8Decoder: n }) {
    this.universalMarshaller = new xge({
      utf8Decoder: n,
      utf8Encoder: e
    });
  }
  deserialize(e, n) {
    const r = Age(e) ? Tge(e) : e;
    return this.universalMarshaller.deserialize(r, n);
  }
  serialize(e, n) {
    const r = this.universalMarshaller.serialize(e, n);
    return typeof ReadableStream == "function" ? Cge(r) : r;
  }
}
const Age = (t) => typeof ReadableStream == "function" && t instanceof ReadableStream, Rge = (t) => new kge(t), Ige = (t) => () => Promise.reject(t), PP = typeof TextEncoder == "function" ? new TextEncoder() : null, Pge = (t) => {
  if (typeof t == "string") {
    if (PP)
      return PP.encode(t).byteLength;
    let e = t.length;
    for (let n = e - 1; n >= 0; n--) {
      const r = t.charCodeAt(n);
      r > 127 && r <= 2047 ? e++ : r > 2047 && r <= 65535 && (e += 2), r >= 56320 && r <= 57343 && n--;
    }
    return e;
  } else {
    if (typeof t.byteLength == "number")
      return t.byteLength;
    if (typeof t.size == "number")
      return t.size;
  }
  throw new Error(`Body Length computation failed for ${t}`);
}, uj = "required", si = "fn", ii = "argv", Ru = "ref", OP = !0, DP = "isSet", Vd = "booleanEquals", Zl = "error", Qu = "endpoint", Vn = "tree", GC = "PartitionResult", NP = { [uj]: !1, type: "String" }, LP = { [uj]: !0, default: !1, type: "Boolean" }, MP = { [Ru]: "Endpoint" }, hj = { [si]: Vd, [ii]: [{ [Ru]: "UseFIPS" }, !0] }, dj = { [si]: Vd, [ii]: [{ [Ru]: "UseDualStack" }, !0] }, Fs = {}, BP = { [si]: "getAttr", [ii]: [{ [Ru]: GC }, "supportsFIPS"] }, FP = { [si]: Vd, [ii]: [!0, { [si]: "getAttr", [ii]: [{ [Ru]: GC }, "supportsDualStack"] }] }, $P = [hj], UP = [dj], jP = [{ [Ru]: "Region" }], Oge = { parameters: { Region: NP, UseDualStack: LP, UseFIPS: LP, Endpoint: NP }, rules: [{ conditions: [{ [si]: DP, [ii]: [MP] }], rules: [{ conditions: $P, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: Zl }, { rules: [{ conditions: UP, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: Zl }, { endpoint: { url: MP, properties: Fs, headers: Fs }, type: Qu }], type: Vn }], type: Vn }, { rules: [{ conditions: [{ [si]: DP, [ii]: jP }], rules: [{ conditions: [{ [si]: "aws.partition", [ii]: jP, assign: GC }], rules: [{ conditions: [hj, dj], rules: [{ conditions: [{ [si]: Vd, [ii]: [OP, BP] }, FP], rules: [{ rules: [{ endpoint: { url: "https://bedrock-runtime-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Fs, headers: Fs }, type: Qu }], type: Vn }], type: Vn }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: Zl }], type: Vn }, { conditions: $P, rules: [{ conditions: [{ [si]: Vd, [ii]: [BP, OP] }], rules: [{ rules: [{ endpoint: { url: "https://bedrock-runtime-fips.{Region}.{PartitionResult#dnsSuffix}", properties: Fs, headers: Fs }, type: Qu }], type: Vn }], type: Vn }, { error: "FIPS is enabled but this partition does not support FIPS", type: Zl }], type: Vn }, { conditions: UP, rules: [{ conditions: [FP], rules: [{ rules: [{ endpoint: { url: "https://bedrock-runtime.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Fs, headers: Fs }, type: Qu }], type: Vn }], type: Vn }, { error: "DualStack is enabled but this partition does not support DualStack", type: Zl }], type: Vn }, { rules: [{ endpoint: { url: "https://bedrock-runtime.{Region}.{PartitionResult#dnsSuffix}", properties: Fs, headers: Fs }, type: Qu }], type: Vn }], type: Vn }], type: Vn }, { error: "Invalid Configuration: Missing Region", type: Zl }], type: Vn }] }, Dge = Oge, Nge = new qde({
  size: 50,
  params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
}), Lge = (t, e = {}) => Nge.get(t, () => dfe(Dge, {
  endpointParams: t,
  logger: e.logger
}));
L0.aws = FU;
const Mge = (t) => ({
  apiVersion: "2023-09-30",
  base64Decoder: t?.base64Decoder ?? MC,
  base64Encoder: t?.base64Encoder ?? TU,
  disableHostPrefix: t?.disableHostPrefix ?? !1,
  endpointProvider: t?.endpointProvider ?? Lge,
  extensions: t?.extensions ?? [],
  httpAuthSchemeProvider: t?.httpAuthSchemeProvider ?? Rme,
  httpAuthSchemes: t?.httpAuthSchemes ?? [
    {
      schemeId: "aws.auth#sigv4",
      identityProvider: (e) => e.getIdentityProvider("aws.auth#sigv4"),
      signer: new Efe()
    }
  ],
  logger: t?.logger ?? new JU(),
  serviceId: t?.serviceId ?? "Bedrock Runtime",
  urlParser: t?.urlParser ?? B0,
  utf8Decoder: t?.utf8Decoder ?? ru,
  utf8Encoder: t?.utf8Encoder ?? xU
}), Bge = ["in-region", "cross-region", "mobile", "standard", "legacy"], Fge = ({ defaultsMode: t } = {}) => Sfe(async () => {
  const e = typeof t == "function" ? await t() : t;
  switch (e?.toLowerCase()) {
    case "auto":
      return Promise.resolve($ge() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(e?.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${Bge.join(", ")}, got ${e}`);
  }
}), $ge = () => {
  const e = (typeof window < "u" && window?.navigator?.userAgent ? aj.parse(window.navigator.userAgent) : void 0)?.platform?.type;
  return e === "tablet" || e === "mobile";
}, Uge = (t) => {
  const e = Fge(t), n = () => e().then(lpe), r = Mge(t);
  return {
    ...r,
    ...t,
    runtime: "browser",
    defaultsMode: e,
    bodyLengthChecker: t?.bodyLengthChecker ?? Pge,
    credentialDefaultProvider: t?.credentialDefaultProvider ?? ((s) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: t?.defaultUserAgentProvider ?? nge({ serviceId: r.serviceId, clientVersion: Dme.version }),
    eventStreamSerdeProvider: t?.eventStreamSerdeProvider ?? Rge,
    maxAttempts: t?.maxAttempts ?? F0,
    region: t?.region ?? Ige("Region is missing"),
    requestHandler: BC.create(t?.requestHandler ?? n),
    retryMode: t?.retryMode ?? (async () => (await n()).retryMode || Jpe),
    sha256: t?.sha256 ?? Zme,
    streamCollector: t?.streamCollector ?? Ode,
    useDualstackEndpoint: t?.useDualstackEndpoint ?? (() => Promise.resolve(Ppe)),
    useFipsEndpoint: t?.useFipsEndpoint ?? (() => Promise.resolve(Ope))
  };
}, jge = (t) => {
  let e = async () => {
    if (t.region === void 0)
      throw new Error("Region is missing from runtimeConfig");
    const n = t.region;
    return typeof n == "string" ? n : n();
  };
  return {
    setRegion(n) {
      e = n;
    },
    region() {
      return e;
    }
  };
}, Hge = (t) => ({
  region: t.region()
}), zge = (t) => {
  const e = t.httpAuthSchemes;
  let n = t.httpAuthSchemeProvider, r = t.credentials;
  return {
    setHttpAuthScheme(s) {
      const i = e.findIndex((o) => o.schemeId === s.schemeId);
      i === -1 ? e.push(s) : e.splice(i, 1, s);
    },
    httpAuthSchemes() {
      return e;
    },
    setHttpAuthSchemeProvider(s) {
      n = s;
    },
    httpAuthSchemeProvider() {
      return n;
    },
    setCredentials(s) {
      r = s;
    },
    credentials() {
      return r;
    }
  };
}, Gge = (t) => ({
  httpAuthSchemes: t.httpAuthSchemes(),
  httpAuthSchemeProvider: t.httpAuthSchemeProvider(),
  credentials: t.credentials()
}), hm = (t) => t, Vge = (t, e) => {
  const n = {
    ...hm(jge(t)),
    ...hm(fpe(t)),
    ...hm(ede(t)),
    ...hm(zge(t))
  };
  return e.forEach((r) => r.configure(n)), {
    ...t,
    ...Hge(n),
    ...ppe(n),
    ...tde(n),
    ...Gge(n)
  };
};
class Wge extends Zfe {
  config;
  constructor(...[e]) {
    const n = Uge(e || {}), r = Pme(n), s = Wde(r), i = bme(s), o = Dpe(i), a = o, l = Zpe(a), c = Npe(l), u = Ime(c), h = Vge(u, e?.extensions || []);
    super(h), this.config = h, this.middlewareStack.use(Ipe(this.config)), this.middlewareStack.use(Tme(this.config)), this.middlewareStack.use(Bpe(this.config)), this.middlewareStack.use(ide(this.config)), this.middlewareStack.use(lde(this.config)), this.middlewareStack.use(fde(this.config)), this.middlewareStack.use(yde(this.config, {
      httpAuthSchemeParametersProvider: kme,
      identityProviderConfigProvider: async (d) => new $de({
        "aws.auth#sigv4": d.credentials
      })
    })), this.middlewareStack.use(Tde(this.config));
  }
  destroy() {
    super.destroy();
  }
}
class nr extends yc {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, nr.prototype);
  }
}
class VC extends nr {
  name = "AccessDeniedException";
  $fault = "client";
  constructor(e) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, VC.prototype);
  }
}
var HP;
(function(t) {
  t.visit = (e, n) => e.s3OutputDataConfig !== void 0 ? n.s3OutputDataConfig(e.s3OutputDataConfig) : n._(e.$unknown[0], e.$unknown[1]);
})(HP || (HP = {}));
class WC extends nr {
  name = "InternalServerException";
  $fault = "server";
  constructor(e) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...e
    }), Object.setPrototypeOf(this, WC.prototype);
  }
}
class qC extends nr {
  name = "ThrottlingException";
  $fault = "client";
  constructor(e) {
    super({
      name: "ThrottlingException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, qC.prototype);
  }
}
class KC extends nr {
  name = "ValidationException";
  $fault = "client";
  constructor(e) {
    super({
      name: "ValidationException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, KC.prototype);
  }
}
class YC extends nr {
  name = "ConflictException";
  $fault = "client";
  constructor(e) {
    super({
      name: "ConflictException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, YC.prototype);
  }
}
class ZC extends nr {
  name = "ResourceNotFoundException";
  $fault = "client";
  constructor(e) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, ZC.prototype);
  }
}
class JC extends nr {
  name = "ServiceQuotaExceededException";
  $fault = "client";
  constructor(e) {
    super({
      name: "ServiceQuotaExceededException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, JC.prototype);
  }
}
class XC extends nr {
  name = "ServiceUnavailableException";
  $fault = "server";
  constructor(e) {
    super({
      name: "ServiceUnavailableException",
      $fault: "server",
      ...e
    }), Object.setPrototypeOf(this, XC.prototype);
  }
}
var zP;
(function(t) {
  t.visit = (e, n) => e.bytes !== void 0 ? n.bytes(e.bytes) : n._(e.$unknown[0], e.$unknown[1]);
})(zP || (zP = {}));
var GP;
(function(t) {
  t.visit = (e, n) => e.text !== void 0 ? n.text(e.text) : e.image !== void 0 ? n.image(e.image) : n._(e.$unknown[0], e.$unknown[1]);
})(GP || (GP = {}));
var cS;
(function(t) {
  t.visit = (e, n) => e.bytes !== void 0 ? n.bytes(e.bytes) : n._(e.$unknown[0], e.$unknown[1]);
})(cS || (cS = {}));
var uS;
(function(t) {
  t.visit = (e, n) => e.bytes !== void 0 ? n.bytes(e.bytes) : n._(e.$unknown[0], e.$unknown[1]);
})(uS || (uS = {}));
var hS;
(function(t) {
  t.visit = (e, n) => e.text !== void 0 ? n.text(e.text) : e.image !== void 0 ? n.image(e.image) : n._(e.$unknown[0], e.$unknown[1]);
})(hS || (hS = {}));
var dS;
(function(t) {
  t.visit = (e, n) => e.bytes !== void 0 ? n.bytes(e.bytes) : n._(e.$unknown[0], e.$unknown[1]);
})(dS || (dS = {}));
var fS;
(function(t) {
  t.visit = (e, n) => e.bytes !== void 0 ? n.bytes(e.bytes) : e.s3Location !== void 0 ? n.s3Location(e.s3Location) : n._(e.$unknown[0], e.$unknown[1]);
})(fS || (fS = {}));
var pS;
(function(t) {
  t.visit = (e, n) => e.json !== void 0 ? n.json(e.json) : e.text !== void 0 ? n.text(e.text) : e.image !== void 0 ? n.image(e.image) : e.document !== void 0 ? n.document(e.document) : e.video !== void 0 ? n.video(e.video) : n._(e.$unknown[0], e.$unknown[1]);
})(pS || (pS = {}));
var mS;
(function(t) {
  t.visit = (e, n) => e.text !== void 0 ? n.text(e.text) : e.image !== void 0 ? n.image(e.image) : e.document !== void 0 ? n.document(e.document) : e.video !== void 0 ? n.video(e.video) : e.toolUse !== void 0 ? n.toolUse(e.toolUse) : e.toolResult !== void 0 ? n.toolResult(e.toolResult) : e.guardContent !== void 0 ? n.guardContent(e.guardContent) : n._(e.$unknown[0], e.$unknown[1]);
})(mS || (mS = {}));
var VP;
(function(t) {
  t.visit = (e, n) => e.text !== void 0 ? n.text(e.text) : n._(e.$unknown[0], e.$unknown[1]);
})(VP || (VP = {}));
var gS;
(function(t) {
  t.visit = (e, n) => e.text !== void 0 ? n.text(e.text) : e.guardContent !== void 0 ? n.guardContent(e.guardContent) : n._(e.$unknown[0], e.$unknown[1]);
})(gS || (gS = {}));
var WP;
(function(t) {
  t.visit = (e, n) => e.auto !== void 0 ? n.auto(e.auto) : e.any !== void 0 ? n.any(e.any) : e.tool !== void 0 ? n.tool(e.tool) : n._(e.$unknown[0], e.$unknown[1]);
})(WP || (WP = {}));
var yS;
(function(t) {
  t.visit = (e, n) => e.json !== void 0 ? n.json(e.json) : n._(e.$unknown[0], e.$unknown[1]);
})(yS || (yS = {}));
var bS;
(function(t) {
  t.visit = (e, n) => e.toolSpec !== void 0 ? n.toolSpec(e.toolSpec) : n._(e.$unknown[0], e.$unknown[1]);
})(bS || (bS = {}));
var qP;
(function(t) {
  t.visit = (e, n) => e.message !== void 0 ? n.message(e.message) : n._(e.$unknown[0], e.$unknown[1]);
})(qP || (qP = {}));
class QC extends nr {
  name = "ModelErrorException";
  $fault = "client";
  originalStatusCode;
  resourceName;
  constructor(e) {
    super({
      name: "ModelErrorException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, QC.prototype), this.originalStatusCode = e.originalStatusCode, this.resourceName = e.resourceName;
  }
}
class ek extends nr {
  name = "ModelNotReadyException";
  $fault = "client";
  $retryable = {};
  constructor(e) {
    super({
      name: "ModelNotReadyException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, ek.prototype);
  }
}
class tk extends nr {
  name = "ModelTimeoutException";
  $fault = "client";
  constructor(e) {
    super({
      name: "ModelTimeoutException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, tk.prototype);
  }
}
var KP;
(function(t) {
  t.visit = (e, n) => e.text !== void 0 ? n.text(e.text) : e.toolUse !== void 0 ? n.toolUse(e.toolUse) : n._(e.$unknown[0], e.$unknown[1]);
})(KP || (KP = {}));
var YP;
(function(t) {
  t.visit = (e, n) => e.toolUse !== void 0 ? n.toolUse(e.toolUse) : n._(e.$unknown[0], e.$unknown[1]);
})(YP || (YP = {}));
class nk extends nr {
  name = "ModelStreamErrorException";
  $fault = "client";
  originalStatusCode;
  originalMessage;
  constructor(e) {
    super({
      name: "ModelStreamErrorException",
      $fault: "client",
      ...e
    }), Object.setPrototypeOf(this, nk.prototype), this.originalStatusCode = e.originalStatusCode, this.originalMessage = e.originalMessage;
  }
}
var ZP;
(function(t) {
  t.visit = (e, n) => e.messageStart !== void 0 ? n.messageStart(e.messageStart) : e.contentBlockStart !== void 0 ? n.contentBlockStart(e.contentBlockStart) : e.contentBlockDelta !== void 0 ? n.contentBlockDelta(e.contentBlockDelta) : e.contentBlockStop !== void 0 ? n.contentBlockStop(e.contentBlockStop) : e.messageStop !== void 0 ? n.messageStop(e.messageStop) : e.metadata !== void 0 ? n.metadata(e.metadata) : e.internalServerException !== void 0 ? n.internalServerException(e.internalServerException) : e.modelStreamErrorException !== void 0 ? n.modelStreamErrorException(e.modelStreamErrorException) : e.validationException !== void 0 ? n.validationException(e.validationException) : e.throttlingException !== void 0 ? n.throttlingException(e.throttlingException) : e.serviceUnavailableException !== void 0 ? n.serviceUnavailableException(e.serviceUnavailableException) : n._(e.$unknown[0], e.$unknown[1]);
})(ZP || (ZP = {}));
var JP;
(function(t) {
  t.visit = (e, n) => e.chunk !== void 0 ? n.chunk(e.chunk) : e.internalServerException !== void 0 ? n.internalServerException(e.internalServerException) : e.modelStreamErrorException !== void 0 ? n.modelStreamErrorException(e.modelStreamErrorException) : e.validationException !== void 0 ? n.validationException(e.validationException) : e.throttlingException !== void 0 ? n.throttlingException(e.throttlingException) : e.modelTimeoutException !== void 0 ? n.modelTimeoutException(e.modelTimeoutException) : e.serviceUnavailableException !== void 0 ? n.serviceUnavailableException(e.serviceUnavailableException) : n._(e.$unknown[0], e.$unknown[1]);
})(JP || (JP = {}));
const fj = (t) => {
  if (t.text !== void 0)
    return { text: t.text };
  if (t.image !== void 0)
    return { image: yl };
  if (t.$unknown !== void 0)
    return { [t.$unknown[0]]: "UNKNOWN" };
}, qge = (t) => {
  if (t.text !== void 0)
    return { text: t.text };
  if (t.image !== void 0)
    return { image: t.image };
  if (t.document !== void 0)
    return { document: t.document };
  if (t.video !== void 0)
    return { video: t.video };
  if (t.toolUse !== void 0)
    return { toolUse: t.toolUse };
  if (t.toolResult !== void 0)
    return { toolResult: t.toolResult };
  if (t.guardContent !== void 0)
    return { guardContent: fj(t.guardContent) };
  if (t.$unknown !== void 0)
    return { [t.$unknown[0]]: "UNKNOWN" };
}, rk = (t) => ({
  ...t,
  ...t.content && { content: t.content.map((e) => qge(e)) }
}), pj = (t) => {
  if (t.text !== void 0)
    return { text: t.text };
  if (t.guardContent !== void 0)
    return { guardContent: fj(t.guardContent) };
  if (t.$unknown !== void 0)
    return { [t.$unknown[0]]: "UNKNOWN" };
}, Kge = (t) => ({
  ...t,
  ...t.messages && { messages: t.messages.map((e) => rk(e)) },
  ...t.system && { system: t.system.map((e) => pj(e)) },
  ...t.toolConfig && { toolConfig: t.toolConfig },
  ...t.promptVariables && { promptVariables: yl },
  ...t.requestMetadata && { requestMetadata: yl }
}), Yge = (t) => {
  if (t.message !== void 0)
    return { message: rk(t.message) };
  if (t.$unknown !== void 0)
    return { [t.$unknown[0]]: "UNKNOWN" };
}, Zge = (t) => ({
  ...t,
  ...t.output && { output: Yge(t.output) }
}), Jge = (t) => ({
  ...t,
  ...t.messages && { messages: t.messages.map((e) => rk(e)) },
  ...t.system && { system: t.system.map((e) => pj(e)) },
  ...t.toolConfig && { toolConfig: t.toolConfig },
  ...t.promptVariables && { promptVariables: yl },
  ...t.requestMetadata && { requestMetadata: yl }
}), Xge = (t) => ({
  ...t,
  ...t.stream && { stream: "STREAMING_CONTENT" }
}), Qge = (t) => ({
  ...t,
  ...t.body && { body: yl }
}), e0e = (t) => ({
  ...t,
  ...t.body && { body: yl }
}), t0e = async (t, e) => {
  const n = FC(t, e), r = {
    "content-type": "application/json"
  };
  n.bp("/model/{modelId}/converse"), n.p("modelId", () => t.modelId, "{modelId}", !1);
  let s;
  return s = JSON.stringify(ot(t, {
    additionalModelRequestFields: (i) => ip(i),
    additionalModelResponseFieldPaths: (i) => ut(i),
    guardrailConfig: (i) => ut(i),
    inferenceConfig: (i) => Sj(i),
    messages: (i) => xj(i, e),
    performanceConfig: (i) => ut(i),
    promptVariables: (i) => ut(i),
    requestMetadata: (i) => ut(i),
    system: (i) => Tj(i, e),
    toolConfig: (i) => Cj(i)
  })), n.m("POST").h(r).b(s), n.build();
}, n0e = async (t, e) => {
  const n = FC(t, e), r = {
    "content-type": "application/json"
  };
  n.bp("/model/{modelId}/converse-stream"), n.p("modelId", () => t.modelId, "{modelId}", !1);
  let s;
  return s = JSON.stringify(ot(t, {
    additionalModelRequestFields: (i) => ip(i),
    additionalModelResponseFieldPaths: (i) => ut(i),
    guardrailConfig: (i) => ut(i),
    inferenceConfig: (i) => Sj(i),
    messages: (i) => xj(i, e),
    performanceConfig: (i) => ut(i),
    promptVariables: (i) => ut(i),
    requestMetadata: (i) => ut(i),
    system: (i) => Tj(i, e),
    toolConfig: (i) => Cj(i)
  })), n.m("POST").h(r).b(s), n.build();
}, r0e = async (t, e) => {
  const n = FC(t, e), r = On({}, mpe, {
    [Nj]: t[Dj] || "application/octet-stream",
    [XP]: t[XP],
    [_ye]: t[gye],
    [yye]: t[pye],
    [bye]: t[mye],
    [Mj]: t[Lj]
  });
  n.bp("/model/{modelId}/invoke"), n.p("modelId", () => t.modelId, "{modelId}", !1);
  let s;
  return t.body !== void 0 && (s = t.body), n.m("POST").h(r).b(s), n.build();
}, s0e = async (t, e) => {
  if (t.statusCode !== 200 && t.statusCode >= 300)
    return sk(t, e);
  const n = On({
    $metadata: rr(t)
  }), r = npe(KU(await Ur(t.body, e)), "body"), s = ot(r, {
    additionalModelResponseFields: (i) => Ab(i),
    metrics: ut,
    output: (i) => W0e(ya(i), e),
    performanceConfig: ut,
    stopReason: xt,
    trace: (i) => Y0e(i),
    usage: ut
  });
  return Object.assign(n, s), n;
}, i0e = async (t, e) => {
  if (t.statusCode !== 200 && t.statusCode >= 300)
    return sk(t, e);
  const n = On({
    $metadata: rr(t)
  }), r = t.body;
  return n.stream = m0e(r, e), n;
}, o0e = async (t, e) => {
  if (t.statusCode !== 200 && t.statusCode >= 300)
    return sk(t, e);
  const n = On({
    $metadata: rr(t),
    [Dj]: [, t.headers[Nj]],
    [Lj]: [, t.headers[Mj]]
  }), r = await AU(t.body, e);
  return n.body = r, n;
}, sk = async (t, e) => {
  const n = {
    ...t,
    body: await vpe(t.body, e)
  }, r = wpe(t, n.body);
  switch (r) {
    case "AccessDeniedException":
    case "com.amazonaws.bedrockruntime#AccessDeniedException":
      throw await l0e(n);
    case "InternalServerException":
    case "com.amazonaws.bedrockruntime#InternalServerException":
      throw await mj(n);
    case "ResourceNotFoundException":
    case "com.amazonaws.bedrockruntime#ResourceNotFoundException":
      throw await f0e(n);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.bedrockruntime#ServiceQuotaExceededException":
      throw await p0e(n);
    case "ThrottlingException":
    case "com.amazonaws.bedrockruntime#ThrottlingException":
      throw await bj(n);
    case "ValidationException":
    case "com.amazonaws.bedrockruntime#ValidationException":
      throw await _j(n);
    case "ModelErrorException":
    case "com.amazonaws.bedrockruntime#ModelErrorException":
      throw await u0e(n);
    case "ModelNotReadyException":
    case "com.amazonaws.bedrockruntime#ModelNotReadyException":
      throw await h0e(n);
    case "ModelTimeoutException":
    case "com.amazonaws.bedrockruntime#ModelTimeoutException":
      throw await d0e(n);
    case "ServiceUnavailableException":
    case "com.amazonaws.bedrockruntime#ServiceUnavailableException":
      throw await yj(n);
    case "ModelStreamErrorException":
    case "com.amazonaws.bedrockruntime#ModelStreamErrorException":
      throw await gj(n);
    case "ConflictException":
    case "com.amazonaws.bedrockruntime#ConflictException":
      throw await c0e(n);
    default:
      const s = n.body;
      return a0e({
        output: t,
        parsedBody: s,
        errorCode: r
      });
  }
}, a0e = ope(nr), l0e = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new VC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, c0e = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new YC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, mj = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new WC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, u0e = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt,
    originalStatusCode: qU,
    resourceName: xt
  });
  Object.assign(n, s);
  const i = new QC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, h0e = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new ek({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, gj = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt,
    originalMessage: xt,
    originalStatusCode: qU
  });
  Object.assign(n, s);
  const i = new nk({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, d0e = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new tk({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, f0e = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new ZC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, p0e = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new JC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, yj = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new XC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, bj = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new qC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, _j = async (t, e) => {
  const n = On({}), r = t.body, s = ot(r, {
    message: xt
  });
  Object.assign(n, s);
  const i = new KC({
    $metadata: rr(t),
    ...n
  });
  return $r(i, t.body);
}, m0e = (t, e) => e.eventStreamMarshaller.deserialize(t, async (n) => n.messageStart != null ? {
  messageStart: await w0e(n.messageStart, e)
} : n.contentBlockStart != null ? {
  contentBlockStart: await y0e(n.contentBlockStart, e)
} : n.contentBlockDelta != null ? {
  contentBlockDelta: await g0e(n.contentBlockDelta, e)
} : n.contentBlockStop != null ? {
  contentBlockStop: await b0e(n.contentBlockStop, e)
} : n.messageStop != null ? {
  messageStop: await E0e(n.messageStop, e)
} : n.metadata != null ? {
  metadata: await _0e(n.metadata, e)
} : n.internalServerException != null ? {
  internalServerException: await v0e(n.internalServerException, e)
} : n.modelStreamErrorException != null ? {
  modelStreamErrorException: await S0e(n.modelStreamErrorException, e)
} : n.validationException != null ? {
  validationException: await C0e(n.validationException, e)
} : n.throttlingException != null ? {
  throttlingException: await T0e(n.throttlingException, e)
} : n.serviceUnavailableException != null ? {
  serviceUnavailableException: await x0e(n.serviceUnavailableException, e)
} : { $unknown: t }), g0e = async (t, e) => {
  const n = {}, r = await Ur(t.body, e);
  return Object.assign(n, ut(r)), n;
}, y0e = async (t, e) => {
  const n = {}, r = await Ur(t.body, e);
  return Object.assign(n, ut(r)), n;
}, b0e = async (t, e) => {
  const n = {}, r = await Ur(t.body, e);
  return Object.assign(n, ut(r)), n;
}, _0e = async (t, e) => {
  const n = {}, r = await Ur(t.body, e);
  return Object.assign(n, q0e(r)), n;
}, v0e = async (t, e) => {
  const n = {
    ...t,
    body: await Ur(t.body, e)
  };
  return mj(n);
}, w0e = async (t, e) => {
  const n = {}, r = await Ur(t.body, e);
  return Object.assign(n, ut(r)), n;
}, E0e = async (t, e) => {
  const n = {}, r = await Ur(t.body, e);
  return Object.assign(n, lye(r)), n;
}, S0e = async (t, e) => {
  const n = {
    ...t,
    body: await Ur(t.body, e)
  };
  return gj(n);
}, x0e = async (t, e) => {
  const n = {
    ...t,
    body: await Ur(t.body, e)
  };
  return yj(n);
}, T0e = async (t, e) => {
  const n = {
    ...t,
    body: await Ur(t.body, e)
  };
  return bj(n);
}, C0e = async (t, e) => {
  const n = {
    ...t,
    body: await Ur(t.body, e)
  };
  return _j(n);
}, k0e = (t, e) => mS.visit(t, {
  document: (n) => ({ document: vj(n, e) }),
  guardContent: (n) => ({ guardContent: wj(n, e) }),
  image: (n) => ({ image: Ej(n, e) }),
  text: (n) => ({ text: n }),
  toolResult: (n) => ({ toolResult: B0e(n, e) }),
  toolUse: (n) => ({ toolUse: H0e(n) }),
  video: (n) => ({ video: kj(n, e) }),
  _: (n, r) => ({ name: r })
}), A0e = (t, e) => t.filter((n) => n != null).map((n) => k0e(n, e)), vj = (t, e) => ot(t, {
  format: [],
  name: [],
  source: (n) => R0e(n, e)
}), R0e = (t, e) => cS.visit(t, {
  bytes: (n) => ({ bytes: e.base64Encoder(n) }),
  _: (n, r) => ({ name: r })
}), wj = (t, e) => hS.visit(t, {
  image: (n) => ({ image: I0e(n, e) }),
  text: (n) => ({ text: ut(n) }),
  _: (n, r) => ({ name: r })
}), I0e = (t, e) => ot(t, {
  format: [],
  source: (n) => P0e(n, e)
}), P0e = (t, e) => uS.visit(t, {
  bytes: (n) => ({ bytes: e.base64Encoder(n) }),
  _: (n, r) => ({ name: r })
}), Ej = (t, e) => ot(t, {
  format: [],
  source: (n) => O0e(n, e)
}), O0e = (t, e) => dS.visit(t, {
  bytes: (n) => ({ bytes: e.base64Encoder(n) }),
  _: (n, r) => ({ name: r })
}), Sj = (t, e) => ot(t, {
  maxTokens: [],
  stopSequences: ut,
  temperature: gP,
  topP: gP
}), D0e = (t, e) => ot(t, {
  content: (n) => A0e(n, e),
  role: []
}), xj = (t, e) => t.filter((n) => n != null).map((n) => D0e(n, e)), N0e = (t, e) => gS.visit(t, {
  guardContent: (n) => ({ guardContent: wj(n, e) }),
  text: (n) => ({ text: n }),
  _: (n, r) => ({ name: r })
}), Tj = (t, e) => t.filter((n) => n != null).map((n) => N0e(n, e)), L0e = (t, e) => bS.visit(t, {
  toolSpec: (n) => ({ toolSpec: j0e(n) }),
  _: (n, r) => ({ name: r })
}), Cj = (t, e) => ot(t, {
  toolChoice: ut,
  tools: (n) => U0e(n)
}), M0e = (t, e) => yS.visit(t, {
  json: (n) => ({ json: ip(n) }),
  _: (n, r) => ({ name: r })
}), B0e = (t, e) => ot(t, {
  content: (n) => $0e(n, e),
  status: [],
  toolUseId: []
}), F0e = (t, e) => pS.visit(t, {
  document: (n) => ({ document: vj(n, e) }),
  image: (n) => ({ image: Ej(n, e) }),
  json: (n) => ({ json: ip(n) }),
  text: (n) => ({ text: n }),
  video: (n) => ({ video: kj(n, e) }),
  _: (n, r) => ({ name: r })
}), $0e = (t, e) => t.filter((n) => n != null).map((n) => F0e(n, e)), U0e = (t, e) => t.filter((n) => n != null).map((n) => L0e(n)), j0e = (t, e) => ot(t, {
  description: [],
  inputSchema: (n) => M0e(n),
  name: []
}), H0e = (t, e) => ot(t, {
  input: (n) => ip(n),
  name: [],
  toolUseId: []
}), kj = (t, e) => ot(t, {
  format: [],
  source: (n) => z0e(n, e)
}), z0e = (t, e) => fS.visit(t, {
  bytes: (n) => ({ bytes: e.base64Encoder(n) }),
  s3Location: (n) => ({ s3Location: ut(n) }),
  _: (n, r) => ({ name: r })
}), ip = (t, e) => t, G0e = (t, e) => t.document != null ? {
  document: Aj(t.document, e)
} : t.guardContent != null ? {
  guardContent: rye(ya(t.guardContent), e)
} : t.image != null ? {
  image: Pj(t.image, e)
} : xt(t.text) !== void 0 ? { text: xt(t.text) } : t.toolResult != null ? {
  toolResult: cye(t.toolResult, e)
} : t.toolUse != null ? {
  toolUse: dye(t.toolUse)
} : t.video != null ? {
  video: Oj(t.video, e)
} : { $unknown: Object.entries(t)[0] }, V0e = (t, e) => (t || []).filter((r) => r != null).map((r) => G0e(ya(r), e)), W0e = (t, e) => t.message != null ? {
  message: aye(t.message, e)
} : { $unknown: Object.entries(t)[0] }, q0e = (t, e) => ot(t, {
  metrics: ut,
  performanceConfig: ut,
  trace: (n) => K0e(n),
  usage: ut
}), K0e = (t, e) => ot(t, {
  guardrail: (n) => Ij(n),
  promptRouter: ut
}), Y0e = (t, e) => ot(t, {
  guardrail: (n) => Ij(n),
  promptRouter: ut
}), Aj = (t, e) => ot(t, {
  format: xt,
  name: xt,
  source: (n) => Z0e(ya(n), e)
}), Z0e = (t, e) => t.bytes != null ? {
  bytes: e.base64Decoder(t.bytes)
} : { $unknown: Object.entries(t)[0] }, Rj = (t, e) => ot(t, {
  contentPolicy: ut,
  contextualGroundingPolicy: (n) => nye(n),
  invocationMetrics: ut,
  sensitiveInformationPolicy: ut,
  topicPolicy: ut,
  wordPolicy: ut
}), J0e = (t, e) => (t || []).filter((r) => r != null).map((r) => Rj(r)), X0e = (t, e) => Object.entries(t).reduce((n, [r, s]) => (s === null || (n[r] = J0e(s)), n), {}), Q0e = (t, e) => Object.entries(t).reduce((n, [r, s]) => (s === null || (n[r] = Rj(s)), n), {}), eye = (t, e) => ot(t, {
  action: xt,
  score: mP,
  threshold: mP,
  type: xt
}), tye = (t, e) => (t || []).filter((r) => r != null).map((r) => eye(r)), nye = (t, e) => ot(t, {
  filters: (n) => tye(n)
}), rye = (t, e) => t.image != null ? {
  image: sye(t.image, e)
} : t.text != null ? {
  text: ut(t.text)
} : { $unknown: Object.entries(t)[0] }, sye = (t, e) => ot(t, {
  format: xt,
  source: (n) => iye(ya(n), e)
}), iye = (t, e) => t.bytes != null ? {
  bytes: e.base64Decoder(t.bytes)
} : { $unknown: Object.entries(t)[0] }, Ij = (t, e) => ot(t, {
  inputAssessment: (n) => Q0e(n),
  modelOutput: ut,
  outputAssessments: (n) => X0e(n)
}), Pj = (t, e) => ot(t, {
  format: xt,
  source: (n) => oye(ya(n), e)
}), oye = (t, e) => t.bytes != null ? {
  bytes: e.base64Decoder(t.bytes)
} : { $unknown: Object.entries(t)[0] }, aye = (t, e) => ot(t, {
  content: (n) => V0e(n, e),
  role: xt
}), lye = (t, e) => ot(t, {
  additionalModelResponseFields: (n) => Ab(n),
  stopReason: xt
}), cye = (t, e) => ot(t, {
  content: (n) => hye(n, e),
  status: xt,
  toolUseId: xt
}), uye = (t, e) => t.document != null ? {
  document: Aj(t.document, e)
} : t.image != null ? {
  image: Pj(t.image, e)
} : t.json != null ? {
  json: Ab(t.json)
} : xt(t.text) !== void 0 ? { text: xt(t.text) } : t.video != null ? {
  video: Oj(t.video, e)
} : { $unknown: Object.entries(t)[0] }, hye = (t, e) => (t || []).filter((r) => r != null).map((r) => uye(ya(r), e)), dye = (t, e) => ot(t, {
  input: (n) => Ab(n),
  name: xt,
  toolUseId: xt
}), Oj = (t, e) => ot(t, {
  format: xt,
  source: (n) => fye(ya(n), e)
}), fye = (t, e) => t.bytes != null ? {
  bytes: e.base64Decoder(t.bytes)
} : t.s3Location != null ? {
  s3Location: ut(t.s3Location)
} : { $unknown: Object.entries(t)[0] }, Ab = (t, e) => t, rr = (t) => ({
  httpStatusCode: t.statusCode,
  requestId: t.headers["x-amzn-requestid"] ?? t.headers["x-amzn-request-id"] ?? t.headers["x-amz-request-id"],
  extendedRequestId: t.headers["x-amz-id-2"],
  cfId: t.headers["x-amz-cf-id"]
}), XP = "accept", Dj = "contentType", Nj = "content-type", pye = "guardrailIdentifier", mye = "guardrailVersion", Lj = "performanceConfigLatency", gye = "trace", yye = "x-amzn-bedrock-guardrailidentifier", bye = "x-amzn-bedrock-guardrailversion", Mj = "x-amzn-bedrock-performanceconfig-latency", _ye = "x-amzn-bedrock-trace";
class vye extends Cb.classBuilder().ep(zC).m(function(e, n, r, s) {
  return [
    LC(r, this.serialize, this.deserialize),
    jC(r, e.getEndpointParameterInstructions())
  ];
}).s("AmazonBedrockFrontendService", "Converse", {}).n("BedrockRuntimeClient", "ConverseCommand").f(Kge, Zge).ser(t0e).de(s0e).build() {
}
class wye extends Cb.classBuilder().ep(zC).m(function(e, n, r, s) {
  return [
    LC(r, this.serialize, this.deserialize),
    jC(r, e.getEndpointParameterInstructions())
  ];
}).s("AmazonBedrockFrontendService", "ConverseStream", {
  eventStream: {
    output: !0
  }
}).n("BedrockRuntimeClient", "ConverseStreamCommand").f(Jge, Xge).ser(n0e).de(i0e).build() {
}
class Eye extends Cb.classBuilder().ep(zC).m(function(e, n, r, s) {
  return [
    LC(r, this.serialize, this.deserialize),
    jC(r, e.getEndpointParameterInstructions())
  ];
}).s("AmazonBedrockFrontendService", "InvokeModel", {}).n("BedrockRuntimeClient", "InvokeModelCommand").f(Qge, e0e).ser(r0e).de(o0e).build() {
}
function Sye(t) {
  var e;
  const n = (e = t.tools) != null && e.length ? t.tools : void 0;
  if (n == null)
    return {
      toolConfig: { tools: void 0, toolChoice: void 0 },
      toolWarnings: []
    };
  const r = [], s = [];
  for (const a of n)
    a.type === "provider-defined" ? r.push({ type: "unsupported-tool", tool: a }) : s.push({
      toolSpec: {
        name: a.name,
        description: a.description,
        inputSchema: {
          json: a.parameters
        }
      }
    });
  const i = t.toolChoice;
  if (i == null)
    return {
      toolConfig: { tools: s, toolChoice: void 0 },
      toolWarnings: r
    };
  const o = i.type;
  switch (o) {
    case "auto":
      return {
        toolConfig: { tools: s, toolChoice: { auto: {} } },
        toolWarnings: r
      };
    case "required":
      return {
        toolConfig: { tools: s, toolChoice: { any: {} } },
        toolWarnings: r
      };
    case "none":
      return {
        toolConfig: { tools: void 0, toolChoice: void 0 },
        toolWarnings: r
      };
    case "tool":
      return {
        toolConfig: {
          tools: s,
          toolChoice: { tool: { name: i.toolName } }
        },
        toolWarnings: r
      };
    default: {
      const a = o;
      throw new Wh({
        functionality: `Unsupported tool choice type: ${a}`
      });
    }
  }
}
var xye = SU({ prefix: "file", size: 16 });
function Tye(t) {
  var e, n, r, s, i;
  const o = Cye(t);
  let a;
  const l = [];
  for (let c = 0; c < o.length; c++) {
    const u = o[c], h = c === o.length - 1, d = u.type;
    switch (d) {
      case "system": {
        if (l.length > 0)
          throw new Wh({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        a = u.messages.map(({ content: f }) => f).join(`
`);
        break;
      }
      case "user": {
        const f = [];
        for (const g of u.messages) {
          const { role: y, content: p } = g;
          switch (y) {
            case "user": {
              for (let m = 0; m < p.length; m++) {
                const b = p[m];
                switch (b.type) {
                  case "text": {
                    f.push({
                      text: b.text
                    });
                    break;
                  }
                  case "image": {
                    if (b.image instanceof URL)
                      throw new Wh({
                        functionality: "Image URLs in user messages"
                      });
                    f.push({
                      image: {
                        format: (n = (e = b.mimeType) == null ? void 0 : e.split("/")) == null ? void 0 : n[1],
                        source: {
                          bytes: (r = b.image) != null ? r : b.image
                        }
                      }
                    });
                    break;
                  }
                  case "file": {
                    if (b.data instanceof URL)
                      throw new Wh({
                        functionality: "File URLs in user messages"
                      });
                    f.push({
                      document: {
                        format: (i = (s = b.mimeType) == null ? void 0 : s.split(
                          "/"
                        )) == null ? void 0 : i[1],
                        name: xye(),
                        source: {
                          bytes: Me.from(b.data, "base64")
                        }
                      }
                    });
                    break;
                  }
                }
              }
              break;
            }
            case "tool": {
              for (let m = 0; m < p.length; m++) {
                const b = p[m];
                f.push({
                  toolResult: {
                    toolUseId: b.toolCallId,
                    content: [{ text: JSON.stringify(b.result) }]
                  }
                });
              }
              break;
            }
            default: {
              const m = y;
              throw new Error(`Unsupported role: ${m}`);
            }
          }
        }
        l.push({ role: "user", content: f });
        break;
      }
      case "assistant": {
        const f = [];
        for (let g = 0; g < u.messages.length; g++) {
          const y = u.messages[g], p = g === u.messages.length - 1, { content: m } = y;
          for (let b = 0; b < m.length; b++) {
            const _ = m[b], v = b === m.length - 1;
            switch (_.type) {
              case "text": {
                f.push({
                  text: (
                    // trim the last text part if it's the last message in the block
                    // because Bedrock does not allow trailing whitespace
                    // in pre-filled assistant responses
                    h && p && v ? _.text.trim() : _.text
                  )
                });
                break;
              }
              case "tool-call": {
                f.push({
                  toolUse: {
                    toolUseId: _.toolCallId,
                    name: _.toolName,
                    input: _.args
                  }
                });
                break;
              }
            }
          }
        }
        l.push({ role: "assistant", content: f });
        break;
      }
      default: {
        const f = d;
        throw new Error(`Unsupported type: ${f}`);
      }
    }
  }
  return {
    system: a,
    messages: l
  };
}
function Cye(t) {
  const e = [];
  let n;
  for (const r of t) {
    const { role: s } = r;
    switch (s) {
      case "system": {
        n?.type !== "system" && (n = { type: "system", messages: [] }, e.push(n)), n.messages.push(r);
        break;
      }
      case "assistant": {
        n?.type !== "assistant" && (n = { type: "assistant", messages: [] }, e.push(n)), n.messages.push(r);
        break;
      }
      case "user": {
        n?.type !== "user" && (n = { type: "user", messages: [] }, e.push(n)), n.messages.push(r);
        break;
      }
      case "tool": {
        n?.type !== "user" && (n = { type: "user", messages: [] }, e.push(n)), n.messages.push(r);
        break;
      }
      default: {
        const i = s;
        throw new Error(`Unsupported role: ${i}`);
      }
    }
  }
  return e;
}
function QP(t) {
  switch (t) {
    case "stop_sequence":
    case "end_turn":
      return "stop";
    case "max_tokens":
      return "length";
    case "content_filtered":
    case "guardrail_intervened":
      return "content-filter";
    case "tool_use":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var kye = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.provider = "amazon-bedrock", this.defaultObjectGenerationMode = "tool", this.supportsImageUrls = !1, this.modelId = t, this.settings = e, this.config = n;
  }
  getArgs({
    mode: t,
    prompt: e,
    maxTokens: n,
    temperature: r,
    topP: s,
    topK: i,
    frequencyPenalty: o,
    presencePenalty: a,
    stopSequences: l,
    responseFormat: c,
    seed: u,
    providerMetadata: h,
    headers: d
  }) {
    var f, g;
    const y = t.type, p = [];
    o != null && p.push({
      type: "unsupported-setting",
      setting: "frequencyPenalty"
    }), a != null && p.push({
      type: "unsupported-setting",
      setting: "presencePenalty"
    }), u != null && p.push({
      type: "unsupported-setting",
      setting: "seed"
    }), d != null && p.push({
      type: "unsupported-setting",
      setting: "headers"
    }), i != null && p.push({
      type: "unsupported-setting",
      setting: "topK"
    }), c != null && c.type !== "text" && p.push({
      type: "unsupported-setting",
      setting: "responseFormat",
      details: "JSON response format is not supported."
    });
    const { system: m, messages: b } = Tye(e), _ = {
      modelId: this.modelId,
      system: m ? [{ text: m }] : void 0,
      additionalModelRequestFields: this.settings.additionalModelRequestFields,
      inferenceConfig: {
        maxTokens: n,
        temperature: r,
        topP: s,
        stopSequences: l
      },
      messages: b,
      guardrailConfig: (f = h?.bedrock) == null ? void 0 : f.guardrailConfig
    };
    switch (y) {
      case "regular": {
        const { toolConfig: v, toolWarnings: w } = Sye(t);
        return {
          command: {
            ..._,
            ...(g = v.tools) != null && g.length ? { toolConfig: v } : {}
          },
          warnings: [...p, ...w]
        };
      }
      case "object-json":
        throw new Wh({
          functionality: "json-mode object generation"
        });
      case "object-tool":
        return {
          command: {
            ..._,
            toolConfig: {
              tools: [
                {
                  toolSpec: {
                    name: t.tool.name,
                    description: t.tool.description,
                    inputSchema: {
                      json: t.tool.parameters
                    }
                  }
                }
              ],
              toolChoice: { tool: { name: t.tool.name } }
            }
          },
          warnings: p
        };
      default: {
        const v = y;
        throw new Error(`Unsupported type: ${v}`);
      }
    }
  }
  async doGenerate(t) {
    var e, n, r, s, i, o, a, l, c, u, h, d;
    const { command: f, warnings: g } = this.getArgs(t), y = await this.config.client.send(
      new vye(f)
    ), { messages: p, ...m } = f, b = y.trace ? { bedrock: { trace: y.trace } } : void 0;
    return {
      text: (s = (r = (n = (e = y.output) == null ? void 0 : e.message) == null ? void 0 : n.content) == null ? void 0 : r.map((_) => {
        var v;
        return (v = _.text) != null ? v : "";
      }).join("")) != null ? s : void 0,
      toolCalls: (l = (a = (o = (i = y.output) == null ? void 0 : i.message) == null ? void 0 : o.content) == null ? void 0 : a.filter((_) => !!_.toolUse)) == null ? void 0 : l.map((_) => {
        var v, w, E, x, S, T;
        return {
          toolCallType: "function",
          toolCallId: (w = (v = _.toolUse) == null ? void 0 : v.toolUseId) != null ? w : this.config.generateId(),
          toolName: (x = (E = _.toolUse) == null ? void 0 : E.name) != null ? x : `tool-${this.config.generateId()}`,
          args: JSON.stringify((T = (S = _.toolUse) == null ? void 0 : S.input) != null ? T : "")
        };
      }),
      finishReason: QP(y.stopReason),
      usage: {
        promptTokens: (u = (c = y.usage) == null ? void 0 : c.inputTokens) != null ? u : Number.NaN,
        completionTokens: (d = (h = y.usage) == null ? void 0 : h.outputTokens) != null ? d : Number.NaN
      },
      rawCall: { rawPrompt: p, rawSettings: m },
      warnings: g,
      providerMetadata: b
    };
  }
  async doStream(t) {
    const { command: e, warnings: n } = this.getArgs(t), r = await this.config.client.send(
      new wye(e)
    ), { messages: s, ...i } = e;
    let o = "unknown", a = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    }, l;
    if (!r.stream)
      throw new Error("No stream found");
    const c = new ReadableStream({
      async start(h) {
        for await (const d of r.stream)
          h.enqueue({ success: !0, value: d });
        h.close();
      }
    }), u = {};
    return {
      stream: c.pipeThrough(
        new TransformStream({
          transform(h, d) {
            var f, g, y, p, m, b, _, v, w;
            function E(F) {
              o = "error", d.enqueue({ type: "error", error: F });
            }
            if (!h.success) {
              E(h.error);
              return;
            }
            const x = h.value;
            if (x.internalServerException) {
              E(x.internalServerException);
              return;
            }
            if (x.modelStreamErrorException) {
              E(x.modelStreamErrorException);
              return;
            }
            if (x.throttlingException) {
              E(x.throttlingException);
              return;
            }
            if (x.validationException) {
              E(x.validationException);
              return;
            }
            x.messageStop && (o = QP(
              x.messageStop.stopReason
            )), x.metadata && (a = {
              promptTokens: (g = (f = x.metadata.usage) == null ? void 0 : f.inputTokens) != null ? g : Number.NaN,
              completionTokens: (p = (y = x.metadata.usage) == null ? void 0 : y.outputTokens) != null ? p : Number.NaN
            }, x.metadata.trace && (l = {
              bedrock: {
                trace: x.metadata.trace
              }
            })), (b = (m = x.contentBlockDelta) == null ? void 0 : m.delta) != null && b.text && d.enqueue({
              type: "text-delta",
              textDelta: x.contentBlockDelta.delta.text
            });
            const S = x.contentBlockStart;
            if (((_ = S?.start) == null ? void 0 : _.toolUse) != null) {
              const F = S.start.toolUse;
              u[S.contentBlockIndex] = {
                toolCallId: F.toolUseId,
                toolName: F.name,
                jsonText: ""
              };
            }
            const T = x.contentBlockDelta;
            if ((v = T?.delta) != null && v.toolUse) {
              const F = u[T.contentBlockIndex], P = (w = T.delta.toolUse.input) != null ? w : "";
              d.enqueue({
                type: "tool-call-delta",
                toolCallType: "function",
                toolCallId: F.toolCallId,
                toolName: F.toolName,
                argsTextDelta: P
              }), F.jsonText += P;
            }
            const R = x.contentBlockStop;
            if (R != null) {
              const F = R.contentBlockIndex, P = u[F];
              P != null && (d.enqueue({
                type: "tool-call",
                toolCallType: "function",
                toolCallId: P.toolCallId,
                toolName: P.toolName,
                args: P.jsonText
              }), delete u[F]);
            }
          },
          flush(h) {
            h.enqueue({
              type: "finish",
              finishReason: o,
              usage: a,
              providerMetadata: l
            });
          }
        })
      ),
      rawCall: { rawPrompt: s, rawSettings: i },
      warnings: n
    };
  }
}, Aye = class {
  constructor(t, e, n) {
    this.specificationVersion = "v1", this.provider = "amazon-bedrock", this.maxEmbeddingsPerCall = void 0, this.supportsParallelCalls = !0, this.modelId = t, this.config = n, this.settings = e;
  }
  async doEmbed({
    values: t
  }) {
    const e = async (s) => {
      const i = {
        inputText: s,
        dimensions: this.settings.dimensions,
        normalize: this.settings.normalize
      }, o = new Eye({
        contentType: "application/json",
        body: JSON.stringify(i),
        modelId: this.modelId
      }), a = await this.config.client.send(o);
      return JSON.parse(new TextDecoder().decode(a.body));
    };
    return (await Promise.all(t.map(e))).reduce(
      (s, i) => (s.embeddings.push(i.embedding), s.usage.tokens += i.inputTextTokenCount, s),
      { embeddings: [], usage: { tokens: 0 } }
    );
  }
};
function Bj(t = {}) {
  const e = () => {
    var i;
    return new Wge(
      (i = t.bedrockOptions) != null ? i : {
        region: xv({
          settingValue: t.region,
          settingName: "region",
          environmentVariableName: "AWS_REGION",
          description: "AWS region"
        }),
        credentials: {
          accessKeyId: xv({
            settingValue: t.accessKeyId,
            settingName: "accessKeyId",
            environmentVariableName: "AWS_ACCESS_KEY_ID",
            description: "AWS access key ID"
          }),
          secretAccessKey: xv({
            settingValue: t.secretAccessKey,
            settingName: "secretAccessKey",
            environmentVariableName: "AWS_SECRET_ACCESS_KEY",
            description: "AWS secret access key"
          }),
          sessionToken: Qhe({
            settingValue: t.sessionToken,
            environmentVariableName: "AWS_SESSION_TOKEN"
          })
        }
      }
    );
  }, n = (i, o = {}) => new kye(i, o, {
    client: e(),
    generateId: Xhe
  }), r = function(i, o) {
    if (new.target)
      throw new Error(
        "The Amazon Bedrock model function cannot be called with the new keyword."
      );
    return n(i, o);
  }, s = (i, o = {}) => new Aye(i, o, {
    client: e()
  });
  return r.languageModel = n, r.embedding = s, r.textEmbedding = s, r.textEmbeddingModel = s, r;
}
Bj();
class Rye extends mn {
  name = "AmazonBedrock";
  getApiKeyLink = "https://console.aws.amazon.com/iam/home";
  config = {
    apiTokenKey: "AWS_BEDROCK_CONFIG"
  };
  staticModels = [
    {
      name: "anthropic.claude-3-5-sonnet-20240620-v1:0",
      label: "Claude 3.5 Sonnet (Bedrock)",
      provider: "AmazonBedrock",
      maxTokenAllowed: 4096
    },
    {
      name: "anthropic.claude-3-sonnet-20240229-v1:0",
      label: "Claude 3 Sonnet (Bedrock)",
      provider: "AmazonBedrock",
      maxTokenAllowed: 4096
    },
    {
      name: "anthropic.claude-3-haiku-20240307-v1:0",
      label: "Claude 3 Haiku (Bedrock)",
      provider: "AmazonBedrock",
      maxTokenAllowed: 4096
    },
    {
      name: "amazon.nova-pro-v1:0",
      label: "Amazon Nova Pro (Bedrock)",
      provider: "AmazonBedrock",
      maxTokenAllowed: 5120
    },
    {
      name: "amazon.nova-lite-v1:0",
      label: "Amazon Nova Lite (Bedrock)",
      provider: "AmazonBedrock",
      maxTokenAllowed: 5120
    },
    {
      name: "mistral.mistral-large-2402-v1:0",
      label: "Mistral Large 24.02 (Bedrock)",
      provider: "AmazonBedrock",
      maxTokenAllowed: 8192
    }
  ];
  _parseAndValidateConfig(e) {
    let n;
    try {
      n = JSON.parse(e);
    } catch {
      throw new Error(
        "Invalid AWS Bedrock configuration format. Please provide a valid JSON string containing region, accessKeyId, and secretAccessKey."
      );
    }
    const { region: r, accessKeyId: s, secretAccessKey: i, sessionToken: o } = n;
    if (!r || !s || !i)
      throw new Error(
        "Missing required AWS credentials. Configuration must include region, accessKeyId, and secretAccessKey."
      );
    return {
      region: r,
      accessKeyId: s,
      secretAccessKey: i,
      ...o && { sessionToken: o }
    };
  }
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "AWS_BEDROCK_CONFIG"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    const a = this._parseAndValidateConfig(o);
    return Bj(a)(n);
  }
}
class Iye extends mn {
  name = "Github";
  getApiKeyLink = "https://github.com/settings/personal-access-tokens";
  config = {
    apiTokenKey: "GITHUB_API_KEY"
  };
  // find more in https://github.com/marketplace?type=models
  staticModels = [
    { name: "gpt-4o", label: "GPT-4o", provider: "Github", maxTokenAllowed: 8e3 },
    { name: "o1", label: "o1-preview", provider: "Github", maxTokenAllowed: 1e5 },
    { name: "o1-mini", label: "o1-mini", provider: "Github", maxTokenAllowed: 8e3 },
    { name: "gpt-4o-mini", label: "GPT-4o Mini", provider: "Github", maxTokenAllowed: 8e3 },
    { name: "gpt-4-turbo", label: "GPT-4 Turbo", provider: "Github", maxTokenAllowed: 8e3 },
    { name: "gpt-4", label: "GPT-4", provider: "Github", maxTokenAllowed: 8e3 },
    { name: "gpt-3.5-turbo", label: "GPT-3.5 Turbo", provider: "Github", maxTokenAllowed: 8e3 }
  ];
  getModelInstance(e) {
    const { model: n, serverEnv: r, apiKeys: s, providerSettings: i } = e, { apiKey: o } = this.getProviderBaseUrlAndKey({
      apiKeys: s,
      providerSettings: i?.[this.name],
      serverEnv: r,
      defaultBaseUrlKey: "",
      defaultApiTokenKey: "GITHUB_API_KEY"
    });
    if (!o)
      throw new Error(`Missing API key for ${this.name} provider`);
    return Pi({
      baseURL: "https://models.inference.ai.azure.com",
      apiKey: o
    })(n);
  }
}
const Pye = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AmazonBedrockProvider: Rye,
  AnthropicProvider: iae,
  CohereProvider: Hae,
  DeepseekProvider: zle,
  GithubProvider: Iye,
  GoogleProvider: Pce,
  GroqProvider: Oce,
  HuggingFaceProvider: Dce,
  HyperbolicProvider: Vhe,
  LMStudioProvider: Nce,
  MistralProvider: Eue,
  OllamaProvider: uhe,
  OpenAILikeProvider: Uhe,
  OpenAIProvider: jhe,
  OpenRouterProvider: $he,
  PerplexityProvider: Hhe,
  TogetherProvider: zhe,
  XAIProvider: Ghe
}, Symbol.toStringTag, { value: "Module" })), $s = Sr("LLMManager");
class Ha {
  static _instance;
  _providers = /* @__PURE__ */ new Map();
  _modelList = [];
  _env = {};
  constructor(e) {
    this._registerProvidersFromDirectory(), this._env = e;
  }
  static getInstance(e = {}) {
    return Ha._instance || (Ha._instance = new Ha(e)), Ha._instance;
  }
  get env() {
    return this._env;
  }
  async _registerProvidersFromDirectory() {
    try {
      for (const e of Object.values(Pye))
        if (typeof e == "function" && e.prototype instanceof mn) {
          const n = new e();
          try {
            this.registerProvider(n);
          } catch (r) {
            $s.warn("Failed To Register Provider: ", n.name, "error:", r.message);
          }
        }
    } catch (e) {
      $s.error("Error registering providers:", e);
    }
  }
  registerProvider(e) {
    if (this._providers.has(e.name)) {
      $s.warn(`Provider ${e.name} is already registered. Skipping.`);
      return;
    }
    $s.info("Registering Provider: ", e.name), this._providers.set(e.name, e), this._modelList = [...this._modelList, ...e.staticModels];
  }
  getProvider(e) {
    return this._providers.get(e);
  }
  getAllProviders() {
    return Array.from(this._providers.values());
  }
  getModelList() {
    return this._modelList;
  }
  async updateModelList(e) {
    const { apiKeys: n, providerSettings: r, serverEnv: s } = e;
    let i = Array.from(this._providers.values()).map((d) => d.name);
    r && Object.keys(r).length > 0 && (i = i.filter((d) => r[d].enabled));
    const o = await Promise.all(
      Array.from(this._providers.values()).filter((d) => i.includes(d.name)).filter(
        (d) => !!d.getDynamicModels
      ).map(async (d) => {
        const f = d.getModelsFromCache(e);
        return f || await d.getDynamicModels(n, r?.[d.name], s).then((y) => ($s.info(`Caching ${y.length} dynamic models for ${d.name}`), d.storeDynamicModels(e, y), y)).catch((y) => ($s.error(`Error getting dynamic models ${d.name} :`, y), []));
      })
    ), a = Array.from(this._providers.values()).flatMap((d) => d.staticModels || []), l = o.flat(), c = l.map((d) => `${d.name}-${d.provider}`), u = a.filter((d) => !c.includes(`${d.name}-${d.provider}`)), h = [...l, ...u];
    return h.sort((d, f) => d.name.localeCompare(f.name)), this._modelList = h, h;
  }
  getStaticModelList() {
    return [...this._providers.values()].flatMap((e) => e.staticModels || []);
  }
  async getModelListFromProvider(e, n) {
    const r = this._providers.get(e.name);
    if (!r)
      throw new Error(`Provider ${e.name} not found`);
    const s = r.staticModels || [];
    if (!r.getDynamicModels)
      return s;
    const { apiKeys: i, providerSettings: o, serverEnv: a } = n, l = r.getModelsFromCache({
      apiKeys: i,
      providerSettings: o,
      serverEnv: a
    });
    if (l)
      return $s.info(`Found ${l.length} cached models for ${r.name}`), [...l, ...s];
    $s.info(`Getting dynamic models for ${r.name}`);
    const c = await r.getDynamicModels?.(i, o?.[r.name], a).then((f) => ($s.info(`Got ${f.length} dynamic models for ${r.name}`), r.storeDynamicModels(n, f), f)).catch((f) => ($s.error(`Error getting dynamic models ${r.name} :`, f), [])), u = c.map((f) => f.name), h = s.filter((f) => !u.includes(f.name)), d = [...c, ...h];
    return d.sort((f, g) => f.name.localeCompare(g.name)), d;
  }
  getStaticModelListFromProvider(e) {
    const n = this._providers.get(e.name);
    if (!n)
      throw new Error(`Provider ${e.name} not found`);
    return [...n.staticModels || []];
  }
  getDefaultProvider() {
    const e = this._providers.values().next().value;
    if (!e)
      throw new Error("No providers registered");
    return e;
  }
}
const Oye = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1, VITE_USER_NODE_ENV: "production" }, Fj = "project", ia = `/home/${Fj}`, Dye = /^\[Model: (.*?)\]\n\n/, Nye = /\[Provider: (.*?)\]\n\n/, Lye = "claude-3-5-sonnet-latest", Dv = "cachedPrompt", $j = Ha.getInstance(Oye), Rb = $j.getAllProviders(), Mye = $j.getDefaultProvider(), Bye = {};
Rb.forEach((t) => {
  Bye[t.name] = {
    baseUrlKey: t.config.baseUrlKey,
    apiTokenKey: t.config.apiTokenKey
  };
});
const Uj = [
  {
    name: "bolt-astro-basic",
    label: "Astro Basic",
    description: "Lightweight Astro starter template for building fast static websites",
    githubRepo: "thecodacus/bolt-astro-basic-template",
    tags: ["astro", "blog", "performance"],
    icon: "i-bolt:astro"
  },
  {
    name: "bolt-nextjs-shadcn",
    label: "Next.js with shadcn/ui",
    description: "Next.js starter fullstack template integrated with shadcn/ui components and styling system",
    githubRepo: "thecodacus/bolt-nextjs-shadcn-template",
    tags: ["nextjs", "react", "typescript", "shadcn", "tailwind"],
    icon: "i-bolt:nextjs"
  },
  {
    name: "bolt-qwik-ts",
    label: "Qwik TypeScript",
    description: "Qwik framework starter with TypeScript for building resumable applications",
    githubRepo: "thecodacus/bolt-qwik-ts-template",
    tags: ["qwik", "typescript", "performance", "resumable"],
    icon: "i-bolt:qwik"
  },
  {
    name: "bolt-remix-ts",
    label: "Remix TypeScript",
    description: "Remix framework starter with TypeScript for full-stack web applications",
    githubRepo: "thecodacus/bolt-remix-ts-template",
    tags: ["remix", "typescript", "fullstack", "react"],
    icon: "i-bolt:remix"
  },
  {
    name: "bolt-slidev",
    label: "Slidev Presentation",
    description: "Slidev starter template for creating developer-friendly presentations using Markdown",
    githubRepo: "thecodacus/bolt-slidev-template",
    tags: ["slidev", "presentation", "markdown"],
    icon: "i-bolt:slidev"
  },
  {
    name: "bolt-sveltekit",
    label: "SvelteKit",
    description: "SvelteKit starter template for building fast, efficient web applications",
    githubRepo: "bolt-sveltekit-template",
    tags: ["svelte", "sveltekit", "typescript"],
    icon: "i-bolt:svelte"
  },
  {
    name: "vanilla-vite",
    label: "Vanilla + Vite",
    description: "Minimal Vite starter template for vanilla JavaScript projects",
    githubRepo: "thecodacus/vanilla-vite-template",
    tags: ["vite", "vanilla-js", "minimal"],
    icon: "i-bolt:vite"
  },
  {
    name: "bolt-vite-react",
    label: "React + Vite + typescript",
    description: "React starter template powered by Vite for fast development experience",
    githubRepo: "thecodacus/bolt-vite-react-ts-template",
    tags: ["react", "vite", "frontend"],
    icon: "i-bolt:react"
  },
  {
    name: "bolt-vite-ts",
    label: "Vite + TypeScript",
    description: "Vite starter template with TypeScript configuration for type-safe development",
    githubRepo: "thecodacus/bolt-vite-ts-template",
    tags: ["vite", "typescript", "minimal"],
    icon: "i-bolt:typescript"
  },
  {
    name: "bolt-vue",
    label: "Vue.js",
    description: "Vue.js starter template with modern tooling and best practices",
    githubRepo: "thecodacus/bolt-vue-template",
    tags: ["vue", "typescript", "frontend"],
    icon: "i-bolt:vue"
  },
  {
    name: "bolt-angular",
    label: "Angular Starter",
    description: "A modern Angular starter template with TypeScript support and best practices configuration",
    githubRepo: "thecodacus/bolt-angular-template",
    tags: ["angular", "typescript", "frontend", "spa"],
    icon: "i-bolt:angular"
  }
];
function Fye(t) {
  const e = (n) => {
    if (!/^https?:\/\/[^\/]+\.webcontainer-api\.io(\/.*)?$/.test(n))
      return n;
    const s = /^https?:\/\/[^\/]+\.webcontainer-api\.io\/(.*?)$/;
    return n.match(s)?.[1] || "";
  };
  return t.split(`
`).map((n) => n.replace(/(https?:\/\/[^\/]+\.webcontainer-api\.io\/[^\s\)]+)/g, (r) => e(r))).join(`
`);
}
let La = new Promise(() => {
});
La = Promise.resolve().then(() => ja.boot({
  coep: "credentialless",
  workdirName: Fj,
  forwardPreviewErrors: !0
  // Enable error forwarding from iframes
})).then(async (t) => {
  const { workbenchStore: e } = await Promise.resolve().then(() => k_e);
  return t.on("preview-message", (n) => {
    if (console.log("WebContainer preview message:", n), n.type === "PREVIEW_UNCAUGHT_EXCEPTION" || n.type === "PREVIEW_UNHANDLED_REJECTION") {
      const r = n.type === "PREVIEW_UNHANDLED_REJECTION";
      e.actionAlert.set({
        type: "preview",
        title: r ? "Unhandled Promise Rejection" : "Uncaught Exception",
        description: n.message,
        content: `Error occurred at ${n.pathname}${n.search}${n.hash}
Port: ${n.port}

Stack trace:
${Fye(n.stack || "")}`,
        source: "preview"
      });
    }
  }), t;
});
class $ye {
  #t;
  selectedFile = nn();
  documents = Ol({});
  currentDocument = MT([this.documents, this.selectedFile], (e, n) => {
    if (n)
      return e[n];
  });
  constructor(e) {
    this.#t = e;
  }
  setDocuments(e) {
    const n = this.documents.value;
    this.documents.set(
      Object.fromEntries(
        Object.entries(e).map(([r, s]) => {
          if (s === void 0 || s.type === "folder")
            return;
          const i = n?.[r];
          return [
            r,
            {
              value: s.content,
              filePath: r,
              scroll: i?.scroll
            }
          ];
        }).filter(Boolean)
      )
    );
  }
  setSelectedFile(e) {
    this.selectedFile.set(e);
  }
  updateScrollPosition(e, n) {
    const s = this.documents.get()[e];
    s && this.documents.setKey(e, {
      ...s,
      scroll: n
    });
  }
  updateFile(e, n) {
    const s = this.documents.get()[e];
    if (!s)
      return;
    s.value !== n && this.documents.setKey(e, {
      ...s,
      value: n
    });
  }
}
function bg(t, e) {
  if (!t)
    return null;
  const n = "utf8", r = "binary", s = e?.chunkLength ?? 24;
  let i = e?.chunkBegin ?? 0;
  if (e?.chunkBegin == null) {
    let o = bg(t, { chunkLength: s, chunkBegin: i });
    return o === n && (i = Math.max(0, Math.floor(t.length / 2) - s), o = bg(t, {
      chunkLength: s,
      chunkBegin: i
    }), o === n && (i = Math.max(0, t.length - s), o = bg(t, {
      chunkLength: s,
      chunkBegin: i
    }))), o;
  } else {
    if (i = Uye(t, i), i === -1)
      return r;
    const o = jye(t, Math.min(t.length, i + s));
    if (o > t.length)
      return r;
    const a = t.toString(n, i, o);
    for (let l = 0; l < a.length; ++l) {
      const c = a.charCodeAt(l);
      if (c === 65533 || c <= 8)
        return r;
    }
    return n;
  }
}
function Uye(t, e) {
  if (e === 0)
    return 0;
  if (!Hye(t[e]))
    return e;
  let n = e - 3;
  return n >= 0 && Oc(t[n]) || (n = e - 2, n >= 0 && (Oc(t[n]) || $0(t[n]))) || (n = e - 1, n >= 0 && (Oc(t[n]) || $0(t[n]) || jj(t[n]))) ? n : -1;
}
function jye(t, e) {
  if (e === t.length)
    return e;
  let n = e - 3;
  if (n >= 0 && Oc(t[n]))
    return e + 1;
  if (n = e - 2, n >= 0) {
    if (Oc(t[n]))
      return e + 2;
    if ($0(t[n]))
      return e + 1;
  }
  if (n = e - 1, n >= 0) {
    if (Oc(t[n]))
      return e + 3;
    if ($0(t[n]))
      return e + 2;
    if (jj(t[n]))
      return e + 1;
  }
  return e;
}
function Oc(t) {
  return t >> 3 === 30;
}
function $0(t) {
  return t >> 4 === 14;
}
function jj(t) {
  return t >> 5 === 6;
}
function Hye(t) {
  return t >> 6 === 2;
}
function zye(t, e) {
  let n, r = [], s = Promise.resolve();
  const i = () => {
    n = self.setTimeout(async () => {
      await s, r.length > 0 && (s = Promise.resolve(e(r))), n = void 0, r = [];
    }, t);
  };
  return (...o) => {
    r.push(o), n || i();
  };
}
function ba() {
}
ba.prototype = {
  diff: function(e, n) {
    var r, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = s.callback;
    typeof s == "function" && (i = s, s = {}), this.options = s;
    var o = this;
    function a(v) {
      return i ? (setTimeout(function() {
        i(void 0, v);
      }, 0), !0) : v;
    }
    e = this.castInput(e), n = this.castInput(n), e = this.removeEmpty(this.tokenize(e)), n = this.removeEmpty(this.tokenize(n));
    var l = n.length, c = e.length, u = 1, h = l + c;
    s.maxEditLength && (h = Math.min(h, s.maxEditLength));
    var d = (r = s.timeout) !== null && r !== void 0 ? r : 1 / 0, f = Date.now() + d, g = [{
      oldPos: -1,
      lastComponent: void 0
    }], y = this.extractCommon(g[0], n, e, 0);
    if (g[0].oldPos + 1 >= c && y + 1 >= l)
      return a([{
        value: this.join(n),
        count: n.length
      }]);
    var p = -1 / 0, m = 1 / 0;
    function b() {
      for (var v = Math.max(p, -u); v <= Math.min(m, u); v += 2) {
        var w = void 0, E = g[v - 1], x = g[v + 1];
        E && (g[v - 1] = void 0);
        var S = !1;
        if (x) {
          var T = x.oldPos - v;
          S = x && 0 <= T && T < l;
        }
        var R = E && E.oldPos + 1 < c;
        if (!S && !R) {
          g[v] = void 0;
          continue;
        }
        if (!R || S && E.oldPos + 1 < x.oldPos ? w = o.addToPath(x, !0, void 0, 0) : w = o.addToPath(E, void 0, !0, 1), y = o.extractCommon(w, n, e, v), w.oldPos + 1 >= c && y + 1 >= l)
          return a(Gye(o, w.lastComponent, n, e, o.useLongestToken));
        g[v] = w, w.oldPos + 1 >= c && (m = Math.min(m, v - 1)), y + 1 >= l && (p = Math.max(p, v + 1));
      }
      u++;
    }
    if (i)
      (function v() {
        setTimeout(function() {
          if (u > h || Date.now() > f)
            return i();
          b() || v();
        }, 0);
      })();
    else
      for (; u <= h && Date.now() <= f; ) {
        var _ = b();
        if (_)
          return _;
      }
  },
  addToPath: function(e, n, r, s) {
    var i = e.lastComponent;
    return i && i.added === n && i.removed === r ? {
      oldPos: e.oldPos + s,
      lastComponent: {
        count: i.count + 1,
        added: n,
        removed: r,
        previousComponent: i.previousComponent
      }
    } : {
      oldPos: e.oldPos + s,
      lastComponent: {
        count: 1,
        added: n,
        removed: r,
        previousComponent: i
      }
    };
  },
  extractCommon: function(e, n, r, s) {
    for (var i = n.length, o = r.length, a = e.oldPos, l = a - s, c = 0; l + 1 < i && a + 1 < o && this.equals(n[l + 1], r[a + 1]); )
      l++, a++, c++;
    return c && (e.lastComponent = {
      count: c,
      previousComponent: e.lastComponent
    }), e.oldPos = a, l;
  },
  equals: function(e, n) {
    return this.options.comparator ? this.options.comparator(e, n) : e === n || this.options.ignoreCase && e.toLowerCase() === n.toLowerCase();
  },
  removeEmpty: function(e) {
    for (var n = [], r = 0; r < e.length; r++)
      e[r] && n.push(e[r]);
    return n;
  },
  castInput: function(e) {
    return e;
  },
  tokenize: function(e) {
    return e.split("");
  },
  join: function(e) {
    return e.join("");
  }
};
function Gye(t, e, n, r, s) {
  for (var i = [], o; e; )
    i.push(e), o = e.previousComponent, delete e.previousComponent, e = o;
  i.reverse();
  for (var a = 0, l = i.length, c = 0, u = 0; a < l; a++) {
    var h = i[a];
    if (h.removed) {
      if (h.value = t.join(r.slice(u, u + h.count)), u += h.count, a && i[a - 1].added) {
        var f = i[a - 1];
        i[a - 1] = i[a], i[a] = f;
      }
    } else {
      if (!h.added && s) {
        var d = n.slice(c, c + h.count);
        d = d.map(function(y, p) {
          var m = r[u + p];
          return m.length > y.length ? m : y;
        }), h.value = t.join(d);
      } else
        h.value = t.join(n.slice(c, c + h.count));
      c += h.count, h.added || (u += h.count);
    }
  }
  var g = i[l - 1];
  return l > 1 && typeof g.value == "string" && (g.added || g.removed) && t.equals("", g.value) && (i[l - 2].value += g.value, i.pop()), i;
}
var eO = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, tO = /\S/, Hj = new ba();
Hj.equals = function(t, e) {
  return this.options.ignoreCase && (t = t.toLowerCase(), e = e.toLowerCase()), t === e || this.options.ignoreWhitespace && !tO.test(t) && !tO.test(e);
};
Hj.tokenize = function(t) {
  for (var e = t.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n = 0; n < e.length - 1; n++)
    !e[n + 1] && e[n + 2] && eO.test(e[n]) && eO.test(e[n + 2]) && (e[n] += e[n + 2], e.splice(n + 1, 2), n--);
  return e;
};
var ik = new ba();
ik.tokenize = function(t) {
  this.options.stripTrailingCr && (t = t.replace(/\r\n/g, `
`));
  var e = [], n = t.split(/(\n|\r\n)/);
  n[n.length - 1] || n.pop();
  for (var r = 0; r < n.length; r++) {
    var s = n[r];
    r % 2 && !this.options.newlineIsToken ? e[e.length - 1] += s : (this.options.ignoreWhitespace && (s = s.trim()), e.push(s));
  }
  return e;
};
function Vye(t, e, n) {
  return ik.diff(t, e, n);
}
var Wye = new ba();
Wye.tokenize = function(t) {
  return t.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var qye = new ba();
qye.tokenize = function(t) {
  return t.split(/([{}:;,]|\s+)/);
};
function _g(t) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _g = function(e) {
    return typeof e;
  } : _g = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _g(t);
}
function Nv(t) {
  return Kye(t) || Yye(t) || Zye(t) || Jye();
}
function Kye(t) {
  if (Array.isArray(t)) return _S(t);
}
function Yye(t) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(t)) return Array.from(t);
}
function Zye(t, e) {
  if (t) {
    if (typeof t == "string") return _S(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _S(t, e);
  }
}
function _S(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function Jye() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var Xye = Object.prototype.toString, Wd = new ba();
Wd.useLongestToken = !0;
Wd.tokenize = ik.tokenize;
Wd.castInput = function(t) {
  var e = this.options, n = e.undefinedReplacement, r = e.stringifyReplacer, s = r === void 0 ? function(i, o) {
    return typeof o > "u" ? n : o;
  } : r;
  return typeof t == "string" ? t : JSON.stringify(vS(t, null, null, s), s, "  ");
};
Wd.equals = function(t, e) {
  return ba.prototype.equals.call(Wd, t.replace(/,([\r\n])/g, "$1"), e.replace(/,([\r\n])/g, "$1"));
};
function vS(t, e, n, r, s) {
  e = e || [], n = n || [], r && (t = r(s, t));
  var i;
  for (i = 0; i < e.length; i += 1)
    if (e[i] === t)
      return n[i];
  var o;
  if (Xye.call(t) === "[object Array]") {
    for (e.push(t), o = new Array(t.length), n.push(o), i = 0; i < t.length; i += 1)
      o[i] = vS(t[i], e, n, r, s);
    return e.pop(), n.pop(), o;
  }
  if (t && t.toJSON && (t = t.toJSON()), _g(t) === "object" && t !== null) {
    e.push(t), o = {}, n.push(o);
    var a = [], l;
    for (l in t)
      t.hasOwnProperty(l) && a.push(l);
    for (a.sort(), i = 0; i < a.length; i += 1)
      l = a[i], o[l] = vS(t[l], e, n, r, l);
    e.pop(), n.pop();
  } else
    o = t;
  return o;
}
var wS = new ba();
wS.tokenize = function(t) {
  return t.slice();
};
wS.join = wS.removeEmpty = function(t) {
  return t;
};
function Qye(t, e, n, r, s, i, o) {
  o || (o = {}), typeof o.context > "u" && (o.context = 4);
  var a = Vye(n, r, o);
  if (!a)
    return;
  a.push({
    value: "",
    lines: []
  });
  function l(m) {
    return m.map(function(b) {
      return " " + b;
    });
  }
  for (var c = [], u = 0, h = 0, d = [], f = 1, g = 1, y = function(b) {
    var _ = a[b], v = _.lines || _.value.replace(/\n$/, "").split(`
`);
    if (_.lines = v, _.added || _.removed) {
      var w;
      if (!u) {
        var E = a[b - 1];
        u = f, h = g, E && (d = o.context > 0 ? l(E.lines.slice(-o.context)) : [], u -= d.length, h -= d.length);
      }
      (w = d).push.apply(w, Nv(v.map(function(A) {
        return (_.added ? "+" : "-") + A;
      }))), _.added ? g += v.length : f += v.length;
    } else {
      if (u)
        if (v.length <= o.context * 2 && b < a.length - 2) {
          var x;
          (x = d).push.apply(x, Nv(l(v)));
        } else {
          var S, T = Math.min(v.length, o.context);
          (S = d).push.apply(S, Nv(l(v.slice(0, T))));
          var R = {
            oldStart: u,
            oldLines: f - u + T,
            newStart: h,
            newLines: g - h + T,
            lines: d
          };
          if (b >= a.length - 2 && v.length <= o.context) {
            var F = /\n$/.test(n), P = /\n$/.test(r), M = v.length == 0 && d.length > R.oldLines;
            !F && M && n.length > 0 && d.splice(R.oldLines, 0, "\\ No newline at end of file"), (!F && !M || !P) && d.push("\\ No newline at end of file");
          }
          c.push(R), u = 0, h = 0, d = [];
        }
      f += v.length, g += v.length;
    }
  }, p = 0; p < a.length; p++)
    y(p);
  return {
    oldFileName: t,
    newFileName: e,
    oldHeader: s,
    newHeader: i,
    hunks: c
  };
}
function zj(t) {
  if (Array.isArray(t))
    return t.map(zj).join(`
`);
  var e = [];
  t.oldFileName == t.newFileName && e.push("Index: " + t.oldFileName), e.push("==================================================================="), e.push("--- " + t.oldFileName + (typeof t.oldHeader > "u" ? "" : "	" + t.oldHeader)), e.push("+++ " + t.newFileName + (typeof t.newHeader > "u" ? "" : "	" + t.newHeader));
  for (var n = 0; n < t.hunks.length; n++) {
    var r = t.hunks[n];
    r.oldLines === 0 && (r.oldStart -= 1), r.newLines === 0 && (r.newStart -= 1), e.push("@@ -" + r.oldStart + "," + r.oldLines + " +" + r.newStart + "," + r.newLines + " @@"), e.push.apply(e, r.lines);
  }
  return e.join(`
`) + `
`;
}
function ebe(t, e, n, r, s, i, o) {
  return zj(Qye(t, e, n, r, s, i, o));
}
function tbe(t, e) {
  const n = {};
  let r = !1;
  for (const [s, i] of e) {
    const o = t[s];
    if (o?.type !== "file")
      continue;
    const a = nbe(s, i, o.content);
    a && (r = !0, a.length > o.content.length ? n[s] = { type: "file", content: o.content } : n[s] = { type: "diff", content: a });
  }
  if (r)
    return n;
}
function nbe(t, e, n) {
  let r = ebe(t, t, e, n);
  const s = `--- ${t}
+++ ${t}
`, i = r.indexOf(s);
  if (i >= 0 && (r = r.slice(i + s.length)), r !== "")
    return r;
}
const rbe = new RegExp(`^${ia}/`);
function Lv(t) {
  return t.replace(rbe, "");
}
const nO = Sr("FilesStore"), sbe = new TextDecoder("utf8", { fatal: !0 });
class ibe {
  #t;
  /**
   * Tracks the number of files without folders.
   */
  #n = 0;
  /**
   * @note Keeps track all modified files with their original content since the last user message.
   * Needs to be reset when the user sends another message and all changes have to be submitted
   * for the model to be aware of the changes.
   */
  #e = /* @__PURE__ */ new Map();
  /**
   * Map of files that matches the state of WebContainer.
   */
  files = Ol({});
  get filesCount() {
    return this.#n;
  }
  constructor(e) {
    this.#t = e, this.#r();
  }
  getFile(e) {
    const n = this.files.get()[e];
    if (n?.type === "file")
      return n;
  }
  getFileModifications() {
    return tbe(this.files.get(), this.#e);
  }
  resetFileModifications() {
    this.#e.clear();
  }
  async saveFile(e, n) {
    const r = await this.#t;
    try {
      const s = rn.relative(r.workdir, e);
      if (!s)
        throw new Error(`EINVAL: invalid file path, write '${s}'`);
      const i = this.getFile(e)?.content;
      i || ps("Expected content to be defined"), await r.fs.writeFile(s, n), this.#e.has(e) || this.#e.set(e, i), this.files.setKey(e, { type: "file", content: n, isBinary: !1 }), nO.info("File updated");
    } catch (s) {
      throw nO.error(`Failed to update file content

`, s), s;
    }
  }
  async #r() {
    (await this.#t).internal.watchPaths(
      { include: [`${ia}/**`], exclude: ["**/node_modules", ".git"], includeContent: !0 },
      zye(100, this.#a.bind(this))
    );
  }
  #a(e) {
    const n = e.flat(2);
    for (const { type: r, path: s, buffer: i } of n) {
      const o = s.replace(/\/+$/g, "");
      switch (r) {
        case "add_dir": {
          this.files.setKey(o, { type: "folder" });
          break;
        }
        case "remove_dir": {
          this.files.setKey(o, void 0);
          for (const [a] of Object.entries(this.files))
            a.startsWith(o) && this.files.setKey(a, void 0);
          break;
        }
        case "add_file":
        case "change": {
          r === "add_file" && this.#n++;
          let a = "";
          const l = obe(i);
          l || (a = this.#s(i)), this.files.setKey(o, { type: "file", content: a, isBinary: l });
          break;
        }
        case "remove_file": {
          this.#n--, this.files.setKey(o, void 0);
          break;
        }
      }
    }
  }
  #s(e) {
    if (!e || e.byteLength === 0)
      return "";
    try {
      return sbe.decode(e);
    } catch (n) {
      return console.log(n), "";
    }
  }
}
function obe(t) {
  return t === void 0 ? !1 : bg(abe(t), { chunkLength: 100 }) === "binary";
}
function abe(t) {
  return W4.from(t.buffer, t.byteOffset, t.byteLength);
}
const lbe = "preview-updates";
class cbe {
  #t = /* @__PURE__ */ new Map();
  #n;
  #e;
  #r = /* @__PURE__ */ new Map();
  #a = /* @__PURE__ */ new Set();
  #s = /* @__PURE__ */ new Map();
  #o = 300;
  #i;
  previews = nn([]);
  constructor(e) {
    if (this.#n = e, this.#e = new BroadcastChannel(lbe), this.#i = new BroadcastChannel("storage-sync-channel"), this.#e.onmessage = (n) => {
      const { type: r, previewId: s } = n.data;
      if (r === "file-change") {
        const i = n.data.timestamp, o = this.#r.get(s) || 0;
        i > o && (this.#r.set(s, i), this.refreshPreview(s));
      }
    }, this.#i.onmessage = (n) => {
      const { storage: r, source: s } = n.data;
      r && s !== this._getTabId() && this._syncStorage(r);
    }, typeof window < "u") {
      const n = localStorage.setItem;
      localStorage.setItem = (...r) => {
        n.apply(localStorage, r), this._broadcastStorageSync();
      };
    }
    this.#l();
  }
  // Generate a unique ID for this tab
  _getTabId() {
    return typeof window < "u" ? (window._tabId || (window._tabId = Math.random().toString(36).substring(2, 15)), window._tabId) : "";
  }
  // Sync storage data between tabs
  _syncStorage(e) {
    if (typeof window < "u" && (Object.entries(e).forEach(([r, s]) => {
      try {
        Object.getPrototypeOf(localStorage).setItem.call(localStorage, r, s);
      } catch (i) {
        console.error("[Preview] Error syncing storage:", i);
      }
    }), this.previews.get().forEach((r) => {
      const s = this.getPreviewId(r.baseUrl);
      s && this.refreshPreview(s);
    }), typeof window < "u" && window.location)) {
      const r = document.querySelector("iframe");
      r && (r.src = r.src);
    }
  }
  // Broadcast storage state to other tabs
  _broadcastStorageSync() {
    if (typeof window < "u") {
      const e = {};
      for (let n = 0; n < localStorage.length; n++) {
        const r = localStorage.key(n);
        r && (e[r] = localStorage.getItem(r) || "");
      }
      this.#i.postMessage({
        type: "storage-sync",
        storage: e,
        source: this._getTabId(),
        timestamp: Date.now()
      });
    }
  }
  async #l() {
    const e = await this.#n;
    e.on("server-ready", (n, r) => {
      console.log("[Preview] Server ready on port:", n, r), this.broadcastUpdate(r), this._broadcastStorageSync();
    });
    try {
      (await e.fs.watch("**/*", { persistent: !0 })).addEventListener("change", async () => {
        const r = this.previews.get();
        for (const s of r) {
          const i = this.getPreviewId(s.baseUrl);
          i && this.broadcastFileChange(i);
        }
      }), typeof window < "u" && new MutationObserver((s) => {
        this._broadcastStorageSync();
      }).observe(document.body, {
        childList: !0,
        subtree: !0,
        characterData: !0,
        attributes: !0
      });
    } catch (n) {
      console.error("[Preview] Error setting up watchers:", n);
    }
    e.on("port", (n, r, s) => {
      let i = this.#t.get(n);
      if (r === "close" && i) {
        this.#t.delete(n), this.previews.set(this.previews.get().filter((a) => a.port !== n));
        return;
      }
      const o = this.previews.get();
      i || (i = { port: n, ready: r === "open", baseUrl: s }, this.#t.set(n, i), o.push(i)), i.ready = r === "open", i.baseUrl = s, this.previews.set([...o]), r === "open" && this.broadcastUpdate(s);
    });
  }
  // Helper to extract preview ID from URL
  getPreviewId(e) {
    const n = e.match(/^https?:\/\/([^.]+)\.local-credentialless\.webcontainer-api\.io/);
    return n ? n[1] : null;
  }
  // Broadcast state change to all tabs
  broadcastStateChange(e) {
    const n = Date.now();
    this.#r.set(e, n), this.#e.postMessage({
      type: "state-change",
      previewId: e,
      timestamp: n
    });
  }
  // Broadcast file change to all tabs
  broadcastFileChange(e) {
    const n = Date.now();
    this.#r.set(e, n), this.#e.postMessage({
      type: "file-change",
      previewId: e,
      timestamp: n
    });
  }
  // Broadcast update to all tabs
  broadcastUpdate(e) {
    const n = this.getPreviewId(e);
    if (n) {
      const r = Date.now();
      this.#r.set(n, r), this.#e.postMessage({
        type: "file-change",
        previewId: n,
        timestamp: r
      });
    }
  }
  // Method to refresh a specific preview
  refreshPreview(e) {
    const n = this.#s.get(e);
    n && clearTimeout(n);
    const r = setTimeout(() => {
      const s = this.previews.get(), i = s.find((o) => this.getPreviewId(o.baseUrl) === e);
      i && (i.ready = !1, this.previews.set([...s]), requestAnimationFrame(() => {
        i.ready = !0, this.previews.set([...s]);
      })), this.#s.delete(e);
    }, this.#o);
    this.#s.set(e, r);
  }
}
function Gj() {
  if (typeof Promise.withResolvers == "function")
    return Promise.withResolvers();
  let t, e;
  const n = new Promise((r, s) => {
    t = r, e = s;
  });
  return {
    resolve: t,
    reject: e,
    promise: n
  };
}
async function ube(t, e) {
  const n = [], r = await t.spawn("/bin/jsh", ["--osc", ...n], {
    terminal: {
      cols: e.cols ?? 80,
      rows: e.rows ?? 15
    }
  }), s = r.input.getWriter(), i = r.output, o = Gj();
  let a = !1;
  return i.pipeTo(
    new WritableStream({
      write(l) {
        if (!a) {
          const [, c] = l.match(/\x1b\]654;([^\x07]+)\x07/) || [];
          c === "interactive" && (a = !0, o.resolve());
        }
        e.write(l);
      }
    })
  ), e.onData((l) => {
    a && s.write(l);
  }), await o.promise, r;
}
class hbe {
  #t;
  #n;
  #e;
  #r;
  #a;
  executionState = nn();
  #s;
  #o;
  constructor() {
    this.#n = new Promise((e) => {
      this.#t = e;
    });
  }
  ready() {
    return this.#n;
  }
  async init(e, n) {
    this.#e = e, this.#r = n;
    const { process: r, output: s } = await this.newBoltShellProcess(e, n);
    this.#a = r, this.#s = s.getReader(), await this.waitTillOscCode("interactive"), this.#t?.();
  }
  get terminal() {
    return this.#r;
  }
  get process() {
    return this.#a;
  }
  async executeCommand(e, n, r) {
    if (!this.process || !this.terminal)
      return;
    const s = this.executionState.get();
    s?.active && s.abort && s.abort(), this.terminal.input(""), await this.waitTillOscCode("prompt"), s && s.executionPrms && await s.executionPrms, this.terminal.input(n.trim() + `
`);
    const i = this.getCurrentExecutionResult();
    this.executionState.set({ sessionId: e, active: !0, executionPrms: i, abort: r });
    const o = await i;
    if (this.executionState.set({ sessionId: e, active: !1 }), o)
      try {
        o.output = dbe(o.output);
      } catch (a) {
        console.log("failed to format terminal output", a);
      }
    return o;
  }
  async newBoltShellProcess(e, n) {
    const r = [], s = await e.spawn("/bin/jsh", ["--osc", ...r], {
      terminal: {
        cols: n.cols ?? 80,
        rows: n.rows ?? 15
      }
    }), i = s.input.getWriter();
    this.#o = i;
    const [o, a] = s.output.tee(), l = Gj();
    let c = !1;
    return a.pipeTo(
      new WritableStream({
        write(u) {
          if (!c) {
            const [, h] = u.match(/\x1b\]654;([^\x07]+)\x07/) || [];
            h === "interactive" && (c = !0, l.resolve());
          }
          n.write(u);
        }
      })
    ), n.onData((u) => {
      c && i.write(u);
    }), await l.promise, { process: s, output: o };
  }
  async getCurrentExecutionResult() {
    const { output: e, exitCode: n } = await this.waitTillOscCode("exit");
    return { output: e, exitCode: n };
  }
  async waitTillOscCode(e) {
    let n = "", r = 0;
    if (!this.#s)
      return { output: n, exitCode: r };
    const s = this.#s;
    for (; ; ) {
      const { value: i, done: o } = await s.read();
      if (o)
        break;
      const a = i || "";
      n += a;
      const [, l, , , c] = a.match(/\x1b\]654;([^\x07=]+)=?((-?\d+):(\d+))?\x07/) || [];
      if (l === "exit" && (r = parseInt(c, 10)), l === e)
        break;
    }
    return { output: n, exitCode: r };
  }
}
function dbe(t) {
  return t.replace(/\x1b\](\d+;[^\x07\x1b]*|\d+[^\x07\x1b]*)\x07/g, "").replace(/\](\d+;[^\n]*|\d+[^\n]*)/g, "").replace(/\u001b\[[\?]?[0-9;]*[a-zA-Z]/g, "").replace(/\x1b\[[\?]?[0-9;]*[a-zA-Z]/g, "").replace(/\u001b\[[0-9;]*m/g, "").replace(/\x1b\[[0-9;]*m/g, "").replace(/\u001b/g, "").replace(/\x1b/g, "").replace(/\r\n/g, `
`).replace(/\r/g, `
`).replace(/\n{3,}/g, `

`).replace(/^([~\/][^\n]+)/m, `$1
`).replace(/(?<!^|\n)>/g, `
>`).replace(/(?<!^|\n|\w)(error|failed|warning|Error|Failed|Warning):/g, `
$1:`).replace(/(?<!^|\n|\/)(at\s+(?!async|sync))/g, `
at `).replace(/\bat\s+async/g, "at async").replace(/(?<!^|\n)(npm ERR!)/g, `
$1`).split(`
`).map((o) => o.trim()).filter((o) => o.length > 0).join(`
`).replace(/\n{3,}/g, `

`).replace(/:\s+/g, ": ").replace(/\s{2,}/g, " ").replace(/^\s+|\s+$/g, "").replace(/\u0000/g, "");
}
function fbe() {
  return new hbe();
}
const pbe = "\x1B[0m", mbe = {
  red: "\x1B[1;31m"
}, rO = {
  red: (t) => `${mbe.red}${t}${pbe}`
};
class gbe {
  #t;
  #n = [];
  #e = fbe();
  showTerminal = nn(!0);
  constructor(e) {
    this.#t = e;
  }
  get boltTerminal() {
    return this.#e;
  }
  toggleTerminal(e) {
    this.showTerminal.set(e !== void 0 ? e : !this.showTerminal.get());
  }
  async attachBoltTerminal(e) {
    try {
      const n = await this.#t;
      await this.#e.init(n, e);
    } catch (n) {
      e.write(rO.red(`Failed to spawn bolt shell

`) + n.message);
      return;
    }
  }
  async attachTerminal(e) {
    try {
      const n = await ube(await this.#t, e);
      this.#n.push({ terminal: e, process: n });
    } catch (n) {
      e.write(rO.red(`Failed to spawn shell

`) + n.message);
      return;
    }
  }
  onTerminalResize(e, n) {
    for (const { process: r } of this.#n)
      r.resize({ cols: e, rows: n });
  }
}
function dm(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Vj = { exports: {} };
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, s, i) {
      function o(c, u) {
        if (!s[c]) {
          if (!r[c]) {
            var h = typeof dm == "function" && dm;
            if (!u && h) return h(c, !0);
            if (a) return a(c, !0);
            var d = new Error("Cannot find module '" + c + "'");
            throw d.code = "MODULE_NOT_FOUND", d;
          }
          var f = s[c] = { exports: {} };
          r[c][0].call(f.exports, function(g) {
            var y = r[c][1][g];
            return o(y || g);
          }, f, f.exports, n, r, s, i);
        }
        return s[c].exports;
      }
      for (var a = typeof dm == "function" && dm, l = 0; l < i.length; l++) o(i[l]);
      return o;
    }({ 1: [function(n, r, s) {
      var i = n("./utils"), o = n("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      s.encode = function(l) {
        for (var c, u, h, d, f, g, y, p = [], m = 0, b = l.length, _ = b, v = i.getTypeOf(l) !== "string"; m < l.length; ) _ = b - m, h = v ? (c = l[m++], u = m < b ? l[m++] : 0, m < b ? l[m++] : 0) : (c = l.charCodeAt(m++), u = m < b ? l.charCodeAt(m++) : 0, m < b ? l.charCodeAt(m++) : 0), d = c >> 2, f = (3 & c) << 4 | u >> 4, g = 1 < _ ? (15 & u) << 2 | h >> 6 : 64, y = 2 < _ ? 63 & h : 64, p.push(a.charAt(d) + a.charAt(f) + a.charAt(g) + a.charAt(y));
        return p.join("");
      }, s.decode = function(l) {
        var c, u, h, d, f, g, y = 0, p = 0, m = "data:";
        if (l.substr(0, m.length) === m) throw new Error("Invalid base64 input, it looks like a data url.");
        var b, _ = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && _--, l.charAt(l.length - 2) === a.charAt(64) && _--, _ % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (b = o.uint8array ? new Uint8Array(0 | _) : new Array(0 | _); y < l.length; ) c = a.indexOf(l.charAt(y++)) << 2 | (d = a.indexOf(l.charAt(y++))) >> 4, u = (15 & d) << 4 | (f = a.indexOf(l.charAt(y++))) >> 2, h = (3 & f) << 6 | (g = a.indexOf(l.charAt(y++))), b[p++] = c, f !== 64 && (b[p++] = u), g !== 64 && (b[p++] = h);
        return b;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, r, s) {
      var i = n("./external"), o = n("./stream/DataWorker"), a = n("./stream/Crc32Probe"), l = n("./stream/DataLengthProbe");
      function c(u, h, d, f, g) {
        this.compressedSize = u, this.uncompressedSize = h, this.crc32 = d, this.compression = f, this.compressedContent = g;
      }
      c.prototype = { getContentWorker: function() {
        var u = new o(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), h = this;
        return u.on("end", function() {
          if (this.streamInfo.data_length !== h.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), u;
      }, getCompressedWorker: function() {
        return new o(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(u, h, d) {
        return u.pipe(new a()).pipe(new l("uncompressedSize")).pipe(h.compressWorker(d)).pipe(new l("compressedSize")).withStreamInfo("compression", h);
      }, r.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, r, s) {
      var i = n("./stream/GenericWorker");
      s.STORE = { magic: "\0\0", compressWorker: function() {
        return new i("STORE compression");
      }, uncompressWorker: function() {
        return new i("STORE decompression");
      } }, s.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, r, s) {
      var i = n("./utils"), o = function() {
        for (var a, l = [], c = 0; c < 256; c++) {
          a = c;
          for (var u = 0; u < 8; u++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[c] = a;
        }
        return l;
      }();
      r.exports = function(a, l) {
        return a !== void 0 && a.length ? i.getTypeOf(a) !== "string" ? function(c, u, h, d) {
          var f = o, g = d + h;
          c ^= -1;
          for (var y = d; y < g; y++) c = c >>> 8 ^ f[255 & (c ^ u[y])];
          return -1 ^ c;
        }(0 | l, a, a.length, 0) : function(c, u, h, d) {
          var f = o, g = d + h;
          c ^= -1;
          for (var y = d; y < g; y++) c = c >>> 8 ^ f[255 & (c ^ u.charCodeAt(y))];
          return -1 ^ c;
        }(0 | l, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(n, r, s) {
      s.base64 = !1, s.binary = !1, s.dir = !1, s.createFolders = !0, s.date = null, s.compression = null, s.compressionOptions = null, s.comment = null, s.unixPermissions = null, s.dosPermissions = null;
    }, {}], 6: [function(n, r, s) {
      var i = null;
      i = typeof Promise < "u" ? Promise : n("lie"), r.exports = { Promise: i };
    }, { lie: 37 }], 7: [function(n, r, s) {
      var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = n("pako"), a = n("./utils"), l = n("./stream/GenericWorker"), c = i ? "uint8array" : "array";
      function u(h, d) {
        l.call(this, "FlateWorker/" + h), this._pako = null, this._pakoAction = h, this._pakoOptions = d, this.meta = {};
      }
      s.magic = "\b\0", a.inherits(u, l), u.prototype.processChunk = function(h) {
        this.meta = h.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(c, h.data), !1);
      }, u.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, u.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var h = this;
        this._pako.onData = function(d) {
          h.push({ data: d, meta: h.meta });
        };
      }, s.compressWorker = function(h) {
        return new u("Deflate", h);
      }, s.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, r, s) {
      function i(f, g) {
        var y, p = "";
        for (y = 0; y < g; y++) p += String.fromCharCode(255 & f), f >>>= 8;
        return p;
      }
      function o(f, g, y, p, m, b) {
        var _, v, w = f.file, E = f.compression, x = b !== c.utf8encode, S = a.transformTo("string", b(w.name)), T = a.transformTo("string", c.utf8encode(w.name)), R = w.comment, F = a.transformTo("string", b(R)), P = a.transformTo("string", c.utf8encode(R)), M = T.length !== w.name.length, A = P.length !== R.length, V = "", ee = "", K = "", te = w.dir, N = w.date, L = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        g && !y || (L.crc32 = f.crc32, L.compressedSize = f.compressedSize, L.uncompressedSize = f.uncompressedSize);
        var j = 0;
        g && (j |= 8), x || !M && !A || (j |= 2048);
        var H = 0, U = 0;
        te && (H |= 16), m === "UNIX" ? (U = 798, H |= function(ne, he) {
          var X = ne;
          return ne || (X = he ? 16893 : 33204), (65535 & X) << 16;
        }(w.unixPermissions, te)) : (U = 20, H |= function(ne) {
          return 63 & (ne || 0);
        }(w.dosPermissions)), _ = N.getUTCHours(), _ <<= 6, _ |= N.getUTCMinutes(), _ <<= 5, _ |= N.getUTCSeconds() / 2, v = N.getUTCFullYear() - 1980, v <<= 4, v |= N.getUTCMonth() + 1, v <<= 5, v |= N.getUTCDate(), M && (ee = i(1, 1) + i(u(S), 4) + T, V += "up" + i(ee.length, 2) + ee), A && (K = i(1, 1) + i(u(F), 4) + P, V += "uc" + i(K.length, 2) + K);
        var Y = "";
        return Y += `
\0`, Y += i(j, 2), Y += E.magic, Y += i(_, 2), Y += i(v, 2), Y += i(L.crc32, 4), Y += i(L.compressedSize, 4), Y += i(L.uncompressedSize, 4), Y += i(S.length, 2), Y += i(V.length, 2), { fileRecord: h.LOCAL_FILE_HEADER + Y + S + V, dirRecord: h.CENTRAL_FILE_HEADER + i(U, 2) + Y + i(F.length, 2) + "\0\0\0\0" + i(H, 4) + i(p, 4) + S + V + F };
      }
      var a = n("../utils"), l = n("../stream/GenericWorker"), c = n("../utf8"), u = n("../crc32"), h = n("../signature");
      function d(f, g, y, p) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = y, this.encodeFileName = p, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(d, l), d.prototype.push = function(f) {
        var g = f.meta.percent || 0, y = this.entriesCount, p = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, l.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: y ? (g + 100 * (y - p - 1)) / y : 100 } }));
      }, d.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var g = this.streamFiles && !f.file.dir;
        if (g) {
          var y = o(f, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: y.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, d.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var g = this.streamFiles && !f.file.dir, y = o(f, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(y.dirRecord), g) this.push({ data: function(p) {
          return h.DATA_DESCRIPTOR + i(p.crc32, 4) + i(p.compressedSize, 4) + i(p.uncompressedSize, 4);
        }(f), meta: { percent: 100 } });
        else for (this.push({ data: y.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, d.prototype.flush = function() {
        for (var f = this.bytesWritten, g = 0; g < this.dirRecords.length; g++) this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
        var y = this.bytesWritten - f, p = function(m, b, _, v, w) {
          var E = a.transformTo("string", w(v));
          return h.CENTRAL_DIRECTORY_END + "\0\0\0\0" + i(m, 2) + i(m, 2) + i(b, 4) + i(_, 4) + i(E.length, 2) + E;
        }(this.dirRecords.length, y, f, this.zipComment, this.encodeFileName);
        this.push({ data: p, meta: { percent: 100 } });
      }, d.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, d.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var g = this;
        return f.on("data", function(y) {
          g.processChunk(y);
        }), f.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), f.on("error", function(y) {
          g.error(y);
        }), this;
      }, d.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, d.prototype.error = function(f) {
        var g = this._sources;
        if (!l.prototype.error.call(this, f)) return !1;
        for (var y = 0; y < g.length; y++) try {
          g[y].error(f);
        } catch {
        }
        return !0;
      }, d.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var f = this._sources, g = 0; g < f.length; g++) f[g].lock();
      }, r.exports = d;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, r, s) {
      var i = n("../compressions"), o = n("./ZipFileWorker");
      s.generateWorker = function(a, l, c) {
        var u = new o(l.streamFiles, c, l.platform, l.encodeFileName), h = 0;
        try {
          a.forEach(function(d, f) {
            h++;
            var g = function(b, _) {
              var v = b || _, w = i[v];
              if (!w) throw new Error(v + " is not a valid compression method !");
              return w;
            }(f.options.compression, l.compression), y = f.options.compressionOptions || l.compressionOptions || {}, p = f.dir, m = f.date;
            f._compressWorker(g, y).withStreamInfo("file", { name: d, dir: p, date: m, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(u);
          }), u.entriesCount = h;
        } catch (d) {
          u.error(d);
        }
        return u;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, r, s) {
      function i() {
        if (!(this instanceof i)) return new i();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new i();
          for (var a in this) typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      (i.prototype = n("./object")).loadAsync = n("./load"), i.support = n("./support"), i.defaults = n("./defaults"), i.version = "3.10.1", i.loadAsync = function(o, a) {
        return new i().loadAsync(o, a);
      }, i.external = n("./external"), r.exports = i;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, r, s) {
      var i = n("./utils"), o = n("./external"), a = n("./utf8"), l = n("./zipEntries"), c = n("./stream/Crc32Probe"), u = n("./nodejsUtils");
      function h(d) {
        return new o.Promise(function(f, g) {
          var y = d.decompressed.getContentWorker().pipe(new c());
          y.on("error", function(p) {
            g(p);
          }).on("end", function() {
            y.streamInfo.crc32 !== d.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      r.exports = function(d, f) {
        var g = this;
        return f = i.extend(f || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), u.isNode && u.isStream(d) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : i.prepareContent("the loaded zip file", d, !0, f.optimizedBinaryString, f.base64).then(function(y) {
          var p = new l(f);
          return p.load(y), p;
        }).then(function(y) {
          var p = [o.Promise.resolve(y)], m = y.files;
          if (f.checkCRC32) for (var b = 0; b < m.length; b++) p.push(h(m[b]));
          return o.Promise.all(p);
        }).then(function(y) {
          for (var p = y.shift(), m = p.files, b = 0; b < m.length; b++) {
            var _ = m[b], v = _.fileNameStr, w = i.resolve(_.fileNameStr);
            g.file(w, _.decompressed, { binary: !0, optimizedBinaryString: !0, date: _.date, dir: _.dir, comment: _.fileCommentStr.length ? _.fileCommentStr : null, unixPermissions: _.unixPermissions, dosPermissions: _.dosPermissions, createFolders: f.createFolders }), _.dir || (g.file(w).unsafeOriginalName = v);
          }
          return p.zipComment.length && (g.comment = p.zipComment), g;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, r, s) {
      var i = n("../utils"), o = n("../stream/GenericWorker");
      function a(l, c) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(c);
      }
      i.inherits(a, o), a.prototype._bindStream = function(l) {
        var c = this;
        (this._stream = l).pause(), l.on("data", function(u) {
          c.push({ data: u, meta: { percent: 0 } });
        }).on("error", function(u) {
          c.isPaused ? this.generatedError = u : c.error(u);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, a.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, r, s) {
      var i = n("readable-stream").Readable;
      function o(a, l, c) {
        i.call(this, l), this._helper = a;
        var u = this;
        a.on("data", function(h, d) {
          u.push(h) || u._helper.pause(), c && c(d);
        }).on("error", function(h) {
          u.emit("error", h);
        }).on("end", function() {
          u.push(null);
        });
      }
      n("../utils").inherits(o, i), o.prototype._read = function() {
        this._helper.resume();
      }, r.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, r, s) {
      r.exports = { isNode: typeof Me < "u", newBufferFrom: function(i, o) {
        if (Me.from && Me.from !== Uint8Array.from) return Me.from(i, o);
        if (typeof i == "number") throw new Error('The "data" argument must not be a number');
        return new Me(i, o);
      }, allocBuffer: function(i) {
        if (Me.alloc) return Me.alloc(i);
        var o = new Me(i);
        return o.fill(0), o;
      }, isBuffer: function(i) {
        return Me.isBuffer(i);
      }, isStream: function(i) {
        return i && typeof i.on == "function" && typeof i.pause == "function" && typeof i.resume == "function";
      } };
    }, {}], 15: [function(n, r, s) {
      function i(w, E, x) {
        var S, T = a.getTypeOf(E), R = a.extend(x || {}, u);
        R.date = R.date || /* @__PURE__ */ new Date(), R.compression !== null && (R.compression = R.compression.toUpperCase()), typeof R.unixPermissions == "string" && (R.unixPermissions = parseInt(R.unixPermissions, 8)), R.unixPermissions && 16384 & R.unixPermissions && (R.dir = !0), R.dosPermissions && 16 & R.dosPermissions && (R.dir = !0), R.dir && (w = m(w)), R.createFolders && (S = p(w)) && b.call(this, S, !0);
        var F = T === "string" && R.binary === !1 && R.base64 === !1;
        x && x.binary !== void 0 || (R.binary = !F), (E instanceof h && E.uncompressedSize === 0 || R.dir || !E || E.length === 0) && (R.base64 = !1, R.binary = !0, E = "", R.compression = "STORE", T = "string");
        var P = null;
        P = E instanceof h || E instanceof l ? E : g.isNode && g.isStream(E) ? new y(w, E) : a.prepareContent(w, E, R.binary, R.optimizedBinaryString, R.base64);
        var M = new d(w, P, R);
        this.files[w] = M;
      }
      var o = n("./utf8"), a = n("./utils"), l = n("./stream/GenericWorker"), c = n("./stream/StreamHelper"), u = n("./defaults"), h = n("./compressedObject"), d = n("./zipObject"), f = n("./generate"), g = n("./nodejsUtils"), y = n("./nodejs/NodejsStreamInputAdapter"), p = function(w) {
        w.slice(-1) === "/" && (w = w.substring(0, w.length - 1));
        var E = w.lastIndexOf("/");
        return 0 < E ? w.substring(0, E) : "";
      }, m = function(w) {
        return w.slice(-1) !== "/" && (w += "/"), w;
      }, b = function(w, E) {
        return E = E !== void 0 ? E : u.createFolders, w = m(w), this.files[w] || i.call(this, w, null, { dir: !0, createFolders: E }), this.files[w];
      };
      function _(w) {
        return Object.prototype.toString.call(w) === "[object RegExp]";
      }
      var v = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(w) {
        var E, x, S;
        for (E in this.files) S = this.files[E], (x = E.slice(this.root.length, E.length)) && E.slice(0, this.root.length) === this.root && w(x, S);
      }, filter: function(w) {
        var E = [];
        return this.forEach(function(x, S) {
          w(x, S) && E.push(S);
        }), E;
      }, file: function(w, E, x) {
        if (arguments.length !== 1) return w = this.root + w, i.call(this, w, E, x), this;
        if (_(w)) {
          var S = w;
          return this.filter(function(R, F) {
            return !F.dir && S.test(R);
          });
        }
        var T = this.files[this.root + w];
        return T && !T.dir ? T : null;
      }, folder: function(w) {
        if (!w) return this;
        if (_(w)) return this.filter(function(T, R) {
          return R.dir && w.test(T);
        });
        var E = this.root + w, x = b.call(this, E), S = this.clone();
        return S.root = x.name, S;
      }, remove: function(w) {
        w = this.root + w;
        var E = this.files[w];
        if (E || (w.slice(-1) !== "/" && (w += "/"), E = this.files[w]), E && !E.dir) delete this.files[w];
        else for (var x = this.filter(function(T, R) {
          return R.name.slice(0, w.length) === w;
        }), S = 0; S < x.length; S++) delete this.files[x[S].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(w) {
        var E, x = {};
        try {
          if ((x = a.extend(w || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = x.type.toLowerCase(), x.compression = x.compression.toUpperCase(), x.type === "binarystring" && (x.type = "string"), !x.type) throw new Error("No output type specified.");
          a.checkSupport(x.type), x.platform !== "darwin" && x.platform !== "freebsd" && x.platform !== "linux" && x.platform !== "sunos" || (x.platform = "UNIX"), x.platform === "win32" && (x.platform = "DOS");
          var S = x.comment || this.comment || "";
          E = f.generateWorker(this, x, S);
        } catch (T) {
          (E = new l("error")).error(T);
        }
        return new c(E, x.type || "string", x.mimeType);
      }, generateAsync: function(w, E) {
        return this.generateInternalStream(w).accumulate(E);
      }, generateNodeStream: function(w, E) {
        return (w = w || {}).type || (w.type = "nodebuffer"), this.generateInternalStream(w).toNodejsStream(E);
      } };
      r.exports = v;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, r, s) {
      r.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, r, s) {
      var i = n("./DataReader");
      function o(a) {
        i.call(this, a);
        for (var l = 0; l < this.data.length; l++) a[l] = 255 & a[l];
      }
      n("../utils").inherits(o, i), o.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, o.prototype.lastIndexOfSignature = function(a) {
        for (var l = a.charCodeAt(0), c = a.charCodeAt(1), u = a.charCodeAt(2), h = a.charCodeAt(3), d = this.length - 4; 0 <= d; --d) if (this.data[d] === l && this.data[d + 1] === c && this.data[d + 2] === u && this.data[d + 3] === h) return d - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(a) {
        var l = a.charCodeAt(0), c = a.charCodeAt(1), u = a.charCodeAt(2), h = a.charCodeAt(3), d = this.readData(4);
        return l === d[0] && c === d[1] && u === d[2] && h === d[3];
      }, o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, r.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, r, s) {
      var i = n("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function() {
      }, readInt: function(a) {
        var l, c = 0;
        for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--) c = (c << 8) + this.byteAt(l);
        return this.index += a, c;
      }, readString: function(a) {
        return i.transformTo("string", this.readData(a));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, r.exports = o;
    }, { "../utils": 32 }], 19: [function(n, r, s) {
      var i = n("./Uint8ArrayReader");
      function o(a) {
        i.call(this, a);
      }
      n("../utils").inherits(o, i), o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, r.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, r, s) {
      var i = n("./DataReader");
      function o(a) {
        i.call(this, a);
      }
      n("../utils").inherits(o, i), o.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, o.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, o.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, r.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, r, s) {
      var i = n("./ArrayReader");
      function o(a) {
        i.call(this, a);
      }
      n("../utils").inherits(o, i), o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, r.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, r, s) {
      var i = n("../utils"), o = n("../support"), a = n("./ArrayReader"), l = n("./StringReader"), c = n("./NodeBufferReader"), u = n("./Uint8ArrayReader");
      r.exports = function(h) {
        var d = i.getTypeOf(h);
        return i.checkSupport(d), d !== "string" || o.uint8array ? d === "nodebuffer" ? new c(h) : o.uint8array ? new u(i.transformTo("uint8array", h)) : new a(i.transformTo("array", h)) : new l(h);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, r, s) {
      s.LOCAL_FILE_HEADER = "PK", s.CENTRAL_FILE_HEADER = "PK", s.CENTRAL_DIRECTORY_END = "PK", s.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", s.ZIP64_CENTRAL_DIRECTORY_END = "PK", s.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, r, s) {
      var i = n("./GenericWorker"), o = n("../utils");
      function a(l) {
        i.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, i), a.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, r, s) {
      var i = n("./GenericWorker"), o = n("../crc32");
      function a() {
        i.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      n("../utils").inherits(a, i), a.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, r.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, r, s) {
      var i = n("../utils"), o = n("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      i.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, r, s) {
      var i = n("../utils"), o = n("./GenericWorker");
      function a(l) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(u) {
          c.dataIsReady = !0, c.data = u, c.max = u && u.length || 0, c.type = i.getTypeOf(u), c.isPaused || c._tickAndRepeat();
        }, function(u) {
          c.error(u);
        });
      }
      i.inherits(a, o), a.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, i.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var l = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, c);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, r, s) {
      function i(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      i.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, a) {
        return this._listeners[o].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, a) {
        if (this._listeners[o]) for (var l = 0; l < this._listeners[o].length; l++) this._listeners[o][l].call(this, a);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var a = this;
        return o.on("data", function(l) {
          a.processChunk(l);
        }), o.on("end", function() {
          a.end();
        }), o.on("error", function(l) {
          a.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, a) {
        return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, r.exports = i;
    }, {}], 29: [function(n, r, s) {
      var i = n("../utils"), o = n("./ConvertWorker"), a = n("./GenericWorker"), l = n("../base64"), c = n("../support"), u = n("../external"), h = null;
      if (c.nodestream) try {
        h = n("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function d(g, y) {
        return new u.Promise(function(p, m) {
          var b = [], _ = g._internalType, v = g._outputType, w = g._mimeType;
          g.on("data", function(E, x) {
            b.push(E), y && y(x);
          }).on("error", function(E) {
            b = [], m(E);
          }).on("end", function() {
            try {
              var E = function(x, S, T) {
                switch (x) {
                  case "blob":
                    return i.newBlob(i.transformTo("arraybuffer", S), T);
                  case "base64":
                    return l.encode(S);
                  default:
                    return i.transformTo(x, S);
                }
              }(v, function(x, S) {
                var T, R = 0, F = null, P = 0;
                for (T = 0; T < S.length; T++) P += S[T].length;
                switch (x) {
                  case "string":
                    return S.join("");
                  case "array":
                    return Array.prototype.concat.apply([], S);
                  case "uint8array":
                    for (F = new Uint8Array(P), T = 0; T < S.length; T++) F.set(S[T], R), R += S[T].length;
                    return F;
                  case "nodebuffer":
                    return Me.concat(S);
                  default:
                    throw new Error("concat : unsupported type '" + x + "'");
                }
              }(_, b), w);
              p(E);
            } catch (x) {
              m(x);
            }
            b = [];
          }).resume();
        });
      }
      function f(g, y, p) {
        var m = y;
        switch (y) {
          case "blob":
          case "arraybuffer":
            m = "uint8array";
            break;
          case "base64":
            m = "string";
        }
        try {
          this._internalType = m, this._outputType = y, this._mimeType = p, i.checkSupport(m), this._worker = g.pipe(new o(m)), g.lock();
        } catch (b) {
          this._worker = new a("error"), this._worker.error(b);
        }
      }
      f.prototype = { accumulate: function(g) {
        return d(this, g);
      }, on: function(g, y) {
        var p = this;
        return g === "data" ? this._worker.on(g, function(m) {
          y.call(p, m.data, m.meta);
        }) : this._worker.on(g, function() {
          i.delay(y, arguments, p);
        }), this;
      }, resume: function() {
        return i.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(g) {
        if (i.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new h(this, { objectMode: this._outputType !== "nodebuffer" }, g);
      } }, r.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, r, s) {
      if (s.base64 = !0, s.array = !0, s.string = !0, s.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", s.nodebuffer = typeof Me < "u", s.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") s.blob = !1;
      else {
        var i = new ArrayBuffer(0);
        try {
          s.blob = new Blob([i], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(i), s.blob = o.getBlob("application/zip").size === 0;
          } catch {
            s.blob = !1;
          }
        }
      }
      try {
        s.nodestream = !!n("readable-stream").Readable;
      } catch {
        s.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(n, r, s) {
      for (var i = n("./utils"), o = n("./support"), a = n("./nodejsUtils"), l = n("./stream/GenericWorker"), c = new Array(256), u = 0; u < 256; u++) c[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      c[254] = c[254] = 1;
      function h() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function d() {
        l.call(this, "utf-8 encode");
      }
      s.utf8encode = function(f) {
        return o.nodebuffer ? a.newBufferFrom(f, "utf-8") : function(g) {
          var y, p, m, b, _, v = g.length, w = 0;
          for (b = 0; b < v; b++) (64512 & (p = g.charCodeAt(b))) == 55296 && b + 1 < v && (64512 & (m = g.charCodeAt(b + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (m - 56320), b++), w += p < 128 ? 1 : p < 2048 ? 2 : p < 65536 ? 3 : 4;
          for (y = o.uint8array ? new Uint8Array(w) : new Array(w), b = _ = 0; _ < w; b++) (64512 & (p = g.charCodeAt(b))) == 55296 && b + 1 < v && (64512 & (m = g.charCodeAt(b + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (m - 56320), b++), p < 128 ? y[_++] = p : (p < 2048 ? y[_++] = 192 | p >>> 6 : (p < 65536 ? y[_++] = 224 | p >>> 12 : (y[_++] = 240 | p >>> 18, y[_++] = 128 | p >>> 12 & 63), y[_++] = 128 | p >>> 6 & 63), y[_++] = 128 | 63 & p);
          return y;
        }(f);
      }, s.utf8decode = function(f) {
        return o.nodebuffer ? i.transformTo("nodebuffer", f).toString("utf-8") : function(g) {
          var y, p, m, b, _ = g.length, v = new Array(2 * _);
          for (y = p = 0; y < _; ) if ((m = g[y++]) < 128) v[p++] = m;
          else if (4 < (b = c[m])) v[p++] = 65533, y += b - 1;
          else {
            for (m &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && y < _; ) m = m << 6 | 63 & g[y++], b--;
            1 < b ? v[p++] = 65533 : m < 65536 ? v[p++] = m : (m -= 65536, v[p++] = 55296 | m >> 10 & 1023, v[p++] = 56320 | 1023 & m);
          }
          return v.length !== p && (v.subarray ? v = v.subarray(0, p) : v.length = p), i.applyFromCharCode(v);
        }(f = i.transformTo(o.uint8array ? "uint8array" : "array", f));
      }, i.inherits(h, l), h.prototype.processChunk = function(f) {
        var g = i.transformTo(o.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var y = g;
            (g = new Uint8Array(y.length + this.leftOver.length)).set(this.leftOver, 0), g.set(y, this.leftOver.length);
          } else g = this.leftOver.concat(g);
          this.leftOver = null;
        }
        var p = function(b, _) {
          var v;
          for ((_ = _ || b.length) > b.length && (_ = b.length), v = _ - 1; 0 <= v && (192 & b[v]) == 128; ) v--;
          return v < 0 || v === 0 ? _ : v + c[b[v]] > _ ? v : _;
        }(g), m = g;
        p !== g.length && (o.uint8array ? (m = g.subarray(0, p), this.leftOver = g.subarray(p, g.length)) : (m = g.slice(0, p), this.leftOver = g.slice(p, g.length))), this.push({ data: s.utf8decode(m), meta: f.meta });
      }, h.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = h, i.inherits(d, l), d.prototype.processChunk = function(f) {
        this.push({ data: s.utf8encode(f.data), meta: f.meta });
      }, s.Utf8EncodeWorker = d;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, r, s) {
      var i = n("./support"), o = n("./base64"), a = n("./nodejsUtils"), l = n("./external");
      function c(y) {
        return y;
      }
      function u(y, p) {
        for (var m = 0; m < y.length; ++m) p[m] = 255 & y.charCodeAt(m);
        return p;
      }
      n("setimmediate"), s.newBlob = function(y, p) {
        s.checkSupport("blob");
        try {
          return new Blob([y], { type: p });
        } catch {
          try {
            var m = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return m.append(y), m.getBlob(p);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var h = { stringifyByChunk: function(y, p, m) {
        var b = [], _ = 0, v = y.length;
        if (v <= m) return String.fromCharCode.apply(null, y);
        for (; _ < v; ) p === "array" || p === "nodebuffer" ? b.push(String.fromCharCode.apply(null, y.slice(_, Math.min(_ + m, v)))) : b.push(String.fromCharCode.apply(null, y.subarray(_, Math.min(_ + m, v)))), _ += m;
        return b.join("");
      }, stringifyByChar: function(y) {
        for (var p = "", m = 0; m < y.length; m++) p += String.fromCharCode(y[m]);
        return p;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return i.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return i.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function d(y) {
        var p = 65536, m = s.getTypeOf(y), b = !0;
        if (m === "uint8array" ? b = h.applyCanBeUsed.uint8array : m === "nodebuffer" && (b = h.applyCanBeUsed.nodebuffer), b) for (; 1 < p; ) try {
          return h.stringifyByChunk(y, m, p);
        } catch {
          p = Math.floor(p / 2);
        }
        return h.stringifyByChar(y);
      }
      function f(y, p) {
        for (var m = 0; m < y.length; m++) p[m] = y[m];
        return p;
      }
      s.applyFromCharCode = d;
      var g = {};
      g.string = { string: c, array: function(y) {
        return u(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return g.string.uint8array(y).buffer;
      }, uint8array: function(y) {
        return u(y, new Uint8Array(y.length));
      }, nodebuffer: function(y) {
        return u(y, a.allocBuffer(y.length));
      } }, g.array = { string: d, array: c, arraybuffer: function(y) {
        return new Uint8Array(y).buffer;
      }, uint8array: function(y) {
        return new Uint8Array(y);
      }, nodebuffer: function(y) {
        return a.newBufferFrom(y);
      } }, g.arraybuffer = { string: function(y) {
        return d(new Uint8Array(y));
      }, array: function(y) {
        return f(new Uint8Array(y), new Array(y.byteLength));
      }, arraybuffer: c, uint8array: function(y) {
        return new Uint8Array(y);
      }, nodebuffer: function(y) {
        return a.newBufferFrom(new Uint8Array(y));
      } }, g.uint8array = { string: d, array: function(y) {
        return f(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return y.buffer;
      }, uint8array: c, nodebuffer: function(y) {
        return a.newBufferFrom(y);
      } }, g.nodebuffer = { string: d, array: function(y) {
        return f(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return g.nodebuffer.uint8array(y).buffer;
      }, uint8array: function(y) {
        return f(y, new Uint8Array(y.length));
      }, nodebuffer: c }, s.transformTo = function(y, p) {
        if (p = p || "", !y) return p;
        s.checkSupport(y);
        var m = s.getTypeOf(p);
        return g[m][y](p);
      }, s.resolve = function(y) {
        for (var p = y.split("/"), m = [], b = 0; b < p.length; b++) {
          var _ = p[b];
          _ === "." || _ === "" && b !== 0 && b !== p.length - 1 || (_ === ".." ? m.pop() : m.push(_));
        }
        return m.join("/");
      }, s.getTypeOf = function(y) {
        return typeof y == "string" ? "string" : Object.prototype.toString.call(y) === "[object Array]" ? "array" : i.nodebuffer && a.isBuffer(y) ? "nodebuffer" : i.uint8array && y instanceof Uint8Array ? "uint8array" : i.arraybuffer && y instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, s.checkSupport = function(y) {
        if (!i[y.toLowerCase()]) throw new Error(y + " is not supported by this platform");
      }, s.MAX_VALUE_16BITS = 65535, s.MAX_VALUE_32BITS = -1, s.pretty = function(y) {
        var p, m, b = "";
        for (m = 0; m < (y || "").length; m++) b += "\\x" + ((p = y.charCodeAt(m)) < 16 ? "0" : "") + p.toString(16).toUpperCase();
        return b;
      }, s.delay = function(y, p, m) {
        setImmediate(function() {
          y.apply(m || null, p || []);
        });
      }, s.inherits = function(y, p) {
        function m() {
        }
        m.prototype = p.prototype, y.prototype = new m();
      }, s.extend = function() {
        var y, p, m = {};
        for (y = 0; y < arguments.length; y++) for (p in arguments[y]) Object.prototype.hasOwnProperty.call(arguments[y], p) && m[p] === void 0 && (m[p] = arguments[y][p]);
        return m;
      }, s.prepareContent = function(y, p, m, b, _) {
        return l.Promise.resolve(p).then(function(v) {
          return i.blob && (v instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(v)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(w, E) {
            var x = new FileReader();
            x.onload = function(S) {
              w(S.target.result);
            }, x.onerror = function(S) {
              E(S.target.error);
            }, x.readAsArrayBuffer(v);
          }) : v;
        }).then(function(v) {
          var w = s.getTypeOf(v);
          return w ? (w === "arraybuffer" ? v = s.transformTo("uint8array", v) : w === "string" && (_ ? v = o.decode(v) : m && b !== !0 && (v = function(E) {
            return u(E, i.uint8array ? new Uint8Array(E.length) : new Array(E.length));
          }(v))), v) : l.Promise.reject(new Error("Can't read the data of '" + y + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, r, s) {
      var i = n("./reader/readerFor"), o = n("./utils"), a = n("./signature"), l = n("./zipEntry"), c = n("./support");
      function u(h) {
        this.files = [], this.loadOptions = h;
      }
      u.prototype = { checkSignature: function(h) {
        if (!this.reader.readAndCheckSignature(h)) {
          this.reader.index -= 4;
          var d = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(d) + ", expected " + o.pretty(h) + ")");
        }
      }, isSignature: function(h, d) {
        var f = this.reader.index;
        this.reader.setIndex(h);
        var g = this.reader.readString(4) === d;
        return this.reader.setIndex(f), g;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var h = this.reader.readData(this.zipCommentLength), d = c.uint8array ? "uint8array" : "array", f = o.transformTo(d, h);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var h, d, f, g = this.zip64EndOfCentralSize - 44; 0 < g; ) h = this.reader.readInt(2), d = this.reader.readInt(4), f = this.reader.readData(d), this.zip64ExtensibleData[h] = { id: h, length: d, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var h, d;
        for (h = 0; h < this.files.length; h++) d = this.files[h], this.reader.setIndex(d.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), d.readLocalPart(this.reader), d.handleUTF8(), d.processAttributes();
      }, readCentralDir: function() {
        var h;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); ) (h = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(h);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var h = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (h < 0) throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(h);
        var d = h;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (h = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(h), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var g = d - f;
        if (0 < g) this.isSignature(d, a.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
        else if (g < 0) throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
      }, prepareReader: function(h) {
        this.reader = i(h);
      }, load: function(h) {
        this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = u;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, r, s) {
      var i = n("./reader/readerFor"), o = n("./utils"), a = n("./compressedObject"), l = n("./crc32"), c = n("./utf8"), u = n("./compressions"), h = n("./support");
      function d(f, g) {
        this.options = f, this.loadOptions = g;
      }
      d.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var g, y;
        if (f.skip(22), this.fileNameLength = f.readInt(2), y = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(y), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((g = function(p) {
          for (var m in u) if (Object.prototype.hasOwnProperty.call(u, m) && u[m].magic === p) return u[m];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, g, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var g = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        f.skip(g), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = i(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var g, y, p, m = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < m; ) g = f.readInt(2), y = f.readInt(2), p = f.readData(y), this.extraFields[g] = { id: g, length: y, value: p };
        f.setIndex(m);
      }, handleUTF8: function() {
        var f = h.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var g = this.findExtraFieldUnicodePath();
          if (g !== null) this.fileNameStr = g;
          else {
            var y = o.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(y);
          }
          var p = this.findExtraFieldUnicodeComment();
          if (p !== null) this.fileCommentStr = p;
          else {
            var m = o.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(m);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var g = i(f.value);
          return g.readInt(1) !== 1 || l(this.fileName) !== g.readInt(4) ? null : c.utf8decode(g.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var g = i(f.value);
          return g.readInt(1) !== 1 || l(this.fileComment) !== g.readInt(4) ? null : c.utf8decode(g.readData(f.length - 5));
        }
        return null;
      } }, r.exports = d;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, r, s) {
      function i(g, y, p) {
        this.name = g, this.dir = p.dir, this.date = p.date, this.comment = p.comment, this.unixPermissions = p.unixPermissions, this.dosPermissions = p.dosPermissions, this._data = y, this._dataBinary = p.binary, this.options = { compression: p.compression, compressionOptions: p.compressionOptions };
      }
      var o = n("./stream/StreamHelper"), a = n("./stream/DataWorker"), l = n("./utf8"), c = n("./compressedObject"), u = n("./stream/GenericWorker");
      i.prototype = { internalStream: function(g) {
        var y = null, p = "string";
        try {
          if (!g) throw new Error("No output type specified.");
          var m = (p = g.toLowerCase()) === "string" || p === "text";
          p !== "binarystring" && p !== "text" || (p = "string"), y = this._decompressWorker();
          var b = !this._dataBinary;
          b && !m && (y = y.pipe(new l.Utf8EncodeWorker())), !b && m && (y = y.pipe(new l.Utf8DecodeWorker()));
        } catch (_) {
          (y = new u("error")).error(_);
        }
        return new o(y, p, "");
      }, async: function(g, y) {
        return this.internalStream(g).accumulate(y);
      }, nodeStream: function(g, y) {
        return this.internalStream(g || "nodebuffer").toNodejsStream(y);
      }, _compressWorker: function(g, y) {
        if (this._data instanceof c && this._data.compression.magic === g.magic) return this._data.getCompressedWorker();
        var p = this._decompressWorker();
        return this._dataBinary || (p = p.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(p, g, y);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof u ? this._data : new a(this._data);
      } };
      for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], d = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < h.length; f++) i.prototype[h[f]] = d;
      r.exports = i;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, r, s) {
      (function(i) {
        var o, a, l = i.MutationObserver || i.WebKitMutationObserver;
        if (l) {
          var c = 0, u = new l(g), h = i.document.createTextNode("");
          u.observe(h, { characterData: !0 }), o = function() {
            h.data = c = ++c % 2;
          };
        } else if (i.setImmediate || i.MessageChannel === void 0) o = "document" in i && "onreadystatechange" in i.document.createElement("script") ? function() {
          var y = i.document.createElement("script");
          y.onreadystatechange = function() {
            g(), y.onreadystatechange = null, y.parentNode.removeChild(y), y = null;
          }, i.document.documentElement.appendChild(y);
        } : function() {
          setTimeout(g, 0);
        };
        else {
          var d = new i.MessageChannel();
          d.port1.onmessage = g, o = function() {
            d.port2.postMessage(0);
          };
        }
        var f = [];
        function g() {
          var y, p;
          a = !0;
          for (var m = f.length; m; ) {
            for (p = f, f = [], y = -1; ++y < m; ) p[y]();
            m = f.length;
          }
          a = !1;
        }
        r.exports = function(y) {
          f.push(y) !== 1 || a || o();
        };
      }).call(this, typeof Jn < "u" ? Jn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, r, s) {
      var i = n("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], c = ["FULFILLED"], u = ["PENDING"];
      function h(m) {
        if (typeof m != "function") throw new TypeError("resolver must be a function");
        this.state = u, this.queue = [], this.outcome = void 0, m !== o && y(this, m);
      }
      function d(m, b, _) {
        this.promise = m, typeof b == "function" && (this.onFulfilled = b, this.callFulfilled = this.otherCallFulfilled), typeof _ == "function" && (this.onRejected = _, this.callRejected = this.otherCallRejected);
      }
      function f(m, b, _) {
        i(function() {
          var v;
          try {
            v = b(_);
          } catch (w) {
            return a.reject(m, w);
          }
          v === m ? a.reject(m, new TypeError("Cannot resolve promise with itself")) : a.resolve(m, v);
        });
      }
      function g(m) {
        var b = m && m.then;
        if (m && (typeof m == "object" || typeof m == "function") && typeof b == "function") return function() {
          b.apply(m, arguments);
        };
      }
      function y(m, b) {
        var _ = !1;
        function v(x) {
          _ || (_ = !0, a.reject(m, x));
        }
        function w(x) {
          _ || (_ = !0, a.resolve(m, x));
        }
        var E = p(function() {
          b(w, v);
        });
        E.status === "error" && v(E.value);
      }
      function p(m, b) {
        var _ = {};
        try {
          _.value = m(b), _.status = "success";
        } catch (v) {
          _.status = "error", _.value = v;
        }
        return _;
      }
      (r.exports = h).prototype.finally = function(m) {
        if (typeof m != "function") return this;
        var b = this.constructor;
        return this.then(function(_) {
          return b.resolve(m()).then(function() {
            return _;
          });
        }, function(_) {
          return b.resolve(m()).then(function() {
            throw _;
          });
        });
      }, h.prototype.catch = function(m) {
        return this.then(null, m);
      }, h.prototype.then = function(m, b) {
        if (typeof m != "function" && this.state === c || typeof b != "function" && this.state === l) return this;
        var _ = new this.constructor(o);
        return this.state !== u ? f(_, this.state === c ? m : b, this.outcome) : this.queue.push(new d(_, m, b)), _;
      }, d.prototype.callFulfilled = function(m) {
        a.resolve(this.promise, m);
      }, d.prototype.otherCallFulfilled = function(m) {
        f(this.promise, this.onFulfilled, m);
      }, d.prototype.callRejected = function(m) {
        a.reject(this.promise, m);
      }, d.prototype.otherCallRejected = function(m) {
        f(this.promise, this.onRejected, m);
      }, a.resolve = function(m, b) {
        var _ = p(g, b);
        if (_.status === "error") return a.reject(m, _.value);
        var v = _.value;
        if (v) y(m, v);
        else {
          m.state = c, m.outcome = b;
          for (var w = -1, E = m.queue.length; ++w < E; ) m.queue[w].callFulfilled(b);
        }
        return m;
      }, a.reject = function(m, b) {
        m.state = l, m.outcome = b;
        for (var _ = -1, v = m.queue.length; ++_ < v; ) m.queue[_].callRejected(b);
        return m;
      }, h.resolve = function(m) {
        return m instanceof this ? m : a.resolve(new this(o), m);
      }, h.reject = function(m) {
        var b = new this(o);
        return a.reject(b, m);
      }, h.all = function(m) {
        var b = this;
        if (Object.prototype.toString.call(m) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var _ = m.length, v = !1;
        if (!_) return this.resolve([]);
        for (var w = new Array(_), E = 0, x = -1, S = new this(o); ++x < _; ) T(m[x], x);
        return S;
        function T(R, F) {
          b.resolve(R).then(function(P) {
            w[F] = P, ++E !== _ || v || (v = !0, a.resolve(S, w));
          }, function(P) {
            v || (v = !0, a.reject(S, P));
          });
        }
      }, h.race = function(m) {
        var b = this;
        if (Object.prototype.toString.call(m) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var _ = m.length, v = !1;
        if (!_) return this.resolve([]);
        for (var w = -1, E = new this(o); ++w < _; ) x = m[w], b.resolve(x).then(function(S) {
          v || (v = !0, a.resolve(E, S));
        }, function(S) {
          v || (v = !0, a.reject(E, S));
        });
        var x;
        return E;
      };
    }, { immediate: 36 }], 38: [function(n, r, s) {
      var i = {};
      (0, n("./lib/utils/common").assign)(i, n("./lib/deflate"), n("./lib/inflate"), n("./lib/zlib/constants")), r.exports = i;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, r, s) {
      var i = n("./zlib/deflate"), o = n("./utils/common"), a = n("./utils/strings"), l = n("./zlib/messages"), c = n("./zlib/zstream"), u = Object.prototype.toString, h = 0, d = -1, f = 0, g = 8;
      function y(m) {
        if (!(this instanceof y)) return new y(m);
        this.options = o.assign({ level: d, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, m || {});
        var b = this.options;
        b.raw && 0 < b.windowBits ? b.windowBits = -b.windowBits : b.gzip && 0 < b.windowBits && b.windowBits < 16 && (b.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var _ = i.deflateInit2(this.strm, b.level, b.method, b.windowBits, b.memLevel, b.strategy);
        if (_ !== h) throw new Error(l[_]);
        if (b.header && i.deflateSetHeader(this.strm, b.header), b.dictionary) {
          var v;
          if (v = typeof b.dictionary == "string" ? a.string2buf(b.dictionary) : u.call(b.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(b.dictionary) : b.dictionary, (_ = i.deflateSetDictionary(this.strm, v)) !== h) throw new Error(l[_]);
          this._dict_set = !0;
        }
      }
      function p(m, b) {
        var _ = new y(b);
        if (_.push(m, !0), _.err) throw _.msg || l[_.err];
        return _.result;
      }
      y.prototype.push = function(m, b) {
        var _, v, w = this.strm, E = this.options.chunkSize;
        if (this.ended) return !1;
        v = b === ~~b ? b : b === !0 ? 4 : 0, typeof m == "string" ? w.input = a.string2buf(m) : u.call(m) === "[object ArrayBuffer]" ? w.input = new Uint8Array(m) : w.input = m, w.next_in = 0, w.avail_in = w.input.length;
        do {
          if (w.avail_out === 0 && (w.output = new o.Buf8(E), w.next_out = 0, w.avail_out = E), (_ = i.deflate(w, v)) !== 1 && _ !== h) return this.onEnd(_), !(this.ended = !0);
          w.avail_out !== 0 && (w.avail_in !== 0 || v !== 4 && v !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(w.output, w.next_out))) : this.onData(o.shrinkBuf(w.output, w.next_out)));
        } while ((0 < w.avail_in || w.avail_out === 0) && _ !== 1);
        return v === 4 ? (_ = i.deflateEnd(this.strm), this.onEnd(_), this.ended = !0, _ === h) : v !== 2 || (this.onEnd(h), !(w.avail_out = 0));
      }, y.prototype.onData = function(m) {
        this.chunks.push(m);
      }, y.prototype.onEnd = function(m) {
        m === h && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, s.Deflate = y, s.deflate = p, s.deflateRaw = function(m, b) {
        return (b = b || {}).raw = !0, p(m, b);
      }, s.gzip = function(m, b) {
        return (b = b || {}).gzip = !0, p(m, b);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, r, s) {
      var i = n("./zlib/inflate"), o = n("./utils/common"), a = n("./utils/strings"), l = n("./zlib/constants"), c = n("./zlib/messages"), u = n("./zlib/zstream"), h = n("./zlib/gzheader"), d = Object.prototype.toString;
      function f(y) {
        if (!(this instanceof f)) return new f(y);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, y || {});
        var p = this.options;
        p.raw && 0 <= p.windowBits && p.windowBits < 16 && (p.windowBits = -p.windowBits, p.windowBits === 0 && (p.windowBits = -15)), !(0 <= p.windowBits && p.windowBits < 16) || y && y.windowBits || (p.windowBits += 32), 15 < p.windowBits && p.windowBits < 48 && !(15 & p.windowBits) && (p.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var m = i.inflateInit2(this.strm, p.windowBits);
        if (m !== l.Z_OK) throw new Error(c[m]);
        this.header = new h(), i.inflateGetHeader(this.strm, this.header);
      }
      function g(y, p) {
        var m = new f(p);
        if (m.push(y, !0), m.err) throw m.msg || c[m.err];
        return m.result;
      }
      f.prototype.push = function(y, p) {
        var m, b, _, v, w, E, x = this.strm, S = this.options.chunkSize, T = this.options.dictionary, R = !1;
        if (this.ended) return !1;
        b = p === ~~p ? p : p === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof y == "string" ? x.input = a.binstring2buf(y) : d.call(y) === "[object ArrayBuffer]" ? x.input = new Uint8Array(y) : x.input = y, x.next_in = 0, x.avail_in = x.input.length;
        do {
          if (x.avail_out === 0 && (x.output = new o.Buf8(S), x.next_out = 0, x.avail_out = S), (m = i.inflate(x, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && T && (E = typeof T == "string" ? a.string2buf(T) : d.call(T) === "[object ArrayBuffer]" ? new Uint8Array(T) : T, m = i.inflateSetDictionary(this.strm, E)), m === l.Z_BUF_ERROR && R === !0 && (m = l.Z_OK, R = !1), m !== l.Z_STREAM_END && m !== l.Z_OK) return this.onEnd(m), !(this.ended = !0);
          x.next_out && (x.avail_out !== 0 && m !== l.Z_STREAM_END && (x.avail_in !== 0 || b !== l.Z_FINISH && b !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (_ = a.utf8border(x.output, x.next_out), v = x.next_out - _, w = a.buf2string(x.output, _), x.next_out = v, x.avail_out = S - v, v && o.arraySet(x.output, x.output, _, v, 0), this.onData(w)) : this.onData(o.shrinkBuf(x.output, x.next_out)))), x.avail_in === 0 && x.avail_out === 0 && (R = !0);
        } while ((0 < x.avail_in || x.avail_out === 0) && m !== l.Z_STREAM_END);
        return m === l.Z_STREAM_END && (b = l.Z_FINISH), b === l.Z_FINISH ? (m = i.inflateEnd(this.strm), this.onEnd(m), this.ended = !0, m === l.Z_OK) : b !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(x.avail_out = 0));
      }, f.prototype.onData = function(y) {
        this.chunks.push(y);
      }, f.prototype.onEnd = function(y) {
        y === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = y, this.msg = this.strm.msg;
      }, s.Inflate = f, s.inflate = g, s.inflateRaw = function(y, p) {
        return (p = p || {}).raw = !0, g(y, p);
      }, s.ungzip = g;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, r, s) {
      var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      s.assign = function(l) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var u = c.shift();
          if (u) {
            if (typeof u != "object") throw new TypeError(u + "must be non-object");
            for (var h in u) u.hasOwnProperty(h) && (l[h] = u[h]);
          }
        }
        return l;
      }, s.shrinkBuf = function(l, c) {
        return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
      };
      var o = { arraySet: function(l, c, u, h, d) {
        if (c.subarray && l.subarray) l.set(c.subarray(u, u + h), d);
        else for (var f = 0; f < h; f++) l[d + f] = c[u + f];
      }, flattenChunks: function(l) {
        var c, u, h, d, f, g;
        for (c = h = 0, u = l.length; c < u; c++) h += l[c].length;
        for (g = new Uint8Array(h), c = d = 0, u = l.length; c < u; c++) f = l[c], g.set(f, d), d += f.length;
        return g;
      } }, a = { arraySet: function(l, c, u, h, d) {
        for (var f = 0; f < h; f++) l[d + f] = c[u + f];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      s.setTyped = function(l) {
        l ? (s.Buf8 = Uint8Array, s.Buf16 = Uint16Array, s.Buf32 = Int32Array, s.assign(s, o)) : (s.Buf8 = Array, s.Buf16 = Array, s.Buf32 = Array, s.assign(s, a));
      }, s.setTyped(i);
    }, {}], 42: [function(n, r, s) {
      var i = n("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new i.Buf8(256), c = 0; c < 256; c++) l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function u(h, d) {
        if (d < 65537 && (h.subarray && a || !h.subarray && o)) return String.fromCharCode.apply(null, i.shrinkBuf(h, d));
        for (var f = "", g = 0; g < d; g++) f += String.fromCharCode(h[g]);
        return f;
      }
      l[254] = l[254] = 1, s.string2buf = function(h) {
        var d, f, g, y, p, m = h.length, b = 0;
        for (y = 0; y < m; y++) (64512 & (f = h.charCodeAt(y))) == 55296 && y + 1 < m && (64512 & (g = h.charCodeAt(y + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (g - 56320), y++), b += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (d = new i.Buf8(b), y = p = 0; p < b; y++) (64512 & (f = h.charCodeAt(y))) == 55296 && y + 1 < m && (64512 & (g = h.charCodeAt(y + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (g - 56320), y++), f < 128 ? d[p++] = f : (f < 2048 ? d[p++] = 192 | f >>> 6 : (f < 65536 ? d[p++] = 224 | f >>> 12 : (d[p++] = 240 | f >>> 18, d[p++] = 128 | f >>> 12 & 63), d[p++] = 128 | f >>> 6 & 63), d[p++] = 128 | 63 & f);
        return d;
      }, s.buf2binstring = function(h) {
        return u(h, h.length);
      }, s.binstring2buf = function(h) {
        for (var d = new i.Buf8(h.length), f = 0, g = d.length; f < g; f++) d[f] = h.charCodeAt(f);
        return d;
      }, s.buf2string = function(h, d) {
        var f, g, y, p, m = d || h.length, b = new Array(2 * m);
        for (f = g = 0; f < m; ) if ((y = h[f++]) < 128) b[g++] = y;
        else if (4 < (p = l[y])) b[g++] = 65533, f += p - 1;
        else {
          for (y &= p === 2 ? 31 : p === 3 ? 15 : 7; 1 < p && f < m; ) y = y << 6 | 63 & h[f++], p--;
          1 < p ? b[g++] = 65533 : y < 65536 ? b[g++] = y : (y -= 65536, b[g++] = 55296 | y >> 10 & 1023, b[g++] = 56320 | 1023 & y);
        }
        return u(b, g);
      }, s.utf8border = function(h, d) {
        var f;
        for ((d = d || h.length) > h.length && (d = h.length), f = d - 1; 0 <= f && (192 & h[f]) == 128; ) f--;
        return f < 0 || f === 0 ? d : f + l[h[f]] > d ? f : d;
      };
    }, { "./common": 41 }], 43: [function(n, r, s) {
      r.exports = function(i, o, a, l) {
        for (var c = 65535 & i | 0, u = i >>> 16 & 65535 | 0, h = 0; a !== 0; ) {
          for (a -= h = 2e3 < a ? 2e3 : a; u = u + (c = c + o[l++] | 0) | 0, --h; ) ;
          c %= 65521, u %= 65521;
        }
        return c | u << 16 | 0;
      };
    }, {}], 44: [function(n, r, s) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(n, r, s) {
      var i = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var c = 0; c < 8; c++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      r.exports = function(o, a, l, c) {
        var u = i, h = c + l;
        o ^= -1;
        for (var d = c; d < h; d++) o = o >>> 8 ^ u[255 & (o ^ a[d])];
        return -1 ^ o;
      };
    }, {}], 46: [function(n, r, s) {
      var i, o = n("../utils/common"), a = n("./trees"), l = n("./adler32"), c = n("./crc32"), u = n("./messages"), h = 0, d = 4, f = 0, g = -2, y = -1, p = 4, m = 2, b = 8, _ = 9, v = 286, w = 30, E = 19, x = 2 * v + 1, S = 15, T = 3, R = 258, F = R + T + 1, P = 42, M = 113, A = 1, V = 2, ee = 3, K = 4;
      function te($, ce) {
        return $.msg = u[ce], ce;
      }
      function N($) {
        return ($ << 1) - (4 < $ ? 9 : 0);
      }
      function L($) {
        for (var ce = $.length; 0 <= --ce; ) $[ce] = 0;
      }
      function j($) {
        var ce = $.state, re = ce.pending;
        re > $.avail_out && (re = $.avail_out), re !== 0 && (o.arraySet($.output, ce.pending_buf, ce.pending_out, re, $.next_out), $.next_out += re, ce.pending_out += re, $.total_out += re, $.avail_out -= re, ce.pending -= re, ce.pending === 0 && (ce.pending_out = 0));
      }
      function H($, ce) {
        a._tr_flush_block($, 0 <= $.block_start ? $.block_start : -1, $.strstart - $.block_start, ce), $.block_start = $.strstart, j($.strm);
      }
      function U($, ce) {
        $.pending_buf[$.pending++] = ce;
      }
      function Y($, ce) {
        $.pending_buf[$.pending++] = ce >>> 8 & 255, $.pending_buf[$.pending++] = 255 & ce;
      }
      function ne($, ce) {
        var re, W, q = $.max_chain_length, ie = $.strstart, ye = $.prev_length, xe = $.nice_match, fe = $.strstart > $.w_size - F ? $.strstart - ($.w_size - F) : 0, Ce = $.window, ve = $.w_mask, Ee = $.prev, oe = $.strstart + R, Te = Ce[ie + ye - 1], ke = Ce[ie + ye];
        $.prev_length >= $.good_match && (q >>= 2), xe > $.lookahead && (xe = $.lookahead);
        do
          if (Ce[(re = ce) + ye] === ke && Ce[re + ye - 1] === Te && Ce[re] === Ce[ie] && Ce[++re] === Ce[ie + 1]) {
            ie += 2, re++;
            do
              ;
            while (Ce[++ie] === Ce[++re] && Ce[++ie] === Ce[++re] && Ce[++ie] === Ce[++re] && Ce[++ie] === Ce[++re] && Ce[++ie] === Ce[++re] && Ce[++ie] === Ce[++re] && Ce[++ie] === Ce[++re] && Ce[++ie] === Ce[++re] && ie < oe);
            if (W = R - (oe - ie), ie = oe - R, ye < W) {
              if ($.match_start = ce, xe <= (ye = W)) break;
              Te = Ce[ie + ye - 1], ke = Ce[ie + ye];
            }
          }
        while ((ce = Ee[ce & ve]) > fe && --q != 0);
        return ye <= $.lookahead ? ye : $.lookahead;
      }
      function he($) {
        var ce, re, W, q, ie, ye, xe, fe, Ce, ve, Ee = $.w_size;
        do {
          if (q = $.window_size - $.lookahead - $.strstart, $.strstart >= Ee + (Ee - F)) {
            for (o.arraySet($.window, $.window, Ee, Ee, 0), $.match_start -= Ee, $.strstart -= Ee, $.block_start -= Ee, ce = re = $.hash_size; W = $.head[--ce], $.head[ce] = Ee <= W ? W - Ee : 0, --re; ) ;
            for (ce = re = Ee; W = $.prev[--ce], $.prev[ce] = Ee <= W ? W - Ee : 0, --re; ) ;
            q += Ee;
          }
          if ($.strm.avail_in === 0) break;
          if (ye = $.strm, xe = $.window, fe = $.strstart + $.lookahead, Ce = q, ve = void 0, ve = ye.avail_in, Ce < ve && (ve = Ce), re = ve === 0 ? 0 : (ye.avail_in -= ve, o.arraySet(xe, ye.input, ye.next_in, ve, fe), ye.state.wrap === 1 ? ye.adler = l(ye.adler, xe, ve, fe) : ye.state.wrap === 2 && (ye.adler = c(ye.adler, xe, ve, fe)), ye.next_in += ve, ye.total_in += ve, ve), $.lookahead += re, $.lookahead + $.insert >= T) for (ie = $.strstart - $.insert, $.ins_h = $.window[ie], $.ins_h = ($.ins_h << $.hash_shift ^ $.window[ie + 1]) & $.hash_mask; $.insert && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[ie + T - 1]) & $.hash_mask, $.prev[ie & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = ie, ie++, $.insert--, !($.lookahead + $.insert < T)); ) ;
        } while ($.lookahead < F && $.strm.avail_in !== 0);
      }
      function X($, ce) {
        for (var re, W; ; ) {
          if ($.lookahead < F) {
            if (he($), $.lookahead < F && ce === h) return A;
            if ($.lookahead === 0) break;
          }
          if (re = 0, $.lookahead >= T && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + T - 1]) & $.hash_mask, re = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart), re !== 0 && $.strstart - re <= $.w_size - F && ($.match_length = ne($, re)), $.match_length >= T) if (W = a._tr_tally($, $.strstart - $.match_start, $.match_length - T), $.lookahead -= $.match_length, $.match_length <= $.max_lazy_match && $.lookahead >= T) {
            for ($.match_length--; $.strstart++, $.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + T - 1]) & $.hash_mask, re = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart, --$.match_length != 0; ) ;
            $.strstart++;
          } else $.strstart += $.match_length, $.match_length = 0, $.ins_h = $.window[$.strstart], $.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + 1]) & $.hash_mask;
          else W = a._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++;
          if (W && (H($, !1), $.strm.avail_out === 0)) return A;
        }
        return $.insert = $.strstart < T - 1 ? $.strstart : T - 1, ce === d ? (H($, !0), $.strm.avail_out === 0 ? ee : K) : $.last_lit && (H($, !1), $.strm.avail_out === 0) ? A : V;
      }
      function z($, ce) {
        for (var re, W, q; ; ) {
          if ($.lookahead < F) {
            if (he($), $.lookahead < F && ce === h) return A;
            if ($.lookahead === 0) break;
          }
          if (re = 0, $.lookahead >= T && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + T - 1]) & $.hash_mask, re = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart), $.prev_length = $.match_length, $.prev_match = $.match_start, $.match_length = T - 1, re !== 0 && $.prev_length < $.max_lazy_match && $.strstart - re <= $.w_size - F && ($.match_length = ne($, re), $.match_length <= 5 && ($.strategy === 1 || $.match_length === T && 4096 < $.strstart - $.match_start) && ($.match_length = T - 1)), $.prev_length >= T && $.match_length <= $.prev_length) {
            for (q = $.strstart + $.lookahead - T, W = a._tr_tally($, $.strstart - 1 - $.prev_match, $.prev_length - T), $.lookahead -= $.prev_length - 1, $.prev_length -= 2; ++$.strstart <= q && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + T - 1]) & $.hash_mask, re = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart), --$.prev_length != 0; ) ;
            if ($.match_available = 0, $.match_length = T - 1, $.strstart++, W && (H($, !1), $.strm.avail_out === 0)) return A;
          } else if ($.match_available) {
            if ((W = a._tr_tally($, 0, $.window[$.strstart - 1])) && H($, !1), $.strstart++, $.lookahead--, $.strm.avail_out === 0) return A;
          } else $.match_available = 1, $.strstart++, $.lookahead--;
        }
        return $.match_available && (W = a._tr_tally($, 0, $.window[$.strstart - 1]), $.match_available = 0), $.insert = $.strstart < T - 1 ? $.strstart : T - 1, ce === d ? (H($, !0), $.strm.avail_out === 0 ? ee : K) : $.last_lit && (H($, !1), $.strm.avail_out === 0) ? A : V;
      }
      function ue($, ce, re, W, q) {
        this.good_length = $, this.max_lazy = ce, this.nice_length = re, this.max_chain = W, this.func = q;
      }
      function ae() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = b, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * x), this.dyn_dtree = new o.Buf16(2 * (2 * w + 1)), this.bl_tree = new o.Buf16(2 * (2 * E + 1)), L(this.dyn_ltree), L(this.dyn_dtree), L(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(S + 1), this.heap = new o.Buf16(2 * v + 1), L(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * v + 1), L(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function be($) {
        var ce;
        return $ && $.state ? ($.total_in = $.total_out = 0, $.data_type = m, (ce = $.state).pending = 0, ce.pending_out = 0, ce.wrap < 0 && (ce.wrap = -ce.wrap), ce.status = ce.wrap ? P : M, $.adler = ce.wrap === 2 ? 0 : 1, ce.last_flush = h, a._tr_init(ce), f) : te($, g);
      }
      function de($) {
        var ce = be($);
        return ce === f && function(re) {
          re.window_size = 2 * re.w_size, L(re.head), re.max_lazy_match = i[re.level].max_lazy, re.good_match = i[re.level].good_length, re.nice_match = i[re.level].nice_length, re.max_chain_length = i[re.level].max_chain, re.strstart = 0, re.block_start = 0, re.lookahead = 0, re.insert = 0, re.match_length = re.prev_length = T - 1, re.match_available = 0, re.ins_h = 0;
        }($.state), ce;
      }
      function _e($, ce, re, W, q, ie) {
        if (!$) return g;
        var ye = 1;
        if (ce === y && (ce = 6), W < 0 ? (ye = 0, W = -W) : 15 < W && (ye = 2, W -= 16), q < 1 || _ < q || re !== b || W < 8 || 15 < W || ce < 0 || 9 < ce || ie < 0 || p < ie) return te($, g);
        W === 8 && (W = 9);
        var xe = new ae();
        return ($.state = xe).strm = $, xe.wrap = ye, xe.gzhead = null, xe.w_bits = W, xe.w_size = 1 << xe.w_bits, xe.w_mask = xe.w_size - 1, xe.hash_bits = q + 7, xe.hash_size = 1 << xe.hash_bits, xe.hash_mask = xe.hash_size - 1, xe.hash_shift = ~~((xe.hash_bits + T - 1) / T), xe.window = new o.Buf8(2 * xe.w_size), xe.head = new o.Buf16(xe.hash_size), xe.prev = new o.Buf16(xe.w_size), xe.lit_bufsize = 1 << q + 6, xe.pending_buf_size = 4 * xe.lit_bufsize, xe.pending_buf = new o.Buf8(xe.pending_buf_size), xe.d_buf = 1 * xe.lit_bufsize, xe.l_buf = 3 * xe.lit_bufsize, xe.level = ce, xe.strategy = ie, xe.method = re, de($);
      }
      i = [new ue(0, 0, 0, 0, function($, ce) {
        var re = 65535;
        for (re > $.pending_buf_size - 5 && (re = $.pending_buf_size - 5); ; ) {
          if ($.lookahead <= 1) {
            if (he($), $.lookahead === 0 && ce === h) return A;
            if ($.lookahead === 0) break;
          }
          $.strstart += $.lookahead, $.lookahead = 0;
          var W = $.block_start + re;
          if (($.strstart === 0 || $.strstart >= W) && ($.lookahead = $.strstart - W, $.strstart = W, H($, !1), $.strm.avail_out === 0) || $.strstart - $.block_start >= $.w_size - F && (H($, !1), $.strm.avail_out === 0)) return A;
        }
        return $.insert = 0, ce === d ? (H($, !0), $.strm.avail_out === 0 ? ee : K) : ($.strstart > $.block_start && (H($, !1), $.strm.avail_out), A);
      }), new ue(4, 4, 8, 4, X), new ue(4, 5, 16, 8, X), new ue(4, 6, 32, 32, X), new ue(4, 4, 16, 16, z), new ue(8, 16, 32, 32, z), new ue(8, 16, 128, 128, z), new ue(8, 32, 128, 256, z), new ue(32, 128, 258, 1024, z), new ue(32, 258, 258, 4096, z)], s.deflateInit = function($, ce) {
        return _e($, ce, b, 15, 8, 0);
      }, s.deflateInit2 = _e, s.deflateReset = de, s.deflateResetKeep = be, s.deflateSetHeader = function($, ce) {
        return $ && $.state ? $.state.wrap !== 2 ? g : ($.state.gzhead = ce, f) : g;
      }, s.deflate = function($, ce) {
        var re, W, q, ie;
        if (!$ || !$.state || 5 < ce || ce < 0) return $ ? te($, g) : g;
        if (W = $.state, !$.output || !$.input && $.avail_in !== 0 || W.status === 666 && ce !== d) return te($, $.avail_out === 0 ? -5 : g);
        if (W.strm = $, re = W.last_flush, W.last_flush = ce, W.status === P) if (W.wrap === 2) $.adler = 0, U(W, 31), U(W, 139), U(W, 8), W.gzhead ? (U(W, (W.gzhead.text ? 1 : 0) + (W.gzhead.hcrc ? 2 : 0) + (W.gzhead.extra ? 4 : 0) + (W.gzhead.name ? 8 : 0) + (W.gzhead.comment ? 16 : 0)), U(W, 255 & W.gzhead.time), U(W, W.gzhead.time >> 8 & 255), U(W, W.gzhead.time >> 16 & 255), U(W, W.gzhead.time >> 24 & 255), U(W, W.level === 9 ? 2 : 2 <= W.strategy || W.level < 2 ? 4 : 0), U(W, 255 & W.gzhead.os), W.gzhead.extra && W.gzhead.extra.length && (U(W, 255 & W.gzhead.extra.length), U(W, W.gzhead.extra.length >> 8 & 255)), W.gzhead.hcrc && ($.adler = c($.adler, W.pending_buf, W.pending, 0)), W.gzindex = 0, W.status = 69) : (U(W, 0), U(W, 0), U(W, 0), U(W, 0), U(W, 0), U(W, W.level === 9 ? 2 : 2 <= W.strategy || W.level < 2 ? 4 : 0), U(W, 3), W.status = M);
        else {
          var ye = b + (W.w_bits - 8 << 4) << 8;
          ye |= (2 <= W.strategy || W.level < 2 ? 0 : W.level < 6 ? 1 : W.level === 6 ? 2 : 3) << 6, W.strstart !== 0 && (ye |= 32), ye += 31 - ye % 31, W.status = M, Y(W, ye), W.strstart !== 0 && (Y(W, $.adler >>> 16), Y(W, 65535 & $.adler)), $.adler = 1;
        }
        if (W.status === 69) if (W.gzhead.extra) {
          for (q = W.pending; W.gzindex < (65535 & W.gzhead.extra.length) && (W.pending !== W.pending_buf_size || (W.gzhead.hcrc && W.pending > q && ($.adler = c($.adler, W.pending_buf, W.pending - q, q)), j($), q = W.pending, W.pending !== W.pending_buf_size)); ) U(W, 255 & W.gzhead.extra[W.gzindex]), W.gzindex++;
          W.gzhead.hcrc && W.pending > q && ($.adler = c($.adler, W.pending_buf, W.pending - q, q)), W.gzindex === W.gzhead.extra.length && (W.gzindex = 0, W.status = 73);
        } else W.status = 73;
        if (W.status === 73) if (W.gzhead.name) {
          q = W.pending;
          do {
            if (W.pending === W.pending_buf_size && (W.gzhead.hcrc && W.pending > q && ($.adler = c($.adler, W.pending_buf, W.pending - q, q)), j($), q = W.pending, W.pending === W.pending_buf_size)) {
              ie = 1;
              break;
            }
            ie = W.gzindex < W.gzhead.name.length ? 255 & W.gzhead.name.charCodeAt(W.gzindex++) : 0, U(W, ie);
          } while (ie !== 0);
          W.gzhead.hcrc && W.pending > q && ($.adler = c($.adler, W.pending_buf, W.pending - q, q)), ie === 0 && (W.gzindex = 0, W.status = 91);
        } else W.status = 91;
        if (W.status === 91) if (W.gzhead.comment) {
          q = W.pending;
          do {
            if (W.pending === W.pending_buf_size && (W.gzhead.hcrc && W.pending > q && ($.adler = c($.adler, W.pending_buf, W.pending - q, q)), j($), q = W.pending, W.pending === W.pending_buf_size)) {
              ie = 1;
              break;
            }
            ie = W.gzindex < W.gzhead.comment.length ? 255 & W.gzhead.comment.charCodeAt(W.gzindex++) : 0, U(W, ie);
          } while (ie !== 0);
          W.gzhead.hcrc && W.pending > q && ($.adler = c($.adler, W.pending_buf, W.pending - q, q)), ie === 0 && (W.status = 103);
        } else W.status = 103;
        if (W.status === 103 && (W.gzhead.hcrc ? (W.pending + 2 > W.pending_buf_size && j($), W.pending + 2 <= W.pending_buf_size && (U(W, 255 & $.adler), U(W, $.adler >> 8 & 255), $.adler = 0, W.status = M)) : W.status = M), W.pending !== 0) {
          if (j($), $.avail_out === 0) return W.last_flush = -1, f;
        } else if ($.avail_in === 0 && N(ce) <= N(re) && ce !== d) return te($, -5);
        if (W.status === 666 && $.avail_in !== 0) return te($, -5);
        if ($.avail_in !== 0 || W.lookahead !== 0 || ce !== h && W.status !== 666) {
          var xe = W.strategy === 2 ? function(fe, Ce) {
            for (var ve; ; ) {
              if (fe.lookahead === 0 && (he(fe), fe.lookahead === 0)) {
                if (Ce === h) return A;
                break;
              }
              if (fe.match_length = 0, ve = a._tr_tally(fe, 0, fe.window[fe.strstart]), fe.lookahead--, fe.strstart++, ve && (H(fe, !1), fe.strm.avail_out === 0)) return A;
            }
            return fe.insert = 0, Ce === d ? (H(fe, !0), fe.strm.avail_out === 0 ? ee : K) : fe.last_lit && (H(fe, !1), fe.strm.avail_out === 0) ? A : V;
          }(W, ce) : W.strategy === 3 ? function(fe, Ce) {
            for (var ve, Ee, oe, Te, ke = fe.window; ; ) {
              if (fe.lookahead <= R) {
                if (he(fe), fe.lookahead <= R && Ce === h) return A;
                if (fe.lookahead === 0) break;
              }
              if (fe.match_length = 0, fe.lookahead >= T && 0 < fe.strstart && (Ee = ke[oe = fe.strstart - 1]) === ke[++oe] && Ee === ke[++oe] && Ee === ke[++oe]) {
                Te = fe.strstart + R;
                do
                  ;
                while (Ee === ke[++oe] && Ee === ke[++oe] && Ee === ke[++oe] && Ee === ke[++oe] && Ee === ke[++oe] && Ee === ke[++oe] && Ee === ke[++oe] && Ee === ke[++oe] && oe < Te);
                fe.match_length = R - (Te - oe), fe.match_length > fe.lookahead && (fe.match_length = fe.lookahead);
              }
              if (fe.match_length >= T ? (ve = a._tr_tally(fe, 1, fe.match_length - T), fe.lookahead -= fe.match_length, fe.strstart += fe.match_length, fe.match_length = 0) : (ve = a._tr_tally(fe, 0, fe.window[fe.strstart]), fe.lookahead--, fe.strstart++), ve && (H(fe, !1), fe.strm.avail_out === 0)) return A;
            }
            return fe.insert = 0, Ce === d ? (H(fe, !0), fe.strm.avail_out === 0 ? ee : K) : fe.last_lit && (H(fe, !1), fe.strm.avail_out === 0) ? A : V;
          }(W, ce) : i[W.level].func(W, ce);
          if (xe !== ee && xe !== K || (W.status = 666), xe === A || xe === ee) return $.avail_out === 0 && (W.last_flush = -1), f;
          if (xe === V && (ce === 1 ? a._tr_align(W) : ce !== 5 && (a._tr_stored_block(W, 0, 0, !1), ce === 3 && (L(W.head), W.lookahead === 0 && (W.strstart = 0, W.block_start = 0, W.insert = 0))), j($), $.avail_out === 0)) return W.last_flush = -1, f;
        }
        return ce !== d ? f : W.wrap <= 0 ? 1 : (W.wrap === 2 ? (U(W, 255 & $.adler), U(W, $.adler >> 8 & 255), U(W, $.adler >> 16 & 255), U(W, $.adler >> 24 & 255), U(W, 255 & $.total_in), U(W, $.total_in >> 8 & 255), U(W, $.total_in >> 16 & 255), U(W, $.total_in >> 24 & 255)) : (Y(W, $.adler >>> 16), Y(W, 65535 & $.adler)), j($), 0 < W.wrap && (W.wrap = -W.wrap), W.pending !== 0 ? f : 1);
      }, s.deflateEnd = function($) {
        var ce;
        return $ && $.state ? (ce = $.state.status) !== P && ce !== 69 && ce !== 73 && ce !== 91 && ce !== 103 && ce !== M && ce !== 666 ? te($, g) : ($.state = null, ce === M ? te($, -3) : f) : g;
      }, s.deflateSetDictionary = function($, ce) {
        var re, W, q, ie, ye, xe, fe, Ce, ve = ce.length;
        if (!$ || !$.state || (ie = (re = $.state).wrap) === 2 || ie === 1 && re.status !== P || re.lookahead) return g;
        for (ie === 1 && ($.adler = l($.adler, ce, ve, 0)), re.wrap = 0, ve >= re.w_size && (ie === 0 && (L(re.head), re.strstart = 0, re.block_start = 0, re.insert = 0), Ce = new o.Buf8(re.w_size), o.arraySet(Ce, ce, ve - re.w_size, re.w_size, 0), ce = Ce, ve = re.w_size), ye = $.avail_in, xe = $.next_in, fe = $.input, $.avail_in = ve, $.next_in = 0, $.input = ce, he(re); re.lookahead >= T; ) {
          for (W = re.strstart, q = re.lookahead - (T - 1); re.ins_h = (re.ins_h << re.hash_shift ^ re.window[W + T - 1]) & re.hash_mask, re.prev[W & re.w_mask] = re.head[re.ins_h], re.head[re.ins_h] = W, W++, --q; ) ;
          re.strstart = W, re.lookahead = T - 1, he(re);
        }
        return re.strstart += re.lookahead, re.block_start = re.strstart, re.insert = re.lookahead, re.lookahead = 0, re.match_length = re.prev_length = T - 1, re.match_available = 0, $.next_in = xe, $.input = fe, $.avail_in = ye, re.wrap = ie, f;
      }, s.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, r, s) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(n, r, s) {
      r.exports = function(i, o) {
        var a, l, c, u, h, d, f, g, y, p, m, b, _, v, w, E, x, S, T, R, F, P, M, A, V;
        a = i.state, l = i.next_in, A = i.input, c = l + (i.avail_in - 5), u = i.next_out, V = i.output, h = u - (o - i.avail_out), d = u + (i.avail_out - 257), f = a.dmax, g = a.wsize, y = a.whave, p = a.wnext, m = a.window, b = a.hold, _ = a.bits, v = a.lencode, w = a.distcode, E = (1 << a.lenbits) - 1, x = (1 << a.distbits) - 1;
        e: do {
          _ < 15 && (b += A[l++] << _, _ += 8, b += A[l++] << _, _ += 8), S = v[b & E];
          t: for (; ; ) {
            if (b >>>= T = S >>> 24, _ -= T, (T = S >>> 16 & 255) === 0) V[u++] = 65535 & S;
            else {
              if (!(16 & T)) {
                if (!(64 & T)) {
                  S = v[(65535 & S) + (b & (1 << T) - 1)];
                  continue t;
                }
                if (32 & T) {
                  a.mode = 12;
                  break e;
                }
                i.msg = "invalid literal/length code", a.mode = 30;
                break e;
              }
              R = 65535 & S, (T &= 15) && (_ < T && (b += A[l++] << _, _ += 8), R += b & (1 << T) - 1, b >>>= T, _ -= T), _ < 15 && (b += A[l++] << _, _ += 8, b += A[l++] << _, _ += 8), S = w[b & x];
              n: for (; ; ) {
                if (b >>>= T = S >>> 24, _ -= T, !(16 & (T = S >>> 16 & 255))) {
                  if (!(64 & T)) {
                    S = w[(65535 & S) + (b & (1 << T) - 1)];
                    continue n;
                  }
                  i.msg = "invalid distance code", a.mode = 30;
                  break e;
                }
                if (F = 65535 & S, _ < (T &= 15) && (b += A[l++] << _, (_ += 8) < T && (b += A[l++] << _, _ += 8)), f < (F += b & (1 << T) - 1)) {
                  i.msg = "invalid distance too far back", a.mode = 30;
                  break e;
                }
                if (b >>>= T, _ -= T, (T = u - h) < F) {
                  if (y < (T = F - T) && a.sane) {
                    i.msg = "invalid distance too far back", a.mode = 30;
                    break e;
                  }
                  if (M = m, (P = 0) === p) {
                    if (P += g - T, T < R) {
                      for (R -= T; V[u++] = m[P++], --T; ) ;
                      P = u - F, M = V;
                    }
                  } else if (p < T) {
                    if (P += g + p - T, (T -= p) < R) {
                      for (R -= T; V[u++] = m[P++], --T; ) ;
                      if (P = 0, p < R) {
                        for (R -= T = p; V[u++] = m[P++], --T; ) ;
                        P = u - F, M = V;
                      }
                    }
                  } else if (P += p - T, T < R) {
                    for (R -= T; V[u++] = m[P++], --T; ) ;
                    P = u - F, M = V;
                  }
                  for (; 2 < R; ) V[u++] = M[P++], V[u++] = M[P++], V[u++] = M[P++], R -= 3;
                  R && (V[u++] = M[P++], 1 < R && (V[u++] = M[P++]));
                } else {
                  for (P = u - F; V[u++] = V[P++], V[u++] = V[P++], V[u++] = V[P++], 2 < (R -= 3); ) ;
                  R && (V[u++] = V[P++], 1 < R && (V[u++] = V[P++]));
                }
                break;
              }
            }
            break;
          }
        } while (l < c && u < d);
        l -= R = _ >> 3, b &= (1 << (_ -= R << 3)) - 1, i.next_in = l, i.next_out = u, i.avail_in = l < c ? c - l + 5 : 5 - (l - c), i.avail_out = u < d ? d - u + 257 : 257 - (u - d), a.hold = b, a.bits = _;
      };
    }, {}], 49: [function(n, r, s) {
      var i = n("../utils/common"), o = n("./adler32"), a = n("./crc32"), l = n("./inffast"), c = n("./inftrees"), u = 1, h = 2, d = 0, f = -2, g = 1, y = 852, p = 592;
      function m(P) {
        return (P >>> 24 & 255) + (P >>> 8 & 65280) + ((65280 & P) << 8) + ((255 & P) << 24);
      }
      function b() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i.Buf16(320), this.work = new i.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function _(P) {
        var M;
        return P && P.state ? (M = P.state, P.total_in = P.total_out = M.total = 0, P.msg = "", M.wrap && (P.adler = 1 & M.wrap), M.mode = g, M.last = 0, M.havedict = 0, M.dmax = 32768, M.head = null, M.hold = 0, M.bits = 0, M.lencode = M.lendyn = new i.Buf32(y), M.distcode = M.distdyn = new i.Buf32(p), M.sane = 1, M.back = -1, d) : f;
      }
      function v(P) {
        var M;
        return P && P.state ? ((M = P.state).wsize = 0, M.whave = 0, M.wnext = 0, _(P)) : f;
      }
      function w(P, M) {
        var A, V;
        return P && P.state ? (V = P.state, M < 0 ? (A = 0, M = -M) : (A = 1 + (M >> 4), M < 48 && (M &= 15)), M && (M < 8 || 15 < M) ? f : (V.window !== null && V.wbits !== M && (V.window = null), V.wrap = A, V.wbits = M, v(P))) : f;
      }
      function E(P, M) {
        var A, V;
        return P ? (V = new b(), (P.state = V).window = null, (A = w(P, M)) !== d && (P.state = null), A) : f;
      }
      var x, S, T = !0;
      function R(P) {
        if (T) {
          var M;
          for (x = new i.Buf32(512), S = new i.Buf32(32), M = 0; M < 144; ) P.lens[M++] = 8;
          for (; M < 256; ) P.lens[M++] = 9;
          for (; M < 280; ) P.lens[M++] = 7;
          for (; M < 288; ) P.lens[M++] = 8;
          for (c(u, P.lens, 0, 288, x, 0, P.work, { bits: 9 }), M = 0; M < 32; ) P.lens[M++] = 5;
          c(h, P.lens, 0, 32, S, 0, P.work, { bits: 5 }), T = !1;
        }
        P.lencode = x, P.lenbits = 9, P.distcode = S, P.distbits = 5;
      }
      function F(P, M, A, V) {
        var ee, K = P.state;
        return K.window === null && (K.wsize = 1 << K.wbits, K.wnext = 0, K.whave = 0, K.window = new i.Buf8(K.wsize)), V >= K.wsize ? (i.arraySet(K.window, M, A - K.wsize, K.wsize, 0), K.wnext = 0, K.whave = K.wsize) : (V < (ee = K.wsize - K.wnext) && (ee = V), i.arraySet(K.window, M, A - V, ee, K.wnext), (V -= ee) ? (i.arraySet(K.window, M, A - V, V, 0), K.wnext = V, K.whave = K.wsize) : (K.wnext += ee, K.wnext === K.wsize && (K.wnext = 0), K.whave < K.wsize && (K.whave += ee))), 0;
      }
      s.inflateReset = v, s.inflateReset2 = w, s.inflateResetKeep = _, s.inflateInit = function(P) {
        return E(P, 15);
      }, s.inflateInit2 = E, s.inflate = function(P, M) {
        var A, V, ee, K, te, N, L, j, H, U, Y, ne, he, X, z, ue, ae, be, de, _e, $, ce, re, W, q = 0, ie = new i.Buf8(4), ye = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!P || !P.state || !P.output || !P.input && P.avail_in !== 0) return f;
        (A = P.state).mode === 12 && (A.mode = 13), te = P.next_out, ee = P.output, L = P.avail_out, K = P.next_in, V = P.input, N = P.avail_in, j = A.hold, H = A.bits, U = N, Y = L, ce = d;
        e: for (; ; ) switch (A.mode) {
          case g:
            if (A.wrap === 0) {
              A.mode = 13;
              break;
            }
            for (; H < 16; ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            if (2 & A.wrap && j === 35615) {
              ie[A.check = 0] = 255 & j, ie[1] = j >>> 8 & 255, A.check = a(A.check, ie, 2, 0), H = j = 0, A.mode = 2;
              break;
            }
            if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & j) << 8) + (j >> 8)) % 31) {
              P.msg = "incorrect header check", A.mode = 30;
              break;
            }
            if ((15 & j) != 8) {
              P.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (H -= 4, $ = 8 + (15 & (j >>>= 4)), A.wbits === 0) A.wbits = $;
            else if ($ > A.wbits) {
              P.msg = "invalid window size", A.mode = 30;
              break;
            }
            A.dmax = 1 << $, P.adler = A.check = 1, A.mode = 512 & j ? 10 : 12, H = j = 0;
            break;
          case 2:
            for (; H < 16; ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            if (A.flags = j, (255 & A.flags) != 8) {
              P.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (57344 & A.flags) {
              P.msg = "unknown header flags set", A.mode = 30;
              break;
            }
            A.head && (A.head.text = j >> 8 & 1), 512 & A.flags && (ie[0] = 255 & j, ie[1] = j >>> 8 & 255, A.check = a(A.check, ie, 2, 0)), H = j = 0, A.mode = 3;
          case 3:
            for (; H < 32; ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            A.head && (A.head.time = j), 512 & A.flags && (ie[0] = 255 & j, ie[1] = j >>> 8 & 255, ie[2] = j >>> 16 & 255, ie[3] = j >>> 24 & 255, A.check = a(A.check, ie, 4, 0)), H = j = 0, A.mode = 4;
          case 4:
            for (; H < 16; ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            A.head && (A.head.xflags = 255 & j, A.head.os = j >> 8), 512 & A.flags && (ie[0] = 255 & j, ie[1] = j >>> 8 & 255, A.check = a(A.check, ie, 2, 0)), H = j = 0, A.mode = 5;
          case 5:
            if (1024 & A.flags) {
              for (; H < 16; ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              A.length = j, A.head && (A.head.extra_len = j), 512 & A.flags && (ie[0] = 255 & j, ie[1] = j >>> 8 & 255, A.check = a(A.check, ie, 2, 0)), H = j = 0;
            } else A.head && (A.head.extra = null);
            A.mode = 6;
          case 6:
            if (1024 & A.flags && (N < (ne = A.length) && (ne = N), ne && (A.head && ($ = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), i.arraySet(A.head.extra, V, K, ne, $)), 512 & A.flags && (A.check = a(A.check, V, ne, K)), N -= ne, K += ne, A.length -= ne), A.length)) break e;
            A.length = 0, A.mode = 7;
          case 7:
            if (2048 & A.flags) {
              if (N === 0) break e;
              for (ne = 0; $ = V[K + ne++], A.head && $ && A.length < 65536 && (A.head.name += String.fromCharCode($)), $ && ne < N; ) ;
              if (512 & A.flags && (A.check = a(A.check, V, ne, K)), N -= ne, K += ne, $) break e;
            } else A.head && (A.head.name = null);
            A.length = 0, A.mode = 8;
          case 8:
            if (4096 & A.flags) {
              if (N === 0) break e;
              for (ne = 0; $ = V[K + ne++], A.head && $ && A.length < 65536 && (A.head.comment += String.fromCharCode($)), $ && ne < N; ) ;
              if (512 & A.flags && (A.check = a(A.check, V, ne, K)), N -= ne, K += ne, $) break e;
            } else A.head && (A.head.comment = null);
            A.mode = 9;
          case 9:
            if (512 & A.flags) {
              for (; H < 16; ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              if (j !== (65535 & A.check)) {
                P.msg = "header crc mismatch", A.mode = 30;
                break;
              }
              H = j = 0;
            }
            A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), P.adler = A.check = 0, A.mode = 12;
            break;
          case 10:
            for (; H < 32; ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            P.adler = A.check = m(j), H = j = 0, A.mode = 11;
          case 11:
            if (A.havedict === 0) return P.next_out = te, P.avail_out = L, P.next_in = K, P.avail_in = N, A.hold = j, A.bits = H, 2;
            P.adler = A.check = 1, A.mode = 12;
          case 12:
            if (M === 5 || M === 6) break e;
          case 13:
            if (A.last) {
              j >>>= 7 & H, H -= 7 & H, A.mode = 27;
              break;
            }
            for (; H < 3; ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            switch (A.last = 1 & j, H -= 1, 3 & (j >>>= 1)) {
              case 0:
                A.mode = 14;
                break;
              case 1:
                if (R(A), A.mode = 20, M !== 6) break;
                j >>>= 2, H -= 2;
                break e;
              case 2:
                A.mode = 17;
                break;
              case 3:
                P.msg = "invalid block type", A.mode = 30;
            }
            j >>>= 2, H -= 2;
            break;
          case 14:
            for (j >>>= 7 & H, H -= 7 & H; H < 32; ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            if ((65535 & j) != (j >>> 16 ^ 65535)) {
              P.msg = "invalid stored block lengths", A.mode = 30;
              break;
            }
            if (A.length = 65535 & j, H = j = 0, A.mode = 15, M === 6) break e;
          case 15:
            A.mode = 16;
          case 16:
            if (ne = A.length) {
              if (N < ne && (ne = N), L < ne && (ne = L), ne === 0) break e;
              i.arraySet(ee, V, K, ne, te), N -= ne, K += ne, L -= ne, te += ne, A.length -= ne;
              break;
            }
            A.mode = 12;
            break;
          case 17:
            for (; H < 14; ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            if (A.nlen = 257 + (31 & j), j >>>= 5, H -= 5, A.ndist = 1 + (31 & j), j >>>= 5, H -= 5, A.ncode = 4 + (15 & j), j >>>= 4, H -= 4, 286 < A.nlen || 30 < A.ndist) {
              P.msg = "too many length or distance symbols", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 18;
          case 18:
            for (; A.have < A.ncode; ) {
              for (; H < 3; ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              A.lens[ye[A.have++]] = 7 & j, j >>>= 3, H -= 3;
            }
            for (; A.have < 19; ) A.lens[ye[A.have++]] = 0;
            if (A.lencode = A.lendyn, A.lenbits = 7, re = { bits: A.lenbits }, ce = c(0, A.lens, 0, 19, A.lencode, 0, A.work, re), A.lenbits = re.bits, ce) {
              P.msg = "invalid code lengths set", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 19;
          case 19:
            for (; A.have < A.nlen + A.ndist; ) {
              for (; ue = (q = A.lencode[j & (1 << A.lenbits) - 1]) >>> 16 & 255, ae = 65535 & q, !((z = q >>> 24) <= H); ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              if (ae < 16) j >>>= z, H -= z, A.lens[A.have++] = ae;
              else {
                if (ae === 16) {
                  for (W = z + 2; H < W; ) {
                    if (N === 0) break e;
                    N--, j += V[K++] << H, H += 8;
                  }
                  if (j >>>= z, H -= z, A.have === 0) {
                    P.msg = "invalid bit length repeat", A.mode = 30;
                    break;
                  }
                  $ = A.lens[A.have - 1], ne = 3 + (3 & j), j >>>= 2, H -= 2;
                } else if (ae === 17) {
                  for (W = z + 3; H < W; ) {
                    if (N === 0) break e;
                    N--, j += V[K++] << H, H += 8;
                  }
                  H -= z, $ = 0, ne = 3 + (7 & (j >>>= z)), j >>>= 3, H -= 3;
                } else {
                  for (W = z + 7; H < W; ) {
                    if (N === 0) break e;
                    N--, j += V[K++] << H, H += 8;
                  }
                  H -= z, $ = 0, ne = 11 + (127 & (j >>>= z)), j >>>= 7, H -= 7;
                }
                if (A.have + ne > A.nlen + A.ndist) {
                  P.msg = "invalid bit length repeat", A.mode = 30;
                  break;
                }
                for (; ne--; ) A.lens[A.have++] = $;
              }
            }
            if (A.mode === 30) break;
            if (A.lens[256] === 0) {
              P.msg = "invalid code -- missing end-of-block", A.mode = 30;
              break;
            }
            if (A.lenbits = 9, re = { bits: A.lenbits }, ce = c(u, A.lens, 0, A.nlen, A.lencode, 0, A.work, re), A.lenbits = re.bits, ce) {
              P.msg = "invalid literal/lengths set", A.mode = 30;
              break;
            }
            if (A.distbits = 6, A.distcode = A.distdyn, re = { bits: A.distbits }, ce = c(h, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, re), A.distbits = re.bits, ce) {
              P.msg = "invalid distances set", A.mode = 30;
              break;
            }
            if (A.mode = 20, M === 6) break e;
          case 20:
            A.mode = 21;
          case 21:
            if (6 <= N && 258 <= L) {
              P.next_out = te, P.avail_out = L, P.next_in = K, P.avail_in = N, A.hold = j, A.bits = H, l(P, Y), te = P.next_out, ee = P.output, L = P.avail_out, K = P.next_in, V = P.input, N = P.avail_in, j = A.hold, H = A.bits, A.mode === 12 && (A.back = -1);
              break;
            }
            for (A.back = 0; ue = (q = A.lencode[j & (1 << A.lenbits) - 1]) >>> 16 & 255, ae = 65535 & q, !((z = q >>> 24) <= H); ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            if (ue && !(240 & ue)) {
              for (be = z, de = ue, _e = ae; ue = (q = A.lencode[_e + ((j & (1 << be + de) - 1) >> be)]) >>> 16 & 255, ae = 65535 & q, !(be + (z = q >>> 24) <= H); ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              j >>>= be, H -= be, A.back += be;
            }
            if (j >>>= z, H -= z, A.back += z, A.length = ae, ue === 0) {
              A.mode = 26;
              break;
            }
            if (32 & ue) {
              A.back = -1, A.mode = 12;
              break;
            }
            if (64 & ue) {
              P.msg = "invalid literal/length code", A.mode = 30;
              break;
            }
            A.extra = 15 & ue, A.mode = 22;
          case 22:
            if (A.extra) {
              for (W = A.extra; H < W; ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              A.length += j & (1 << A.extra) - 1, j >>>= A.extra, H -= A.extra, A.back += A.extra;
            }
            A.was = A.length, A.mode = 23;
          case 23:
            for (; ue = (q = A.distcode[j & (1 << A.distbits) - 1]) >>> 16 & 255, ae = 65535 & q, !((z = q >>> 24) <= H); ) {
              if (N === 0) break e;
              N--, j += V[K++] << H, H += 8;
            }
            if (!(240 & ue)) {
              for (be = z, de = ue, _e = ae; ue = (q = A.distcode[_e + ((j & (1 << be + de) - 1) >> be)]) >>> 16 & 255, ae = 65535 & q, !(be + (z = q >>> 24) <= H); ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              j >>>= be, H -= be, A.back += be;
            }
            if (j >>>= z, H -= z, A.back += z, 64 & ue) {
              P.msg = "invalid distance code", A.mode = 30;
              break;
            }
            A.offset = ae, A.extra = 15 & ue, A.mode = 24;
          case 24:
            if (A.extra) {
              for (W = A.extra; H < W; ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              A.offset += j & (1 << A.extra) - 1, j >>>= A.extra, H -= A.extra, A.back += A.extra;
            }
            if (A.offset > A.dmax) {
              P.msg = "invalid distance too far back", A.mode = 30;
              break;
            }
            A.mode = 25;
          case 25:
            if (L === 0) break e;
            if (ne = Y - L, A.offset > ne) {
              if ((ne = A.offset - ne) > A.whave && A.sane) {
                P.msg = "invalid distance too far back", A.mode = 30;
                break;
              }
              he = ne > A.wnext ? (ne -= A.wnext, A.wsize - ne) : A.wnext - ne, ne > A.length && (ne = A.length), X = A.window;
            } else X = ee, he = te - A.offset, ne = A.length;
            for (L < ne && (ne = L), L -= ne, A.length -= ne; ee[te++] = X[he++], --ne; ) ;
            A.length === 0 && (A.mode = 21);
            break;
          case 26:
            if (L === 0) break e;
            ee[te++] = A.length, L--, A.mode = 21;
            break;
          case 27:
            if (A.wrap) {
              for (; H < 32; ) {
                if (N === 0) break e;
                N--, j |= V[K++] << H, H += 8;
              }
              if (Y -= L, P.total_out += Y, A.total += Y, Y && (P.adler = A.check = A.flags ? a(A.check, ee, Y, te - Y) : o(A.check, ee, Y, te - Y)), Y = L, (A.flags ? j : m(j)) !== A.check) {
                P.msg = "incorrect data check", A.mode = 30;
                break;
              }
              H = j = 0;
            }
            A.mode = 28;
          case 28:
            if (A.wrap && A.flags) {
              for (; H < 32; ) {
                if (N === 0) break e;
                N--, j += V[K++] << H, H += 8;
              }
              if (j !== (4294967295 & A.total)) {
                P.msg = "incorrect length check", A.mode = 30;
                break;
              }
              H = j = 0;
            }
            A.mode = 29;
          case 29:
            ce = 1;
            break e;
          case 30:
            ce = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return f;
        }
        return P.next_out = te, P.avail_out = L, P.next_in = K, P.avail_in = N, A.hold = j, A.bits = H, (A.wsize || Y !== P.avail_out && A.mode < 30 && (A.mode < 27 || M !== 4)) && F(P, P.output, P.next_out, Y - P.avail_out) ? (A.mode = 31, -4) : (U -= P.avail_in, Y -= P.avail_out, P.total_in += U, P.total_out += Y, A.total += Y, A.wrap && Y && (P.adler = A.check = A.flags ? a(A.check, ee, Y, P.next_out - Y) : o(A.check, ee, Y, P.next_out - Y)), P.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (U == 0 && Y === 0 || M === 4) && ce === d && (ce = -5), ce);
      }, s.inflateEnd = function(P) {
        if (!P || !P.state) return f;
        var M = P.state;
        return M.window && (M.window = null), P.state = null, d;
      }, s.inflateGetHeader = function(P, M) {
        var A;
        return P && P.state && 2 & (A = P.state).wrap ? ((A.head = M).done = !1, d) : f;
      }, s.inflateSetDictionary = function(P, M) {
        var A, V = M.length;
        return P && P.state ? (A = P.state).wrap !== 0 && A.mode !== 11 ? f : A.mode === 11 && o(1, M, V, 0) !== A.check ? -3 : F(P, M, V, V) ? (A.mode = 31, -4) : (A.havedict = 1, d) : f;
      }, s.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, r, s) {
      var i = n("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(u, h, d, f, g, y, p, m) {
        var b, _, v, w, E, x, S, T, R, F = m.bits, P = 0, M = 0, A = 0, V = 0, ee = 0, K = 0, te = 0, N = 0, L = 0, j = 0, H = null, U = 0, Y = new i.Buf16(16), ne = new i.Buf16(16), he = null, X = 0;
        for (P = 0; P <= 15; P++) Y[P] = 0;
        for (M = 0; M < f; M++) Y[h[d + M]]++;
        for (ee = F, V = 15; 1 <= V && Y[V] === 0; V--) ;
        if (V < ee && (ee = V), V === 0) return g[y++] = 20971520, g[y++] = 20971520, m.bits = 1, 0;
        for (A = 1; A < V && Y[A] === 0; A++) ;
        for (ee < A && (ee = A), P = N = 1; P <= 15; P++) if (N <<= 1, (N -= Y[P]) < 0) return -1;
        if (0 < N && (u === 0 || V !== 1)) return -1;
        for (ne[1] = 0, P = 1; P < 15; P++) ne[P + 1] = ne[P] + Y[P];
        for (M = 0; M < f; M++) h[d + M] !== 0 && (p[ne[h[d + M]]++] = M);
        if (x = u === 0 ? (H = he = p, 19) : u === 1 ? (H = o, U -= 257, he = a, X -= 257, 256) : (H = l, he = c, -1), P = A, E = y, te = M = j = 0, v = -1, w = (L = 1 << (K = ee)) - 1, u === 1 && 852 < L || u === 2 && 592 < L) return 1;
        for (; ; ) {
          for (S = P - te, R = p[M] < x ? (T = 0, p[M]) : p[M] > x ? (T = he[X + p[M]], H[U + p[M]]) : (T = 96, 0), b = 1 << P - te, A = _ = 1 << K; g[E + (j >> te) + (_ -= b)] = S << 24 | T << 16 | R | 0, _ !== 0; ) ;
          for (b = 1 << P - 1; j & b; ) b >>= 1;
          if (b !== 0 ? (j &= b - 1, j += b) : j = 0, M++, --Y[P] == 0) {
            if (P === V) break;
            P = h[d + p[M]];
          }
          if (ee < P && (j & w) !== v) {
            for (te === 0 && (te = ee), E += A, N = 1 << (K = P - te); K + te < V && !((N -= Y[K + te]) <= 0); ) K++, N <<= 1;
            if (L += 1 << K, u === 1 && 852 < L || u === 2 && 592 < L) return 1;
            g[v = j & w] = ee << 24 | K << 16 | E - y | 0;
          }
        }
        return j !== 0 && (g[E + j] = P - te << 24 | 64 << 16 | 0), m.bits = ee, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, r, s) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(n, r, s) {
      var i = n("../utils/common"), o = 0, a = 1;
      function l(q) {
        for (var ie = q.length; 0 <= --ie; ) q[ie] = 0;
      }
      var c = 0, u = 29, h = 256, d = h + 1 + u, f = 30, g = 19, y = 2 * d + 1, p = 15, m = 16, b = 7, _ = 256, v = 16, w = 17, E = 18, x = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], S = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], R = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], F = new Array(2 * (d + 2));
      l(F);
      var P = new Array(2 * f);
      l(P);
      var M = new Array(512);
      l(M);
      var A = new Array(256);
      l(A);
      var V = new Array(u);
      l(V);
      var ee, K, te, N = new Array(f);
      function L(q, ie, ye, xe, fe) {
        this.static_tree = q, this.extra_bits = ie, this.extra_base = ye, this.elems = xe, this.max_length = fe, this.has_stree = q && q.length;
      }
      function j(q, ie) {
        this.dyn_tree = q, this.max_code = 0, this.stat_desc = ie;
      }
      function H(q) {
        return q < 256 ? M[q] : M[256 + (q >>> 7)];
      }
      function U(q, ie) {
        q.pending_buf[q.pending++] = 255 & ie, q.pending_buf[q.pending++] = ie >>> 8 & 255;
      }
      function Y(q, ie, ye) {
        q.bi_valid > m - ye ? (q.bi_buf |= ie << q.bi_valid & 65535, U(q, q.bi_buf), q.bi_buf = ie >> m - q.bi_valid, q.bi_valid += ye - m) : (q.bi_buf |= ie << q.bi_valid & 65535, q.bi_valid += ye);
      }
      function ne(q, ie, ye) {
        Y(q, ye[2 * ie], ye[2 * ie + 1]);
      }
      function he(q, ie) {
        for (var ye = 0; ye |= 1 & q, q >>>= 1, ye <<= 1, 0 < --ie; ) ;
        return ye >>> 1;
      }
      function X(q, ie, ye) {
        var xe, fe, Ce = new Array(p + 1), ve = 0;
        for (xe = 1; xe <= p; xe++) Ce[xe] = ve = ve + ye[xe - 1] << 1;
        for (fe = 0; fe <= ie; fe++) {
          var Ee = q[2 * fe + 1];
          Ee !== 0 && (q[2 * fe] = he(Ce[Ee]++, Ee));
        }
      }
      function z(q) {
        var ie;
        for (ie = 0; ie < d; ie++) q.dyn_ltree[2 * ie] = 0;
        for (ie = 0; ie < f; ie++) q.dyn_dtree[2 * ie] = 0;
        for (ie = 0; ie < g; ie++) q.bl_tree[2 * ie] = 0;
        q.dyn_ltree[2 * _] = 1, q.opt_len = q.static_len = 0, q.last_lit = q.matches = 0;
      }
      function ue(q) {
        8 < q.bi_valid ? U(q, q.bi_buf) : 0 < q.bi_valid && (q.pending_buf[q.pending++] = q.bi_buf), q.bi_buf = 0, q.bi_valid = 0;
      }
      function ae(q, ie, ye, xe) {
        var fe = 2 * ie, Ce = 2 * ye;
        return q[fe] < q[Ce] || q[fe] === q[Ce] && xe[ie] <= xe[ye];
      }
      function be(q, ie, ye) {
        for (var xe = q.heap[ye], fe = ye << 1; fe <= q.heap_len && (fe < q.heap_len && ae(ie, q.heap[fe + 1], q.heap[fe], q.depth) && fe++, !ae(ie, xe, q.heap[fe], q.depth)); ) q.heap[ye] = q.heap[fe], ye = fe, fe <<= 1;
        q.heap[ye] = xe;
      }
      function de(q, ie, ye) {
        var xe, fe, Ce, ve, Ee = 0;
        if (q.last_lit !== 0) for (; xe = q.pending_buf[q.d_buf + 2 * Ee] << 8 | q.pending_buf[q.d_buf + 2 * Ee + 1], fe = q.pending_buf[q.l_buf + Ee], Ee++, xe === 0 ? ne(q, fe, ie) : (ne(q, (Ce = A[fe]) + h + 1, ie), (ve = x[Ce]) !== 0 && Y(q, fe -= V[Ce], ve), ne(q, Ce = H(--xe), ye), (ve = S[Ce]) !== 0 && Y(q, xe -= N[Ce], ve)), Ee < q.last_lit; ) ;
        ne(q, _, ie);
      }
      function _e(q, ie) {
        var ye, xe, fe, Ce = ie.dyn_tree, ve = ie.stat_desc.static_tree, Ee = ie.stat_desc.has_stree, oe = ie.stat_desc.elems, Te = -1;
        for (q.heap_len = 0, q.heap_max = y, ye = 0; ye < oe; ye++) Ce[2 * ye] !== 0 ? (q.heap[++q.heap_len] = Te = ye, q.depth[ye] = 0) : Ce[2 * ye + 1] = 0;
        for (; q.heap_len < 2; ) Ce[2 * (fe = q.heap[++q.heap_len] = Te < 2 ? ++Te : 0)] = 1, q.depth[fe] = 0, q.opt_len--, Ee && (q.static_len -= ve[2 * fe + 1]);
        for (ie.max_code = Te, ye = q.heap_len >> 1; 1 <= ye; ye--) be(q, Ce, ye);
        for (fe = oe; ye = q.heap[1], q.heap[1] = q.heap[q.heap_len--], be(q, Ce, 1), xe = q.heap[1], q.heap[--q.heap_max] = ye, q.heap[--q.heap_max] = xe, Ce[2 * fe] = Ce[2 * ye] + Ce[2 * xe], q.depth[fe] = (q.depth[ye] >= q.depth[xe] ? q.depth[ye] : q.depth[xe]) + 1, Ce[2 * ye + 1] = Ce[2 * xe + 1] = fe, q.heap[1] = fe++, be(q, Ce, 1), 2 <= q.heap_len; ) ;
        q.heap[--q.heap_max] = q.heap[1], function(ke, Ge) {
          var G, O, B, Z, le, ge, we = Ge.dyn_tree, Je = Ge.max_code, ft = Ge.stat_desc.static_tree, Ot = Ge.stat_desc.has_stree, Bt = Ge.stat_desc.extra_bits, Ct = Ge.stat_desc.extra_base, Yu = Ge.stat_desc.max_length, Lp = 0;
          for (Z = 0; Z <= p; Z++) ke.bl_count[Z] = 0;
          for (we[2 * ke.heap[ke.heap_max] + 1] = 0, G = ke.heap_max + 1; G < y; G++) Yu < (Z = we[2 * we[2 * (O = ke.heap[G]) + 1] + 1] + 1) && (Z = Yu, Lp++), we[2 * O + 1] = Z, Je < O || (ke.bl_count[Z]++, le = 0, Ct <= O && (le = Bt[O - Ct]), ge = we[2 * O], ke.opt_len += ge * (Z + le), Ot && (ke.static_len += ge * (ft[2 * O + 1] + le)));
          if (Lp !== 0) {
            do {
              for (Z = Yu - 1; ke.bl_count[Z] === 0; ) Z--;
              ke.bl_count[Z]--, ke.bl_count[Z + 1] += 2, ke.bl_count[Yu]--, Lp -= 2;
            } while (0 < Lp);
            for (Z = Yu; Z !== 0; Z--) for (O = ke.bl_count[Z]; O !== 0; ) Je < (B = ke.heap[--G]) || (we[2 * B + 1] !== Z && (ke.opt_len += (Z - we[2 * B + 1]) * we[2 * B], we[2 * B + 1] = Z), O--);
          }
        }(q, ie), X(Ce, Te, q.bl_count);
      }
      function $(q, ie, ye) {
        var xe, fe, Ce = -1, ve = ie[1], Ee = 0, oe = 7, Te = 4;
        for (ve === 0 && (oe = 138, Te = 3), ie[2 * (ye + 1) + 1] = 65535, xe = 0; xe <= ye; xe++) fe = ve, ve = ie[2 * (xe + 1) + 1], ++Ee < oe && fe === ve || (Ee < Te ? q.bl_tree[2 * fe] += Ee : fe !== 0 ? (fe !== Ce && q.bl_tree[2 * fe]++, q.bl_tree[2 * v]++) : Ee <= 10 ? q.bl_tree[2 * w]++ : q.bl_tree[2 * E]++, Ce = fe, Te = (Ee = 0) === ve ? (oe = 138, 3) : fe === ve ? (oe = 6, 3) : (oe = 7, 4));
      }
      function ce(q, ie, ye) {
        var xe, fe, Ce = -1, ve = ie[1], Ee = 0, oe = 7, Te = 4;
        for (ve === 0 && (oe = 138, Te = 3), xe = 0; xe <= ye; xe++) if (fe = ve, ve = ie[2 * (xe + 1) + 1], !(++Ee < oe && fe === ve)) {
          if (Ee < Te) for (; ne(q, fe, q.bl_tree), --Ee != 0; ) ;
          else fe !== 0 ? (fe !== Ce && (ne(q, fe, q.bl_tree), Ee--), ne(q, v, q.bl_tree), Y(q, Ee - 3, 2)) : Ee <= 10 ? (ne(q, w, q.bl_tree), Y(q, Ee - 3, 3)) : (ne(q, E, q.bl_tree), Y(q, Ee - 11, 7));
          Ce = fe, Te = (Ee = 0) === ve ? (oe = 138, 3) : fe === ve ? (oe = 6, 3) : (oe = 7, 4);
        }
      }
      l(N);
      var re = !1;
      function W(q, ie, ye, xe) {
        Y(q, (c << 1) + (xe ? 1 : 0), 3), function(fe, Ce, ve, Ee) {
          ue(fe), U(fe, ve), U(fe, ~ve), i.arraySet(fe.pending_buf, fe.window, Ce, ve, fe.pending), fe.pending += ve;
        }(q, ie, ye);
      }
      s._tr_init = function(q) {
        re || (function() {
          var ie, ye, xe, fe, Ce, ve = new Array(p + 1);
          for (fe = xe = 0; fe < u - 1; fe++) for (V[fe] = xe, ie = 0; ie < 1 << x[fe]; ie++) A[xe++] = fe;
          for (A[xe - 1] = fe, fe = Ce = 0; fe < 16; fe++) for (N[fe] = Ce, ie = 0; ie < 1 << S[fe]; ie++) M[Ce++] = fe;
          for (Ce >>= 7; fe < f; fe++) for (N[fe] = Ce << 7, ie = 0; ie < 1 << S[fe] - 7; ie++) M[256 + Ce++] = fe;
          for (ye = 0; ye <= p; ye++) ve[ye] = 0;
          for (ie = 0; ie <= 143; ) F[2 * ie + 1] = 8, ie++, ve[8]++;
          for (; ie <= 255; ) F[2 * ie + 1] = 9, ie++, ve[9]++;
          for (; ie <= 279; ) F[2 * ie + 1] = 7, ie++, ve[7]++;
          for (; ie <= 287; ) F[2 * ie + 1] = 8, ie++, ve[8]++;
          for (X(F, d + 1, ve), ie = 0; ie < f; ie++) P[2 * ie + 1] = 5, P[2 * ie] = he(ie, 5);
          ee = new L(F, x, h + 1, d, p), K = new L(P, S, 0, f, p), te = new L(new Array(0), T, 0, g, b);
        }(), re = !0), q.l_desc = new j(q.dyn_ltree, ee), q.d_desc = new j(q.dyn_dtree, K), q.bl_desc = new j(q.bl_tree, te), q.bi_buf = 0, q.bi_valid = 0, z(q);
      }, s._tr_stored_block = W, s._tr_flush_block = function(q, ie, ye, xe) {
        var fe, Ce, ve = 0;
        0 < q.level ? (q.strm.data_type === 2 && (q.strm.data_type = function(Ee) {
          var oe, Te = 4093624447;
          for (oe = 0; oe <= 31; oe++, Te >>>= 1) if (1 & Te && Ee.dyn_ltree[2 * oe] !== 0) return o;
          if (Ee.dyn_ltree[18] !== 0 || Ee.dyn_ltree[20] !== 0 || Ee.dyn_ltree[26] !== 0) return a;
          for (oe = 32; oe < h; oe++) if (Ee.dyn_ltree[2 * oe] !== 0) return a;
          return o;
        }(q)), _e(q, q.l_desc), _e(q, q.d_desc), ve = function(Ee) {
          var oe;
          for ($(Ee, Ee.dyn_ltree, Ee.l_desc.max_code), $(Ee, Ee.dyn_dtree, Ee.d_desc.max_code), _e(Ee, Ee.bl_desc), oe = g - 1; 3 <= oe && Ee.bl_tree[2 * R[oe] + 1] === 0; oe--) ;
          return Ee.opt_len += 3 * (oe + 1) + 5 + 5 + 4, oe;
        }(q), fe = q.opt_len + 3 + 7 >>> 3, (Ce = q.static_len + 3 + 7 >>> 3) <= fe && (fe = Ce)) : fe = Ce = ye + 5, ye + 4 <= fe && ie !== -1 ? W(q, ie, ye, xe) : q.strategy === 4 || Ce === fe ? (Y(q, 2 + (xe ? 1 : 0), 3), de(q, F, P)) : (Y(q, 4 + (xe ? 1 : 0), 3), function(Ee, oe, Te, ke) {
          var Ge;
          for (Y(Ee, oe - 257, 5), Y(Ee, Te - 1, 5), Y(Ee, ke - 4, 4), Ge = 0; Ge < ke; Ge++) Y(Ee, Ee.bl_tree[2 * R[Ge] + 1], 3);
          ce(Ee, Ee.dyn_ltree, oe - 1), ce(Ee, Ee.dyn_dtree, Te - 1);
        }(q, q.l_desc.max_code + 1, q.d_desc.max_code + 1, ve + 1), de(q, q.dyn_ltree, q.dyn_dtree)), z(q), xe && ue(q);
      }, s._tr_tally = function(q, ie, ye) {
        return q.pending_buf[q.d_buf + 2 * q.last_lit] = ie >>> 8 & 255, q.pending_buf[q.d_buf + 2 * q.last_lit + 1] = 255 & ie, q.pending_buf[q.l_buf + q.last_lit] = 255 & ye, q.last_lit++, ie === 0 ? q.dyn_ltree[2 * ye]++ : (q.matches++, ie--, q.dyn_ltree[2 * (A[ye] + h + 1)]++, q.dyn_dtree[2 * H(ie)]++), q.last_lit === q.lit_bufsize - 1;
      }, s._tr_align = function(q) {
        Y(q, 2, 3), ne(q, _, F), function(ie) {
          ie.bi_valid === 16 ? (U(ie, ie.bi_buf), ie.bi_buf = 0, ie.bi_valid = 0) : 8 <= ie.bi_valid && (ie.pending_buf[ie.pending++] = 255 & ie.bi_buf, ie.bi_buf >>= 8, ie.bi_valid -= 8);
        }(q);
      };
    }, { "../utils/common": 41 }], 53: [function(n, r, s) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(n, r, s) {
      (function(i) {
        (function(o, a) {
          if (!o.setImmediate) {
            var l, c, u, h, d = 1, f = {}, g = !1, y = o.document, p = Object.getPrototypeOf && Object.getPrototypeOf(o);
            p = p && p.setTimeout ? p : o, l = {}.toString.call(o.process) === "[object process]" ? function(v) {
              je.nextTick(function() {
                b(v);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var v = !0, w = o.onmessage;
                return o.onmessage = function() {
                  v = !1;
                }, o.postMessage("", "*"), o.onmessage = w, v;
              }
            }() ? (h = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", _, !1) : o.attachEvent("onmessage", _), function(v) {
              o.postMessage(h + v, "*");
            }) : o.MessageChannel ? ((u = new MessageChannel()).port1.onmessage = function(v) {
              b(v.data);
            }, function(v) {
              u.port2.postMessage(v);
            }) : y && "onreadystatechange" in y.createElement("script") ? (c = y.documentElement, function(v) {
              var w = y.createElement("script");
              w.onreadystatechange = function() {
                b(v), w.onreadystatechange = null, c.removeChild(w), w = null;
              }, c.appendChild(w);
            }) : function(v) {
              setTimeout(b, 0, v);
            }, p.setImmediate = function(v) {
              typeof v != "function" && (v = new Function("" + v));
              for (var w = new Array(arguments.length - 1), E = 0; E < w.length; E++) w[E] = arguments[E + 1];
              var x = { callback: v, args: w };
              return f[d] = x, l(d), d++;
            }, p.clearImmediate = m;
          }
          function m(v) {
            delete f[v];
          }
          function b(v) {
            if (g) setTimeout(b, 0, v);
            else {
              var w = f[v];
              if (w) {
                g = !0;
                try {
                  (function(E) {
                    var x = E.callback, S = E.args;
                    switch (S.length) {
                      case 0:
                        x();
                        break;
                      case 1:
                        x(S[0]);
                        break;
                      case 2:
                        x(S[0], S[1]);
                        break;
                      case 3:
                        x(S[0], S[1], S[2]);
                        break;
                      default:
                        x.apply(a, S);
                    }
                  })(w);
                } finally {
                  m(v), g = !1;
                }
              }
            }
          }
          function _(v) {
            v.source === o && typeof v.data == "string" && v.data.indexOf(h) === 0 && b(+v.data.slice(h.length));
          }
        })(typeof self > "u" ? i === void 0 ? this : i : self);
      }).call(this, typeof Jn < "u" ? Jn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Vj);
var ybe = Vj.exports;
const bbe = /* @__PURE__ */ Is(ybe);
var Wj = { exports: {} };
(function(t, e) {
  (function(n, r) {
    r();
  })(Jn, function() {
    function n(c, u) {
      return typeof u > "u" ? u = { autoBom: !1 } : typeof u != "object" && (console.warn("Deprecated: Expected third argument to be a object"), u = { autoBom: !u }), u.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(c.type) ? new Blob(["\uFEFF", c], { type: c.type }) : c;
    }
    function r(c, u, h) {
      var d = new XMLHttpRequest();
      d.open("GET", c), d.responseType = "blob", d.onload = function() {
        l(d.response, u, h);
      }, d.onerror = function() {
        console.error("could not download file");
      }, d.send();
    }
    function s(c) {
      var u = new XMLHttpRequest();
      u.open("HEAD", c, !1);
      try {
        u.send();
      } catch {
      }
      return 200 <= u.status && 299 >= u.status;
    }
    function i(c) {
      try {
        c.dispatchEvent(new MouseEvent("click"));
      } catch {
        var u = document.createEvent("MouseEvents");
        u.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), c.dispatchEvent(u);
      }
    }
    var o = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof Jn == "object" && Jn.global === Jn ? Jn : void 0, a = o.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), l = o.saveAs || (typeof window != "object" || window !== o ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(c, u, h) {
      var d = o.URL || o.webkitURL, f = document.createElement("a");
      u = u || c.name || "download", f.download = u, f.rel = "noopener", typeof c == "string" ? (f.href = c, f.origin === location.origin ? i(f) : s(f.href) ? r(c, u, h) : i(f, f.target = "_blank")) : (f.href = d.createObjectURL(c), setTimeout(function() {
        d.revokeObjectURL(f.href);
      }, 4e4), setTimeout(function() {
        i(f);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(c, u, h) {
      if (u = u || c.name || "download", typeof c != "string") navigator.msSaveOrOpenBlob(n(c, h), u);
      else if (s(c)) r(c, u, h);
      else {
        var d = document.createElement("a");
        d.href = c, d.target = "_blank", setTimeout(function() {
          i(d);
        });
      }
    } : function(c, u, h, d) {
      if (d = d || open("", "_blank"), d && (d.document.title = d.document.body.innerText = "downloading..."), typeof c == "string") return r(c, u, h);
      var f = c.type === "application/octet-stream", g = /constructor/i.test(o.HTMLElement) || o.safari, y = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((y || f && g || a) && typeof FileReader < "u") {
        var p = new FileReader();
        p.onloadend = function() {
          var _ = p.result;
          _ = y ? _ : _.replace(/^data:[^;]*;/, "data:attachment/file;"), d ? d.location.href = _ : location = _, d = null;
        }, p.readAsDataURL(c);
      } else {
        var m = o.URL || o.webkitURL, b = m.createObjectURL(c);
        d ? d.location = b : location.href = b, d = null, setTimeout(function() {
          m.revokeObjectURL(b);
        }, 4e4);
      }
    });
    o.saveAs = l.saveAs = l, t.exports = l;
  });
})(Wj);
var _be = Wj.exports;
function Ib() {
  return typeof navigator == "object" && "userAgent" in navigator ? navigator.userAgent : typeof je == "object" && je.version !== void 0 ? `Node.js/${je.version.substr(1)} (${je.platform}; ${je.arch})` : "<environment undetectable>";
}
function qj(t, e, n, r) {
  if (typeof n != "function")
    throw new Error("method for before hook must be a function");
  return r || (r = {}), Array.isArray(e) ? e.reverse().reduce((s, i) => qj.bind(null, t, i, s, r), n)() : Promise.resolve().then(() => t.registry[e] ? t.registry[e].reduce((s, i) => i.hook.bind(null, s, r), n)() : n(r));
}
function vbe(t, e, n, r) {
  const s = r;
  t.registry[n] || (t.registry[n] = []), e === "before" && (r = (i, o) => Promise.resolve().then(s.bind(null, o)).then(i.bind(null, o))), e === "after" && (r = (i, o) => {
    let a;
    return Promise.resolve().then(i.bind(null, o)).then((l) => (a = l, s(a, o))).then(() => a);
  }), e === "error" && (r = (i, o) => Promise.resolve().then(i.bind(null, o)).catch((a) => s(a, o))), t.registry[n].push({
    hook: r,
    orig: s
  });
}
function wbe(t, e, n) {
  if (!t.registry[e])
    return;
  const r = t.registry[e].map((s) => s.orig).indexOf(n);
  r !== -1 && t.registry[e].splice(r, 1);
}
const sO = Function.bind, iO = sO.bind(sO);
function Ebe(t, e, n) {
  const r = iO(wbe, null).apply(
    null,
    [e]
  );
  t.api = { remove: r }, t.remove = r, ["before", "error", "after", "wrap"].forEach((s) => {
    const i = [e, s];
    t[s] = t.api[s] = iO(vbe, null).apply(null, i);
  });
}
function Sbe() {
  const t = {
    registry: {}
  }, e = qj.bind(null, t);
  return Ebe(e, t), e;
}
const xbe = { Collection: Sbe };
var Tbe = "0.0.0-development", Cbe = `octokit-endpoint.js/${Tbe} ${Ib()}`, kbe = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": Cbe
  },
  mediaType: {
    format: ""
  }
};
function Abe(t) {
  return t ? Object.keys(t).reduce((e, n) => (e[n.toLowerCase()] = t[n], e), {}) : {};
}
function Rbe(t) {
  if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]") return !1;
  const e = Object.getPrototypeOf(t);
  if (e === null) return !0;
  const n = Object.prototype.hasOwnProperty.call(e, "constructor") && e.constructor;
  return typeof n == "function" && n instanceof n && Function.prototype.call(n) === Function.prototype.call(t);
}
function Kj(t, e) {
  const n = Object.assign({}, t);
  return Object.keys(e).forEach((r) => {
    Rbe(e[r]) ? r in t ? n[r] = Kj(t[r], e[r]) : Object.assign(n, { [r]: e[r] }) : Object.assign(n, { [r]: e[r] });
  }), n;
}
function oO(t) {
  for (const e in t)
    t[e] === void 0 && delete t[e];
  return t;
}
function ES(t, e, n) {
  if (typeof e == "string") {
    let [s, i] = e.split(" ");
    n = Object.assign(i ? { method: s, url: i } : { url: s }, n);
  } else
    n = Object.assign({}, e);
  n.headers = Abe(n.headers), oO(n), oO(n.headers);
  const r = Kj(t || {}, n);
  return n.url === "/graphql" && (t && t.mediaType.previews?.length && (r.mediaType.previews = t.mediaType.previews.filter(
    (s) => !r.mediaType.previews.includes(s)
  ).concat(r.mediaType.previews)), r.mediaType.previews = (r.mediaType.previews || []).map((s) => s.replace(/-preview/, ""))), r;
}
function Ibe(t, e) {
  const n = /\?/.test(t) ? "&" : "?", r = Object.keys(e);
  return r.length === 0 ? t : t + n + r.map((s) => s === "q" ? "q=" + e.q.split("+").map(encodeURIComponent).join("+") : `${s}=${encodeURIComponent(e[s])}`).join("&");
}
var Pbe = /\{[^}]+\}/g;
function Obe(t) {
  return t.replace(/^\W+|\W+$/g, "").split(/,/);
}
function Dbe(t) {
  const e = t.match(Pbe);
  return e ? e.map(Obe).reduce((n, r) => n.concat(r), []) : [];
}
function aO(t, e) {
  const n = { __proto__: null };
  for (const r of Object.keys(t))
    e.indexOf(r) === -1 && (n[r] = t[r]);
  return n;
}
function Yj(t) {
  return t.split(/(%[0-9A-Fa-f]{2})/g).map(function(e) {
    return /%[0-9A-Fa-f]/.test(e) || (e = encodeURI(e).replace(/%5B/g, "[").replace(/%5D/g, "]")), e;
  }).join("");
}
function bc(t) {
  return encodeURIComponent(t).replace(/[!'()*]/g, function(e) {
    return "%" + e.charCodeAt(0).toString(16).toUpperCase();
  });
}
function eh(t, e, n) {
  return e = t === "+" || t === "#" ? Yj(e) : bc(e), n ? bc(n) + "=" + e : e;
}
function Jl(t) {
  return t != null;
}
function Mv(t) {
  return t === ";" || t === "&" || t === "?";
}
function Nbe(t, e, n, r) {
  var s = t[n], i = [];
  if (Jl(s) && s !== "")
    if (typeof s == "string" || typeof s == "number" || typeof s == "boolean")
      s = s.toString(), r && r !== "*" && (s = s.substring(0, parseInt(r, 10))), i.push(
        eh(e, s, Mv(e) ? n : "")
      );
    else if (r === "*")
      Array.isArray(s) ? s.filter(Jl).forEach(function(o) {
        i.push(
          eh(e, o, Mv(e) ? n : "")
        );
      }) : Object.keys(s).forEach(function(o) {
        Jl(s[o]) && i.push(eh(e, s[o], o));
      });
    else {
      const o = [];
      Array.isArray(s) ? s.filter(Jl).forEach(function(a) {
        o.push(eh(e, a));
      }) : Object.keys(s).forEach(function(a) {
        Jl(s[a]) && (o.push(bc(a)), o.push(eh(e, s[a].toString())));
      }), Mv(e) ? i.push(bc(n) + "=" + o.join(",")) : o.length !== 0 && i.push(o.join(","));
    }
  else
    e === ";" ? Jl(s) && i.push(bc(n)) : s === "" && (e === "&" || e === "?") ? i.push(bc(n) + "=") : s === "" && i.push("");
  return i;
}
function Lbe(t) {
  return {
    expand: Mbe.bind(null, t)
  };
}
function Mbe(t, e) {
  var n = ["+", "#", ".", "/", ";", "?", "&"];
  return t = t.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(r, s, i) {
      if (s) {
        let a = "";
        const l = [];
        if (n.indexOf(s.charAt(0)) !== -1 && (a = s.charAt(0), s = s.substr(1)), s.split(/,/g).forEach(function(c) {
          var u = /([^:\*]*)(?::(\d+)|(\*))?/.exec(c);
          l.push(Nbe(e, a, u[1], u[2] || u[3]));
        }), a && a !== "+") {
          var o = ",";
          return a === "?" ? o = "&" : a !== "#" && (o = a), (l.length !== 0 ? a : "") + l.join(o);
        } else
          return l.join(",");
      } else
        return Yj(i);
    }
  ), t === "/" ? t : t.replace(/\/$/, "");
}
function Zj(t) {
  let e = t.method.toUpperCase(), n = (t.url || "/").replace(/:([a-z]\w+)/g, "{$1}"), r = Object.assign({}, t.headers), s, i = aO(t, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const o = Dbe(n);
  n = Lbe(n).expand(i), /^http/.test(n) || (n = t.baseUrl + n);
  const a = Object.keys(t).filter((u) => o.includes(u)).concat("baseUrl"), l = aO(i, a);
  if (!/application\/octet-stream/i.test(r.accept) && (t.mediaType.format && (r.accept = r.accept.split(/,/).map(
    (u) => u.replace(
      /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
      `application/vnd$1$2.${t.mediaType.format}`
    )
  ).join(",")), n.endsWith("/graphql") && t.mediaType.previews?.length)) {
    const u = r.accept.match(/[\w-]+(?=-preview)/g) || [];
    r.accept = u.concat(t.mediaType.previews).map((h) => {
      const d = t.mediaType.format ? `.${t.mediaType.format}` : "+json";
      return `application/vnd.github.${h}-preview${d}`;
    }).join(",");
  }
  return ["GET", "HEAD"].includes(e) ? n = Ibe(n, l) : "data" in l ? s = l.data : Object.keys(l).length && (s = l), !r["content-type"] && typeof s < "u" && (r["content-type"] = "application/json; charset=utf-8"), ["PATCH", "PUT"].includes(e) && typeof s > "u" && (s = ""), Object.assign(
    { method: e, url: n, headers: r },
    typeof s < "u" ? { body: s } : null,
    t.request ? { request: t.request } : null
  );
}
function Bbe(t, e, n) {
  return Zj(ES(t, e, n));
}
function Jj(t, e) {
  const n = ES(t, e), r = Bbe.bind(null, n);
  return Object.assign(r, {
    DEFAULTS: n,
    defaults: Jj.bind(null, n),
    merge: ES.bind(null, n),
    parse: Zj
  });
}
var Fbe = Jj(null, kbe);
const ok = function() {
};
ok.prototype = /* @__PURE__ */ Object.create(null);
const lO = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu, cO = /\\([\v\u0020-\u00ff])/gu, $be = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u, _c = { type: "", parameters: new ok() };
Object.freeze(_c.parameters);
Object.freeze(_c);
function Ube(t) {
  if (typeof t != "string")
    return _c;
  let e = t.indexOf(";");
  const n = e !== -1 ? t.slice(0, e).trim() : t.trim();
  if ($be.test(n) === !1)
    return _c;
  const r = {
    type: n.toLowerCase(),
    parameters: new ok()
  };
  if (e === -1)
    return r;
  let s, i, o;
  for (lO.lastIndex = e; i = lO.exec(t); ) {
    if (i.index !== e)
      return _c;
    e += i[0].length, s = i[1].toLowerCase(), o = i[2], o[0] === '"' && (o = o.slice(1, o.length - 1), cO.test(o) && (o = o.replace(cO, "$1"))), r.parameters[s] = o;
  }
  return e !== t.length ? _c : r;
}
var jbe = Ube;
class fm extends Error {
  name;
  /**
   * http status code
   */
  status;
  /**
   * Request options that lead to the error.
   */
  request;
  /**
   * Response object if a response was received
   */
  response;
  constructor(e, n, r) {
    super(e), this.name = "HttpError", this.status = Number.parseInt(n), Number.isNaN(this.status) && (this.status = 0), "response" in r && (this.response = r.response);
    const s = Object.assign({}, r.request);
    r.request.headers.authorization && (s.headers = Object.assign({}, r.request.headers, {
      authorization: r.request.headers.authorization.replace(
        / .*$/,
        " [REDACTED]"
      )
    })), s.url = s.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]"), this.request = s;
  }
}
var Hbe = "0.0.0-development", zbe = {
  headers: {
    "user-agent": `octokit-request.js/${Hbe} ${Ib()}`
  }
};
function Gbe(t) {
  if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]") return !1;
  const e = Object.getPrototypeOf(t);
  if (e === null) return !0;
  const n = Object.prototype.hasOwnProperty.call(e, "constructor") && e.constructor;
  return typeof n == "function" && n instanceof n && Function.prototype.call(n) === Function.prototype.call(t);
}
async function uO(t) {
  const e = t.request?.fetch || globalThis.fetch;
  if (!e)
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  const n = t.request?.log || console, r = t.request?.parseSuccessResponseBody !== !1, s = Gbe(t.body) || Array.isArray(t.body) ? JSON.stringify(t.body) : t.body, i = Object.fromEntries(
    Object.entries(t.headers).map(([h, d]) => [
      h,
      String(d)
    ])
  );
  let o;
  try {
    o = await e(t.url, {
      method: t.method,
      body: s,
      redirect: t.request?.redirect,
      headers: i,
      signal: t.request?.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...t.body && { duplex: "half" }
    });
  } catch (h) {
    let d = "Unknown Error";
    if (h instanceof Error) {
      if (h.name === "AbortError")
        throw h.status = 500, h;
      d = h.message, h.name === "TypeError" && "cause" in h && (h.cause instanceof Error ? d = h.cause.message : typeof h.cause == "string" && (d = h.cause));
    }
    const f = new fm(d, 500, {
      request: t
    });
    throw f.cause = h, f;
  }
  const a = o.status, l = o.url, c = {};
  for (const [h, d] of o.headers)
    c[h] = d;
  const u = {
    url: l,
    status: a,
    headers: c,
    data: ""
  };
  if ("deprecation" in c) {
    const h = c.link && c.link.match(/<([^>]+)>; rel="deprecation"/), d = h && h.pop();
    n.warn(
      `[@octokit/request] "${t.method} ${t.url}" is deprecated. It is scheduled to be removed on ${c.sunset}${d ? `. See ${d}` : ""}`
    );
  }
  if (a === 204 || a === 205)
    return u;
  if (t.method === "HEAD") {
    if (a < 400)
      return u;
    throw new fm(o.statusText, a, {
      response: u,
      request: t
    });
  }
  if (a === 304)
    throw u.data = await Bv(o), new fm("Not modified", a, {
      response: u,
      request: t
    });
  if (a >= 400)
    throw u.data = await Bv(o), new fm(Wbe(u.data), a, {
      response: u,
      request: t
    });
  return u.data = r ? await Bv(o) : o.body, u;
}
async function Bv(t) {
  const e = t.headers.get("content-type");
  if (!e)
    return t.text().catch(() => "");
  const n = jbe(e);
  if (Vbe(n)) {
    let r = "";
    try {
      return r = await t.text(), JSON.parse(r);
    } catch {
      return r;
    }
  } else return n.type.startsWith("text/") || n.parameters.charset?.toLowerCase() === "utf-8" ? t.text().catch(() => "") : t.arrayBuffer().catch(() => new ArrayBuffer(0));
}
function Vbe(t) {
  return t.type === "application/json" || t.type === "application/scim+json";
}
function Wbe(t) {
  if (typeof t == "string")
    return t;
  if (t instanceof ArrayBuffer)
    return "Unknown error";
  if ("message" in t) {
    const e = "documentation_url" in t ? ` - ${t.documentation_url}` : "";
    return Array.isArray(t.errors) ? `${t.message}: ${t.errors.map((n) => JSON.stringify(n)).join(", ")}${e}` : `${t.message}${e}`;
  }
  return `Unknown error: ${JSON.stringify(t)}`;
}
function SS(t, e) {
  const n = t.defaults(e);
  return Object.assign(function(s, i) {
    const o = n.merge(s, i);
    if (!o.request || !o.request.hook)
      return uO(n.parse(o));
    const a = (l, c) => uO(
      n.parse(n.merge(l, c))
    );
    return Object.assign(a, {
      endpoint: n,
      defaults: SS.bind(null, n)
    }), o.request.hook(a, o);
  }, {
    endpoint: n,
    defaults: SS.bind(null, n)
  });
}
var xS = SS(Fbe, zbe), qbe = "0.0.0-development";
function Kbe(t) {
  return `Request failed due to following response errors:
` + t.errors.map((e) => ` - ${e.message}`).join(`
`);
}
var Ybe = class extends Error {
  constructor(t, e, n) {
    super(Kbe(n)), this.request = t, this.headers = e, this.response = n, this.errors = n.errors, this.data = n.data, Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
  name = "GraphqlResponseError";
  errors;
  data;
}, Zbe = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType",
  "operationName"
], Jbe = ["query", "method", "url"], hO = /\/api\/v3\/?$/;
function Xbe(t, e, n) {
  if (n) {
    if (typeof e == "string" && "query" in n)
      return Promise.reject(
        new Error('[@octokit/graphql] "query" cannot be used as variable name')
      );
    for (const o in n)
      if (Jbe.includes(o))
        return Promise.reject(
          new Error(
            `[@octokit/graphql] "${o}" cannot be used as variable name`
          )
        );
  }
  const r = typeof e == "string" ? Object.assign({ query: e }, n) : e, s = Object.keys(
    r
  ).reduce((o, a) => Zbe.includes(a) ? (o[a] = r[a], o) : (o.variables || (o.variables = {}), o.variables[a] = r[a], o), {}), i = r.baseUrl || t.endpoint.DEFAULTS.baseUrl;
  return hO.test(i) && (s.url = i.replace(hO, "/api/graphql")), t(s).then((o) => {
    if (o.data.errors) {
      const a = {};
      for (const l of Object.keys(o.headers))
        a[l] = o.headers[l];
      throw new Ybe(
        s,
        a,
        o.data
      );
    }
    return o.data.data;
  });
}
function ak(t, e) {
  const n = t.defaults(e);
  return Object.assign((s, i) => Xbe(n, s, i), {
    defaults: ak.bind(null, n),
    endpoint: n.endpoint
  });
}
ak(xS, {
  headers: {
    "user-agent": `octokit-graphql.js/${qbe} ${Ib()}`
  },
  method: "POST",
  url: "/graphql"
});
function Qbe(t) {
  return ak(t, {
    method: "POST",
    url: "/graphql"
  });
}
var Fv = "(?:[a-zA-Z0-9_-]+)", dO = "\\.", fO = new RegExp(`^${Fv}${dO}${Fv}${dO}${Fv}$`), e_e = fO.test.bind(fO);
async function t_e(t) {
  const e = e_e(t), n = t.startsWith("v1.") || t.startsWith("ghs_"), r = t.startsWith("ghu_");
  return {
    type: "token",
    token: t,
    tokenType: e ? "app" : n ? "installation" : r ? "user-to-server" : "oauth"
  };
}
function n_e(t) {
  return t.split(/\./).length === 3 ? `bearer ${t}` : `token ${t}`;
}
async function r_e(t, e, n, r) {
  const s = e.endpoint.merge(
    n,
    r
  );
  return s.headers.authorization = n_e(t), e(s);
}
var s_e = function(e) {
  if (!e)
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  if (typeof e != "string")
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  return e = e.replace(/^(token|bearer) +/i, ""), Object.assign(t_e.bind(null, e), {
    hook: r_e.bind(null, e)
  });
};
const Xj = "6.1.3", pO = () => {
}, i_e = console.warn.bind(console), o_e = console.error.bind(console), mO = `octokit-core.js/${Xj} ${Ib()}`;
let a_e = class {
  static VERSION = Xj;
  static defaults(e) {
    return class extends this {
      constructor(...r) {
        const s = r[0] || {};
        if (typeof e == "function") {
          super(e(s));
          return;
        }
        super(
          Object.assign(
            {},
            e,
            s,
            s.userAgent && e.userAgent ? {
              userAgent: `${s.userAgent} ${e.userAgent}`
            } : null
          )
        );
      }
    };
  }
  static plugins = [];
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...e) {
    const n = this.plugins;
    return class extends this {
      static plugins = n.concat(
        e.filter((s) => !n.includes(s))
      );
    };
  }
  constructor(e = {}) {
    const n = new xbe.Collection(), r = {
      baseUrl: xS.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, e.request, {
        // @ts-ignore internal usage only, no need to type
        hook: n.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    if (r.headers["user-agent"] = e.userAgent ? `${e.userAgent} ${mO}` : mO, e.baseUrl && (r.baseUrl = e.baseUrl), e.previews && (r.mediaType.previews = e.previews), e.timeZone && (r.headers["time-zone"] = e.timeZone), this.request = xS.defaults(r), this.graphql = Qbe(this.request).defaults(r), this.log = Object.assign(
      {
        debug: pO,
        info: pO,
        warn: i_e,
        error: o_e
      },
      e.log
    ), this.hook = n, e.authStrategy) {
      const { authStrategy: i, ...o } = e, a = i(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: o
          },
          e.auth
        )
      );
      n.wrap("request", a.hook), this.auth = a;
    } else if (!e.auth)
      this.auth = async () => ({
        type: "unauthenticated"
      });
    else {
      const i = s_e(e.auth);
      n.wrap("request", i.hook), this.auth = i;
    }
    const s = this.constructor;
    for (let i = 0; i < s.plugins.length; ++i)
      Object.assign(this, s.plugins[i](this, e));
  }
  // assigned during constructor
  request;
  graphql;
  log;
  hook;
  // TODO: type `octokit.auth` based on passed options.authStrategy
  auth;
};
const l_e = "5.3.1";
function Qj(t) {
  t.hook.wrap("request", (e, n) => {
    t.log.debug("request", n);
    const r = Date.now(), s = t.request.endpoint.parse(n), i = s.url.replace(n.baseUrl, "");
    return e(n).then((o) => {
      const a = o.headers["x-github-request-id"];
      return t.log.info(
        `${s.method} ${i} - ${o.status} with id ${a} in ${Date.now() - r}ms`
      ), o;
    }).catch((o) => {
      const a = o.response?.headers["x-github-request-id"] || "UNKNOWN";
      throw t.log.error(
        `${s.method} ${i} - ${o.status} with id ${a} in ${Date.now() - r}ms`
      ), o;
    });
  });
}
Qj.VERSION = l_e;
var c_e = "0.0.0-development";
function u_e(t) {
  if (!t.data)
    return {
      ...t,
      data: []
    };
  if (!("total_count" in t.data && !("url" in t.data))) return t;
  const n = t.data.incomplete_results, r = t.data.repository_selection, s = t.data.total_count;
  delete t.data.incomplete_results, delete t.data.repository_selection, delete t.data.total_count;
  const i = Object.keys(t.data)[0], o = t.data[i];
  return t.data = o, typeof n < "u" && (t.data.incomplete_results = n), typeof r < "u" && (t.data.repository_selection = r), t.data.total_count = s, t;
}
function lk(t, e, n) {
  const r = typeof e == "function" ? e.endpoint(n) : t.request.endpoint(e, n), s = typeof e == "function" ? e : t.request, i = r.method, o = r.headers;
  let a = r.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!a) return { done: !0 };
        try {
          const l = await s({ method: i, url: a, headers: o }), c = u_e(l);
          return a = ((c.headers.link || "").match(
            /<([^>]+)>;\s*rel="next"/
          ) || [])[1], { value: c };
        } catch (l) {
          if (l.status !== 409) throw l;
          return a = "", {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function eH(t, e, n, r) {
  return typeof n == "function" && (r = n, n = void 0), tH(
    t,
    [],
    lk(t, e, n)[Symbol.asyncIterator](),
    r
  );
}
function tH(t, e, n, r) {
  return n.next().then((s) => {
    if (s.done)
      return e;
    let i = !1;
    function o() {
      i = !0;
    }
    return e = e.concat(
      r ? r(s.value, o) : s.value.data
    ), i ? e : tH(t, e, n, r);
  });
}
Object.assign(eH, {
  iterator: lk
});
function nH(t) {
  return {
    paginate: Object.assign(eH.bind(null, t), {
      iterator: lk.bind(null, t)
    })
  };
}
nH.VERSION = c_e;
const h_e = "13.3.0", d_e = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addRepoAccessToSelfHostedRunnerGroupInOrg: [
      "PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    createOrUpdateEnvironmentSecret: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubBillingUsageReportOrg: [
      "GET /organizations/{org}/settings/billing/usage"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    commitAutofix: [
      "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"
    ],
    createAutofix: [
      "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
    ],
    createVariantAnalysis: [
      "POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"
    ],
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    deleteCodeqlDatabase: [
      "DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getAutofix: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    getVariantAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"
    ],
    getVariantAnalysisRepoTask: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"
    ],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codeSecurity: {
    attachConfiguration: [
      "POST /orgs/{org}/code-security/configurations/{configuration_id}/attach"
    ],
    attachEnterpriseConfiguration: [
      "POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"
    ],
    createConfiguration: ["POST /orgs/{org}/code-security/configurations"],
    createConfigurationForEnterprise: [
      "POST /enterprises/{enterprise}/code-security/configurations"
    ],
    deleteConfiguration: [
      "DELETE /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    deleteConfigurationForEnterprise: [
      "DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ],
    detachConfiguration: [
      "DELETE /orgs/{org}/code-security/configurations/detach"
    ],
    getConfiguration: [
      "GET /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    getConfigurationForRepository: [
      "GET /repos/{owner}/{repo}/code-security-configuration"
    ],
    getConfigurationsForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations"
    ],
    getConfigurationsForOrg: ["GET /orgs/{org}/code-security/configurations"],
    getDefaultConfigurations: [
      "GET /orgs/{org}/code-security/configurations/defaults"
    ],
    getDefaultConfigurationsForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations/defaults"
    ],
    getRepositoriesForConfiguration: [
      "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories"
    ],
    getRepositoriesForEnterpriseConfiguration: [
      "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"
    ],
    getSingleConfigurationForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ],
    setConfigurationAsDefault: [
      "PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults"
    ],
    setConfigurationAsDefaultForEnterprise: [
      "PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"
    ],
    updateConfiguration: [
      "PATCH /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    updateEnterpriseConfiguration: [
      "PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    copilotMetricsForOrganization: ["GET /orgs/{org}/copilot/metrics"],
    copilotMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/metrics"],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"],
    usageMetricsForOrg: ["GET /orgs/{org}/copilot/usage"],
    usageMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/usage"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    addSubIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
    ],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    listSubIssues: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
    ],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    removeSubIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue"
    ],
    reprioritizeSubIssue: [
      "PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}",
      {},
      {
        deprecated: "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team"
      }
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}",
      {},
      {
        deprecated: "octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization"
      }
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listAttestations: ["GET /orgs/{org}/attestations/{subject_digest}"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: [
      "GET /orgs/{org}/security-managers",
      {},
      {
        deprecated: "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams"
      }
    ],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
      {},
      {
        deprecated: "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team"
      }
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  privateRegistries: {
    createOrgPrivateRegistry: ["POST /orgs/{org}/private-registries"],
    deleteOrgPrivateRegistry: [
      "DELETE /orgs/{org}/private-registries/{secret_name}"
    ],
    getOrgPrivateRegistry: ["GET /orgs/{org}/private-registries/{secret_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/private-registries/public-key"],
    listOrgPrivateRegistries: ["GET /orgs/{org}/private-registries"],
    updateOrgPrivateRegistry: [
      "PATCH /orgs/{org}/private-registries/{secret_name}"
    ]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: [
      "GET /projects/{project_id}/collaborators/{username}/permission"
    ],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: [
      "DELETE /projects/{project_id}/collaborators/{username}"
    ],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkPrivateVulnerabilityReporting: [
      "GET /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAttestation: ["POST /repos/{owner}/{repo}/attestations"],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAttestations: [
      "GET /repos/{owner}/{repo}/attestations/{subject_digest}"
    ],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    createPushProtectionBypass: [
      "POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    getScanHistory: ["GET /repos/{owner}/{repo}/secret-scanning/scan-history"],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateProjectPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForProjectInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeProjectInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getById: ["GET /user/{account_id}"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listAttestations: ["GET /users/{username}/attestations/{subject_digest}"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var f_e = d_e;
const sl = /* @__PURE__ */ new Map();
for (const [t, e] of Object.entries(f_e))
  for (const [n, r] of Object.entries(e)) {
    const [s, i, o] = r, [a, l] = s.split(/ /), c = Object.assign(
      {
        method: a,
        url: l
      },
      i
    );
    sl.has(t) || sl.set(t, /* @__PURE__ */ new Map()), sl.get(t).set(n, {
      scope: t,
      methodName: n,
      endpointDefaults: c,
      decorations: o
    });
  }
const p_e = {
  has({ scope: t }, e) {
    return sl.get(t).has(e);
  },
  getOwnPropertyDescriptor(t, e) {
    return {
      value: this.get(t, e),
      // ensures method is in the cache
      configurable: !0,
      writable: !0,
      enumerable: !0
    };
  },
  defineProperty(t, e, n) {
    return Object.defineProperty(t.cache, e, n), !0;
  },
  deleteProperty(t, e) {
    return delete t.cache[e], !0;
  },
  ownKeys({ scope: t }) {
    return [...sl.get(t).keys()];
  },
  set(t, e, n) {
    return t.cache[e] = n;
  },
  get({ octokit: t, scope: e, cache: n }, r) {
    if (n[r])
      return n[r];
    const s = sl.get(e).get(r);
    if (!s)
      return;
    const { endpointDefaults: i, decorations: o } = s;
    return o ? n[r] = g_e(
      t,
      e,
      r,
      i,
      o
    ) : n[r] = t.request.defaults(i), n[r];
  }
};
function m_e(t) {
  const e = {};
  for (const n of sl.keys())
    e[n] = new Proxy({ octokit: t, scope: n, cache: {} }, p_e);
  return e;
}
function g_e(t, e, n, r, s) {
  const i = t.request.defaults(r);
  function o(...a) {
    let l = i.endpoint.merge(...a);
    if (s.mapToData)
      return l = Object.assign({}, l, {
        data: l[s.mapToData],
        [s.mapToData]: void 0
      }), i(l);
    if (s.renamed) {
      const [c, u] = s.renamed;
      t.log.warn(
        `octokit.${e}.${n}() has been renamed to octokit.${c}.${u}()`
      );
    }
    if (s.deprecated && t.log.warn(s.deprecated), s.renamedParameters) {
      const c = i.endpoint.merge(...a);
      for (const [u, h] of Object.entries(
        s.renamedParameters
      ))
        u in c && (t.log.warn(
          `"${u}" parameter is deprecated for "octokit.${e}.${n}()". Use "${h}" instead`
        ), h in c || (c[h] = c[u]), delete c[u]);
      return i(c);
    }
    return i(...a);
  }
  return Object.assign(o, i);
}
function rH(t) {
  const e = m_e(t);
  return {
    ...e,
    rest: e
  };
}
rH.VERSION = h_e;
const y_e = "21.1.0", b_e = a_e.plugin(Qj, rH, nH).defaults(
  {
    userAgent: `octokit-rest.js/${y_e}`
  }
), __e = Sr("ChatHistory");
async function v_e() {
  if (typeof indexedDB > "u") {
    console.error("indexedDB is not available in this environment.");
    return;
  }
  return new Promise((t) => {
    const e = indexedDB.open("boltHistory", 1);
    e.onupgradeneeded = (n) => {
      const r = n.target.result;
      if (!r.objectStoreNames.contains("chats")) {
        const s = r.createObjectStore("chats", { keyPath: "id" });
        s.createIndex("id", "id", { unique: !0 }), s.createIndex("urlId", "urlId", { unique: !0 });
      }
    }, e.onsuccess = (n) => {
      t(n.target.result);
    }, e.onerror = (n) => {
      t(void 0), __e.error(n.target.error);
    };
  });
}
async function U0(t, e, n, r, s, i, o) {
  return new Promise((a, l) => {
    const u = t.transaction("chats", "readwrite").objectStore("chats");
    if (i && isNaN(Date.parse(i))) {
      l(new Error("Invalid timestamp"));
      return;
    }
    const h = u.put({
      id: e,
      messages: n,
      urlId: r,
      description: s,
      timestamp: i ?? (/* @__PURE__ */ new Date()).toISOString(),
      metadata: o
    });
    h.onsuccess = () => a(), h.onerror = () => l(h.error);
  });
}
async function iu(t, e) {
  return await E_e(t, e) || await w_e(t, e);
}
async function w_e(t, e) {
  return new Promise((n, r) => {
    const a = t.transaction("chats", "readonly").objectStore("chats").index("urlId").get(e);
    a.onsuccess = () => n(a.result), a.onerror = () => r(a.error);
  });
}
async function E_e(t, e) {
  return new Promise((n, r) => {
    const o = t.transaction("chats", "readonly").objectStore("chats").get(e);
    o.onsuccess = () => n(o.result), o.onerror = () => r(o.error);
  });
}
async function sH(t) {
  return new Promise((e, n) => {
    const i = t.transaction("chats", "readonly").objectStore("chats").getAllKeys();
    i.onsuccess = () => {
      const o = i.result.reduce((a, l) => Math.max(+a, +l), 0);
      e(String(+o + 1));
    }, i.onerror = () => n(i.error);
  });
}
async function iH(t, e) {
  const n = await S_e(t);
  if (n.includes(e)) {
    let r = 2;
    for (; n.includes(`${e}-${r}`); )
      r++;
    return `${e}-${r}`;
  } else
    return e;
}
async function S_e(t) {
  return new Promise((e, n) => {
    const s = t.transaction("chats", "readonly").objectStore("chats"), i = [], o = s.openCursor();
    o.onsuccess = (a) => {
      const l = a.target.result;
      l ? (i.push(l.value.urlId), l.continue()) : e(i);
    }, o.onerror = () => {
      n(o.error);
    };
  });
}
async function x_e(t, e, n) {
  const r = await iu(t, e);
  if (!r)
    throw new Error("Chat not found");
  const s = r.messages.findIndex((o) => o.id === n);
  if (s === -1)
    throw new Error("Message not found");
  const i = r.messages.slice(0, s + 1);
  return ck(t, r.description ? `${r.description} (fork)` : "Forked chat", i);
}
async function T_e(t, e) {
  const n = await iu(t, e);
  if (!n)
    throw new Error("Chat not found");
  return ck(t, `${n.description || "Chat"} (copy)`, n.messages);
}
async function ck(t, e, n, r) {
  const s = await sH(t), i = await iH(t, s);
  return await U0(
    t,
    s,
    n,
    i,
    // Use the new urlId
    e,
    void 0,
    // Use the current timestamp
    r
  ), i;
}
async function C_e(t, e, n) {
  const r = await iu(t, e);
  if (!r)
    throw new Error("Chat not found");
  if (!n.trim())
    throw new Error("Description cannot be empty");
  await U0(t, e, r.messages, r.urlId, n, r.timestamp, r.metadata);
}
const Kt = await v_e(), Mo = nn(void 0), oi = nn(void 0), vg = nn(void 0);
function oH() {
  const t = yZ(), { id: e } = bZ(), [n] = vB(), [r, s] = I.useState([]), [i, o] = I.useState(!1), [a, l] = I.useState();
  return I.useEffect(() => {
    if (!Kt) {
      o(!0);
      {
        const c = new Error("Chat persistence is unavailable");
        hr.logError("Chat persistence initialization failed", c), $e.error("Chat persistence is unavailable");
      }
      return;
    }
    e && iu(Kt, e).then((c) => {
      if (c && c.messages.length > 0) {
        const u = n.get("rewindTo"), h = u ? c.messages.slice(0, c.messages.findIndex((d) => d.id === u) + 1) : c.messages;
        s(h), l(c.urlId), oi.set(c.description), Mo.set(c.id), vg.set(c.metadata);
      } else
        t("/", { replace: !0 });
      o(!0);
    }).catch((c) => {
      hr.logError("Failed to load chat messages", c), $e.error(c.message);
    });
  }, []), {
    ready: !e || i,
    initialMessages: r,
    updateChatMestaData: async (c) => {
      const u = Mo.get();
      if (!(!Kt || !u))
        try {
          await U0(Kt, u, r, a, oi.get(), void 0, c), vg.set(c);
        } catch (h) {
          $e.error("Failed to update chat metadata"), console.error(h);
        }
    },
    storeMessageHistory: async (c) => {
      if (!Kt || c.length === 0)
        return;
      const { firstArtifact: u } = We;
      if (!a && u?.id) {
        const h = await iH(Kt, u.id);
        gO(h), l(h);
      }
      if (!oi.get() && u?.title && oi.set(u?.title), r.length === 0 && !Mo.get()) {
        const h = await sH(Kt);
        Mo.set(h), a || gO(h);
      }
      await U0(Kt, Mo.get(), c, a, oi.get(), void 0, vg.get());
    },
    duplicateCurrentChat: async (c) => {
      if (!(!Kt || !e && !c))
        try {
          const u = await T_e(Kt, e || c);
          t(`/chat/${u}`), $e.success("Chat duplicated successfully");
        } catch (u) {
          $e.error("Failed to duplicate chat"), console.log(u);
        }
    },
    importChat: async (c, u, h) => {
      if (Kt)
        try {
          const d = await ck(Kt, c, u, h);
          window.location.href = `/chat/${d}`, $e.success("Chat imported successfully");
        } catch (d) {
          d instanceof Error ? $e.error("Failed to import chat: " + d.message) : $e.error("Failed to import chat");
        }
    },
    exportChat: async (c = a) => {
      if (!Kt || !c)
        return;
      const u = await iu(Kt, c), h = {
        messages: u.messages,
        description: u.description,
        exportDate: (/* @__PURE__ */ new Date()).toISOString()
      }, d = new Blob([JSON.stringify(h, null, 2)], { type: "application/json" }), f = URL.createObjectURL(d), g = document.createElement("a");
      g.href = f, g.download = `chat-${(/* @__PURE__ */ new Date()).toISOString()}.json`, document.body.appendChild(g), g.click(), document.body.removeChild(g), URL.revokeObjectURL(f);
    }
  };
}
function gO(t) {
  const e = new URL(window.location.href);
  e.pathname = `/chat/${t}`, window.history.replaceState({}, "", e);
}
function aH(t, e) {
  let n = null, r = 0, s = null;
  return function(...o) {
    const a = Date.now();
    if (n = o, a - r < e) {
      s || (s = setTimeout(
        () => {
          s = null, r = Date.now(), n && (t.apply(this, n), n = null);
        },
        e - (a - r)
      ));
      return;
    }
    r = a, t.apply(this, o), n = null;
  };
}
class lH {
  #t = new cbe(La);
  #n = new ibe(La);
  #e = new $ye(this.#n);
  #r = new gbe(La);
  #a = /* @__PURE__ */ new Set();
  artifacts = Ol({});
  showWorkbench = nn(!1);
  currentView = nn("code");
  unsavedFiles = nn(/* @__PURE__ */ new Set());
  actionAlert = nn(void 0);
  modifiedFiles = /* @__PURE__ */ new Set();
  artifactIdList = [];
  #s = Promise.resolve();
  constructor() {
  }
  addToExecutionQueue(e) {
    this.#s = this.#s.then(() => e());
  }
  get previews() {
    return this.#t.previews;
  }
  get files() {
    return this.#n.files;
  }
  get currentDocument() {
    return this.#e.currentDocument;
  }
  get selectedFile() {
    return this.#e.selectedFile;
  }
  get firstArtifact() {
    return this.#o(this.artifactIdList[0]);
  }
  get filesCount() {
    return this.#n.filesCount;
  }
  get showTerminal() {
    return this.#r.showTerminal;
  }
  get boltTerminal() {
    return this.#r.boltTerminal;
  }
  get alert() {
    return this.actionAlert;
  }
  clearAlert() {
    this.actionAlert.set(void 0);
  }
  toggleTerminal(e) {
    this.#r.toggleTerminal(e);
  }
  attachTerminal(e) {
    this.#r.attachTerminal(e);
  }
  attachBoltTerminal(e) {
    this.#r.attachBoltTerminal(e);
  }
  onTerminalResize(e, n) {
    this.#r.onTerminalResize(e, n);
  }
  setDocuments(e) {
    if (this.#e.setDocuments(e), this.#n.filesCount > 0 && this.currentDocument.get() === void 0) {
      for (const [n, r] of Object.entries(e))
        if (r?.type === "file") {
          this.setSelectedFile(n);
          break;
        }
    }
  }
  setShowWorkbench(e) {
    this.showWorkbench.set(e);
  }
  setCurrentDocumentContent(e) {
    const n = this.currentDocument.get()?.filePath;
    if (!n)
      return;
    const r = this.#n.getFile(n)?.content, s = r !== void 0 && r !== e;
    this.#e.updateFile(n, e);
    const i = this.currentDocument.get();
    if (i) {
      const o = this.unsavedFiles.get();
      if (s && o.has(i.filePath))
        return;
      const a = new Set(o);
      s ? a.add(i.filePath) : a.delete(i.filePath), this.unsavedFiles.set(a);
    }
  }
  setCurrentDocumentScrollPosition(e) {
    const n = this.currentDocument.get();
    if (!n)
      return;
    const { filePath: r } = n;
    this.#e.updateScrollPosition(r, e);
  }
  setSelectedFile(e) {
    this.#e.setSelectedFile(e);
  }
  async saveFile(e) {
    const r = this.#e.documents.get()[e];
    if (r === void 0)
      return;
    await this.#n.saveFile(e, r.value);
    const s = new Set(this.unsavedFiles.get());
    s.delete(e), this.unsavedFiles.set(s);
  }
  async saveCurrentDocument() {
    const e = this.currentDocument.get();
    e !== void 0 && await this.saveFile(e.filePath);
  }
  resetCurrentDocument() {
    const e = this.currentDocument.get();
    if (e === void 0)
      return;
    const { filePath: n } = e, r = this.#n.getFile(n);
    r && this.setCurrentDocumentContent(r.content);
  }
  async saveAllFiles() {
    for (const e of this.unsavedFiles.get())
      await this.saveFile(e);
  }
  getFileModifcations() {
    return this.#n.getFileModifications();
  }
  resetAllFileModifications() {
    this.#n.resetFileModifications();
  }
  abortAllActions() {
  }
  setReloadedMessages(e) {
    this.#a = new Set(e);
  }
  addArtifact({ messageId: e, title: n, id: r, type: s }) {
    this.#o(e) || (this.artifactIdList.includes(e) || this.artifactIdList.push(e), this.artifacts.setKey(e, {
      id: r,
      title: n,
      closed: !1,
      type: s,
      runner: new gse(
        La,
        () => this.boltTerminal,
        (o) => {
          this.#a.has(e) || this.actionAlert.set(o);
        }
      )
    }));
  }
  updateArtifact({ messageId: e }, n) {
    const r = this.#o(e);
    r && this.artifacts.setKey(e, { ...r, ...n });
  }
  addAction(e) {
    this.addToExecutionQueue(() => this._addAction(e));
  }
  async _addAction(e) {
    const { messageId: n } = e, r = this.#o(n);
    return r || ps("Artifact not found"), r.runner.addAction(e);
  }
  runAction(e, n = !1) {
    n ? this.actionStreamSampler(e, n) : this.addToExecutionQueue(() => this._runAction(e, n));
  }
  async _runAction(e, n = !1) {
    const { messageId: r } = e, s = this.#o(r);
    s || ps("Artifact not found");
    const i = s.runner.actions.get()[e.actionId];
    if (!(!i || i.executed))
      if (e.action.type === "file") {
        const o = await La, a = rn.join(o.workdir, e.action.filePath);
        this.selectedFile.value !== a && this.setSelectedFile(a), this.currentView.value !== "code" && this.currentView.set("code"), this.#e.documents.get()[a] || await s.runner.runAction(e, n), this.#e.updateFile(a, e.action.content), n || (await s.runner.runAction(e), this.resetAllFileModifications());
      } else
        await s.runner.runAction(e);
  }
  actionStreamSampler = aH(async (e, n = !1) => await this._runAction(e, n), 100);
  // TODO: remove this magic number to have it configurable
  #o(e) {
    return this.artifacts.get()[e];
  }
  async downloadZip() {
    const e = new bbe(), n = this.files.get(), r = (oi.value ?? "project").toLocaleLowerCase().split(" ").join("_"), s = Date.now().toString(36).slice(-6), i = `${r}_${s}`;
    for (const [a, l] of Object.entries(n))
      if (l?.type === "file" && !l.isBinary) {
        const c = Lv(a), u = c.split("/");
        if (u.length > 1) {
          let h = e;
          for (let d = 0; d < u.length - 1; d++)
            h = h.folder(u[d]);
          h.file(u[u.length - 1], l.content);
        } else
          e.file(c, l.content);
      }
    const o = await e.generateAsync({ type: "blob" });
    _be.saveAs(o, `${i}.zip`);
  }
  async syncFiles(e) {
    const n = this.files.get(), r = [];
    for (const [s, i] of Object.entries(n))
      if (i?.type === "file" && !i.isBinary) {
        const o = Lv(s), a = o.split("/");
        let l = e;
        for (let h = 0; h < a.length - 1; h++)
          l = await l.getDirectoryHandle(a[h], { create: !0 });
        const u = await (await l.getFileHandle(a[a.length - 1], {
          create: !0
        })).createWritable();
        await u.write(i.content), await u.close(), r.push(o);
      }
    return r;
  }
  async pushToGitHub(e, n, r, s) {
    try {
      const i = s || nt.get("githubToken"), o = r || nt.get("githubUsername");
      if (!i || !o)
        throw new Error("GitHub token or username is not set in cookies or provided.");
      const a = new b_e({ auth: i });
      let l;
      try {
        l = (await a.repos.get({ owner: o, repo: e })).data;
      } catch (p) {
        if (p instanceof Error && "status" in p && p.status === 404) {
          const { data: m } = await a.repos.createForAuthenticatedUser({
            name: e,
            private: !1,
            auto_init: !0
          });
          l = m;
        } else
          throw console.log("cannot create repo!"), p;
      }
      const c = this.files.get();
      if (!c || Object.keys(c).length === 0)
        throw new Error("No files found to push");
      const h = (await Promise.all(
        Object.entries(c).map(async ([p, m]) => {
          if (m?.type === "file" && m.content) {
            const { data: b } = await a.git.createBlob({
              owner: l.owner.login,
              repo: l.name,
              content: Me.from(m.content).toString("base64"),
              encoding: "base64"
            });
            return { path: Lv(p), sha: b.sha };
          }
          return null;
        })
      )).filter(Boolean);
      if (h.length === 0)
        throw new Error("No valid files to push");
      const { data: d } = await a.git.getRef({
        owner: l.owner.login,
        repo: l.name,
        ref: `heads/${l.default_branch || "main"}`
        // Handle dynamic branch
      }), f = d.object.sha, { data: g } = await a.git.createTree({
        owner: l.owner.login,
        repo: l.name,
        base_tree: f,
        tree: h.map((p) => ({
          path: p.path,
          mode: "100644",
          type: "blob",
          sha: p.sha
        }))
      }), { data: y } = await a.git.createCommit({
        owner: l.owner.login,
        repo: l.name,
        message: n || "Initial commit from your app",
        tree: g.sha,
        parents: [f]
      });
      await a.git.updateRef({
        owner: l.owner.login,
        repo: l.name,
        ref: `heads/${l.default_branch || "main"}`,
        // Handle dynamic branch
        sha: y.sha
      }), alert(`Repository created and code pushed: ${l.html_url}`);
    } catch (i) {
      throw console.error("Error pushing to GitHub:", i), i;
    }
  }
}
const We = new lH(), k_e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WorkbenchStore: lH,
  workbenchStore: We
}, Symbol.toStringTag, { value: "Module" })), A_e = ["OpenAILike", "LMStudio", "Ollama"], R_e = Ol({
  toggleTerminal: {
    key: "j",
    ctrlOrMetaKey: !0,
    action: () => We.toggleTerminal()
  }
}), cH = {};
Rb.forEach((t) => {
  cH[t.name] = {
    ...t,
    settings: {
      enabled: !0
    }
  };
});
const pm = Ol(cH), $v = nn(!1), Uv = nn(!1), jv = nn(!0), Hv = nn("default"), mm = nn(!1), zv = nn(!1), Gv = nn(!1), th = {
  commit: "0cb5004",
  version: "1.0.0"
};
function I_e() {
  const t = mt(pm), e = mt($v), n = mt(Uv), r = mt(Hv), s = mt(jv), i = mt(mm), o = mt(zv), [a, l] = I.useState([]), c = mt(Gv), u = async () => {
    try {
      const v = await (await fetch(
        `https://api.github.com/repos/stackblitz-labs/bolt.diy/git/refs/tags/v${th.version}`
      )).json();
      return th.commit.slice(0, 7) === v.object.sha.slice(0, 7);
    } catch (_) {
      return console.warn("Error checking stable version:", _), !1;
    }
  };
  I.useEffect(() => {
    const _ = nt.get("providers");
    if (_)
      try {
        const P = JSON.parse(_);
        Object.keys(t).forEach((M) => {
          const A = P[M];
          A && pm.setKey(M, {
            ...t[M],
            settings: {
              ...A,
              enabled: A.enabled ?? !0
            }
          });
        });
      } catch (P) {
        console.error("Failed to parse providers from cookies:", P);
      }
    const v = nt.get("isDebugEnabled");
    v && $v.set(v === "true");
    const w = nt.get("isEventLogsEnabled");
    w && Uv.set(w === "true");
    const E = nt.get("isLocalModelsEnabled");
    E && jv.set(E === "true");
    const x = nt.get("promptId");
    x && Hv.set(x);
    const S = nt.get("isLatestBranch");
    let T = nt.get("commitHash");
    T === void 0 && (T = th.commit), S === void 0 || T !== th.commit ? u().then((P) => {
      const M = !P;
      mm.set(M), nt.set("isLatestBranch", String(M)), nt.set("commitHash", String(th.commit));
    }) : mm.set(S === "true");
    const R = nt.get("autoSelectTemplate");
    R && zv.set(R === "true");
    const F = nt.get("contextOptimizationEnabled");
    F && Gv.set(F === "true");
  }, []), I.useEffect(() => {
    const _ = pm.get(), v = {};
    Object.keys(_).forEach((w) => {
      v[w] = _[w].settings;
    }), nt.set("providers", JSON.stringify(v));
  }, [t]), I.useEffect(() => {
    let _ = Object.entries(t).filter(([v, w]) => w.settings.enabled).map(([v, w]) => w);
    s || (_ = _.filter((v) => !A_e.includes(v.name))), l(_);
  }, [t, s]);
  const h = I.useCallback(
    (_, v) => {
      const w = t[_].settings;
      pm.setKey(_, { ...t[_], settings: { ...w, ...v } });
    },
    [t]
  ), d = I.useCallback((_) => {
    $v.set(_), hr.logSystem(`Debug mode ${_ ? "enabled" : "disabled"}`), nt.set("isDebugEnabled", String(_));
  }, []), f = I.useCallback((_) => {
    Uv.set(_), hr.logSystem(`Event logs ${_ ? "enabled" : "disabled"}`), nt.set("isEventLogsEnabled", String(_));
  }, []), g = I.useCallback((_) => {
    jv.set(_), hr.logSystem(`Local models ${_ ? "enabled" : "disabled"}`), nt.set("isLocalModelsEnabled", String(_));
  }, []), y = I.useCallback((_) => {
    Hv.set(_), nt.set("promptId", _);
  }, []), p = I.useCallback((_) => {
    mm.set(_), hr.logSystem(`Main branch updates ${_ ? "enabled" : "disabled"}`), nt.set("isLatestBranch", String(_));
  }, []), m = I.useCallback((_) => {
    zv.set(_), hr.logSystem(`Auto select template ${_ ? "enabled" : "disabled"}`), nt.set("autoSelectTemplate", String(_));
  }, []), b = I.useCallback((_) => {
    Gv.set(_), hr.logSystem(`Context optimization ${_ ? "enabled" : "disabled"}`), nt.set("contextOptimizationEnabled", String(_));
  }, []);
  return {
    providers: t,
    activeProviders: a,
    updateProviderSettings: h,
    debug: e,
    enableDebugMode: d,
    eventLogs: n,
    enableEventLogs: f,
    isLocalModel: s,
    enableLocalModels: g,
    promptId: r,
    setPromptId: y,
    isLatestBranch: i,
    enableLatestBranch: p,
    autoSelectTemplate: o,
    setAutoSelectTemplate: m,
    contextOptimizationEnabled: c,
    enableContextOptimization: b
  };
}
const uH = -1, Pb = 0, Jh = 1, j0 = 2, uk = 3, hk = 4, dk = 5, fk = 6, hH = 7, dH = 8, yO = typeof self == "object" ? self : globalThis, P_e = (t, e) => {
  const n = (s, i) => (t.set(i, s), s), r = (s) => {
    if (t.has(s))
      return t.get(s);
    const [i, o] = e[s];
    switch (i) {
      case Pb:
      case uH:
        return n(o, s);
      case Jh: {
        const a = n([], s);
        for (const l of o)
          a.push(r(l));
        return a;
      }
      case j0: {
        const a = n({}, s);
        for (const [l, c] of o)
          a[r(l)] = r(c);
        return a;
      }
      case uk:
        return n(new Date(o), s);
      case hk: {
        const { source: a, flags: l } = o;
        return n(new RegExp(a, l), s);
      }
      case dk: {
        const a = n(/* @__PURE__ */ new Map(), s);
        for (const [l, c] of o)
          a.set(r(l), r(c));
        return a;
      }
      case fk: {
        const a = n(/* @__PURE__ */ new Set(), s);
        for (const l of o)
          a.add(r(l));
        return a;
      }
      case hH: {
        const { name: a, message: l } = o;
        return n(new yO[a](l), s);
      }
      case dH:
        return n(BigInt(o), s);
      case "BigInt":
        return n(Object(BigInt(o)), s);
      case "ArrayBuffer":
        return n(new Uint8Array(o).buffer, o);
      case "DataView": {
        const { buffer: a } = new Uint8Array(o);
        return n(new DataView(a), o);
      }
    }
    return n(new yO[i](o), s);
  };
  return r;
}, bO = (t) => P_e(/* @__PURE__ */ new Map(), t)(0), Xl = "", { toString: O_e } = {}, { keys: D_e } = Object, nh = (t) => {
  const e = typeof t;
  if (e !== "object" || !t)
    return [Pb, e];
  const n = O_e.call(t).slice(8, -1);
  switch (n) {
    case "Array":
      return [Jh, Xl];
    case "Object":
      return [j0, Xl];
    case "Date":
      return [uk, Xl];
    case "RegExp":
      return [hk, Xl];
    case "Map":
      return [dk, Xl];
    case "Set":
      return [fk, Xl];
    case "DataView":
      return [Jh, n];
  }
  return n.includes("Array") ? [Jh, n] : n.includes("Error") ? [hH, n] : [j0, n];
}, gm = ([t, e]) => t === Pb && (e === "function" || e === "symbol"), N_e = (t, e, n, r) => {
  const s = (o, a) => {
    const l = r.push(o) - 1;
    return n.set(a, l), l;
  }, i = (o) => {
    if (n.has(o))
      return n.get(o);
    let [a, l] = nh(o);
    switch (a) {
      case Pb: {
        let u = o;
        switch (l) {
          case "bigint":
            a = dH, u = o.toString();
            break;
          case "function":
          case "symbol":
            if (t)
              throw new TypeError("unable to serialize " + l);
            u = null;
            break;
          case "undefined":
            return s([uH], o);
        }
        return s([a, u], o);
      }
      case Jh: {
        if (l) {
          let d = o;
          return l === "DataView" ? d = new Uint8Array(o.buffer) : l === "ArrayBuffer" && (d = new Uint8Array(o)), s([l, [...d]], o);
        }
        const u = [], h = s([a, u], o);
        for (const d of o)
          u.push(i(d));
        return h;
      }
      case j0: {
        if (l)
          switch (l) {
            case "BigInt":
              return s([l, o.toString()], o);
            case "Boolean":
            case "Number":
            case "String":
              return s([l, o.valueOf()], o);
          }
        if (e && "toJSON" in o)
          return i(o.toJSON());
        const u = [], h = s([a, u], o);
        for (const d of D_e(o))
          (t || !gm(nh(o[d]))) && u.push([i(d), i(o[d])]);
        return h;
      }
      case uk:
        return s([a, o.toISOString()], o);
      case hk: {
        const { source: u, flags: h } = o;
        return s([a, { source: u, flags: h }], o);
      }
      case dk: {
        const u = [], h = s([a, u], o);
        for (const [d, f] of o)
          (t || !(gm(nh(d)) || gm(nh(f)))) && u.push([i(d), i(f)]);
        return h;
      }
      case fk: {
        const u = [], h = s([a, u], o);
        for (const d of o)
          (t || !gm(nh(d))) && u.push(i(d));
        return h;
      }
    }
    const { message: c } = o;
    return s([a, { name: l, message: c }], o);
  };
  return i;
}, _O = (t, { json: e, lossy: n } = {}) => {
  const r = [];
  return N_e(!(e || n), !!e, /* @__PURE__ */ new Map(), r)(t), r;
}, bl = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (t, e) => e && ("json" in e || "lossy" in e) ? bO(_O(t, e)) : structuredClone(t)
) : (t, e) => bO(_O(t, e));
class op {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(e, n, r) {
    this.property = e, this.normal = n, r && (this.space = r);
  }
}
op.prototype.property = {};
op.prototype.normal = {};
op.prototype.space = null;
function fH(t, e) {
  const n = {}, r = {};
  let s = -1;
  for (; ++s < t.length; )
    Object.assign(n, t[s].property), Object.assign(r, t[s].normal);
  return new op(n, r, e);
}
function qd(t) {
  return t.toLowerCase();
}
class cs {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(e, n) {
    this.property = e, this.attribute = n;
  }
}
cs.prototype.space = null;
cs.prototype.boolean = !1;
cs.prototype.booleanish = !1;
cs.prototype.overloadedBoolean = !1;
cs.prototype.number = !1;
cs.prototype.commaSeparated = !1;
cs.prototype.spaceSeparated = !1;
cs.prototype.commaOrSpaceSeparated = !1;
cs.prototype.mustUseProperty = !1;
cs.prototype.defined = !1;
let L_e = 0;
const et = Ll(), en = Ll(), pH = Ll(), De = Ll(), Dt = Ll(), Dc = Ll(), Tr = Ll();
function Ll() {
  return 2 ** ++L_e;
}
const TS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: et,
  booleanish: en,
  commaOrSpaceSeparated: Tr,
  commaSeparated: Dc,
  number: De,
  overloadedBoolean: pH,
  spaceSeparated: Dt
}, Symbol.toStringTag, { value: "Module" })), Vv = Object.keys(TS);
class pk extends cs {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(e, n, r, s) {
    let i = -1;
    if (super(e, n), vO(this, "space", s), typeof r == "number")
      for (; ++i < Vv.length; ) {
        const o = Vv[i];
        vO(this, Vv[i], (r & TS[o]) === TS[o]);
      }
  }
}
pk.prototype.defined = !0;
function vO(t, e, n) {
  n && (t[e] = n);
}
const M_e = {}.hasOwnProperty;
function Iu(t) {
  const e = {}, n = {};
  let r;
  for (r in t.properties)
    if (M_e.call(t.properties, r)) {
      const s = t.properties[r], i = new pk(
        r,
        t.transform(t.attributes || {}, r),
        s,
        t.space
      );
      t.mustUseProperty && t.mustUseProperty.includes(r) && (i.mustUseProperty = !0), e[r] = i, n[qd(r)] = r, n[qd(i.attribute)] = r;
    }
  return new op(e, n, t.space);
}
const mH = Iu({
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), gH = Iu({
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function yH(t, e) {
  return e in t ? t[e] : e;
}
function bH(t, e) {
  return yH(t, e.toLowerCase());
}
const _H = Iu({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: bH,
  properties: { xmlns: null, xmlnsXLink: null }
}), vH = Iu({
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: en,
    ariaAutoComplete: null,
    ariaBusy: en,
    ariaChecked: en,
    ariaColCount: De,
    ariaColIndex: De,
    ariaColSpan: De,
    ariaControls: Dt,
    ariaCurrent: null,
    ariaDescribedBy: Dt,
    ariaDetails: null,
    ariaDisabled: en,
    ariaDropEffect: Dt,
    ariaErrorMessage: null,
    ariaExpanded: en,
    ariaFlowTo: Dt,
    ariaGrabbed: en,
    ariaHasPopup: null,
    ariaHidden: en,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Dt,
    ariaLevel: De,
    ariaLive: null,
    ariaModal: en,
    ariaMultiLine: en,
    ariaMultiSelectable: en,
    ariaOrientation: null,
    ariaOwns: Dt,
    ariaPlaceholder: null,
    ariaPosInSet: De,
    ariaPressed: en,
    ariaReadOnly: en,
    ariaRelevant: null,
    ariaRequired: en,
    ariaRoleDescription: Dt,
    ariaRowCount: De,
    ariaRowIndex: De,
    ariaRowSpan: De,
    ariaSelected: en,
    ariaSetSize: De,
    ariaSort: null,
    ariaValueMax: De,
    ariaValueMin: De,
    ariaValueNow: De,
    ariaValueText: null,
    role: null
  }
}), B_e = Iu({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: bH,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Dc,
    acceptCharset: Dt,
    accessKey: Dt,
    action: null,
    allow: null,
    allowFullScreen: et,
    allowPaymentRequest: et,
    allowUserMedia: et,
    alt: null,
    as: null,
    async: et,
    autoCapitalize: null,
    autoComplete: Dt,
    autoFocus: et,
    autoPlay: et,
    blocking: Dt,
    capture: null,
    charSet: null,
    checked: et,
    cite: null,
    className: Dt,
    cols: De,
    colSpan: null,
    content: null,
    contentEditable: en,
    controls: et,
    controlsList: Dt,
    coords: De | Dc,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: et,
    defer: et,
    dir: null,
    dirName: null,
    disabled: et,
    download: pH,
    draggable: en,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: et,
    formTarget: null,
    headers: Dt,
    height: De,
    hidden: et,
    high: De,
    href: null,
    hrefLang: null,
    htmlFor: Dt,
    httpEquiv: Dt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: et,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: et,
    itemId: null,
    itemProp: Dt,
    itemRef: Dt,
    itemScope: et,
    itemType: Dt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: et,
    low: De,
    manifest: null,
    max: null,
    maxLength: De,
    media: null,
    method: null,
    min: null,
    minLength: De,
    multiple: et,
    muted: et,
    name: null,
    nonce: null,
    noModule: et,
    noValidate: et,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: et,
    optimum: De,
    pattern: null,
    ping: Dt,
    placeholder: null,
    playsInline: et,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: et,
    referrerPolicy: null,
    rel: Dt,
    required: et,
    reversed: et,
    rows: De,
    rowSpan: De,
    sandbox: Dt,
    scope: null,
    scoped: et,
    seamless: et,
    selected: et,
    shadowRootClonable: et,
    shadowRootDelegatesFocus: et,
    shadowRootMode: null,
    shape: null,
    size: De,
    sizes: null,
    slot: null,
    span: De,
    spellCheck: en,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: De,
    step: null,
    style: null,
    tabIndex: De,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: et,
    useMap: null,
    value: en,
    width: De,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Dt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: De,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: De,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: et,
    // Lists. Use CSS to reduce space between items instead
    declare: et,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: De,
    // `<img>` and `<object>`
    leftMargin: De,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: De,
    // `<body>`
    marginWidth: De,
    // `<body>`
    noResize: et,
    // `<frame>`
    noHref: et,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: et,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: et,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: De,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: en,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: De,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: De,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: et,
    disableRemotePlayback: et,
    prefix: null,
    property: null,
    results: De,
    security: null,
    unselectable: null
  }
}), F_e = Iu({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: yH,
  properties: {
    about: Tr,
    accentHeight: De,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: De,
    amplitude: De,
    arabicForm: null,
    ascent: De,
    attributeName: null,
    attributeType: null,
    azimuth: De,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: De,
    by: null,
    calcMode: null,
    capHeight: De,
    className: Dt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: De,
    diffuseConstant: De,
    direction: null,
    display: null,
    dur: null,
    divisor: De,
    dominantBaseline: null,
    download: et,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: De,
    enableBackground: null,
    end: null,
    event: null,
    exponent: De,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: De,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Dc,
    g2: Dc,
    glyphName: Dc,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: De,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: De,
    horizOriginX: De,
    horizOriginY: De,
    id: null,
    ideographic: De,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: De,
    k: De,
    k1: De,
    k2: De,
    k3: De,
    k4: De,
    kernelMatrix: Tr,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: De,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: De,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: De,
    overlineThickness: De,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: De,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Dt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: De,
    pointsAtY: De,
    pointsAtZ: De,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Tr,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Tr,
    rev: Tr,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Tr,
    requiredFeatures: Tr,
    requiredFonts: Tr,
    requiredFormats: Tr,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: De,
    specularExponent: De,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: De,
    strikethroughThickness: De,
    string: null,
    stroke: null,
    strokeDashArray: Tr,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: De,
    strokeOpacity: De,
    strokeWidth: null,
    style: null,
    surfaceScale: De,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Tr,
    tabIndex: De,
    tableValues: null,
    target: null,
    targetX: De,
    targetY: De,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Tr,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: De,
    underlineThickness: De,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: De,
    values: null,
    vAlphabetic: De,
    vMathematical: De,
    vectorEffect: null,
    vHanging: De,
    vIdeographic: De,
    version: null,
    vertAdvY: De,
    vertOriginX: De,
    vertOriginY: De,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: De,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), $_e = /^data[-\w.:]+$/i, wO = /-[a-z]/g, U_e = /[A-Z]/g;
function ap(t, e) {
  const n = qd(e);
  let r = e, s = cs;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && $_e.test(e)) {
    if (e.charAt(4) === "-") {
      const i = e.slice(5).replace(wO, H_e);
      r = "data" + i.charAt(0).toUpperCase() + i.slice(1);
    } else {
      const i = e.slice(4);
      if (!wO.test(i)) {
        let o = i.replace(U_e, j_e);
        o.charAt(0) !== "-" && (o = "-" + o), e = "data" + o;
      }
    }
    s = pk;
  }
  return new s(r, e);
}
function j_e(t) {
  return "-" + t.toLowerCase();
}
function H_e(t) {
  return t.charAt(1).toUpperCase();
}
const z_e = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Pu = fH([gH, mH, _H, vH, B_e], "html"), Oi = fH([gH, mH, _H, vH, F_e], "svg");
function EO(t) {
  const e = [], n = String(t || "");
  let r = n.indexOf(","), s = 0, i = !1;
  for (; !i; ) {
    r === -1 && (r = n.length, i = !0);
    const o = n.slice(s, r).trim();
    (o || !i) && e.push(o), s = r + 1, r = n.indexOf(",", s);
  }
  return e;
}
function mk(t, e) {
  const n = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const SO = /[#.]/g;
function G_e(t, e) {
  const n = t || "", r = {};
  let s = 0, i, o;
  for (; s < n.length; ) {
    SO.lastIndex = s;
    const a = SO.exec(n), l = n.slice(s, a ? a.index : n.length);
    l && (i ? i === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : o = l, s += l.length), a && (i = a[0], s++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: o || e || "div",
    properties: r,
    children: []
  };
}
function xO(t) {
  const e = String(t || "").trim();
  return e ? e.split(/[ \t\n\r\f]+/g) : [];
}
function gk(t) {
  return t.join(" ").trim();
}
const CS = {}.hasOwnProperty;
function wH(t, e, n) {
  const r = n && K_e(n);
  function s(i, o, ...a) {
    let l = -1, c;
    if (i == null) {
      c = { type: "root", children: [] };
      const u = (
        /** @type {Child} */
        o
      );
      a.unshift(u);
    } else if (c = G_e(i, e), c.tagName = c.tagName.toLowerCase(), r && CS.call(r, c.tagName) && (c.tagName = r[c.tagName]), V_e(o))
      a.unshift(o);
    else {
      let u;
      for (u in o)
        CS.call(o, u) && W_e(t, c.properties, u, o[u]);
    }
    for (; ++l < a.length; )
      kS(c.children, a[l]);
    return c.type === "element" && c.tagName === "template" && (c.content = { type: "root", children: c.children }, c.children = []), c;
  }
  return s;
}
function V_e(t) {
  if (t === null || typeof t != "object" || Array.isArray(t))
    return !0;
  if (typeof t.type != "string") return !1;
  const e = (
    /** @type {Record<string, unknown>} */
    t
  ), n = Object.keys(t);
  for (const r of n) {
    const s = e[r];
    if (s && typeof s == "object") {
      if (!Array.isArray(s)) return !0;
      const i = (
        /** @type {Array<unknown>} */
        s
      );
      for (const o of i)
        if (typeof o != "number" && typeof o != "string")
          return !0;
    }
  }
  return !!("children" in t && Array.isArray(t.children));
}
function W_e(t, e, n, r) {
  const s = ap(t, n);
  let i = -1, o;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      o = r;
    } else typeof r == "boolean" ? o = r : typeof r == "string" ? s.spaceSeparated ? o = xO(r) : s.commaSeparated ? o = EO(r) : s.commaOrSpaceSeparated ? o = xO(EO(r).join(" ")) : o = TO(s, s.property, r) : Array.isArray(r) ? o = r.concat() : o = s.property === "style" ? q_e(r) : String(r);
    if (Array.isArray(o)) {
      const a = [];
      for (; ++i < o.length; ) {
        const l = (
          /** @type {number | string} */
          TO(s, s.property, o[i])
        );
        a[i] = l;
      }
      o = a;
    }
    if (s.property === "className" && Array.isArray(e.className)) {
      const a = (
        /** @type {number | string} */
        o
      );
      o = e.className.concat(a);
    }
    e[s.property] = o;
  }
}
function kS(t, e) {
  let n = -1;
  if (e != null) if (typeof e == "string" || typeof e == "number")
    t.push({ type: "text", value: String(e) });
  else if (Array.isArray(e))
    for (; ++n < e.length; )
      kS(t, e[n]);
  else if (typeof e == "object" && "type" in e)
    e.type === "root" ? kS(t, e.children) : t.push(e);
  else
    throw new Error("Expected node, nodes, or string, got `" + e + "`");
}
function TO(t, e, n) {
  if (typeof n == "string") {
    if (t.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((t.boolean || t.overloadedBoolean) && (n === "" || qd(n) === qd(e)))
      return !0;
  }
  return n;
}
function q_e(t) {
  const e = [];
  let n;
  for (n in t)
    CS.call(t, n) && e.push([n, t[n]].join(": "));
  return e.join("; ");
}
function K_e(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    e[t[n].toLowerCase()] = t[n];
  return e;
}
const Y_e = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], Z_e = wH(Pu, "div"), J_e = wH(Oi, "g", Y_e);
function X_e(t) {
  const e = String(t), n = [];
  return { toOffset: s, toPoint: r };
  function r(i) {
    if (typeof i == "number" && i > -1 && i <= e.length) {
      let o = 0;
      for (; ; ) {
        let a = n[o];
        if (a === void 0) {
          const l = CO(e, n[o - 1]);
          a = l === -1 ? e.length + 1 : l + 1, n[o] = a;
        }
        if (a > i)
          return {
            line: o + 1,
            column: i - (o > 0 ? n[o - 1] : 0) + 1,
            offset: i
          };
        o++;
      }
    }
  }
  function s(i) {
    if (i && typeof i.line == "number" && typeof i.column == "number" && !Number.isNaN(i.line) && !Number.isNaN(i.column)) {
      for (; n.length < i.line; ) {
        const a = n[n.length - 1], l = CO(e, a), c = l === -1 ? e.length + 1 : l + 1;
        if (a === c) break;
        n.push(c);
      }
      const o = (i.line > 1 ? n[i.line - 2] : 0) + i.column - 1;
      if (o < n[i.line - 1]) return o;
    }
  }
}
function CO(t, e) {
  const n = t.indexOf("\r", e), r = t.indexOf(`
`, e);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const za = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, EH = {}.hasOwnProperty, Q_e = Object.prototype;
function eve(t, e) {
  const n = e || {};
  return yk(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? Oi : Pu,
      verbose: n.verbose || !1
    },
    t
  );
}
function yk(t, e) {
  let n;
  switch (e.nodeName) {
    case "#comment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        e
      );
      return n = { type: "comment", value: r.data }, wg(t, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        e
      ), s = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: SH(t, e.childNodes),
        data: { quirksMode: s }
      }, t.file && t.location) {
        const i = String(t.file), o = X_e(i), a = o.toPoint(0), l = o.toPoint(i.length);
        n.position = { start: a, end: l };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        e
      );
      return n = { type: "doctype" }, wg(t, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        e
      );
      return n = { type: "text", value: r.value }, wg(t, r, n), n;
    }
    default:
      return n = tve(
        t,
        /** @type {DefaultTreeAdapterMap['element']} */
        e
      ), n;
  }
}
function SH(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; ) {
    const s = (
      /** @type {RootContent} */
      yk(t, e[n])
    );
    r.push(s);
  }
  return r;
}
function tve(t, e) {
  const n = t.schema;
  t.schema = e.namespaceURI === za.svg ? Oi : Pu;
  let r = -1;
  const s = {};
  for (; ++r < e.attrs.length; ) {
    const a = e.attrs[r], l = (a.prefix ? a.prefix + ":" : "") + a.name;
    EH.call(Q_e, l) || (s[l] = a.value);
  }
  const o = (t.schema.space === "svg" ? J_e : Z_e)(e.tagName, s, SH(t, e.childNodes));
  if (wg(t, e, o), o.tagName === "template") {
    const a = (
      /** @type {DefaultTreeAdapterMap['template']} */
      e
    ), l = a.sourceCodeLocation, c = l && l.startTag && vc(l.startTag), u = l && l.endTag && vc(l.endTag), h = (
      /** @type {Root} */
      yk(t, a.content)
    );
    c && u && t.file && (h.position = { start: c.end, end: u.start }), o.content = h;
  }
  return t.schema = n, o;
}
function wg(t, e, n) {
  if ("sourceCodeLocation" in e && e.sourceCodeLocation && t.file) {
    const r = nve(t, n, e.sourceCodeLocation);
    r && (t.location = !0, n.position = r);
  }
}
function nve(t, e, n) {
  const r = vc(n);
  if (e.type === "element") {
    const s = e.children[e.children.length - 1];
    if (r && !n.endTag && s && s.position && s.position.end && (r.end = Object.assign({}, s.position.end)), t.verbose) {
      const i = {};
      let o;
      if (n.attrs)
        for (o in n.attrs)
          EH.call(n.attrs, o) && (i[ap(t.schema, o).property] = vc(
            n.attrs[o]
          ));
      n.startTag;
      const a = vc(n.startTag), l = n.endTag ? vc(n.endTag) : void 0, c = { opening: a };
      l && (c.closing = l), c.properties = i, e.data = { position: c };
    }
  }
  return r;
}
function vc(t) {
  const e = kO({
    line: t.startLine,
    column: t.startCol,
    offset: t.startOffset
  }), n = kO({
    line: t.endLine,
    column: t.endCol,
    offset: t.endOffset
  });
  return e || n ? { start: e, end: n } : void 0;
}
function kO(t) {
  return t.line && t.column ? t : void 0;
}
const AO = {}.hasOwnProperty;
function bk(t, e) {
  const n = e || {};
  function r(s, ...i) {
    let o = r.invalid;
    const a = r.handlers;
    if (s && AO.call(s, t)) {
      const l = String(s[t]);
      o = AO.call(a, l) ? a[l] : r.unknown;
    }
    if (o)
      return o.call(this, s, ...i);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const rve = {}, sve = {}.hasOwnProperty, xH = bk("type", { handlers: { root: ove, element: hve, text: cve, comment: uve, doctype: lve } });
function ive(t, e) {
  const r = (e || rve).space;
  return xH(t, r === "svg" ? Oi : Pu);
}
function ove(t, e) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (t.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = _k(t.children, n, e), Ou(t, n), n;
}
function ave(t, e) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = _k(t.children, n, e), Ou(t, n), n;
}
function lve(t) {
  const e = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return Ou(t, e), e;
}
function cve(t) {
  const e = {
    nodeName: "#text",
    value: t.value,
    parentNode: null
  };
  return Ou(t, e), e;
}
function uve(t) {
  const e = {
    nodeName: "#comment",
    data: t.value,
    parentNode: null
  };
  return Ou(t, e), e;
}
function hve(t, e) {
  const n = e;
  let r = n;
  t.type === "element" && t.tagName.toLowerCase() === "svg" && n.space === "html" && (r = Oi);
  const s = [];
  let i;
  if (t.properties) {
    for (i in t.properties)
      if (i !== "children" && sve.call(t.properties, i)) {
        const l = dve(
          r,
          i,
          t.properties[i]
        );
        l && s.push(l);
      }
  }
  const o = r.space, a = {
    nodeName: t.tagName,
    tagName: t.tagName,
    attrs: s,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: za[o],
    childNodes: [],
    parentNode: null
  };
  return a.childNodes = _k(t.children, a, r), Ou(t, a), t.tagName === "template" && t.content && (a.content = ave(t.content, r)), a;
}
function dve(t, e, n) {
  const r = ap(t, e);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? mk(n) : gk(n));
  const s = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const i = s.name.indexOf(":");
    i < 0 ? s.prefix = "" : (s.name = s.name.slice(i + 1), s.prefix = r.attribute.slice(0, i)), s.namespace = za[r.space];
  }
  return s;
}
function _k(t, e, n) {
  let r = -1;
  const s = [];
  if (t)
    for (; ++r < t.length; ) {
      const i = xH(t[r], n);
      i.parentNode = e, s.push(i);
    }
  return s;
}
function Ou(t, e) {
  const n = t.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, e.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const TH = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], fve = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), $t = "";
var J;
(function(t) {
  t[t.EOF = -1] = "EOF", t[t.NULL = 0] = "NULL", t[t.TABULATION = 9] = "TABULATION", t[t.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", t[t.LINE_FEED = 10] = "LINE_FEED", t[t.FORM_FEED = 12] = "FORM_FEED", t[t.SPACE = 32] = "SPACE", t[t.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", t[t.QUOTATION_MARK = 34] = "QUOTATION_MARK", t[t.AMPERSAND = 38] = "AMPERSAND", t[t.APOSTROPHE = 39] = "APOSTROPHE", t[t.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", t[t.SOLIDUS = 47] = "SOLIDUS", t[t.DIGIT_0 = 48] = "DIGIT_0", t[t.DIGIT_9 = 57] = "DIGIT_9", t[t.SEMICOLON = 59] = "SEMICOLON", t[t.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", t[t.EQUALS_SIGN = 61] = "EQUALS_SIGN", t[t.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", t[t.QUESTION_MARK = 63] = "QUESTION_MARK", t[t.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", t[t.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", t[t.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", t[t.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", t[t.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", t[t.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(J || (J = {}));
const or = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function CH(t) {
  return t >= 55296 && t <= 57343;
}
function pve(t) {
  return t >= 56320 && t <= 57343;
}
function mve(t, e) {
  return (t - 55296) * 1024 + 9216 + e;
}
function kH(t) {
  return t !== 32 && t !== 10 && t !== 13 && t !== 9 && t !== 12 && t >= 1 && t <= 31 || t >= 127 && t <= 159;
}
function AH(t) {
  return t >= 64976 && t <= 65007 || fve.has(t);
}
var Se;
(function(t) {
  t.controlCharacterInInputStream = "control-character-in-input-stream", t.noncharacterInInputStream = "noncharacter-in-input-stream", t.surrogateInInputStream = "surrogate-in-input-stream", t.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", t.endTagWithAttributes = "end-tag-with-attributes", t.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", t.unexpectedSolidusInTag = "unexpected-solidus-in-tag", t.unexpectedNullCharacter = "unexpected-null-character", t.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", t.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", t.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", t.missingEndTagName = "missing-end-tag-name", t.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", t.unknownNamedCharacterReference = "unknown-named-character-reference", t.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", t.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", t.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", t.eofBeforeTagName = "eof-before-tag-name", t.eofInTag = "eof-in-tag", t.missingAttributeValue = "missing-attribute-value", t.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", t.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", t.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", t.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", t.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", t.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", t.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", t.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", t.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", t.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", t.cdataInHtmlContent = "cdata-in-html-content", t.incorrectlyOpenedComment = "incorrectly-opened-comment", t.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", t.eofInDoctype = "eof-in-doctype", t.nestedComment = "nested-comment", t.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", t.eofInComment = "eof-in-comment", t.incorrectlyClosedComment = "incorrectly-closed-comment", t.eofInCdata = "eof-in-cdata", t.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", t.nullCharacterReference = "null-character-reference", t.surrogateCharacterReference = "surrogate-character-reference", t.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", t.controlCharacterReference = "control-character-reference", t.noncharacterCharacterReference = "noncharacter-character-reference", t.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", t.missingDoctypeName = "missing-doctype-name", t.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", t.duplicateAttribute = "duplicate-attribute", t.nonConformingDoctype = "non-conforming-doctype", t.missingDoctype = "missing-doctype", t.misplacedDoctype = "misplaced-doctype", t.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", t.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", t.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", t.openElementsLeftAfterEof = "open-elements-left-after-eof", t.abandonedHeadElementChild = "abandoned-head-element-child", t.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", t.nestedNoscriptInHead = "nested-noscript-in-head", t.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(Se || (Se = {}));
const gve = 65536;
class yve {
  constructor(e) {
    this.handler = e, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = gve, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(e, n) {
    const { line: r, col: s, offset: i } = this, o = s + n, a = i + n;
    return {
      code: e,
      startLine: r,
      endLine: r,
      startCol: o,
      endCol: o,
      startOffset: a,
      endOffset: a
    };
  }
  _err(e) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(e, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(e) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (pve(n))
        return this.pos++, this._addGap(), mve(e, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, J.EOF;
    return this._err(Se.surrogateInInputStream), e;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(e, n) {
    this.html.length > 0 ? this.html += e : this.html = e, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(e) {
    this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(e, n) {
    if (this.pos + e.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(e, this.pos);
    for (let r = 0; r < e.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== e.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(e) {
    const n = this.pos + e;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, J.EOF;
    const r = this.html.charCodeAt(n);
    return r === J.CARRIAGE_RETURN ? J.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, J.EOF;
    let e = this.html.charCodeAt(this.pos);
    return e === J.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, J.LINE_FEED) : e === J.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, CH(e) && (e = this._processSurrogate(e)), this.handler.onParseError === null || e > 31 && e < 127 || e === J.LINE_FEED || e === J.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e);
  }
  _checkForProblematicCharacters(e) {
    kH(e) ? this._err(Se.controlCharacterInInputStream) : AH(e) && this._err(Se.noncharacterInInputStream);
  }
  retreat(e) {
    for (this.pos -= e; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var lt;
(function(t) {
  t[t.CHARACTER = 0] = "CHARACTER", t[t.NULL_CHARACTER = 1] = "NULL_CHARACTER", t[t.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", t[t.START_TAG = 3] = "START_TAG", t[t.END_TAG = 4] = "END_TAG", t[t.COMMENT = 5] = "COMMENT", t[t.DOCTYPE = 6] = "DOCTYPE", t[t.EOF = 7] = "EOF", t[t.HIBERNATION = 8] = "HIBERNATION";
})(lt || (lt = {}));
function RH(t, e) {
  for (let n = t.attrs.length - 1; n >= 0; n--)
    if (t.attrs[n].name === e)
      return t.attrs[n].value;
  return null;
}
const IH = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((t) => t.charCodeAt(0))
), bve = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((t) => t.charCodeAt(0))
);
var Wv;
const _ve = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), vve = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Wv = String.fromCodePoint) !== null && Wv !== void 0 ? Wv : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function wve(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = _ve.get(t)) !== null && e !== void 0 ? e : t;
}
var _n;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(_n || (_n = {}));
const Eve = 32;
var jo;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(jo || (jo = {}));
function AS(t) {
  return t >= _n.ZERO && t <= _n.NINE;
}
function Sve(t) {
  return t >= _n.UPPER_A && t <= _n.UPPER_F || t >= _n.LOWER_A && t <= _n.LOWER_F;
}
function xve(t) {
  return t >= _n.UPPER_A && t <= _n.UPPER_Z || t >= _n.LOWER_A && t <= _n.LOWER_Z || AS(t);
}
function Tve(t) {
  return t === _n.EQUALS || xve(t);
}
var yn;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(yn || (yn = {}));
var Xi;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(Xi || (Xi = {}));
class PH {
  constructor(e, n, r) {
    this.decodeTree = e, this.emitCodePoint = n, this.errors = r, this.state = yn.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Xi.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = yn.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, n) {
    switch (this.state) {
      case yn.EntityStart:
        return e.charCodeAt(n) === _n.NUM ? (this.state = yn.NumericStart, this.consumed += 1, this.stateNumericStart(e, n + 1)) : (this.state = yn.NamedEntity, this.stateNamedEntity(e, n));
      case yn.NumericStart:
        return this.stateNumericStart(e, n);
      case yn.NumericDecimal:
        return this.stateNumericDecimal(e, n);
      case yn.NumericHex:
        return this.stateNumericHex(e, n);
      case yn.NamedEntity:
        return this.stateNamedEntity(e, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, n) {
    return n >= e.length ? -1 : (e.charCodeAt(n) | Eve) === _n.LOWER_X ? (this.state = yn.NumericHex, this.consumed += 1, this.stateNumericHex(e, n + 1)) : (this.state = yn.NumericDecimal, this.stateNumericDecimal(e, n));
  }
  addToNumericResult(e, n, r, s) {
    if (n !== r) {
      const i = r - n;
      this.result = this.result * Math.pow(s, i) + parseInt(e.substr(n, i), s), this.consumed += i;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const s = e.charCodeAt(n);
      if (AS(s) || Sve(s))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 16), this.emitNumericEntity(s, 3);
    }
    return this.addToNumericResult(e, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const s = e.charCodeAt(n);
      if (AS(s))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 10), this.emitNumericEntity(s, 2);
    }
    return this.addToNumericResult(e, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === _n.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Xi.Strict)
      return 0;
    return this.emitCodePoint(wve(this.result), this.consumed), this.errors && (e !== _n.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, n) {
    const { decodeTree: r } = this;
    let s = r[this.treeIndex], i = (s & jo.VALUE_LENGTH) >> 14;
    for (; n < e.length; n++, this.excess++) {
      const o = e.charCodeAt(n);
      if (this.treeIndex = Cve(r, s, this.treeIndex + Math.max(1, i), o), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Xi.Attribute && // We shouldn't have consumed any characters after the entity,
        (i === 0 || // And there should be no invalid characters.
        Tve(o)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (s = r[this.treeIndex], i = (s & jo.VALUE_LENGTH) >> 14, i !== 0) {
        if (o === _n.SEMI)
          return this.emitNamedEntityData(this.treeIndex, i, this.consumed + this.excess);
        this.decodeMode !== Xi.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: n, decodeTree: r } = this, s = (r[n] & jo.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, s, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, n, r) {
    const { decodeTree: s } = this;
    return this.emitCodePoint(n === 1 ? s[e] & ~jo.VALUE_LENGTH : s[e + 1], r), n === 3 && this.emitCodePoint(s[e + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case yn.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Xi.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case yn.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case yn.NumericHex:
        return this.emitNumericEntity(0, 3);
      case yn.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case yn.EntityStart:
        return 0;
    }
  }
}
function OH(t) {
  let e = "";
  const n = new PH(t, (r) => e += vve(r));
  return function(s, i) {
    let o = 0, a = 0;
    for (; (a = s.indexOf("&", a)) >= 0; ) {
      e += s.slice(o, a), n.startEntity(i);
      const c = n.write(
        s,
        // Skip the "&"
        a + 1
      );
      if (c < 0) {
        o = a + n.end();
        break;
      }
      o = a + c, a = c === 0 ? o + 1 : o;
    }
    const l = e + s.slice(o);
    return e = "", l;
  };
}
function Cve(t, e, n, r) {
  const s = (e & jo.BRANCH_LENGTH) >> 7, i = e & jo.JUMP_TABLE;
  if (s === 0)
    return i !== 0 && r === i ? n : -1;
  if (i) {
    const l = r - i;
    return l < 0 || l >= s ? -1 : t[n + l] - 1;
  }
  let o = n, a = o + s - 1;
  for (; o <= a; ) {
    const l = o + a >>> 1, c = t[l];
    if (c < r)
      o = l + 1;
    else if (c > r)
      a = l - 1;
    else
      return t[l + s];
  }
  return -1;
}
OH(IH);
OH(bve);
var Ie;
(function(t) {
  t.HTML = "http://www.w3.org/1999/xhtml", t.MATHML = "http://www.w3.org/1998/Math/MathML", t.SVG = "http://www.w3.org/2000/svg", t.XLINK = "http://www.w3.org/1999/xlink", t.XML = "http://www.w3.org/XML/1998/namespace", t.XMLNS = "http://www.w3.org/2000/xmlns/";
})(Ie || (Ie = {}));
var il;
(function(t) {
  t.TYPE = "type", t.ACTION = "action", t.ENCODING = "encoding", t.PROMPT = "prompt", t.NAME = "name", t.COLOR = "color", t.FACE = "face", t.SIZE = "size";
})(il || (il = {}));
var Wr;
(function(t) {
  t.NO_QUIRKS = "no-quirks", t.QUIRKS = "quirks", t.LIMITED_QUIRKS = "limited-quirks";
})(Wr || (Wr = {}));
var pe;
(function(t) {
  t.A = "a", t.ADDRESS = "address", t.ANNOTATION_XML = "annotation-xml", t.APPLET = "applet", t.AREA = "area", t.ARTICLE = "article", t.ASIDE = "aside", t.B = "b", t.BASE = "base", t.BASEFONT = "basefont", t.BGSOUND = "bgsound", t.BIG = "big", t.BLOCKQUOTE = "blockquote", t.BODY = "body", t.BR = "br", t.BUTTON = "button", t.CAPTION = "caption", t.CENTER = "center", t.CODE = "code", t.COL = "col", t.COLGROUP = "colgroup", t.DD = "dd", t.DESC = "desc", t.DETAILS = "details", t.DIALOG = "dialog", t.DIR = "dir", t.DIV = "div", t.DL = "dl", t.DT = "dt", t.EM = "em", t.EMBED = "embed", t.FIELDSET = "fieldset", t.FIGCAPTION = "figcaption", t.FIGURE = "figure", t.FONT = "font", t.FOOTER = "footer", t.FOREIGN_OBJECT = "foreignObject", t.FORM = "form", t.FRAME = "frame", t.FRAMESET = "frameset", t.H1 = "h1", t.H2 = "h2", t.H3 = "h3", t.H4 = "h4", t.H5 = "h5", t.H6 = "h6", t.HEAD = "head", t.HEADER = "header", t.HGROUP = "hgroup", t.HR = "hr", t.HTML = "html", t.I = "i", t.IMG = "img", t.IMAGE = "image", t.INPUT = "input", t.IFRAME = "iframe", t.KEYGEN = "keygen", t.LABEL = "label", t.LI = "li", t.LINK = "link", t.LISTING = "listing", t.MAIN = "main", t.MALIGNMARK = "malignmark", t.MARQUEE = "marquee", t.MATH = "math", t.MENU = "menu", t.META = "meta", t.MGLYPH = "mglyph", t.MI = "mi", t.MO = "mo", t.MN = "mn", t.MS = "ms", t.MTEXT = "mtext", t.NAV = "nav", t.NOBR = "nobr", t.NOFRAMES = "noframes", t.NOEMBED = "noembed", t.NOSCRIPT = "noscript", t.OBJECT = "object", t.OL = "ol", t.OPTGROUP = "optgroup", t.OPTION = "option", t.P = "p", t.PARAM = "param", t.PLAINTEXT = "plaintext", t.PRE = "pre", t.RB = "rb", t.RP = "rp", t.RT = "rt", t.RTC = "rtc", t.RUBY = "ruby", t.S = "s", t.SCRIPT = "script", t.SEARCH = "search", t.SECTION = "section", t.SELECT = "select", t.SOURCE = "source", t.SMALL = "small", t.SPAN = "span", t.STRIKE = "strike", t.STRONG = "strong", t.STYLE = "style", t.SUB = "sub", t.SUMMARY = "summary", t.SUP = "sup", t.TABLE = "table", t.TBODY = "tbody", t.TEMPLATE = "template", t.TEXTAREA = "textarea", t.TFOOT = "tfoot", t.TD = "td", t.TH = "th", t.THEAD = "thead", t.TITLE = "title", t.TR = "tr", t.TRACK = "track", t.TT = "tt", t.U = "u", t.UL = "ul", t.SVG = "svg", t.VAR = "var", t.WBR = "wbr", t.XMP = "xmp";
})(pe || (pe = {}));
var C;
(function(t) {
  t[t.UNKNOWN = 0] = "UNKNOWN", t[t.A = 1] = "A", t[t.ADDRESS = 2] = "ADDRESS", t[t.ANNOTATION_XML = 3] = "ANNOTATION_XML", t[t.APPLET = 4] = "APPLET", t[t.AREA = 5] = "AREA", t[t.ARTICLE = 6] = "ARTICLE", t[t.ASIDE = 7] = "ASIDE", t[t.B = 8] = "B", t[t.BASE = 9] = "BASE", t[t.BASEFONT = 10] = "BASEFONT", t[t.BGSOUND = 11] = "BGSOUND", t[t.BIG = 12] = "BIG", t[t.BLOCKQUOTE = 13] = "BLOCKQUOTE", t[t.BODY = 14] = "BODY", t[t.BR = 15] = "BR", t[t.BUTTON = 16] = "BUTTON", t[t.CAPTION = 17] = "CAPTION", t[t.CENTER = 18] = "CENTER", t[t.CODE = 19] = "CODE", t[t.COL = 20] = "COL", t[t.COLGROUP = 21] = "COLGROUP", t[t.DD = 22] = "DD", t[t.DESC = 23] = "DESC", t[t.DETAILS = 24] = "DETAILS", t[t.DIALOG = 25] = "DIALOG", t[t.DIR = 26] = "DIR", t[t.DIV = 27] = "DIV", t[t.DL = 28] = "DL", t[t.DT = 29] = "DT", t[t.EM = 30] = "EM", t[t.EMBED = 31] = "EMBED", t[t.FIELDSET = 32] = "FIELDSET", t[t.FIGCAPTION = 33] = "FIGCAPTION", t[t.FIGURE = 34] = "FIGURE", t[t.FONT = 35] = "FONT", t[t.FOOTER = 36] = "FOOTER", t[t.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", t[t.FORM = 38] = "FORM", t[t.FRAME = 39] = "FRAME", t[t.FRAMESET = 40] = "FRAMESET", t[t.H1 = 41] = "H1", t[t.H2 = 42] = "H2", t[t.H3 = 43] = "H3", t[t.H4 = 44] = "H4", t[t.H5 = 45] = "H5", t[t.H6 = 46] = "H6", t[t.HEAD = 47] = "HEAD", t[t.HEADER = 48] = "HEADER", t[t.HGROUP = 49] = "HGROUP", t[t.HR = 50] = "HR", t[t.HTML = 51] = "HTML", t[t.I = 52] = "I", t[t.IMG = 53] = "IMG", t[t.IMAGE = 54] = "IMAGE", t[t.INPUT = 55] = "INPUT", t[t.IFRAME = 56] = "IFRAME", t[t.KEYGEN = 57] = "KEYGEN", t[t.LABEL = 58] = "LABEL", t[t.LI = 59] = "LI", t[t.LINK = 60] = "LINK", t[t.LISTING = 61] = "LISTING", t[t.MAIN = 62] = "MAIN", t[t.MALIGNMARK = 63] = "MALIGNMARK", t[t.MARQUEE = 64] = "MARQUEE", t[t.MATH = 65] = "MATH", t[t.MENU = 66] = "MENU", t[t.META = 67] = "META", t[t.MGLYPH = 68] = "MGLYPH", t[t.MI = 69] = "MI", t[t.MO = 70] = "MO", t[t.MN = 71] = "MN", t[t.MS = 72] = "MS", t[t.MTEXT = 73] = "MTEXT", t[t.NAV = 74] = "NAV", t[t.NOBR = 75] = "NOBR", t[t.NOFRAMES = 76] = "NOFRAMES", t[t.NOEMBED = 77] = "NOEMBED", t[t.NOSCRIPT = 78] = "NOSCRIPT", t[t.OBJECT = 79] = "OBJECT", t[t.OL = 80] = "OL", t[t.OPTGROUP = 81] = "OPTGROUP", t[t.OPTION = 82] = "OPTION", t[t.P = 83] = "P", t[t.PARAM = 84] = "PARAM", t[t.PLAINTEXT = 85] = "PLAINTEXT", t[t.PRE = 86] = "PRE", t[t.RB = 87] = "RB", t[t.RP = 88] = "RP", t[t.RT = 89] = "RT", t[t.RTC = 90] = "RTC", t[t.RUBY = 91] = "RUBY", t[t.S = 92] = "S", t[t.SCRIPT = 93] = "SCRIPT", t[t.SEARCH = 94] = "SEARCH", t[t.SECTION = 95] = "SECTION", t[t.SELECT = 96] = "SELECT", t[t.SOURCE = 97] = "SOURCE", t[t.SMALL = 98] = "SMALL", t[t.SPAN = 99] = "SPAN", t[t.STRIKE = 100] = "STRIKE", t[t.STRONG = 101] = "STRONG", t[t.STYLE = 102] = "STYLE", t[t.SUB = 103] = "SUB", t[t.SUMMARY = 104] = "SUMMARY", t[t.SUP = 105] = "SUP", t[t.TABLE = 106] = "TABLE", t[t.TBODY = 107] = "TBODY", t[t.TEMPLATE = 108] = "TEMPLATE", t[t.TEXTAREA = 109] = "TEXTAREA", t[t.TFOOT = 110] = "TFOOT", t[t.TD = 111] = "TD", t[t.TH = 112] = "TH", t[t.THEAD = 113] = "THEAD", t[t.TITLE = 114] = "TITLE", t[t.TR = 115] = "TR", t[t.TRACK = 116] = "TRACK", t[t.TT = 117] = "TT", t[t.U = 118] = "U", t[t.UL = 119] = "UL", t[t.SVG = 120] = "SVG", t[t.VAR = 121] = "VAR", t[t.WBR = 122] = "WBR", t[t.XMP = 123] = "XMP";
})(C || (C = {}));
const kve = /* @__PURE__ */ new Map([
  [pe.A, C.A],
  [pe.ADDRESS, C.ADDRESS],
  [pe.ANNOTATION_XML, C.ANNOTATION_XML],
  [pe.APPLET, C.APPLET],
  [pe.AREA, C.AREA],
  [pe.ARTICLE, C.ARTICLE],
  [pe.ASIDE, C.ASIDE],
  [pe.B, C.B],
  [pe.BASE, C.BASE],
  [pe.BASEFONT, C.BASEFONT],
  [pe.BGSOUND, C.BGSOUND],
  [pe.BIG, C.BIG],
  [pe.BLOCKQUOTE, C.BLOCKQUOTE],
  [pe.BODY, C.BODY],
  [pe.BR, C.BR],
  [pe.BUTTON, C.BUTTON],
  [pe.CAPTION, C.CAPTION],
  [pe.CENTER, C.CENTER],
  [pe.CODE, C.CODE],
  [pe.COL, C.COL],
  [pe.COLGROUP, C.COLGROUP],
  [pe.DD, C.DD],
  [pe.DESC, C.DESC],
  [pe.DETAILS, C.DETAILS],
  [pe.DIALOG, C.DIALOG],
  [pe.DIR, C.DIR],
  [pe.DIV, C.DIV],
  [pe.DL, C.DL],
  [pe.DT, C.DT],
  [pe.EM, C.EM],
  [pe.EMBED, C.EMBED],
  [pe.FIELDSET, C.FIELDSET],
  [pe.FIGCAPTION, C.FIGCAPTION],
  [pe.FIGURE, C.FIGURE],
  [pe.FONT, C.FONT],
  [pe.FOOTER, C.FOOTER],
  [pe.FOREIGN_OBJECT, C.FOREIGN_OBJECT],
  [pe.FORM, C.FORM],
  [pe.FRAME, C.FRAME],
  [pe.FRAMESET, C.FRAMESET],
  [pe.H1, C.H1],
  [pe.H2, C.H2],
  [pe.H3, C.H3],
  [pe.H4, C.H4],
  [pe.H5, C.H5],
  [pe.H6, C.H6],
  [pe.HEAD, C.HEAD],
  [pe.HEADER, C.HEADER],
  [pe.HGROUP, C.HGROUP],
  [pe.HR, C.HR],
  [pe.HTML, C.HTML],
  [pe.I, C.I],
  [pe.IMG, C.IMG],
  [pe.IMAGE, C.IMAGE],
  [pe.INPUT, C.INPUT],
  [pe.IFRAME, C.IFRAME],
  [pe.KEYGEN, C.KEYGEN],
  [pe.LABEL, C.LABEL],
  [pe.LI, C.LI],
  [pe.LINK, C.LINK],
  [pe.LISTING, C.LISTING],
  [pe.MAIN, C.MAIN],
  [pe.MALIGNMARK, C.MALIGNMARK],
  [pe.MARQUEE, C.MARQUEE],
  [pe.MATH, C.MATH],
  [pe.MENU, C.MENU],
  [pe.META, C.META],
  [pe.MGLYPH, C.MGLYPH],
  [pe.MI, C.MI],
  [pe.MO, C.MO],
  [pe.MN, C.MN],
  [pe.MS, C.MS],
  [pe.MTEXT, C.MTEXT],
  [pe.NAV, C.NAV],
  [pe.NOBR, C.NOBR],
  [pe.NOFRAMES, C.NOFRAMES],
  [pe.NOEMBED, C.NOEMBED],
  [pe.NOSCRIPT, C.NOSCRIPT],
  [pe.OBJECT, C.OBJECT],
  [pe.OL, C.OL],
  [pe.OPTGROUP, C.OPTGROUP],
  [pe.OPTION, C.OPTION],
  [pe.P, C.P],
  [pe.PARAM, C.PARAM],
  [pe.PLAINTEXT, C.PLAINTEXT],
  [pe.PRE, C.PRE],
  [pe.RB, C.RB],
  [pe.RP, C.RP],
  [pe.RT, C.RT],
  [pe.RTC, C.RTC],
  [pe.RUBY, C.RUBY],
  [pe.S, C.S],
  [pe.SCRIPT, C.SCRIPT],
  [pe.SEARCH, C.SEARCH],
  [pe.SECTION, C.SECTION],
  [pe.SELECT, C.SELECT],
  [pe.SOURCE, C.SOURCE],
  [pe.SMALL, C.SMALL],
  [pe.SPAN, C.SPAN],
  [pe.STRIKE, C.STRIKE],
  [pe.STRONG, C.STRONG],
  [pe.STYLE, C.STYLE],
  [pe.SUB, C.SUB],
  [pe.SUMMARY, C.SUMMARY],
  [pe.SUP, C.SUP],
  [pe.TABLE, C.TABLE],
  [pe.TBODY, C.TBODY],
  [pe.TEMPLATE, C.TEMPLATE],
  [pe.TEXTAREA, C.TEXTAREA],
  [pe.TFOOT, C.TFOOT],
  [pe.TD, C.TD],
  [pe.TH, C.TH],
  [pe.THEAD, C.THEAD],
  [pe.TITLE, C.TITLE],
  [pe.TR, C.TR],
  [pe.TRACK, C.TRACK],
  [pe.TT, C.TT],
  [pe.U, C.U],
  [pe.UL, C.UL],
  [pe.SVG, C.SVG],
  [pe.VAR, C.VAR],
  [pe.WBR, C.WBR],
  [pe.XMP, C.XMP]
]);
function Du(t) {
  var e;
  return (e = kve.get(t)) !== null && e !== void 0 ? e : C.UNKNOWN;
}
const Pe = C, Ave = {
  [Ie.HTML]: /* @__PURE__ */ new Set([
    Pe.ADDRESS,
    Pe.APPLET,
    Pe.AREA,
    Pe.ARTICLE,
    Pe.ASIDE,
    Pe.BASE,
    Pe.BASEFONT,
    Pe.BGSOUND,
    Pe.BLOCKQUOTE,
    Pe.BODY,
    Pe.BR,
    Pe.BUTTON,
    Pe.CAPTION,
    Pe.CENTER,
    Pe.COL,
    Pe.COLGROUP,
    Pe.DD,
    Pe.DETAILS,
    Pe.DIR,
    Pe.DIV,
    Pe.DL,
    Pe.DT,
    Pe.EMBED,
    Pe.FIELDSET,
    Pe.FIGCAPTION,
    Pe.FIGURE,
    Pe.FOOTER,
    Pe.FORM,
    Pe.FRAME,
    Pe.FRAMESET,
    Pe.H1,
    Pe.H2,
    Pe.H3,
    Pe.H4,
    Pe.H5,
    Pe.H6,
    Pe.HEAD,
    Pe.HEADER,
    Pe.HGROUP,
    Pe.HR,
    Pe.HTML,
    Pe.IFRAME,
    Pe.IMG,
    Pe.INPUT,
    Pe.LI,
    Pe.LINK,
    Pe.LISTING,
    Pe.MAIN,
    Pe.MARQUEE,
    Pe.MENU,
    Pe.META,
    Pe.NAV,
    Pe.NOEMBED,
    Pe.NOFRAMES,
    Pe.NOSCRIPT,
    Pe.OBJECT,
    Pe.OL,
    Pe.P,
    Pe.PARAM,
    Pe.PLAINTEXT,
    Pe.PRE,
    Pe.SCRIPT,
    Pe.SECTION,
    Pe.SELECT,
    Pe.SOURCE,
    Pe.STYLE,
    Pe.SUMMARY,
    Pe.TABLE,
    Pe.TBODY,
    Pe.TD,
    Pe.TEMPLATE,
    Pe.TEXTAREA,
    Pe.TFOOT,
    Pe.TH,
    Pe.THEAD,
    Pe.TITLE,
    Pe.TR,
    Pe.TRACK,
    Pe.UL,
    Pe.WBR,
    Pe.XMP
  ]),
  [Ie.MATHML]: /* @__PURE__ */ new Set([Pe.MI, Pe.MO, Pe.MN, Pe.MS, Pe.MTEXT, Pe.ANNOTATION_XML]),
  [Ie.SVG]: /* @__PURE__ */ new Set([Pe.TITLE, Pe.FOREIGN_OBJECT, Pe.DESC]),
  [Ie.XLINK]: /* @__PURE__ */ new Set(),
  [Ie.XML]: /* @__PURE__ */ new Set(),
  [Ie.XMLNS]: /* @__PURE__ */ new Set()
}, RS = /* @__PURE__ */ new Set([Pe.H1, Pe.H2, Pe.H3, Pe.H4, Pe.H5, Pe.H6]);
pe.STYLE, pe.SCRIPT, pe.XMP, pe.IFRAME, pe.NOEMBED, pe.NOFRAMES, pe.PLAINTEXT;
var Q;
(function(t) {
  t[t.DATA = 0] = "DATA", t[t.RCDATA = 1] = "RCDATA", t[t.RAWTEXT = 2] = "RAWTEXT", t[t.SCRIPT_DATA = 3] = "SCRIPT_DATA", t[t.PLAINTEXT = 4] = "PLAINTEXT", t[t.TAG_OPEN = 5] = "TAG_OPEN", t[t.END_TAG_OPEN = 6] = "END_TAG_OPEN", t[t.TAG_NAME = 7] = "TAG_NAME", t[t.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", t[t.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", t[t.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", t[t.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", t[t.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", t[t.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", t[t.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", t[t.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", t[t.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", t[t.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", t[t.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", t[t.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", t[t.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", t[t.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", t[t.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", t[t.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", t[t.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", t[t.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", t[t.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", t[t.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", t[t.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", t[t.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", t[t.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", t[t.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", t[t.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", t[t.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", t[t.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", t[t.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", t[t.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", t[t.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", t[t.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", t[t.COMMENT_START = 42] = "COMMENT_START", t[t.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", t[t.COMMENT = 44] = "COMMENT", t[t.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", t[t.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", t[t.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", t[t.COMMENT_END = 50] = "COMMENT_END", t[t.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", t[t.DOCTYPE = 52] = "DOCTYPE", t[t.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", t[t.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", t[t.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", t[t.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", t[t.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", t[t.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", t[t.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", t[t.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", t[t.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", t[t.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", t[t.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", t[t.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", t[t.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", t[t.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", t[t.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", t[t.CDATA_SECTION = 68] = "CDATA_SECTION", t[t.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", t[t.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", t[t.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", t[t.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(Q || (Q = {}));
const Qt = {
  DATA: Q.DATA,
  RCDATA: Q.RCDATA,
  RAWTEXT: Q.RAWTEXT,
  SCRIPT_DATA: Q.SCRIPT_DATA,
  PLAINTEXT: Q.PLAINTEXT,
  CDATA_SECTION: Q.CDATA_SECTION
};
function Rve(t) {
  return t >= J.DIGIT_0 && t <= J.DIGIT_9;
}
function kh(t) {
  return t >= J.LATIN_CAPITAL_A && t <= J.LATIN_CAPITAL_Z;
}
function Ive(t) {
  return t >= J.LATIN_SMALL_A && t <= J.LATIN_SMALL_Z;
}
function Ao(t) {
  return Ive(t) || kh(t);
}
function RO(t) {
  return Ao(t) || Rve(t);
}
function ym(t) {
  return t + 32;
}
function DH(t) {
  return t === J.SPACE || t === J.LINE_FEED || t === J.TABULATION || t === J.FORM_FEED;
}
function IO(t) {
  return DH(t) || t === J.SOLIDUS || t === J.GREATER_THAN_SIGN;
}
function Pve(t) {
  return t === J.NULL ? Se.nullCharacterReference : t > 1114111 ? Se.characterReferenceOutsideUnicodeRange : CH(t) ? Se.surrogateCharacterReference : AH(t) ? Se.noncharacterCharacterReference : kH(t) || t === J.CARRIAGE_RETURN ? Se.controlCharacterReference : null;
}
class Ove {
  constructor(e, n) {
    this.options = e, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = Q.DATA, this.returnState = Q.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new yve(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new PH(IH, (r, s) => {
      this.preprocessor.pos = this.entityStartPos + s - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(Se.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(Se.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const s = Pve(r);
        s && this._err(s, 1);
      }
    } : void 0);
  }
  //Errors
  _err(e, n = 0) {
    var r, s;
    (s = (r = this.handler).onParseError) === null || s === void 0 || s.call(r, this.preprocessor.getError(e, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(e) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - e,
      startOffset: this.preprocessor.offset - e,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const e = this._consume();
        this._ensureHibernation() || this._callState(e);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(e) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || e?.());
  }
  write(e, n, r) {
    this.active = !0, this.preprocessor.write(e, n), this._runParsingLoop(), this.paused || r?.();
  }
  insertHtmlAtCurrentPos(e) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(e) {
    this.consumedAfterSnapshot += e;
    for (let n = 0; n < e; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(e, n) {
    return this.preprocessor.startsWith(e, n) ? (this._advanceBy(e.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: lt.START_TAG,
      tagName: "",
      tagID: C.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: lt.END_TAG,
      tagName: "",
      tagID: C.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(e) {
    this.currentToken = {
      type: lt.COMMENT,
      data: "",
      location: this.getCurrentLocation(e)
    };
  }
  _createDoctypeToken(e) {
    this.currentToken = {
      type: lt.DOCTYPE,
      name: e,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(e, n) {
    this.currentCharacterToken = {
      type: e,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(e) {
    this.currentAttr = {
      name: e,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var e, n;
    const r = this.currentToken;
    if (RH(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const s = (e = (n = r.location).attrs) !== null && e !== void 0 ? e : n.attrs = /* @__PURE__ */ Object.create(null);
        s[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(Se.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(e) {
    this._emitCurrentCharacterToken(e.location), this.currentToken = null, e.location && (e.location.endLine = this.preprocessor.line, e.location.endCol = this.preprocessor.col + 1, e.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const e = this.currentToken;
    this.prepareToken(e), e.tagID = Du(e.tagName), e.type === lt.START_TAG ? (this.lastStartTagName = e.tagName, this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(Se.endTagWithAttributes), e.selfClosing && this._err(Se.endTagWithTrailingSolidus), this.handler.onEndTag(e)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(e) {
    this.prepareToken(e), this.handler.onComment(e), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(e) {
    this.prepareToken(e), this.handler.onDoctype(e), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(e) {
    if (this.currentCharacterToken) {
      switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine, this.currentCharacterToken.location.endCol = e.startCol, this.currentCharacterToken.location.endOffset = e.startOffset), this.currentCharacterToken.type) {
        case lt.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case lt.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case lt.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const e = this.getCurrentLocation(0);
    e && (e.endLine = e.startLine, e.endCol = e.startCol, e.endOffset = e.startOffset), this._emitCurrentCharacterToken(e), this.handler.onEof({ type: lt.EOF, location: e }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(e, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === e) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(e, n);
  }
  _emitCodePoint(e) {
    const n = DH(e) ? lt.WHITESPACE_CHARACTER : e === J.NULL ? lt.NULL_CHARACTER : lt.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(e));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(e) {
    this._appendCharToCurrentCharacterToken(lt.CHARACTER, e);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = Q.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? Xi.Attribute : Xi.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === Q.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === Q.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === Q.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(e) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(e) {
    switch (this.state) {
      case Q.DATA: {
        this._stateData(e);
        break;
      }
      case Q.RCDATA: {
        this._stateRcdata(e);
        break;
      }
      case Q.RAWTEXT: {
        this._stateRawtext(e);
        break;
      }
      case Q.SCRIPT_DATA: {
        this._stateScriptData(e);
        break;
      }
      case Q.PLAINTEXT: {
        this._statePlaintext(e);
        break;
      }
      case Q.TAG_OPEN: {
        this._stateTagOpen(e);
        break;
      }
      case Q.END_TAG_OPEN: {
        this._stateEndTagOpen(e);
        break;
      }
      case Q.TAG_NAME: {
        this._stateTagName(e);
        break;
      }
      case Q.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(e);
        break;
      }
      case Q.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(e);
        break;
      }
      case Q.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(e);
        break;
      }
      case Q.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(e);
        break;
      }
      case Q.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(e);
        break;
      }
      case Q.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(e);
        break;
      }
      case Q.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(e);
        break;
      }
      case Q.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(e);
        break;
      }
      case Q.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(e);
        break;
      }
      case Q.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(e);
        break;
      }
      case Q.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(e);
        break;
      }
      case Q.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(e);
        break;
      }
      case Q.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(e);
        break;
      }
      case Q.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(e);
        break;
      }
      case Q.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(e);
        break;
      }
      case Q.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(e);
        break;
      }
      case Q.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(e);
        break;
      }
      case Q.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(e);
        break;
      }
      case Q.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(e);
        break;
      }
      case Q.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(e);
        break;
      }
      case Q.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(e);
        break;
      }
      case Q.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(e);
        break;
      }
      case Q.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(e);
        break;
      }
      case Q.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(e);
        break;
      }
      case Q.ATTRIBUTE_NAME: {
        this._stateAttributeName(e);
        break;
      }
      case Q.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(e);
        break;
      }
      case Q.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(e);
        break;
      }
      case Q.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(e);
        break;
      }
      case Q.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(e);
        break;
      }
      case Q.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(e);
        break;
      }
      case Q.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(e);
        break;
      }
      case Q.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(e);
        break;
      }
      case Q.BOGUS_COMMENT: {
        this._stateBogusComment(e);
        break;
      }
      case Q.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(e);
        break;
      }
      case Q.COMMENT_START: {
        this._stateCommentStart(e);
        break;
      }
      case Q.COMMENT_START_DASH: {
        this._stateCommentStartDash(e);
        break;
      }
      case Q.COMMENT: {
        this._stateComment(e);
        break;
      }
      case Q.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(e);
        break;
      }
      case Q.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(e);
        break;
      }
      case Q.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(e);
        break;
      }
      case Q.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(e);
        break;
      }
      case Q.COMMENT_END_DASH: {
        this._stateCommentEndDash(e);
        break;
      }
      case Q.COMMENT_END: {
        this._stateCommentEnd(e);
        break;
      }
      case Q.COMMENT_END_BANG: {
        this._stateCommentEndBang(e);
        break;
      }
      case Q.DOCTYPE: {
        this._stateDoctype(e);
        break;
      }
      case Q.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(e);
        break;
      }
      case Q.DOCTYPE_NAME: {
        this._stateDoctypeName(e);
        break;
      }
      case Q.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(e);
        break;
      }
      case Q.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(e);
        break;
      }
      case Q.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(e);
        break;
      }
      case Q.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(e);
        break;
      }
      case Q.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(e);
        break;
      }
      case Q.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(e);
        break;
      }
      case Q.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(e);
        break;
      }
      case Q.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(e);
        break;
      }
      case Q.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(e);
        break;
      }
      case Q.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(e);
        break;
      }
      case Q.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(e);
        break;
      }
      case Q.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(e);
        break;
      }
      case Q.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(e);
        break;
      }
      case Q.CDATA_SECTION: {
        this._stateCdataSection(e);
        break;
      }
      case Q.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(e);
        break;
      }
      case Q.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(e);
        break;
      }
      case Q.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case Q.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(e);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(e) {
    switch (e) {
      case J.LESS_THAN_SIGN: {
        this.state = Q.TAG_OPEN;
        break;
      }
      case J.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this._emitCodePoint(e);
        break;
      }
      case J.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(e) {
    switch (e) {
      case J.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case J.LESS_THAN_SIGN: {
        this.state = Q.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(e) {
    switch (e) {
      case J.LESS_THAN_SIGN: {
        this.state = Q.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(e) {
    switch (e) {
      case J.LESS_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(e) {
    switch (e) {
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(e) {
    if (Ao(e))
      this._createStartTagToken(), this.state = Q.TAG_NAME, this._stateTagName(e);
    else
      switch (e) {
        case J.EXCLAMATION_MARK: {
          this.state = Q.MARKUP_DECLARATION_OPEN;
          break;
        }
        case J.SOLIDUS: {
          this.state = Q.END_TAG_OPEN;
          break;
        }
        case J.QUESTION_MARK: {
          this._err(Se.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = Q.BOGUS_COMMENT, this._stateBogusComment(e);
          break;
        }
        case J.EOF: {
          this._err(Se.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(Se.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = Q.DATA, this._stateData(e);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(e) {
    if (Ao(e))
      this._createEndTagToken(), this.state = Q.TAG_NAME, this._stateTagName(e);
    else
      switch (e) {
        case J.GREATER_THAN_SIGN: {
          this._err(Se.missingEndTagName), this.state = Q.DATA;
          break;
        }
        case J.EOF: {
          this._err(Se.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(Se.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = Q.BOGUS_COMMENT, this._stateBogusComment(e);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED: {
        this.state = Q.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case J.SOLIDUS: {
        this.state = Q.SELF_CLOSING_START_TAG;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this.state = Q.DATA, this.emitCurrentTagToken();
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), n.tagName += $t;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(kh(e) ? ym(e) : e);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(e) {
    e === J.SOLIDUS ? this.state = Q.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = Q.RCDATA, this._stateRcdata(e));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(e) {
    Ao(e) ? (this.state = Q.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(e)) : (this._emitChars("</"), this.state = Q.RCDATA, this._stateRcdata(e));
  }
  handleSpecialEndTag(e) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = Q.BEFORE_ATTRIBUTE_NAME, !1;
      case J.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = Q.SELF_CLOSING_START_TAG, !1;
      case J.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = Q.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = Q.RCDATA, this._stateRcdata(e));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(e) {
    e === J.SOLIDUS ? this.state = Q.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = Q.RAWTEXT, this._stateRawtext(e));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(e) {
    Ao(e) ? (this.state = Q.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(e)) : (this._emitChars("</"), this.state = Q.RAWTEXT, this._stateRawtext(e));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = Q.RAWTEXT, this._stateRawtext(e));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(e) {
    switch (e) {
      case J.SOLIDUS: {
        this.state = Q.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case J.EXCLAMATION_MARK: {
        this.state = Q.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = Q.SCRIPT_DATA, this._stateScriptData(e);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(e) {
    Ao(e) ? (this.state = Q.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(e)) : (this._emitChars("</"), this.state = Q.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = Q.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(e) {
    e === J.HYPHEN_MINUS ? (this.state = Q.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = Q.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(e) {
    e === J.HYPHEN_MINUS ? (this.state = Q.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = Q.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(e) {
    switch (e) {
      case J.HYPHEN_MINUS: {
        this.state = Q.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case J.LESS_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(e) {
    switch (e) {
      case J.HYPHEN_MINUS: {
        this.state = Q.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case J.LESS_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this.state = Q.SCRIPT_DATA_ESCAPED, this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = Q.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(e) {
    switch (e) {
      case J.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case J.LESS_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this.state = Q.SCRIPT_DATA_ESCAPED, this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = Q.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(e) {
    e === J.SOLIDUS ? this.state = Q.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Ao(e) ? (this._emitChars("<"), this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"), this.state = Q.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(e) {
    Ao(e) ? (this.state = Q.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"), this.state = Q.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = Q.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(e) {
    if (this.preprocessor.startsWith(or.SCRIPT, !1) && IO(this.preprocessor.peek(or.SCRIPT.length))) {
      this._emitCodePoint(e);
      for (let n = 0; n < or.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = Q.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(e) {
    switch (e) {
      case J.HYPHEN_MINUS: {
        this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case J.LESS_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(e) {
    switch (e) {
      case J.HYPHEN_MINUS: {
        this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case J.LESS_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(e) {
    switch (e) {
      case J.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case J.LESS_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this.state = Q.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars($t);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(e) {
    e === J.SOLIDUS ? (this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(e) {
    if (this.preprocessor.startsWith(or.SCRIPT, !1) && IO(this.preprocessor.peek(or.SCRIPT.length))) {
      this._emitCodePoint(e);
      for (let n = 0; n < or.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = Q.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = Q.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(e) {
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        break;
      case J.SOLIDUS:
      case J.GREATER_THAN_SIGN:
      case J.EOF: {
        this.state = Q.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e);
        break;
      }
      case J.EQUALS_SIGN: {
        this._err(Se.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = Q.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = Q.ATTRIBUTE_NAME, this._stateAttributeName(e);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(e) {
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
      case J.SOLIDUS:
      case J.GREATER_THAN_SIGN:
      case J.EOF: {
        this._leaveAttrName(), this.state = Q.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e);
        break;
      }
      case J.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = Q.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case J.QUOTATION_MARK:
      case J.APOSTROPHE:
      case J.LESS_THAN_SIGN: {
        this._err(Se.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(e);
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this.currentAttr.name += $t;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(kh(e) ? ym(e) : e);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(e) {
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        break;
      case J.SOLIDUS: {
        this.state = Q.SELF_CLOSING_START_TAG;
        break;
      }
      case J.EQUALS_SIGN: {
        this.state = Q.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this.state = Q.DATA, this.emitCurrentTagToken();
        break;
      }
      case J.EOF: {
        this._err(Se.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = Q.ATTRIBUTE_NAME, this._stateAttributeName(e);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(e) {
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        break;
      case J.QUOTATION_MARK: {
        this.state = Q.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case J.APOSTROPHE: {
        this.state = Q.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.missingAttributeValue), this.state = Q.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = Q.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(e);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(e) {
    switch (e) {
      case J.QUOTATION_MARK: {
        this.state = Q.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case J.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this.currentAttr.value += $t;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(e) {
    switch (e) {
      case J.APOSTROPHE: {
        this.state = Q.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case J.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this.currentAttr.value += $t;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(e) {
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED: {
        this._leaveAttrValue(), this.state = Q.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case J.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = Q.DATA, this.emitCurrentTagToken();
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), this.currentAttr.value += $t;
        break;
      }
      case J.QUOTATION_MARK:
      case J.APOSTROPHE:
      case J.LESS_THAN_SIGN:
      case J.EQUALS_SIGN:
      case J.GRAVE_ACCENT: {
        this._err(Se.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(e);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(e) {
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED: {
        this._leaveAttrValue(), this.state = Q.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case J.SOLIDUS: {
        this._leaveAttrValue(), this.state = Q.SELF_CLOSING_START_TAG;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = Q.DATA, this.emitCurrentTagToken();
        break;
      }
      case J.EOF: {
        this._err(Se.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.missingWhitespaceBetweenAttributes), this.state = Q.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(e) {
    switch (e) {
      case J.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = Q.DATA, this.emitCurrentTagToken();
        break;
      }
      case J.EOF: {
        this._err(Se.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.unexpectedSolidusInTag), this.state = Q.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(e) {
    const n = this.currentToken;
    switch (e) {
      case J.GREATER_THAN_SIGN: {
        this.state = Q.DATA, this.emitCurrentComment(n);
        break;
      }
      case J.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), n.data += $t;
        break;
      }
      default:
        n.data += String.fromCodePoint(e);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(e) {
    this._consumeSequenceIfMatch(or.DASH_DASH, !0) ? (this._createCommentToken(or.DASH_DASH.length + 1), this.state = Q.COMMENT_START) : this._consumeSequenceIfMatch(or.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(or.DOCTYPE.length + 1), this.state = Q.DOCTYPE) : this._consumeSequenceIfMatch(or.CDATA_START, !0) ? this.inForeignNode ? this.state = Q.CDATA_SECTION : (this._err(Se.cdataInHtmlContent), this._createCommentToken(or.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = Q.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(Se.incorrectlyOpenedComment), this._createCommentToken(2), this.state = Q.BOGUS_COMMENT, this._stateBogusComment(e));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(e) {
    switch (e) {
      case J.HYPHEN_MINUS: {
        this.state = Q.COMMENT_START_DASH;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.abruptClosingOfEmptyComment), this.state = Q.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = Q.COMMENT, this._stateComment(e);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(e) {
    const n = this.currentToken;
    switch (e) {
      case J.HYPHEN_MINUS: {
        this.state = Q.COMMENT_END;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.abruptClosingOfEmptyComment), this.state = Q.DATA, this.emitCurrentComment(n);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = Q.COMMENT, this._stateComment(e);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(e) {
    const n = this.currentToken;
    switch (e) {
      case J.HYPHEN_MINUS: {
        this.state = Q.COMMENT_END_DASH;
        break;
      }
      case J.LESS_THAN_SIGN: {
        n.data += "<", this.state = Q.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), n.data += $t;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(e);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(e) {
    const n = this.currentToken;
    switch (e) {
      case J.EXCLAMATION_MARK: {
        n.data += "!", this.state = Q.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case J.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = Q.COMMENT, this._stateComment(e);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(e) {
    e === J.HYPHEN_MINUS ? this.state = Q.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = Q.COMMENT, this._stateComment(e));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(e) {
    e === J.HYPHEN_MINUS ? this.state = Q.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = Q.COMMENT_END_DASH, this._stateCommentEndDash(e));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(e) {
    e !== J.GREATER_THAN_SIGN && e !== J.EOF && this._err(Se.nestedComment), this.state = Q.COMMENT_END, this._stateCommentEnd(e);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(e) {
    const n = this.currentToken;
    switch (e) {
      case J.HYPHEN_MINUS: {
        this.state = Q.COMMENT_END;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = Q.COMMENT, this._stateComment(e);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(e) {
    const n = this.currentToken;
    switch (e) {
      case J.GREATER_THAN_SIGN: {
        this.state = Q.DATA, this.emitCurrentComment(n);
        break;
      }
      case J.EXCLAMATION_MARK: {
        this.state = Q.COMMENT_END_BANG;
        break;
      }
      case J.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case J.EOF: {
        this._err(Se.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = Q.COMMENT, this._stateComment(e);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(e) {
    const n = this.currentToken;
    switch (e) {
      case J.HYPHEN_MINUS: {
        n.data += "--!", this.state = Q.COMMENT_END_DASH;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.incorrectlyClosedComment), this.state = Q.DATA, this.emitCurrentComment(n);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = Q.COMMENT, this._stateComment(e);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(e) {
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED: {
        this.state = Q.BEFORE_DOCTYPE_NAME;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this.state = Q.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.missingWhitespaceBeforeDoctypeName), this.state = Q.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(e) {
    if (kh(e))
      this._createDoctypeToken(String.fromCharCode(ym(e))), this.state = Q.DOCTYPE_NAME;
    else
      switch (e) {
        case J.SPACE:
        case J.LINE_FEED:
        case J.TABULATION:
        case J.FORM_FEED:
          break;
        case J.NULL: {
          this._err(Se.unexpectedNullCharacter), this._createDoctypeToken($t), this.state = Q.DOCTYPE_NAME;
          break;
        }
        case J.GREATER_THAN_SIGN: {
          this._err(Se.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = Q.DATA;
          break;
        }
        case J.EOF: {
          this._err(Se.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(e)), this.state = Q.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED: {
        this.state = Q.AFTER_DOCTYPE_NAME;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this.state = Q.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), n.name += $t;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(kh(e) ? ym(e) : e);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        break;
      case J.GREATER_THAN_SIGN: {
        this.state = Q.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(or.PUBLIC, !1) ? this.state = Q.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(or.SYSTEM, !1) ? this.state = Q.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(Se.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = Q.BOGUS_DOCTYPE, this._stateBogusDoctype(e));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED: {
        this.state = Q.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case J.QUOTATION_MARK: {
        this._err(Se.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = Q.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case J.APOSTROPHE: {
        this._err(Se.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = Q.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = Q.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = Q.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        break;
      case J.QUOTATION_MARK: {
        n.publicId = "", this.state = Q.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case J.APOSTROPHE: {
        n.publicId = "", this.state = Q.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = Q.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = Q.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case J.QUOTATION_MARK: {
        this.state = Q.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), n.publicId += $t;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = Q.DATA;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(e);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case J.APOSTROPHE: {
        this.state = Q.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), n.publicId += $t;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = Q.DATA;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(e);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED: {
        this.state = Q.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this.state = Q.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case J.QUOTATION_MARK: {
        this._err(Se.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = Q.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case J.APOSTROPHE: {
        this._err(Se.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = Q.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = Q.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        break;
      case J.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = Q.DATA;
        break;
      }
      case J.QUOTATION_MARK: {
        n.systemId = "", this.state = Q.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case J.APOSTROPHE: {
        n.systemId = "", this.state = Q.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = Q.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED: {
        this.state = Q.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case J.QUOTATION_MARK: {
        this._err(Se.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = Q.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case J.APOSTROPHE: {
        this._err(Se.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = Q.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = Q.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = Q.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        break;
      case J.QUOTATION_MARK: {
        n.systemId = "", this.state = Q.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case J.APOSTROPHE: {
        n.systemId = "", this.state = Q.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = Q.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = Q.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case J.QUOTATION_MARK: {
        this.state = Q.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), n.systemId += $t;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = Q.DATA;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(e);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case J.APOSTROPHE: {
        this.state = Q.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter), n.systemId += $t;
        break;
      }
      case J.GREATER_THAN_SIGN: {
        this._err(Se.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = Q.DATA;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(e);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case J.SPACE:
      case J.LINE_FEED:
      case J.TABULATION:
      case J.FORM_FEED:
        break;
      case J.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = Q.DATA;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Se.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = Q.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(e) {
    const n = this.currentToken;
    switch (e) {
      case J.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = Q.DATA;
        break;
      }
      case J.NULL: {
        this._err(Se.unexpectedNullCharacter);
        break;
      }
      case J.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(e) {
    switch (e) {
      case J.RIGHT_SQUARE_BRACKET: {
        this.state = Q.CDATA_SECTION_BRACKET;
        break;
      }
      case J.EOF: {
        this._err(Se.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(e) {
    e === J.RIGHT_SQUARE_BRACKET ? this.state = Q.CDATA_SECTION_END : (this._emitChars("]"), this.state = Q.CDATA_SECTION, this._stateCdataSection(e));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(e) {
    switch (e) {
      case J.GREATER_THAN_SIGN: {
        this.state = Q.DATA;
        break;
      }
      case J.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = Q.CDATA_SECTION, this._stateCdataSection(e);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let e = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (e < 0)
      if (this.preprocessor.lastChunkWritten)
        e = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    e === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(J.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && RO(this.preprocessor.peek(1)) ? Q.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(e) {
    RO(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === J.SEMICOLON && this._err(Se.unknownNamedCharacterReference), this.state = this.returnState, this._callState(e));
  }
}
const NH = /* @__PURE__ */ new Set([C.DD, C.DT, C.LI, C.OPTGROUP, C.OPTION, C.P, C.RB, C.RP, C.RT, C.RTC]), PO = /* @__PURE__ */ new Set([
  ...NH,
  C.CAPTION,
  C.COLGROUP,
  C.TBODY,
  C.TD,
  C.TFOOT,
  C.TH,
  C.THEAD,
  C.TR
]), H0 = /* @__PURE__ */ new Set([
  C.APPLET,
  C.CAPTION,
  C.HTML,
  C.MARQUEE,
  C.OBJECT,
  C.TABLE,
  C.TD,
  C.TEMPLATE,
  C.TH
]), Dve = /* @__PURE__ */ new Set([...H0, C.OL, C.UL]), Nve = /* @__PURE__ */ new Set([...H0, C.BUTTON]), OO = /* @__PURE__ */ new Set([C.ANNOTATION_XML, C.MI, C.MN, C.MO, C.MS, C.MTEXT]), DO = /* @__PURE__ */ new Set([C.DESC, C.FOREIGN_OBJECT, C.TITLE]), Lve = /* @__PURE__ */ new Set([C.TR, C.TEMPLATE, C.HTML]), Mve = /* @__PURE__ */ new Set([C.TBODY, C.TFOOT, C.THEAD, C.TEMPLATE, C.HTML]), Bve = /* @__PURE__ */ new Set([C.TABLE, C.TEMPLATE, C.HTML]), Fve = /* @__PURE__ */ new Set([C.TD, C.TH]);
class $ve {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(e, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = C.UNKNOWN, this.current = e;
  }
  //Index of element
  _indexOf(e) {
    return this.items.lastIndexOf(e, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === C.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Ie.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(e, n) {
    this.stackTop++, this.items[this.stackTop] = e, this.current = e, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(e, n, !0);
  }
  pop() {
    const e = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !0);
  }
  replace(e, n) {
    const r = this._indexOf(e);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(e, n, r) {
    const s = this._indexOf(e) + 1;
    this.items.splice(s, 0, n), this.tagIDs.splice(s, 0, r), this.stackTop++, s === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, s === this.stackTop);
  }
  popUntilTagNamePopped(e) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(e, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== Ie.HTML);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  shortenToLength(e) {
    for (; this.stackTop >= e; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < e);
    }
  }
  popUntilElementPopped(e) {
    const n = this._indexOf(e);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  popUntilPopped(e, n) {
    const r = this._indexOfTagNames(e, n);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(RS, Ie.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(Fve, Ie.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(e, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (e.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(e, n) {
    const r = this._indexOfTagNames(e, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(Bve, Ie.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(Mve, Ie.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(Lve, Ie.HTML);
  }
  remove(e) {
    const n = this._indexOf(e);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === C.BODY ? this.items[1] : null;
  }
  contains(e) {
    return this._indexOf(e) > -1;
  }
  getCommonAncestor(e) {
    const n = this._indexOf(e) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === C.HTML;
  }
  //Element in scope
  hasInDynamicScope(e, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const s = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case Ie.HTML: {
          if (s === e)
            return !0;
          if (n.has(s))
            return !1;
          break;
        }
        case Ie.SVG: {
          if (DO.has(s))
            return !1;
          break;
        }
        case Ie.MATHML: {
          if (OO.has(s))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(e) {
    return this.hasInDynamicScope(e, H0);
  }
  hasInListItemScope(e) {
    return this.hasInDynamicScope(e, Dve);
  }
  hasInButtonScope(e) {
    return this.hasInDynamicScope(e, Nve);
  }
  hasNumberedHeaderInScope() {
    for (let e = this.stackTop; e >= 0; e--) {
      const n = this.tagIDs[e];
      switch (this.treeAdapter.getNamespaceURI(this.items[e])) {
        case Ie.HTML: {
          if (RS.has(n))
            return !0;
          if (H0.has(n))
            return !1;
          break;
        }
        case Ie.SVG: {
          if (DO.has(n))
            return !1;
          break;
        }
        case Ie.MATHML: {
          if (OO.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === Ie.HTML)
        switch (this.tagIDs[n]) {
          case e:
            return !0;
          case C.TABLE:
          case C.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let e = this.stackTop; e >= 0; e--)
      if (this.treeAdapter.getNamespaceURI(this.items[e]) === Ie.HTML)
        switch (this.tagIDs[e]) {
          case C.TBODY:
          case C.THEAD:
          case C.TFOOT:
            return !0;
          case C.TABLE:
          case C.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === Ie.HTML)
        switch (this.tagIDs[n]) {
          case e:
            return !0;
          case C.OPTION:
          case C.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; NH.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; PO.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(e) {
    for (; this.currentTagId !== e && PO.has(this.currentTagId); )
      this.pop();
  }
}
const qv = 3;
var ti;
(function(t) {
  t[t.Marker = 0] = "Marker", t[t.Element = 1] = "Element";
})(ti || (ti = {}));
const NO = { type: ti.Marker };
class Uve {
  constructor(e) {
    this.treeAdapter = e, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(e, n) {
    const r = [], s = n.length, i = this.treeAdapter.getTagName(e), o = this.treeAdapter.getNamespaceURI(e);
    for (let a = 0; a < this.entries.length; a++) {
      const l = this.entries[a];
      if (l.type === ti.Marker)
        break;
      const { element: c } = l;
      if (this.treeAdapter.getTagName(c) === i && this.treeAdapter.getNamespaceURI(c) === o) {
        const u = this.treeAdapter.getAttrList(c);
        u.length === s && r.push({ idx: a, attrs: u });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(e) {
    if (this.entries.length < qv)
      return;
    const n = this.treeAdapter.getAttrList(e), r = this._getNoahArkConditionCandidates(e, n);
    if (r.length < qv)
      return;
    const s = new Map(n.map((o) => [o.name, o.value]));
    let i = 0;
    for (let o = 0; o < r.length; o++) {
      const a = r[o];
      a.attrs.every((l) => s.get(l.name) === l.value) && (i += 1, i >= qv && this.entries.splice(a.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(NO);
  }
  pushElement(e, n) {
    this._ensureNoahArkCondition(e), this.entries.unshift({
      type: ti.Element,
      element: e,
      token: n
    });
  }
  insertElementAfterBookmark(e, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: ti.Element,
      element: e,
      token: n
    });
  }
  removeEntry(e) {
    const n = this.entries.indexOf(e);
    n >= 0 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const e = this.entries.indexOf(NO);
    e >= 0 ? this.entries.splice(0, e + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(e) {
    const n = this.entries.find((r) => r.type === ti.Marker || this.treeAdapter.getTagName(r.element) === e);
    return n && n.type === ti.Element ? n : null;
  }
  getElementEntry(e) {
    return this.entries.find((n) => n.type === ti.Element && n.element === e);
  }
}
const Ro = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: Wr.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(t, e, n) {
    return {
      nodeName: t,
      tagName: t,
      attrs: n,
      namespaceURI: e,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(t) {
    return {
      nodeName: "#comment",
      data: t,
      parentNode: null
    };
  },
  createTextNode(t) {
    return {
      nodeName: "#text",
      value: t,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(t, e) {
    t.childNodes.push(e), e.parentNode = t;
  },
  insertBefore(t, e, n) {
    const r = t.childNodes.indexOf(n);
    t.childNodes.splice(r, 0, e), e.parentNode = t;
  },
  setTemplateContent(t, e) {
    t.content = e;
  },
  getTemplateContent(t) {
    return t.content;
  },
  setDocumentType(t, e, n, r) {
    const s = t.childNodes.find((i) => i.nodeName === "#documentType");
    if (s)
      s.name = e, s.publicId = n, s.systemId = r;
    else {
      const i = {
        nodeName: "#documentType",
        name: e,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      Ro.appendChild(t, i);
    }
  },
  setDocumentMode(t, e) {
    t.mode = e;
  },
  getDocumentMode(t) {
    return t.mode;
  },
  detachNode(t) {
    if (t.parentNode) {
      const e = t.parentNode.childNodes.indexOf(t);
      t.parentNode.childNodes.splice(e, 1), t.parentNode = null;
    }
  },
  insertText(t, e) {
    if (t.childNodes.length > 0) {
      const n = t.childNodes[t.childNodes.length - 1];
      if (Ro.isTextNode(n)) {
        n.value += e;
        return;
      }
    }
    Ro.appendChild(t, Ro.createTextNode(e));
  },
  insertTextBefore(t, e, n) {
    const r = t.childNodes[t.childNodes.indexOf(n) - 1];
    r && Ro.isTextNode(r) ? r.value += e : Ro.insertBefore(t, Ro.createTextNode(e), n);
  },
  adoptAttributes(t, e) {
    const n = new Set(t.attrs.map((r) => r.name));
    for (let r = 0; r < e.length; r++)
      n.has(e[r].name) || t.attrs.push(e[r]);
  },
  //Tree traversing
  getFirstChild(t) {
    return t.childNodes[0];
  },
  getChildNodes(t) {
    return t.childNodes;
  },
  getParentNode(t) {
    return t.parentNode;
  },
  getAttrList(t) {
    return t.attrs;
  },
  //Node data
  getTagName(t) {
    return t.tagName;
  },
  getNamespaceURI(t) {
    return t.namespaceURI;
  },
  getTextNodeContent(t) {
    return t.value;
  },
  getCommentNodeContent(t) {
    return t.data;
  },
  getDocumentTypeNodeName(t) {
    return t.name;
  },
  getDocumentTypeNodePublicId(t) {
    return t.publicId;
  },
  getDocumentTypeNodeSystemId(t) {
    return t.systemId;
  },
  //Node types
  isTextNode(t) {
    return t.nodeName === "#text";
  },
  isCommentNode(t) {
    return t.nodeName === "#comment";
  },
  isDocumentTypeNode(t) {
    return t.nodeName === "#documentType";
  },
  isElementNode(t) {
    return Object.prototype.hasOwnProperty.call(t, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(t, e) {
    t.sourceCodeLocation = e;
  },
  getNodeSourceCodeLocation(t) {
    return t.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(t, e) {
    t.sourceCodeLocation = { ...t.sourceCodeLocation, ...e };
  }
}, LH = "html", jve = "about:legacy-compat", Hve = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", MH = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], zve = [
  ...MH,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], Gve = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), BH = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], Vve = [
  ...BH,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function LO(t, e) {
  return e.some((n) => t.startsWith(n));
}
function Wve(t) {
  return t.name === LH && t.publicId === null && (t.systemId === null || t.systemId === jve);
}
function qve(t) {
  if (t.name !== LH)
    return Wr.QUIRKS;
  const { systemId: e } = t;
  if (e && e.toLowerCase() === Hve)
    return Wr.QUIRKS;
  let { publicId: n } = t;
  if (n !== null) {
    if (n = n.toLowerCase(), Gve.has(n))
      return Wr.QUIRKS;
    let r = e === null ? zve : MH;
    if (LO(n, r))
      return Wr.QUIRKS;
    if (r = e === null ? BH : Vve, LO(n, r))
      return Wr.LIMITED_QUIRKS;
  }
  return Wr.NO_QUIRKS;
}
const MO = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, Kve = "definitionurl", Yve = "definitionURL", Zve = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((t) => [t.toLowerCase(), t])), Jve = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: Ie.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: Ie.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: Ie.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: Ie.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: Ie.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: Ie.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: Ie.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: Ie.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: Ie.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: Ie.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: Ie.XMLNS }]
]), Xve = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((t) => [t.toLowerCase(), t])), Qve = /* @__PURE__ */ new Set([
  C.B,
  C.BIG,
  C.BLOCKQUOTE,
  C.BODY,
  C.BR,
  C.CENTER,
  C.CODE,
  C.DD,
  C.DIV,
  C.DL,
  C.DT,
  C.EM,
  C.EMBED,
  C.H1,
  C.H2,
  C.H3,
  C.H4,
  C.H5,
  C.H6,
  C.HEAD,
  C.HR,
  C.I,
  C.IMG,
  C.LI,
  C.LISTING,
  C.MENU,
  C.META,
  C.NOBR,
  C.OL,
  C.P,
  C.PRE,
  C.RUBY,
  C.S,
  C.SMALL,
  C.SPAN,
  C.STRONG,
  C.STRIKE,
  C.SUB,
  C.SUP,
  C.TABLE,
  C.TT,
  C.U,
  C.UL,
  C.VAR
]);
function ewe(t) {
  const e = t.tagID;
  return e === C.FONT && t.attrs.some(({ name: r }) => r === il.COLOR || r === il.SIZE || r === il.FACE) || Qve.has(e);
}
function FH(t) {
  for (let e = 0; e < t.attrs.length; e++)
    if (t.attrs[e].name === Kve) {
      t.attrs[e].name = Yve;
      break;
    }
}
function $H(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = Zve.get(t.attrs[e].name);
    n != null && (t.attrs[e].name = n);
  }
}
function vk(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = Jve.get(t.attrs[e].name);
    n && (t.attrs[e].prefix = n.prefix, t.attrs[e].name = n.name, t.attrs[e].namespace = n.namespace);
  }
}
function twe(t) {
  const e = Xve.get(t.tagName);
  e != null && (t.tagName = e, t.tagID = Du(t.tagName));
}
function nwe(t, e) {
  return e === Ie.MATHML && (t === C.MI || t === C.MO || t === C.MN || t === C.MS || t === C.MTEXT);
}
function rwe(t, e, n) {
  if (e === Ie.MATHML && t === C.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === il.ENCODING) {
        const s = n[r].value.toLowerCase();
        return s === MO.TEXT_HTML || s === MO.APPLICATION_XML;
      }
  }
  return e === Ie.SVG && (t === C.FOREIGN_OBJECT || t === C.DESC || t === C.TITLE);
}
function swe(t, e, n, r) {
  return (!r || r === Ie.HTML) && rwe(t, e, n) || (!r || r === Ie.MATHML) && nwe(t, e);
}
const iwe = "hidden", owe = 8, awe = 3;
var se;
(function(t) {
  t[t.INITIAL = 0] = "INITIAL", t[t.BEFORE_HTML = 1] = "BEFORE_HTML", t[t.BEFORE_HEAD = 2] = "BEFORE_HEAD", t[t.IN_HEAD = 3] = "IN_HEAD", t[t.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", t[t.AFTER_HEAD = 5] = "AFTER_HEAD", t[t.IN_BODY = 6] = "IN_BODY", t[t.TEXT = 7] = "TEXT", t[t.IN_TABLE = 8] = "IN_TABLE", t[t.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", t[t.IN_CAPTION = 10] = "IN_CAPTION", t[t.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", t[t.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", t[t.IN_ROW = 13] = "IN_ROW", t[t.IN_CELL = 14] = "IN_CELL", t[t.IN_SELECT = 15] = "IN_SELECT", t[t.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", t[t.IN_TEMPLATE = 17] = "IN_TEMPLATE", t[t.AFTER_BODY = 18] = "AFTER_BODY", t[t.IN_FRAMESET = 19] = "IN_FRAMESET", t[t.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", t[t.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", t[t.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(se || (se = {}));
const lwe = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, UH = /* @__PURE__ */ new Set([C.TABLE, C.TBODY, C.TFOOT, C.THEAD, C.TR]), BO = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: Ro,
  onParseError: null
};
let FO = class {
  constructor(e, n, r = null, s = null) {
    this.fragmentContext = r, this.scriptHandler = s, this.currentToken = null, this.stopped = !1, this.insertionMode = se.INITIAL, this.originalInsertionMode = se.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...BO,
      ...e
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new Ove(this.options, this), this.activeFormattingElements = new Uve(this.treeAdapter), this.fragmentContextID = r ? Du(this.treeAdapter.getTagName(r)) : C.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new $ve(this.document, this.treeAdapter, this);
  }
  // API
  static parse(e, n) {
    const r = new this(n);
    return r.tokenizer.write(e, !0), r.document;
  }
  static getFragmentParser(e, n) {
    const r = {
      ...BO,
      ...n
    };
    e ?? (e = r.treeAdapter.createElement(pe.TEMPLATE, Ie.HTML, []));
    const s = r.treeAdapter.createElement("documentmock", Ie.HTML, []), i = new this(r, s, e);
    return i.fragmentContextID === C.TEMPLATE && i.tmplInsertionModeStack.unshift(se.IN_TEMPLATE), i._initTokenizerForFragmentParsing(), i._insertFakeRootElement(), i._resetInsertionMode(), i._findFormInFragmentContext(), i;
  }
  getFragment() {
    const e = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(e, n), n;
  }
  //Errors
  /** @internal */
  _err(e, n, r) {
    var s;
    if (!this.onParseError)
      return;
    const i = (s = e.location) !== null && s !== void 0 ? s : lwe, o = {
      code: n,
      startLine: i.startLine,
      startCol: i.startCol,
      startOffset: i.startOffset,
      endLine: r ? i.startLine : i.endLine,
      endCol: r ? i.startCol : i.endCol,
      endOffset: r ? i.startOffset : i.endOffset
    };
    this.onParseError(o);
  }
  //Stack events
  /** @internal */
  onItemPush(e, n, r) {
    var s, i;
    (i = (s = this.treeAdapter).onItemPush) === null || i === void 0 || i.call(s, e), r && this.openElements.stackTop > 0 && this._setContextModes(e, n);
  }
  /** @internal */
  onItemPop(e, n) {
    var r, s;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken), (s = (r = this.treeAdapter).onItemPop) === null || s === void 0 || s.call(r, e, this.openElements.current), n) {
      let i, o;
      this.openElements.stackTop === 0 && this.fragmentContext ? (i = this.fragmentContext, o = this.fragmentContextID) : { current: i, currentTagId: o } = this.openElements, this._setContextModes(i, o);
    }
  }
  _setContextModes(e, n) {
    const r = e === this.document || this.treeAdapter.getNamespaceURI(e) === Ie.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, e);
  }
  /** @protected */
  _switchToTextParsing(e, n) {
    this._insertElement(e, Ie.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = se.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = se.TEXT, this.originalInsertionMode = se.IN_BODY, this.tokenizer.state = Qt.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let e = this.fragmentContext;
    for (; e; ) {
      if (this.treeAdapter.getTagName(e) === pe.FORM) {
        this.formElement = e;
        break;
      }
      e = this.treeAdapter.getParentNode(e);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== Ie.HTML))
      switch (this.fragmentContextID) {
        case C.TITLE:
        case C.TEXTAREA: {
          this.tokenizer.state = Qt.RCDATA;
          break;
        }
        case C.STYLE:
        case C.XMP:
        case C.IFRAME:
        case C.NOEMBED:
        case C.NOFRAMES:
        case C.NOSCRIPT: {
          this.tokenizer.state = Qt.RAWTEXT;
          break;
        }
        case C.SCRIPT: {
          this.tokenizer.state = Qt.SCRIPT_DATA;
          break;
        }
        case C.PLAINTEXT: {
          this.tokenizer.state = Qt.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(e) {
    const n = e.name || "", r = e.publicId || "", s = e.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, s), e.location) {
      const o = this.treeAdapter.getChildNodes(this.document).find((a) => this.treeAdapter.isDocumentTypeNode(a));
      o && this.treeAdapter.setNodeSourceCodeLocation(o, e.location);
    }
  }
  /** @protected */
  _attachElementToTree(e, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(e, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(e);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, e);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r, e.location);
  }
  /** @protected */
  _insertElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r, e.location), this.openElements.push(r, e.tagID);
  }
  /** @protected */
  _insertFakeElement(e, n) {
    const r = this.treeAdapter.createElement(e, Ie.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(e) {
    const n = this.treeAdapter.createElement(e.tagName, Ie.HTML, e.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, e.location), this.openElements.push(n, e.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const e = this.treeAdapter.createElement(pe.HTML, Ie.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null), this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e, C.HTML);
  }
  /** @protected */
  _appendCommentNode(e, n) {
    const r = this.treeAdapter.createCommentNode(e.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, e.location);
  }
  /** @protected */
  _insertCharacters(e) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, e.chars, r) : this.treeAdapter.insertText(n, e.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, e.chars)), !e.location)
      return;
    const s = this.treeAdapter.getChildNodes(n), i = r ? s.lastIndexOf(r) : s.length, o = s[i - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(o)) {
      const { endLine: l, endCol: c, endOffset: u } = e.location;
      this.treeAdapter.updateNodeSourceCodeLocation(o, { endLine: l, endCol: c, endOffset: u });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(o, e.location);
  }
  /** @protected */
  _adoptNodes(e, n) {
    for (let r = this.treeAdapter.getFirstChild(e); r; r = this.treeAdapter.getFirstChild(e))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(e, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(e) && n.location) {
      const r = n.location, s = this.treeAdapter.getTagName(e), i = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === lt.END_TAG && s === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(e, i);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(e) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, e.tagID === C.SVG && this.treeAdapter.getTagName(n) === pe.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === Ie.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (e.tagID === C.MGLYPH || e.tagID === C.MALIGNMARK) && !this._isIntegrationPoint(r, n, Ie.HTML)
    );
  }
  /** @protected */
  _processToken(e) {
    switch (e.type) {
      case lt.CHARACTER: {
        this.onCharacter(e);
        break;
      }
      case lt.NULL_CHARACTER: {
        this.onNullCharacter(e);
        break;
      }
      case lt.COMMENT: {
        this.onComment(e);
        break;
      }
      case lt.DOCTYPE: {
        this.onDoctype(e);
        break;
      }
      case lt.START_TAG: {
        this._processStartTag(e);
        break;
      }
      case lt.END_TAG: {
        this.onEndTag(e);
        break;
      }
      case lt.EOF: {
        this.onEof(e);
        break;
      }
      case lt.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(e);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(e, n, r) {
    const s = this.treeAdapter.getNamespaceURI(n), i = this.treeAdapter.getAttrList(n);
    return swe(e, s, i, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const e = this.activeFormattingElements.entries.length;
    if (e) {
      const n = this.activeFormattingElements.entries.findIndex((s) => s.type === ti.Marker || this.openElements.contains(s.element)), r = n < 0 ? e - 1 : n - 1;
      for (let s = r; s >= 0; s--) {
        const i = this.activeFormattingElements.entries[s];
        this._insertElement(i.token, this.treeAdapter.getNamespaceURI(i.element)), i.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = se.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(C.P), this.openElements.popUntilTagNamePopped(C.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let e = this.openElements.stackTop; e >= 0; e--)
      switch (e === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) {
        case C.TR: {
          this.insertionMode = se.IN_ROW;
          return;
        }
        case C.TBODY:
        case C.THEAD:
        case C.TFOOT: {
          this.insertionMode = se.IN_TABLE_BODY;
          return;
        }
        case C.CAPTION: {
          this.insertionMode = se.IN_CAPTION;
          return;
        }
        case C.COLGROUP: {
          this.insertionMode = se.IN_COLUMN_GROUP;
          return;
        }
        case C.TABLE: {
          this.insertionMode = se.IN_TABLE;
          return;
        }
        case C.BODY: {
          this.insertionMode = se.IN_BODY;
          return;
        }
        case C.FRAMESET: {
          this.insertionMode = se.IN_FRAMESET;
          return;
        }
        case C.SELECT: {
          this._resetInsertionModeForSelect(e);
          return;
        }
        case C.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case C.HTML: {
          this.insertionMode = this.headElement ? se.AFTER_HEAD : se.BEFORE_HEAD;
          return;
        }
        case C.TD:
        case C.TH: {
          if (e > 0) {
            this.insertionMode = se.IN_CELL;
            return;
          }
          break;
        }
        case C.HEAD: {
          if (e > 0) {
            this.insertionMode = se.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = se.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(e) {
    if (e > 0)
      for (let n = e - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === C.TEMPLATE)
          break;
        if (r === C.TABLE) {
          this.insertionMode = se.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = se.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(e) {
    return UH.has(e);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let e = this.openElements.stackTop; e >= 0; e--) {
      const n = this.openElements.items[e];
      switch (this.openElements.tagIDs[e]) {
        case C.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === Ie.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case C.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[e - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(e) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, e, n.beforeElement) : this.treeAdapter.appendChild(n.parent, e);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(e, n) {
    const r = this.treeAdapter.getNamespaceURI(e);
    return Ave[r].has(n);
  }
  /** @internal */
  onCharacter(e) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      F1e(this, e);
      return;
    }
    switch (this.insertionMode) {
      case se.INITIAL: {
        rh(this, e);
        break;
      }
      case se.BEFORE_HTML: {
        Xh(this, e);
        break;
      }
      case se.BEFORE_HEAD: {
        Qh(this, e);
        break;
      }
      case se.IN_HEAD: {
        ed(this, e);
        break;
      }
      case se.IN_HEAD_NO_SCRIPT: {
        td(this, e);
        break;
      }
      case se.AFTER_HEAD: {
        nd(this, e);
        break;
      }
      case se.IN_BODY:
      case se.IN_CAPTION:
      case se.IN_CELL:
      case se.IN_TEMPLATE: {
        HH(this, e);
        break;
      }
      case se.TEXT:
      case se.IN_SELECT:
      case se.IN_SELECT_IN_TABLE: {
        this._insertCharacters(e);
        break;
      }
      case se.IN_TABLE:
      case se.IN_TABLE_BODY:
      case se.IN_ROW: {
        Kv(this, e);
        break;
      }
      case se.IN_TABLE_TEXT: {
        KH(this, e);
        break;
      }
      case se.IN_COLUMN_GROUP: {
        z0(this, e);
        break;
      }
      case se.AFTER_BODY: {
        G0(this, e);
        break;
      }
      case se.AFTER_AFTER_BODY: {
        Eg(this, e);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(e) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      B1e(this, e);
      return;
    }
    switch (this.insertionMode) {
      case se.INITIAL: {
        rh(this, e);
        break;
      }
      case se.BEFORE_HTML: {
        Xh(this, e);
        break;
      }
      case se.BEFORE_HEAD: {
        Qh(this, e);
        break;
      }
      case se.IN_HEAD: {
        ed(this, e);
        break;
      }
      case se.IN_HEAD_NO_SCRIPT: {
        td(this, e);
        break;
      }
      case se.AFTER_HEAD: {
        nd(this, e);
        break;
      }
      case se.TEXT: {
        this._insertCharacters(e);
        break;
      }
      case se.IN_TABLE:
      case se.IN_TABLE_BODY:
      case se.IN_ROW: {
        Kv(this, e);
        break;
      }
      case se.IN_COLUMN_GROUP: {
        z0(this, e);
        break;
      }
      case se.AFTER_BODY: {
        G0(this, e);
        break;
      }
      case se.AFTER_AFTER_BODY: {
        Eg(this, e);
        break;
      }
    }
  }
  /** @internal */
  onComment(e) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      IS(this, e);
      return;
    }
    switch (this.insertionMode) {
      case se.INITIAL:
      case se.BEFORE_HTML:
      case se.BEFORE_HEAD:
      case se.IN_HEAD:
      case se.IN_HEAD_NO_SCRIPT:
      case se.AFTER_HEAD:
      case se.IN_BODY:
      case se.IN_TABLE:
      case se.IN_CAPTION:
      case se.IN_COLUMN_GROUP:
      case se.IN_TABLE_BODY:
      case se.IN_ROW:
      case se.IN_CELL:
      case se.IN_SELECT:
      case se.IN_SELECT_IN_TABLE:
      case se.IN_TEMPLATE:
      case se.IN_FRAMESET:
      case se.AFTER_FRAMESET: {
        IS(this, e);
        break;
      }
      case se.IN_TABLE_TEXT: {
        sh(this, e);
        break;
      }
      case se.AFTER_BODY: {
        mwe(this, e);
        break;
      }
      case se.AFTER_AFTER_BODY:
      case se.AFTER_AFTER_FRAMESET: {
        gwe(this, e);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(e) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case se.INITIAL: {
        ywe(this, e);
        break;
      }
      case se.BEFORE_HEAD:
      case se.IN_HEAD:
      case se.IN_HEAD_NO_SCRIPT:
      case se.AFTER_HEAD: {
        this._err(e, Se.misplacedDoctype);
        break;
      }
      case se.IN_TABLE_TEXT: {
        sh(this, e);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(e) {
    this.skipNextNewLine = !1, this.currentToken = e, this._processStartTag(e), e.selfClosing && !e.ackSelfClosing && this._err(e, Se.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(e) {
    this.shouldProcessStartTagTokenInForeignContent(e) ? $1e(this, e) : this._startTagOutsideForeignContent(e);
  }
  /** @protected */
  _startTagOutsideForeignContent(e) {
    switch (this.insertionMode) {
      case se.INITIAL: {
        rh(this, e);
        break;
      }
      case se.BEFORE_HTML: {
        bwe(this, e);
        break;
      }
      case se.BEFORE_HEAD: {
        vwe(this, e);
        break;
      }
      case se.IN_HEAD: {
        Os(this, e);
        break;
      }
      case se.IN_HEAD_NO_SCRIPT: {
        Swe(this, e);
        break;
      }
      case se.AFTER_HEAD: {
        Twe(this, e);
        break;
      }
      case se.IN_BODY: {
        zn(this, e);
        break;
      }
      case se.IN_TABLE: {
        ou(this, e);
        break;
      }
      case se.IN_TABLE_TEXT: {
        sh(this, e);
        break;
      }
      case se.IN_CAPTION: {
        w1e(this, e);
        break;
      }
      case se.IN_COLUMN_GROUP: {
        Sk(this, e);
        break;
      }
      case se.IN_TABLE_BODY: {
        Nb(this, e);
        break;
      }
      case se.IN_ROW: {
        Lb(this, e);
        break;
      }
      case se.IN_CELL: {
        x1e(this, e);
        break;
      }
      case se.IN_SELECT: {
        JH(this, e);
        break;
      }
      case se.IN_SELECT_IN_TABLE: {
        C1e(this, e);
        break;
      }
      case se.IN_TEMPLATE: {
        A1e(this, e);
        break;
      }
      case se.AFTER_BODY: {
        I1e(this, e);
        break;
      }
      case se.IN_FRAMESET: {
        P1e(this, e);
        break;
      }
      case se.AFTER_FRAMESET: {
        D1e(this, e);
        break;
      }
      case se.AFTER_AFTER_BODY: {
        L1e(this, e);
        break;
      }
      case se.AFTER_AFTER_FRAMESET: {
        M1e(this, e);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(e) {
    this.skipNextNewLine = !1, this.currentToken = e, this.currentNotInHTML ? U1e(this, e) : this._endTagOutsideForeignContent(e);
  }
  /** @protected */
  _endTagOutsideForeignContent(e) {
    switch (this.insertionMode) {
      case se.INITIAL: {
        rh(this, e);
        break;
      }
      case se.BEFORE_HTML: {
        _we(this, e);
        break;
      }
      case se.BEFORE_HEAD: {
        wwe(this, e);
        break;
      }
      case se.IN_HEAD: {
        Ewe(this, e);
        break;
      }
      case se.IN_HEAD_NO_SCRIPT: {
        xwe(this, e);
        break;
      }
      case se.AFTER_HEAD: {
        Cwe(this, e);
        break;
      }
      case se.IN_BODY: {
        Db(this, e);
        break;
      }
      case se.TEXT: {
        h1e(this, e);
        break;
      }
      case se.IN_TABLE: {
        Kd(this, e);
        break;
      }
      case se.IN_TABLE_TEXT: {
        sh(this, e);
        break;
      }
      case se.IN_CAPTION: {
        E1e(this, e);
        break;
      }
      case se.IN_COLUMN_GROUP: {
        S1e(this, e);
        break;
      }
      case se.IN_TABLE_BODY: {
        PS(this, e);
        break;
      }
      case se.IN_ROW: {
        ZH(this, e);
        break;
      }
      case se.IN_CELL: {
        T1e(this, e);
        break;
      }
      case se.IN_SELECT: {
        XH(this, e);
        break;
      }
      case se.IN_SELECT_IN_TABLE: {
        k1e(this, e);
        break;
      }
      case se.IN_TEMPLATE: {
        R1e(this, e);
        break;
      }
      case se.AFTER_BODY: {
        e9(this, e);
        break;
      }
      case se.IN_FRAMESET: {
        O1e(this, e);
        break;
      }
      case se.AFTER_FRAMESET: {
        N1e(this, e);
        break;
      }
      case se.AFTER_AFTER_BODY: {
        Eg(this, e);
        break;
      }
    }
  }
  /** @internal */
  onEof(e) {
    switch (this.insertionMode) {
      case se.INITIAL: {
        rh(this, e);
        break;
      }
      case se.BEFORE_HTML: {
        Xh(this, e);
        break;
      }
      case se.BEFORE_HEAD: {
        Qh(this, e);
        break;
      }
      case se.IN_HEAD: {
        ed(this, e);
        break;
      }
      case se.IN_HEAD_NO_SCRIPT: {
        td(this, e);
        break;
      }
      case se.AFTER_HEAD: {
        nd(this, e);
        break;
      }
      case se.IN_BODY:
      case se.IN_TABLE:
      case se.IN_CAPTION:
      case se.IN_COLUMN_GROUP:
      case se.IN_TABLE_BODY:
      case se.IN_ROW:
      case se.IN_CELL:
      case se.IN_SELECT:
      case se.IN_SELECT_IN_TABLE: {
        WH(this, e);
        break;
      }
      case se.TEXT: {
        d1e(this, e);
        break;
      }
      case se.IN_TABLE_TEXT: {
        sh(this, e);
        break;
      }
      case se.IN_TEMPLATE: {
        QH(this, e);
        break;
      }
      case se.AFTER_BODY:
      case se.IN_FRAMESET:
      case se.AFTER_FRAMESET:
      case se.AFTER_AFTER_BODY:
      case se.AFTER_AFTER_FRAMESET: {
        Ek(this, e);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(e) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, e.chars.charCodeAt(0) === J.LINE_FEED)) {
      if (e.chars.length === 1)
        return;
      e.chars = e.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(e);
      return;
    }
    switch (this.insertionMode) {
      case se.IN_HEAD:
      case se.IN_HEAD_NO_SCRIPT:
      case se.AFTER_HEAD:
      case se.TEXT:
      case se.IN_COLUMN_GROUP:
      case se.IN_SELECT:
      case se.IN_SELECT_IN_TABLE:
      case se.IN_FRAMESET:
      case se.AFTER_FRAMESET: {
        this._insertCharacters(e);
        break;
      }
      case se.IN_BODY:
      case se.IN_CAPTION:
      case se.IN_CELL:
      case se.IN_TEMPLATE:
      case se.AFTER_BODY:
      case se.AFTER_AFTER_BODY:
      case se.AFTER_AFTER_FRAMESET: {
        jH(this, e);
        break;
      }
      case se.IN_TABLE:
      case se.IN_TABLE_BODY:
      case se.IN_ROW: {
        Kv(this, e);
        break;
      }
      case se.IN_TABLE_TEXT: {
        qH(this, e);
        break;
      }
    }
  }
};
function cwe(t, e) {
  let n = t.activeFormattingElements.getElementEntryInScopeWithTagName(e.tagName);
  return n ? t.openElements.contains(n.element) ? t.openElements.hasInScope(e.tagID) || (n = null) : (t.activeFormattingElements.removeEntry(n), n = null) : VH(t, e), n;
}
function uwe(t, e) {
  let n = null, r = t.openElements.stackTop;
  for (; r >= 0; r--) {
    const s = t.openElements.items[r];
    if (s === e.element)
      break;
    t._isSpecialElement(s, t.openElements.tagIDs[r]) && (n = s);
  }
  return n || (t.openElements.shortenToLength(r < 0 ? 0 : r), t.activeFormattingElements.removeEntry(e)), n;
}
function hwe(t, e, n) {
  let r = e, s = t.openElements.getCommonAncestor(e);
  for (let i = 0, o = s; o !== n; i++, o = s) {
    s = t.openElements.getCommonAncestor(o);
    const a = t.activeFormattingElements.getElementEntry(o), l = a && i >= awe;
    !a || l ? (l && t.activeFormattingElements.removeEntry(a), t.openElements.remove(o)) : (o = dwe(t, a), r === e && (t.activeFormattingElements.bookmark = a), t.treeAdapter.detachNode(r), t.treeAdapter.appendChild(o, r), r = o);
  }
  return r;
}
function dwe(t, e) {
  const n = t.treeAdapter.getNamespaceURI(e.element), r = t.treeAdapter.createElement(e.token.tagName, n, e.token.attrs);
  return t.openElements.replace(e.element, r), e.element = r, r;
}
function fwe(t, e, n) {
  const r = t.treeAdapter.getTagName(e), s = Du(r);
  if (t._isElementCausesFosterParenting(s))
    t._fosterParentElement(n);
  else {
    const i = t.treeAdapter.getNamespaceURI(e);
    s === C.TEMPLATE && i === Ie.HTML && (e = t.treeAdapter.getTemplateContent(e)), t.treeAdapter.appendChild(e, n);
  }
}
function pwe(t, e, n) {
  const r = t.treeAdapter.getNamespaceURI(n.element), { token: s } = n, i = t.treeAdapter.createElement(s.tagName, r, s.attrs);
  t._adoptNodes(e, i), t.treeAdapter.appendChild(e, i), t.activeFormattingElements.insertElementAfterBookmark(i, s), t.activeFormattingElements.removeEntry(n), t.openElements.remove(n.element), t.openElements.insertAfter(e, i, s.tagID);
}
function wk(t, e) {
  for (let n = 0; n < owe; n++) {
    const r = cwe(t, e);
    if (!r)
      break;
    const s = uwe(t, r);
    if (!s)
      break;
    t.activeFormattingElements.bookmark = r;
    const i = hwe(t, s, r.element), o = t.openElements.getCommonAncestor(r.element);
    t.treeAdapter.detachNode(i), o && fwe(t, o, i), pwe(t, s, r);
  }
}
function IS(t, e) {
  t._appendCommentNode(e, t.openElements.currentTmplContentOrNode);
}
function mwe(t, e) {
  t._appendCommentNode(e, t.openElements.items[0]);
}
function gwe(t, e) {
  t._appendCommentNode(e, t.document);
}
function Ek(t, e) {
  if (t.stopped = !0, e.location) {
    const n = t.fragmentContext ? 0 : 2;
    for (let r = t.openElements.stackTop; r >= n; r--)
      t._setEndLocation(t.openElements.items[r], e);
    if (!t.fragmentContext && t.openElements.stackTop >= 0) {
      const r = t.openElements.items[0], s = t.treeAdapter.getNodeSourceCodeLocation(r);
      if (s && !s.endTag && (t._setEndLocation(r, e), t.openElements.stackTop >= 1)) {
        const i = t.openElements.items[1], o = t.treeAdapter.getNodeSourceCodeLocation(i);
        o && !o.endTag && t._setEndLocation(i, e);
      }
    }
  }
}
function ywe(t, e) {
  t._setDocumentType(e);
  const n = e.forceQuirks ? Wr.QUIRKS : qve(e);
  Wve(e) || t._err(e, Se.nonConformingDoctype), t.treeAdapter.setDocumentMode(t.document, n), t.insertionMode = se.BEFORE_HTML;
}
function rh(t, e) {
  t._err(e, Se.missingDoctype, !0), t.treeAdapter.setDocumentMode(t.document, Wr.QUIRKS), t.insertionMode = se.BEFORE_HTML, t._processToken(e);
}
function bwe(t, e) {
  e.tagID === C.HTML ? (t._insertElement(e, Ie.HTML), t.insertionMode = se.BEFORE_HEAD) : Xh(t, e);
}
function _we(t, e) {
  const n = e.tagID;
  (n === C.HTML || n === C.HEAD || n === C.BODY || n === C.BR) && Xh(t, e);
}
function Xh(t, e) {
  t._insertFakeRootElement(), t.insertionMode = se.BEFORE_HEAD, t._processToken(e);
}
function vwe(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.HEAD: {
      t._insertElement(e, Ie.HTML), t.headElement = t.openElements.current, t.insertionMode = se.IN_HEAD;
      break;
    }
    default:
      Qh(t, e);
  }
}
function wwe(t, e) {
  const n = e.tagID;
  n === C.HEAD || n === C.BODY || n === C.HTML || n === C.BR ? Qh(t, e) : t._err(e, Se.endTagWithoutMatchingOpenElement);
}
function Qh(t, e) {
  t._insertFakeElement(pe.HEAD, C.HEAD), t.headElement = t.openElements.current, t.insertionMode = se.IN_HEAD, t._processToken(e);
}
function Os(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.BASE:
    case C.BASEFONT:
    case C.BGSOUND:
    case C.LINK:
    case C.META: {
      t._appendElement(e, Ie.HTML), e.ackSelfClosing = !0;
      break;
    }
    case C.TITLE: {
      t._switchToTextParsing(e, Qt.RCDATA);
      break;
    }
    case C.NOSCRIPT: {
      t.options.scriptingEnabled ? t._switchToTextParsing(e, Qt.RAWTEXT) : (t._insertElement(e, Ie.HTML), t.insertionMode = se.IN_HEAD_NO_SCRIPT);
      break;
    }
    case C.NOFRAMES:
    case C.STYLE: {
      t._switchToTextParsing(e, Qt.RAWTEXT);
      break;
    }
    case C.SCRIPT: {
      t._switchToTextParsing(e, Qt.SCRIPT_DATA);
      break;
    }
    case C.TEMPLATE: {
      t._insertTemplate(e), t.activeFormattingElements.insertMarker(), t.framesetOk = !1, t.insertionMode = se.IN_TEMPLATE, t.tmplInsertionModeStack.unshift(se.IN_TEMPLATE);
      break;
    }
    case C.HEAD: {
      t._err(e, Se.misplacedStartTagForHeadElement);
      break;
    }
    default:
      ed(t, e);
  }
}
function Ewe(t, e) {
  switch (e.tagID) {
    case C.HEAD: {
      t.openElements.pop(), t.insertionMode = se.AFTER_HEAD;
      break;
    }
    case C.BODY:
    case C.BR:
    case C.HTML: {
      ed(t, e);
      break;
    }
    case C.TEMPLATE: {
      Ml(t, e);
      break;
    }
    default:
      t._err(e, Se.endTagWithoutMatchingOpenElement);
  }
}
function Ml(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.generateImpliedEndTagsThoroughly(), t.openElements.currentTagId !== C.TEMPLATE && t._err(e, Se.closingOfElementWithOpenChildElements), t.openElements.popUntilTagNamePopped(C.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t.tmplInsertionModeStack.shift(), t._resetInsertionMode()) : t._err(e, Se.endTagWithoutMatchingOpenElement);
}
function ed(t, e) {
  t.openElements.pop(), t.insertionMode = se.AFTER_HEAD, t._processToken(e);
}
function Swe(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.BASEFONT:
    case C.BGSOUND:
    case C.HEAD:
    case C.LINK:
    case C.META:
    case C.NOFRAMES:
    case C.STYLE: {
      Os(t, e);
      break;
    }
    case C.NOSCRIPT: {
      t._err(e, Se.nestedNoscriptInHead);
      break;
    }
    default:
      td(t, e);
  }
}
function xwe(t, e) {
  switch (e.tagID) {
    case C.NOSCRIPT: {
      t.openElements.pop(), t.insertionMode = se.IN_HEAD;
      break;
    }
    case C.BR: {
      td(t, e);
      break;
    }
    default:
      t._err(e, Se.endTagWithoutMatchingOpenElement);
  }
}
function td(t, e) {
  const n = e.type === lt.EOF ? Se.openElementsLeftAfterEof : Se.disallowedContentInNoscriptInHead;
  t._err(e, n), t.openElements.pop(), t.insertionMode = se.IN_HEAD, t._processToken(e);
}
function Twe(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.BODY: {
      t._insertElement(e, Ie.HTML), t.framesetOk = !1, t.insertionMode = se.IN_BODY;
      break;
    }
    case C.FRAMESET: {
      t._insertElement(e, Ie.HTML), t.insertionMode = se.IN_FRAMESET;
      break;
    }
    case C.BASE:
    case C.BASEFONT:
    case C.BGSOUND:
    case C.LINK:
    case C.META:
    case C.NOFRAMES:
    case C.SCRIPT:
    case C.STYLE:
    case C.TEMPLATE:
    case C.TITLE: {
      t._err(e, Se.abandonedHeadElementChild), t.openElements.push(t.headElement, C.HEAD), Os(t, e), t.openElements.remove(t.headElement);
      break;
    }
    case C.HEAD: {
      t._err(e, Se.misplacedStartTagForHeadElement);
      break;
    }
    default:
      nd(t, e);
  }
}
function Cwe(t, e) {
  switch (e.tagID) {
    case C.BODY:
    case C.HTML:
    case C.BR: {
      nd(t, e);
      break;
    }
    case C.TEMPLATE: {
      Ml(t, e);
      break;
    }
    default:
      t._err(e, Se.endTagWithoutMatchingOpenElement);
  }
}
function nd(t, e) {
  t._insertFakeElement(pe.BODY, C.BODY), t.insertionMode = se.IN_BODY, Ob(t, e);
}
function Ob(t, e) {
  switch (e.type) {
    case lt.CHARACTER: {
      HH(t, e);
      break;
    }
    case lt.WHITESPACE_CHARACTER: {
      jH(t, e);
      break;
    }
    case lt.COMMENT: {
      IS(t, e);
      break;
    }
    case lt.START_TAG: {
      zn(t, e);
      break;
    }
    case lt.END_TAG: {
      Db(t, e);
      break;
    }
    case lt.EOF: {
      WH(t, e);
      break;
    }
  }
}
function jH(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e);
}
function HH(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e), t.framesetOk = !1;
}
function kwe(t, e) {
  t.openElements.tmplCount === 0 && t.treeAdapter.adoptAttributes(t.openElements.items[0], e.attrs);
}
function Awe(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  n && t.openElements.tmplCount === 0 && (t.framesetOk = !1, t.treeAdapter.adoptAttributes(n, e.attrs));
}
function Rwe(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  t.framesetOk && n && (t.treeAdapter.detachNode(n), t.openElements.popAllUpToHtmlElement(), t._insertElement(e, Ie.HTML), t.insertionMode = se.IN_FRAMESET);
}
function Iwe(t, e) {
  t.openElements.hasInButtonScope(C.P) && t._closePElement(), t._insertElement(e, Ie.HTML);
}
function Pwe(t, e) {
  t.openElements.hasInButtonScope(C.P) && t._closePElement(), RS.has(t.openElements.currentTagId) && t.openElements.pop(), t._insertElement(e, Ie.HTML);
}
function Owe(t, e) {
  t.openElements.hasInButtonScope(C.P) && t._closePElement(), t._insertElement(e, Ie.HTML), t.skipNextNewLine = !0, t.framesetOk = !1;
}
function Dwe(t, e) {
  const n = t.openElements.tmplCount > 0;
  (!t.formElement || n) && (t.openElements.hasInButtonScope(C.P) && t._closePElement(), t._insertElement(e, Ie.HTML), n || (t.formElement = t.openElements.current));
}
function Nwe(t, e) {
  t.framesetOk = !1;
  const n = e.tagID;
  for (let r = t.openElements.stackTop; r >= 0; r--) {
    const s = t.openElements.tagIDs[r];
    if (n === C.LI && s === C.LI || (n === C.DD || n === C.DT) && (s === C.DD || s === C.DT)) {
      t.openElements.generateImpliedEndTagsWithExclusion(s), t.openElements.popUntilTagNamePopped(s);
      break;
    }
    if (s !== C.ADDRESS && s !== C.DIV && s !== C.P && t._isSpecialElement(t.openElements.items[r], s))
      break;
  }
  t.openElements.hasInButtonScope(C.P) && t._closePElement(), t._insertElement(e, Ie.HTML);
}
function Lwe(t, e) {
  t.openElements.hasInButtonScope(C.P) && t._closePElement(), t._insertElement(e, Ie.HTML), t.tokenizer.state = Qt.PLAINTEXT;
}
function Mwe(t, e) {
  t.openElements.hasInScope(C.BUTTON) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(C.BUTTON)), t._reconstructActiveFormattingElements(), t._insertElement(e, Ie.HTML), t.framesetOk = !1;
}
function Bwe(t, e) {
  const n = t.activeFormattingElements.getElementEntryInScopeWithTagName(pe.A);
  n && (wk(t, e), t.openElements.remove(n.element), t.activeFormattingElements.removeEntry(n)), t._reconstructActiveFormattingElements(), t._insertElement(e, Ie.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function Fwe(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Ie.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function $we(t, e) {
  t._reconstructActiveFormattingElements(), t.openElements.hasInScope(C.NOBR) && (wk(t, e), t._reconstructActiveFormattingElements()), t._insertElement(e, Ie.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function Uwe(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Ie.HTML), t.activeFormattingElements.insertMarker(), t.framesetOk = !1;
}
function jwe(t, e) {
  t.treeAdapter.getDocumentMode(t.document) !== Wr.QUIRKS && t.openElements.hasInButtonScope(C.P) && t._closePElement(), t._insertElement(e, Ie.HTML), t.framesetOk = !1, t.insertionMode = se.IN_TABLE;
}
function zH(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, Ie.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function GH(t) {
  const e = RH(t, il.TYPE);
  return e != null && e.toLowerCase() === iwe;
}
function Hwe(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, Ie.HTML), GH(e) || (t.framesetOk = !1), e.ackSelfClosing = !0;
}
function zwe(t, e) {
  t._appendElement(e, Ie.HTML), e.ackSelfClosing = !0;
}
function Gwe(t, e) {
  t.openElements.hasInButtonScope(C.P) && t._closePElement(), t._appendElement(e, Ie.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function Vwe(t, e) {
  e.tagName = pe.IMG, e.tagID = C.IMG, zH(t, e);
}
function Wwe(t, e) {
  t._insertElement(e, Ie.HTML), t.skipNextNewLine = !0, t.tokenizer.state = Qt.RCDATA, t.originalInsertionMode = t.insertionMode, t.framesetOk = !1, t.insertionMode = se.TEXT;
}
function qwe(t, e) {
  t.openElements.hasInButtonScope(C.P) && t._closePElement(), t._reconstructActiveFormattingElements(), t.framesetOk = !1, t._switchToTextParsing(e, Qt.RAWTEXT);
}
function Kwe(t, e) {
  t.framesetOk = !1, t._switchToTextParsing(e, Qt.RAWTEXT);
}
function $O(t, e) {
  t._switchToTextParsing(e, Qt.RAWTEXT);
}
function Ywe(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Ie.HTML), t.framesetOk = !1, t.insertionMode = t.insertionMode === se.IN_TABLE || t.insertionMode === se.IN_CAPTION || t.insertionMode === se.IN_TABLE_BODY || t.insertionMode === se.IN_ROW || t.insertionMode === se.IN_CELL ? se.IN_SELECT_IN_TABLE : se.IN_SELECT;
}
function Zwe(t, e) {
  t.openElements.currentTagId === C.OPTION && t.openElements.pop(), t._reconstructActiveFormattingElements(), t._insertElement(e, Ie.HTML);
}
function Jwe(t, e) {
  t.openElements.hasInScope(C.RUBY) && t.openElements.generateImpliedEndTags(), t._insertElement(e, Ie.HTML);
}
function Xwe(t, e) {
  t.openElements.hasInScope(C.RUBY) && t.openElements.generateImpliedEndTagsWithExclusion(C.RTC), t._insertElement(e, Ie.HTML);
}
function Qwe(t, e) {
  t._reconstructActiveFormattingElements(), FH(e), vk(e), e.selfClosing ? t._appendElement(e, Ie.MATHML) : t._insertElement(e, Ie.MATHML), e.ackSelfClosing = !0;
}
function e1e(t, e) {
  t._reconstructActiveFormattingElements(), $H(e), vk(e), e.selfClosing ? t._appendElement(e, Ie.SVG) : t._insertElement(e, Ie.SVG), e.ackSelfClosing = !0;
}
function UO(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Ie.HTML);
}
function zn(t, e) {
  switch (e.tagID) {
    case C.I:
    case C.S:
    case C.B:
    case C.U:
    case C.EM:
    case C.TT:
    case C.BIG:
    case C.CODE:
    case C.FONT:
    case C.SMALL:
    case C.STRIKE:
    case C.STRONG: {
      Fwe(t, e);
      break;
    }
    case C.A: {
      Bwe(t, e);
      break;
    }
    case C.H1:
    case C.H2:
    case C.H3:
    case C.H4:
    case C.H5:
    case C.H6: {
      Pwe(t, e);
      break;
    }
    case C.P:
    case C.DL:
    case C.OL:
    case C.UL:
    case C.DIV:
    case C.DIR:
    case C.NAV:
    case C.MAIN:
    case C.MENU:
    case C.ASIDE:
    case C.CENTER:
    case C.FIGURE:
    case C.FOOTER:
    case C.HEADER:
    case C.HGROUP:
    case C.DIALOG:
    case C.DETAILS:
    case C.ADDRESS:
    case C.ARTICLE:
    case C.SEARCH:
    case C.SECTION:
    case C.SUMMARY:
    case C.FIELDSET:
    case C.BLOCKQUOTE:
    case C.FIGCAPTION: {
      Iwe(t, e);
      break;
    }
    case C.LI:
    case C.DD:
    case C.DT: {
      Nwe(t, e);
      break;
    }
    case C.BR:
    case C.IMG:
    case C.WBR:
    case C.AREA:
    case C.EMBED:
    case C.KEYGEN: {
      zH(t, e);
      break;
    }
    case C.HR: {
      Gwe(t, e);
      break;
    }
    case C.RB:
    case C.RTC: {
      Jwe(t, e);
      break;
    }
    case C.RT:
    case C.RP: {
      Xwe(t, e);
      break;
    }
    case C.PRE:
    case C.LISTING: {
      Owe(t, e);
      break;
    }
    case C.XMP: {
      qwe(t, e);
      break;
    }
    case C.SVG: {
      e1e(t, e);
      break;
    }
    case C.HTML: {
      kwe(t, e);
      break;
    }
    case C.BASE:
    case C.LINK:
    case C.META:
    case C.STYLE:
    case C.TITLE:
    case C.SCRIPT:
    case C.BGSOUND:
    case C.BASEFONT:
    case C.TEMPLATE: {
      Os(t, e);
      break;
    }
    case C.BODY: {
      Awe(t, e);
      break;
    }
    case C.FORM: {
      Dwe(t, e);
      break;
    }
    case C.NOBR: {
      $we(t, e);
      break;
    }
    case C.MATH: {
      Qwe(t, e);
      break;
    }
    case C.TABLE: {
      jwe(t, e);
      break;
    }
    case C.INPUT: {
      Hwe(t, e);
      break;
    }
    case C.PARAM:
    case C.TRACK:
    case C.SOURCE: {
      zwe(t, e);
      break;
    }
    case C.IMAGE: {
      Vwe(t, e);
      break;
    }
    case C.BUTTON: {
      Mwe(t, e);
      break;
    }
    case C.APPLET:
    case C.OBJECT:
    case C.MARQUEE: {
      Uwe(t, e);
      break;
    }
    case C.IFRAME: {
      Kwe(t, e);
      break;
    }
    case C.SELECT: {
      Ywe(t, e);
      break;
    }
    case C.OPTION:
    case C.OPTGROUP: {
      Zwe(t, e);
      break;
    }
    case C.NOEMBED:
    case C.NOFRAMES: {
      $O(t, e);
      break;
    }
    case C.FRAMESET: {
      Rwe(t, e);
      break;
    }
    case C.TEXTAREA: {
      Wwe(t, e);
      break;
    }
    case C.NOSCRIPT: {
      t.options.scriptingEnabled ? $O(t, e) : UO(t, e);
      break;
    }
    case C.PLAINTEXT: {
      Lwe(t, e);
      break;
    }
    case C.COL:
    case C.TH:
    case C.TD:
    case C.TR:
    case C.HEAD:
    case C.FRAME:
    case C.TBODY:
    case C.TFOOT:
    case C.THEAD:
    case C.CAPTION:
    case C.COLGROUP:
      break;
    default:
      UO(t, e);
  }
}
function t1e(t, e) {
  if (t.openElements.hasInScope(C.BODY) && (t.insertionMode = se.AFTER_BODY, t.options.sourceCodeLocationInfo)) {
    const n = t.openElements.tryPeekProperlyNestedBodyElement();
    n && t._setEndLocation(n, e);
  }
}
function n1e(t, e) {
  t.openElements.hasInScope(C.BODY) && (t.insertionMode = se.AFTER_BODY, e9(t, e));
}
function r1e(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n));
}
function s1e(t) {
  const e = t.openElements.tmplCount > 0, { formElement: n } = t;
  e || (t.formElement = null), (n || e) && t.openElements.hasInScope(C.FORM) && (t.openElements.generateImpliedEndTags(), e ? t.openElements.popUntilTagNamePopped(C.FORM) : n && t.openElements.remove(n));
}
function i1e(t) {
  t.openElements.hasInButtonScope(C.P) || t._insertFakeElement(pe.P, C.P), t._closePElement();
}
function o1e(t) {
  t.openElements.hasInListItemScope(C.LI) && (t.openElements.generateImpliedEndTagsWithExclusion(C.LI), t.openElements.popUntilTagNamePopped(C.LI));
}
function a1e(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTagsWithExclusion(n), t.openElements.popUntilTagNamePopped(n));
}
function l1e(t) {
  t.openElements.hasNumberedHeaderInScope() && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilNumberedHeaderPopped());
}
function c1e(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker());
}
function u1e(t) {
  t._reconstructActiveFormattingElements(), t._insertFakeElement(pe.BR, C.BR), t.openElements.pop(), t.framesetOk = !1;
}
function VH(t, e) {
  const n = e.tagName, r = e.tagID;
  for (let s = t.openElements.stackTop; s > 0; s--) {
    const i = t.openElements.items[s], o = t.openElements.tagIDs[s];
    if (r === o && (r !== C.UNKNOWN || t.treeAdapter.getTagName(i) === n)) {
      t.openElements.generateImpliedEndTagsWithExclusion(r), t.openElements.stackTop >= s && t.openElements.shortenToLength(s);
      break;
    }
    if (t._isSpecialElement(i, o))
      break;
  }
}
function Db(t, e) {
  switch (e.tagID) {
    case C.A:
    case C.B:
    case C.I:
    case C.S:
    case C.U:
    case C.EM:
    case C.TT:
    case C.BIG:
    case C.CODE:
    case C.FONT:
    case C.NOBR:
    case C.SMALL:
    case C.STRIKE:
    case C.STRONG: {
      wk(t, e);
      break;
    }
    case C.P: {
      i1e(t);
      break;
    }
    case C.DL:
    case C.UL:
    case C.OL:
    case C.DIR:
    case C.DIV:
    case C.NAV:
    case C.PRE:
    case C.MAIN:
    case C.MENU:
    case C.ASIDE:
    case C.BUTTON:
    case C.CENTER:
    case C.FIGURE:
    case C.FOOTER:
    case C.HEADER:
    case C.HGROUP:
    case C.DIALOG:
    case C.ADDRESS:
    case C.ARTICLE:
    case C.DETAILS:
    case C.SEARCH:
    case C.SECTION:
    case C.SUMMARY:
    case C.LISTING:
    case C.FIELDSET:
    case C.BLOCKQUOTE:
    case C.FIGCAPTION: {
      r1e(t, e);
      break;
    }
    case C.LI: {
      o1e(t);
      break;
    }
    case C.DD:
    case C.DT: {
      a1e(t, e);
      break;
    }
    case C.H1:
    case C.H2:
    case C.H3:
    case C.H4:
    case C.H5:
    case C.H6: {
      l1e(t);
      break;
    }
    case C.BR: {
      u1e(t);
      break;
    }
    case C.BODY: {
      t1e(t, e);
      break;
    }
    case C.HTML: {
      n1e(t, e);
      break;
    }
    case C.FORM: {
      s1e(t);
      break;
    }
    case C.APPLET:
    case C.OBJECT:
    case C.MARQUEE: {
      c1e(t, e);
      break;
    }
    case C.TEMPLATE: {
      Ml(t, e);
      break;
    }
    default:
      VH(t, e);
  }
}
function WH(t, e) {
  t.tmplInsertionModeStack.length > 0 ? QH(t, e) : Ek(t, e);
}
function h1e(t, e) {
  var n;
  e.tagID === C.SCRIPT && ((n = t.scriptHandler) === null || n === void 0 || n.call(t, t.openElements.current)), t.openElements.pop(), t.insertionMode = t.originalInsertionMode;
}
function d1e(t, e) {
  t._err(e, Se.eofInElementThatCanContainOnlyText), t.openElements.pop(), t.insertionMode = t.originalInsertionMode, t.onEof(e);
}
function Kv(t, e) {
  if (UH.has(t.openElements.currentTagId))
    switch (t.pendingCharacterTokens.length = 0, t.hasNonWhitespacePendingCharacterToken = !1, t.originalInsertionMode = t.insertionMode, t.insertionMode = se.IN_TABLE_TEXT, e.type) {
      case lt.CHARACTER: {
        KH(t, e);
        break;
      }
      case lt.WHITESPACE_CHARACTER: {
        qH(t, e);
        break;
      }
    }
  else
    lp(t, e);
}
function f1e(t, e) {
  t.openElements.clearBackToTableContext(), t.activeFormattingElements.insertMarker(), t._insertElement(e, Ie.HTML), t.insertionMode = se.IN_CAPTION;
}
function p1e(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, Ie.HTML), t.insertionMode = se.IN_COLUMN_GROUP;
}
function m1e(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(pe.COLGROUP, C.COLGROUP), t.insertionMode = se.IN_COLUMN_GROUP, Sk(t, e);
}
function g1e(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, Ie.HTML), t.insertionMode = se.IN_TABLE_BODY;
}
function y1e(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(pe.TBODY, C.TBODY), t.insertionMode = se.IN_TABLE_BODY, Nb(t, e);
}
function b1e(t, e) {
  t.openElements.hasInTableScope(C.TABLE) && (t.openElements.popUntilTagNamePopped(C.TABLE), t._resetInsertionMode(), t._processStartTag(e));
}
function _1e(t, e) {
  GH(e) ? t._appendElement(e, Ie.HTML) : lp(t, e), e.ackSelfClosing = !0;
}
function v1e(t, e) {
  !t.formElement && t.openElements.tmplCount === 0 && (t._insertElement(e, Ie.HTML), t.formElement = t.openElements.current, t.openElements.pop());
}
function ou(t, e) {
  switch (e.tagID) {
    case C.TD:
    case C.TH:
    case C.TR: {
      y1e(t, e);
      break;
    }
    case C.STYLE:
    case C.SCRIPT:
    case C.TEMPLATE: {
      Os(t, e);
      break;
    }
    case C.COL: {
      m1e(t, e);
      break;
    }
    case C.FORM: {
      v1e(t, e);
      break;
    }
    case C.TABLE: {
      b1e(t, e);
      break;
    }
    case C.TBODY:
    case C.TFOOT:
    case C.THEAD: {
      g1e(t, e);
      break;
    }
    case C.INPUT: {
      _1e(t, e);
      break;
    }
    case C.CAPTION: {
      f1e(t, e);
      break;
    }
    case C.COLGROUP: {
      p1e(t, e);
      break;
    }
    default:
      lp(t, e);
  }
}
function Kd(t, e) {
  switch (e.tagID) {
    case C.TABLE: {
      t.openElements.hasInTableScope(C.TABLE) && (t.openElements.popUntilTagNamePopped(C.TABLE), t._resetInsertionMode());
      break;
    }
    case C.TEMPLATE: {
      Ml(t, e);
      break;
    }
    case C.BODY:
    case C.CAPTION:
    case C.COL:
    case C.COLGROUP:
    case C.HTML:
    case C.TBODY:
    case C.TD:
    case C.TFOOT:
    case C.TH:
    case C.THEAD:
    case C.TR:
      break;
    default:
      lp(t, e);
  }
}
function lp(t, e) {
  const n = t.fosterParentingEnabled;
  t.fosterParentingEnabled = !0, Ob(t, e), t.fosterParentingEnabled = n;
}
function qH(t, e) {
  t.pendingCharacterTokens.push(e);
}
function KH(t, e) {
  t.pendingCharacterTokens.push(e), t.hasNonWhitespacePendingCharacterToken = !0;
}
function sh(t, e) {
  let n = 0;
  if (t.hasNonWhitespacePendingCharacterToken)
    for (; n < t.pendingCharacterTokens.length; n++)
      lp(t, t.pendingCharacterTokens[n]);
  else
    for (; n < t.pendingCharacterTokens.length; n++)
      t._insertCharacters(t.pendingCharacterTokens[n]);
  t.insertionMode = t.originalInsertionMode, t._processToken(e);
}
const YH = /* @__PURE__ */ new Set([C.CAPTION, C.COL, C.COLGROUP, C.TBODY, C.TD, C.TFOOT, C.TH, C.THEAD, C.TR]);
function w1e(t, e) {
  const n = e.tagID;
  YH.has(n) ? t.openElements.hasInTableScope(C.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(C.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = se.IN_TABLE, ou(t, e)) : zn(t, e);
}
function E1e(t, e) {
  const n = e.tagID;
  switch (n) {
    case C.CAPTION:
    case C.TABLE: {
      t.openElements.hasInTableScope(C.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(C.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = se.IN_TABLE, n === C.TABLE && Kd(t, e));
      break;
    }
    case C.BODY:
    case C.COL:
    case C.COLGROUP:
    case C.HTML:
    case C.TBODY:
    case C.TD:
    case C.TFOOT:
    case C.TH:
    case C.THEAD:
    case C.TR:
      break;
    default:
      Db(t, e);
  }
}
function Sk(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.COL: {
      t._appendElement(e, Ie.HTML), e.ackSelfClosing = !0;
      break;
    }
    case C.TEMPLATE: {
      Os(t, e);
      break;
    }
    default:
      z0(t, e);
  }
}
function S1e(t, e) {
  switch (e.tagID) {
    case C.COLGROUP: {
      t.openElements.currentTagId === C.COLGROUP && (t.openElements.pop(), t.insertionMode = se.IN_TABLE);
      break;
    }
    case C.TEMPLATE: {
      Ml(t, e);
      break;
    }
    case C.COL:
      break;
    default:
      z0(t, e);
  }
}
function z0(t, e) {
  t.openElements.currentTagId === C.COLGROUP && (t.openElements.pop(), t.insertionMode = se.IN_TABLE, t._processToken(e));
}
function Nb(t, e) {
  switch (e.tagID) {
    case C.TR: {
      t.openElements.clearBackToTableBodyContext(), t._insertElement(e, Ie.HTML), t.insertionMode = se.IN_ROW;
      break;
    }
    case C.TH:
    case C.TD: {
      t.openElements.clearBackToTableBodyContext(), t._insertFakeElement(pe.TR, C.TR), t.insertionMode = se.IN_ROW, Lb(t, e);
      break;
    }
    case C.CAPTION:
    case C.COL:
    case C.COLGROUP:
    case C.TBODY:
    case C.TFOOT:
    case C.THEAD: {
      t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = se.IN_TABLE, ou(t, e));
      break;
    }
    default:
      ou(t, e);
  }
}
function PS(t, e) {
  const n = e.tagID;
  switch (e.tagID) {
    case C.TBODY:
    case C.TFOOT:
    case C.THEAD: {
      t.openElements.hasInTableScope(n) && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = se.IN_TABLE);
      break;
    }
    case C.TABLE: {
      t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = se.IN_TABLE, Kd(t, e));
      break;
    }
    case C.BODY:
    case C.CAPTION:
    case C.COL:
    case C.COLGROUP:
    case C.HTML:
    case C.TD:
    case C.TH:
    case C.TR:
      break;
    default:
      Kd(t, e);
  }
}
function Lb(t, e) {
  switch (e.tagID) {
    case C.TH:
    case C.TD: {
      t.openElements.clearBackToTableRowContext(), t._insertElement(e, Ie.HTML), t.insertionMode = se.IN_CELL, t.activeFormattingElements.insertMarker();
      break;
    }
    case C.CAPTION:
    case C.COL:
    case C.COLGROUP:
    case C.TBODY:
    case C.TFOOT:
    case C.THEAD:
    case C.TR: {
      t.openElements.hasInTableScope(C.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = se.IN_TABLE_BODY, Nb(t, e));
      break;
    }
    default:
      ou(t, e);
  }
}
function ZH(t, e) {
  switch (e.tagID) {
    case C.TR: {
      t.openElements.hasInTableScope(C.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = se.IN_TABLE_BODY);
      break;
    }
    case C.TABLE: {
      t.openElements.hasInTableScope(C.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = se.IN_TABLE_BODY, PS(t, e));
      break;
    }
    case C.TBODY:
    case C.TFOOT:
    case C.THEAD: {
      (t.openElements.hasInTableScope(e.tagID) || t.openElements.hasInTableScope(C.TR)) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = se.IN_TABLE_BODY, PS(t, e));
      break;
    }
    case C.BODY:
    case C.CAPTION:
    case C.COL:
    case C.COLGROUP:
    case C.HTML:
    case C.TD:
    case C.TH:
      break;
    default:
      Kd(t, e);
  }
}
function x1e(t, e) {
  const n = e.tagID;
  YH.has(n) ? (t.openElements.hasInTableScope(C.TD) || t.openElements.hasInTableScope(C.TH)) && (t._closeTableCell(), Lb(t, e)) : zn(t, e);
}
function T1e(t, e) {
  const n = e.tagID;
  switch (n) {
    case C.TD:
    case C.TH: {
      t.openElements.hasInTableScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = se.IN_ROW);
      break;
    }
    case C.TABLE:
    case C.TBODY:
    case C.TFOOT:
    case C.THEAD:
    case C.TR: {
      t.openElements.hasInTableScope(n) && (t._closeTableCell(), ZH(t, e));
      break;
    }
    case C.BODY:
    case C.CAPTION:
    case C.COL:
    case C.COLGROUP:
    case C.HTML:
      break;
    default:
      Db(t, e);
  }
}
function JH(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.OPTION: {
      t.openElements.currentTagId === C.OPTION && t.openElements.pop(), t._insertElement(e, Ie.HTML);
      break;
    }
    case C.OPTGROUP: {
      t.openElements.currentTagId === C.OPTION && t.openElements.pop(), t.openElements.currentTagId === C.OPTGROUP && t.openElements.pop(), t._insertElement(e, Ie.HTML);
      break;
    }
    case C.HR: {
      t.openElements.currentTagId === C.OPTION && t.openElements.pop(), t.openElements.currentTagId === C.OPTGROUP && t.openElements.pop(), t._appendElement(e, Ie.HTML), e.ackSelfClosing = !0;
      break;
    }
    case C.INPUT:
    case C.KEYGEN:
    case C.TEXTAREA:
    case C.SELECT: {
      t.openElements.hasInSelectScope(C.SELECT) && (t.openElements.popUntilTagNamePopped(C.SELECT), t._resetInsertionMode(), e.tagID !== C.SELECT && t._processStartTag(e));
      break;
    }
    case C.SCRIPT:
    case C.TEMPLATE: {
      Os(t, e);
      break;
    }
  }
}
function XH(t, e) {
  switch (e.tagID) {
    case C.OPTGROUP: {
      t.openElements.stackTop > 0 && t.openElements.currentTagId === C.OPTION && t.openElements.tagIDs[t.openElements.stackTop - 1] === C.OPTGROUP && t.openElements.pop(), t.openElements.currentTagId === C.OPTGROUP && t.openElements.pop();
      break;
    }
    case C.OPTION: {
      t.openElements.currentTagId === C.OPTION && t.openElements.pop();
      break;
    }
    case C.SELECT: {
      t.openElements.hasInSelectScope(C.SELECT) && (t.openElements.popUntilTagNamePopped(C.SELECT), t._resetInsertionMode());
      break;
    }
    case C.TEMPLATE: {
      Ml(t, e);
      break;
    }
  }
}
function C1e(t, e) {
  const n = e.tagID;
  n === C.CAPTION || n === C.TABLE || n === C.TBODY || n === C.TFOOT || n === C.THEAD || n === C.TR || n === C.TD || n === C.TH ? (t.openElements.popUntilTagNamePopped(C.SELECT), t._resetInsertionMode(), t._processStartTag(e)) : JH(t, e);
}
function k1e(t, e) {
  const n = e.tagID;
  n === C.CAPTION || n === C.TABLE || n === C.TBODY || n === C.TFOOT || n === C.THEAD || n === C.TR || n === C.TD || n === C.TH ? t.openElements.hasInTableScope(n) && (t.openElements.popUntilTagNamePopped(C.SELECT), t._resetInsertionMode(), t.onEndTag(e)) : XH(t, e);
}
function A1e(t, e) {
  switch (e.tagID) {
    case C.BASE:
    case C.BASEFONT:
    case C.BGSOUND:
    case C.LINK:
    case C.META:
    case C.NOFRAMES:
    case C.SCRIPT:
    case C.STYLE:
    case C.TEMPLATE:
    case C.TITLE: {
      Os(t, e);
      break;
    }
    case C.CAPTION:
    case C.COLGROUP:
    case C.TBODY:
    case C.TFOOT:
    case C.THEAD: {
      t.tmplInsertionModeStack[0] = se.IN_TABLE, t.insertionMode = se.IN_TABLE, ou(t, e);
      break;
    }
    case C.COL: {
      t.tmplInsertionModeStack[0] = se.IN_COLUMN_GROUP, t.insertionMode = se.IN_COLUMN_GROUP, Sk(t, e);
      break;
    }
    case C.TR: {
      t.tmplInsertionModeStack[0] = se.IN_TABLE_BODY, t.insertionMode = se.IN_TABLE_BODY, Nb(t, e);
      break;
    }
    case C.TD:
    case C.TH: {
      t.tmplInsertionModeStack[0] = se.IN_ROW, t.insertionMode = se.IN_ROW, Lb(t, e);
      break;
    }
    default:
      t.tmplInsertionModeStack[0] = se.IN_BODY, t.insertionMode = se.IN_BODY, zn(t, e);
  }
}
function R1e(t, e) {
  e.tagID === C.TEMPLATE && Ml(t, e);
}
function QH(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.popUntilTagNamePopped(C.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t.tmplInsertionModeStack.shift(), t._resetInsertionMode(), t.onEof(e)) : Ek(t, e);
}
function I1e(t, e) {
  e.tagID === C.HTML ? zn(t, e) : G0(t, e);
}
function e9(t, e) {
  var n;
  if (e.tagID === C.HTML) {
    if (t.fragmentContext || (t.insertionMode = se.AFTER_AFTER_BODY), t.options.sourceCodeLocationInfo && t.openElements.tagIDs[0] === C.HTML) {
      t._setEndLocation(t.openElements.items[0], e);
      const r = t.openElements.items[1];
      r && !(!((n = t.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && t._setEndLocation(r, e);
    }
  } else
    G0(t, e);
}
function G0(t, e) {
  t.insertionMode = se.IN_BODY, Ob(t, e);
}
function P1e(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.FRAMESET: {
      t._insertElement(e, Ie.HTML);
      break;
    }
    case C.FRAME: {
      t._appendElement(e, Ie.HTML), e.ackSelfClosing = !0;
      break;
    }
    case C.NOFRAMES: {
      Os(t, e);
      break;
    }
  }
}
function O1e(t, e) {
  e.tagID === C.FRAMESET && !t.openElements.isRootHtmlElementCurrent() && (t.openElements.pop(), !t.fragmentContext && t.openElements.currentTagId !== C.FRAMESET && (t.insertionMode = se.AFTER_FRAMESET));
}
function D1e(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.NOFRAMES: {
      Os(t, e);
      break;
    }
  }
}
function N1e(t, e) {
  e.tagID === C.HTML && (t.insertionMode = se.AFTER_AFTER_FRAMESET);
}
function L1e(t, e) {
  e.tagID === C.HTML ? zn(t, e) : Eg(t, e);
}
function Eg(t, e) {
  t.insertionMode = se.IN_BODY, Ob(t, e);
}
function M1e(t, e) {
  switch (e.tagID) {
    case C.HTML: {
      zn(t, e);
      break;
    }
    case C.NOFRAMES: {
      Os(t, e);
      break;
    }
  }
}
function B1e(t, e) {
  e.chars = $t, t._insertCharacters(e);
}
function F1e(t, e) {
  t._insertCharacters(e), t.framesetOk = !1;
}
function t9(t) {
  for (; t.treeAdapter.getNamespaceURI(t.openElements.current) !== Ie.HTML && !t._isIntegrationPoint(t.openElements.currentTagId, t.openElements.current); )
    t.openElements.pop();
}
function $1e(t, e) {
  if (ewe(e))
    t9(t), t._startTagOutsideForeignContent(e);
  else {
    const n = t._getAdjustedCurrentElement(), r = t.treeAdapter.getNamespaceURI(n);
    r === Ie.MATHML ? FH(e) : r === Ie.SVG && (twe(e), $H(e)), vk(e), e.selfClosing ? t._appendElement(e, r) : t._insertElement(e, r), e.ackSelfClosing = !0;
  }
}
function U1e(t, e) {
  if (e.tagID === C.P || e.tagID === C.BR) {
    t9(t), t._endTagOutsideForeignContent(e);
    return;
  }
  for (let n = t.openElements.stackTop; n > 0; n--) {
    const r = t.openElements.items[n];
    if (t.treeAdapter.getNamespaceURI(r) === Ie.HTML) {
      t._endTagOutsideForeignContent(e);
      break;
    }
    const s = t.treeAdapter.getTagName(r);
    if (s.toLowerCase() === e.tagName) {
      e.tagName = s, t.openElements.shortenToLength(n);
      break;
    }
  }
}
pe.AREA, pe.BASE, pe.BASEFONT, pe.BGSOUND, pe.BR, pe.COL, pe.EMBED, pe.FRAME, pe.HR, pe.IMG, pe.INPUT, pe.KEYGEN, pe.LINK, pe.META, pe.PARAM, pe.SOURCE, pe.TRACK, pe.WBR;
const n9 = r9("end"), Bl = r9("start");
function r9(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
const s9 = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return G1e;
    if (typeof t == "function")
      return Mb(t);
    if (typeof t == "object")
      return Array.isArray(t) ? j1e(t) : H1e(t);
    if (typeof t == "string")
      return z1e(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function j1e(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = s9(t[n]);
  return Mb(r);
  function r(...s) {
    let i = -1;
    for (; ++i < e.length; )
      if (e[i].apply(this, s)) return !0;
    return !1;
  }
}
function H1e(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return Mb(n);
  function n(r) {
    const s = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let i;
    for (i in t)
      if (s[i] !== e[i]) return !1;
    return !0;
  }
}
function z1e(t) {
  return Mb(e);
  function e(n) {
    return n && n.type === t;
  }
}
function Mb(t) {
  return e;
  function e(n, r, s) {
    return !!(V1e(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      s || void 0
    ));
  }
}
function G1e() {
  return !0;
}
function V1e(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const i9 = [], W1e = !0, V0 = !1, o9 = "skip";
function a9(t, e, n, r) {
  let s;
  typeof e == "function" && typeof n != "function" ? (r = n, n = e) : s = e;
  const i = s9(s), o = r ? -1 : 1;
  a(t, void 0, [])();
  function a(l, c, u) {
    const h = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof h.type == "string") {
      const f = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(d, "name", {
        value: "node (" + (l.type + (f ? "<" + f + ">" : "")) + ")"
      });
    }
    return d;
    function d() {
      let f = i9, g, y, p;
      if ((!e || i(l, c, u[u.length - 1] || void 0)) && (f = q1e(n(l, u)), f[0] === V0))
        return f;
      if ("children" in l && l.children) {
        const m = (
          /** @type {UnistParent} */
          l
        );
        if (m.children && f[0] !== o9)
          for (y = (r ? m.children.length : -1) + o, p = u.concat(m); y > -1 && y < m.children.length; ) {
            const b = m.children[y];
            if (g = a(b, y, p)(), g[0] === V0)
              return g;
            y = typeof g[1] == "number" ? g[1] : y + o;
          }
      }
      return f;
    }
  }
}
function q1e(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [W1e, t] : t == null ? i9 : [t];
}
function Fl(t, e, n, r) {
  let s, i, o;
  typeof e == "function" && typeof n != "function" ? (i = void 0, o = e, s = n) : (i = e, o = n, s = r), a9(t, i, a, s);
  function a(l, c) {
    const u = c[c.length - 1], h = u ? u.children.indexOf(l) : void 0;
    return o(l, h, u);
  }
}
const K1e = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, Y1e = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), jO = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function l9(t, e) {
  const n = iEe(t), r = bk("type", {
    handlers: { root: Z1e, element: J1e, text: X1e, comment: u9, doctype: Q1e, raw: tEe },
    unknown: nEe
  }), s = {
    parser: n ? new FO(jO) : FO.getFragmentParser(void 0, jO),
    handle(a) {
      r(a, s);
    },
    stitches: !1,
    options: e || {}
  };
  r(t, s), Nu(s, Bl());
  const i = n ? s.parser.document : s.parser.getFragment(), o = eve(i, {
    // To do: support `space`?
    file: s.options.file
  });
  return s.stitches && Fl(o, "comment", function(a, l, c) {
    const u = (
      /** @type {Stitch} */
      /** @type {unknown} */
      a
    );
    if (u.value.stitch && c && l !== void 0) {
      const h = c.children;
      return h[l] = u.value.stitch, l;
    }
  }), o.type === "root" && o.children.length === 1 && o.children[0].type === t.type ? o.children[0] : o;
}
function c9(t, e) {
  let n = -1;
  if (t)
    for (; ++n < t.length; )
      e.handle(t[n]);
}
function Z1e(t, e) {
  c9(t.children, e);
}
function J1e(t, e) {
  rEe(t, e), c9(t.children, e), sEe(t, e);
}
function X1e(t, e) {
  e.parser.tokenizer.state > 4 && (e.parser.tokenizer.state = 0);
  const n = {
    type: lt.CHARACTER,
    chars: t.value,
    location: cp(t)
  };
  Nu(e, Bl(t)), e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken);
}
function Q1e(t, e) {
  const n = {
    type: lt.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: cp(t)
  };
  Nu(e, Bl(t)), e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken);
}
function eEe(t, e) {
  e.stitches = !0;
  const n = oEe(t);
  if ("children" in t && "children" in n) {
    const r = (
      /** @type {Root} */
      l9({ type: "root", children: t.children }, e.options)
    );
    n.children = r.children;
  }
  u9({ type: "comment", value: { stitch: n } }, e);
}
function u9(t, e) {
  const n = t.value, r = {
    type: lt.COMMENT,
    data: n,
    location: cp(t)
  };
  Nu(e, Bl(t)), e.parser.currentToken = r, e.parser._processToken(e.parser.currentToken);
}
function tEe(t, e) {
  if (e.parser.tokenizer.preprocessor.html = "", e.parser.tokenizer.preprocessor.pos = -1, e.parser.tokenizer.preprocessor.lastGapPos = -2, e.parser.tokenizer.preprocessor.gapStack = [], e.parser.tokenizer.preprocessor.skipNextNewLine = !1, e.parser.tokenizer.preprocessor.lastChunkWritten = !1, e.parser.tokenizer.preprocessor.endOfChunkHit = !1, e.parser.tokenizer.preprocessor.isEol = !1, h9(e, Bl(t)), e.parser.tokenizer.write(
    e.options.tagfilter ? t.value.replace(K1e, "&lt;$1$2") : t.value,
    !1
  ), e.parser.tokenizer._runParsingLoop(), e.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  e.parser.tokenizer.state === 78) {
    e.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = e.parser.tokenizer._consume();
    e.parser.tokenizer._callState(n);
  }
}
function nEe(t, e) {
  const n = (
    /** @type {Nodes} */
    t
  );
  if (e.options.passThrough && e.options.passThrough.includes(n.type))
    eEe(n, e);
  else {
    let r = "";
    throw Y1e.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function Nu(t, e) {
  h9(t, e);
  const n = t.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = t.parser.tokenizer.preprocessor.line, n.location.endCol = t.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = t.parser.tokenizer.preprocessor.offset + 1, t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken)), t.parser.tokenizer.paused = !1, t.parser.tokenizer.inLoop = !1, t.parser.tokenizer.active = !1, t.parser.tokenizer.returnState = Qt.DATA, t.parser.tokenizer.charRefCode = -1, t.parser.tokenizer.consumedAfterSnapshot = -1, t.parser.tokenizer.currentLocation = null, t.parser.tokenizer.currentCharacterToken = null, t.parser.tokenizer.currentToken = null, t.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function h9(t, e) {
  if (e && e.offset !== void 0) {
    const n = {
      startLine: e.line,
      startCol: e.column,
      startOffset: e.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    t.parser.tokenizer.preprocessor.lineStartPos = -e.column + 1, t.parser.tokenizer.preprocessor.droppedBufferSize = e.offset, t.parser.tokenizer.preprocessor.line = e.line, t.parser.tokenizer.currentLocation = n;
  }
}
function rEe(t, e) {
  const n = t.tagName.toLowerCase();
  if (e.parser.tokenizer.state === Qt.PLAINTEXT) return;
  Nu(e, Bl(t));
  const r = e.parser.openElements.current;
  let s = "namespaceURI" in r ? r.namespaceURI : za.html;
  s === za.html && n === "svg" && (s = za.svg);
  const i = ive(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...t, children: [] },
    { space: s === za.svg ? "svg" : "html" }
  ), o = {
    type: lt.START_TAG,
    tagName: n,
    tagID: Du(n),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in i ? i.attrs : [],
    location: cp(t)
  };
  e.parser.currentToken = o, e.parser._processToken(e.parser.currentToken), e.parser.tokenizer.lastStartTagName = n;
}
function sEe(t, e) {
  const n = t.tagName.toLowerCase();
  if (!e.parser.tokenizer.inForeignNode && TH.includes(n) || e.parser.tokenizer.state === Qt.PLAINTEXT) return;
  Nu(e, n9(t));
  const r = {
    type: lt.END_TAG,
    tagName: n,
    tagID: Du(n),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: cp(t)
  };
  e.parser.currentToken = r, e.parser._processToken(e.parser.currentToken), // Current element is closed.
  n === e.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (e.parser.tokenizer.state === Qt.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  e.parser.tokenizer.state === Qt.RAWTEXT || // `<script>`
  e.parser.tokenizer.state === Qt.SCRIPT_DATA) && (e.parser.tokenizer.state = Qt.DATA);
}
function iEe(t) {
  const e = t.type === "root" ? t.children[0] : t;
  return !!(e && (e.type === "doctype" || e.type === "element" && e.tagName.toLowerCase() === "html"));
}
function cp(t) {
  const e = Bl(t) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = n9(t) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: e.line,
    startCol: e.column,
    startOffset: e.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function oEe(t) {
  return "children" in t ? bl({ ...t, children: [] }) : bl(t);
}
function aEe(t) {
  return function(e, n) {
    return (
      /** @type {Root} */
      l9(e, { ...t, file: n })
    );
  };
}
function W0(t, e) {
  const n = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, s = n.indexOf(e);
  for (; s !== -1; )
    r++, s = n.indexOf(e, s + e.length);
  return r;
}
const lEe = d9(/\p{P}|\p{S}/u), cEe = d9(/\s/);
function d9(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function uEe(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const f9 = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return pEe;
    if (typeof t == "function")
      return Bb(t);
    if (typeof t == "object")
      return Array.isArray(t) ? hEe(t) : dEe(t);
    if (typeof t == "string")
      return fEe(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function hEe(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = f9(t[n]);
  return Bb(r);
  function r(...s) {
    let i = -1;
    for (; ++i < e.length; )
      if (e[i].apply(this, s)) return !0;
    return !1;
  }
}
function dEe(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return Bb(n);
  function n(r) {
    const s = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let i;
    for (i in t)
      if (s[i] !== e[i]) return !1;
    return !0;
  }
}
function fEe(t) {
  return Bb(e);
  function e(n) {
    return n && n.type === t;
  }
}
function Bb(t) {
  return e;
  function e(n, r, s) {
    return !!(mEe(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      s || void 0
    ));
  }
}
function pEe() {
  return !0;
}
function mEe(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
function gEe(t, e, n) {
  const s = f9((n || {}).ignore || []), i = yEe(e);
  let o = -1;
  for (; ++o < i.length; )
    a9(t, "text", a);
  function a(c, u) {
    let h = -1, d;
    for (; ++h < u.length; ) {
      const f = u[h], g = d ? d.children : void 0;
      if (s(
        f,
        g ? g.indexOf(f) : void 0,
        d
      ))
        return;
      d = f;
    }
    if (d)
      return l(c, u);
  }
  function l(c, u) {
    const h = u[u.length - 1], d = i[o][0], f = i[o][1];
    let g = 0;
    const p = h.children.indexOf(c);
    let m = !1, b = [];
    d.lastIndex = 0;
    let _ = d.exec(c.value);
    for (; _; ) {
      const v = _.index, w = {
        index: _.index,
        input: _.input,
        stack: [...u, c]
      };
      let E = f(..._, w);
      if (typeof E == "string" && (E = E.length > 0 ? { type: "text", value: E } : void 0), E === !1 ? d.lastIndex = v + 1 : (g !== v && b.push({
        type: "text",
        value: c.value.slice(g, v)
      }), Array.isArray(E) ? b.push(...E) : E && b.push(E), g = v + _[0].length, m = !0), !d.global)
        break;
      _ = d.exec(c.value);
    }
    return m ? (g < c.value.length && b.push({ type: "text", value: c.value.slice(g) }), h.children.splice(p, 1, ...b)) : b = [c], p + b.length;
  }
}
function yEe(t) {
  const e = [];
  if (!Array.isArray(t))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !t[0] || Array.isArray(t[0]) ? t : [t];
  let r = -1;
  for (; ++r < n.length; ) {
    const s = n[r];
    e.push([bEe(s[0]), _Ee(s[1])]);
  }
  return e;
}
function bEe(t) {
  return typeof t == "string" ? new RegExp(uEe(t), "g") : t;
}
function _Ee(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}
const Yv = "phrasing", Zv = ["autolink", "link", "image", "label"];
function vEe() {
  return {
    transforms: [kEe],
    enter: {
      literalAutolink: EEe,
      literalAutolinkEmail: Jv,
      literalAutolinkHttp: Jv,
      literalAutolinkWww: Jv
    },
    exit: {
      literalAutolink: CEe,
      literalAutolinkEmail: TEe,
      literalAutolinkHttp: SEe,
      literalAutolinkWww: xEe
    }
  };
}
function wEe() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Yv,
        notInConstruct: Zv
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Yv,
        notInConstruct: Zv
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Yv,
        notInConstruct: Zv
      }
    ]
  };
}
function EEe(t) {
  this.enter({ type: "link", title: null, url: "", children: [] }, t);
}
function Jv(t) {
  this.config.enter.autolinkProtocol.call(this, t);
}
function SEe(t) {
  this.config.exit.autolinkProtocol.call(this, t);
}
function xEe(t) {
  this.config.exit.data.call(this, t);
  const e = this.stack[this.stack.length - 1];
  e.type, e.url = "http://" + this.sliceSerialize(t);
}
function TEe(t) {
  this.config.exit.autolinkEmail.call(this, t);
}
function CEe(t) {
  this.exit(t);
}
function kEe(t) {
  gEe(
    t,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, AEe],
      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, REe]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function AEe(t, e, n, r, s) {
  let i = "";
  if (!p9(s) || (/^w/i.test(e) && (n = e + n, e = "", i = "http://"), !IEe(n)))
    return !1;
  const o = PEe(n + r);
  if (!o[0]) return !1;
  const a = {
    type: "link",
    title: null,
    url: i + e + o[0],
    children: [{ type: "text", value: e + o[0] }]
  };
  return o[1] ? [a, { type: "text", value: o[1] }] : a;
}
function REe(t, e, n, r) {
  return (
    // Not an expected previous character.
    !p9(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + e + "@" + n,
      children: [{ type: "text", value: e + "@" + n }]
    }
  );
}
function IEe(t) {
  const e = t.split(".");
  return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])));
}
function PEe(t) {
  const e = /[!"&'),.:;<>?\]}]+$/.exec(t);
  if (!e)
    return [t, void 0];
  t = t.slice(0, e.index);
  let n = e[0], r = n.indexOf(")");
  const s = W0(t, "(");
  let i = W0(t, ")");
  for (; r !== -1 && s > i; )
    t += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++;
  return [t, n];
}
function p9(t, e) {
  const n = t.input.charCodeAt(t.index - 1);
  return (t.index === 0 || cEe(n) || lEe(n)) && // If its an email, the previous character should not be a slash.
  (!e || n !== 47);
}
function m9(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
g9.peek = HEe;
function OEe() {
  return {
    enter: {
      gfmFootnoteDefinition: NEe,
      gfmFootnoteDefinitionLabelString: LEe,
      gfmFootnoteCall: FEe,
      gfmFootnoteCallString: $Ee
    },
    exit: {
      gfmFootnoteDefinition: BEe,
      gfmFootnoteDefinitionLabelString: MEe,
      gfmFootnoteCall: jEe,
      gfmFootnoteCallString: UEe
    }
  };
}
function DEe() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: zEe, footnoteReference: g9 }
  };
}
function NEe(t) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    t
  );
}
function LEe() {
  this.buffer();
}
function MEe(t) {
  const e = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = e, n.identifier = m9(
    this.sliceSerialize(t)
  ).toLowerCase();
}
function BEe(t) {
  this.exit(t);
}
function FEe(t) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, t);
}
function $Ee() {
  this.buffer();
}
function UEe(t) {
  const e = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = e, n.identifier = m9(
    this.sliceSerialize(t)
  ).toLowerCase();
}
function jEe(t) {
  this.exit(t);
}
function g9(t, e, n, r) {
  const s = n.createTracker(r);
  let i = s.move("[^");
  const o = n.enter("footnoteReference"), a = n.enter("reference");
  return i += s.move(
    n.safe(n.associationId(t), {
      ...s.current(),
      before: i,
      after: "]"
    })
  ), a(), o(), i += s.move("]"), i;
}
function HEe() {
  return "[";
}
function zEe(t, e, n, r) {
  const s = n.createTracker(r);
  let i = s.move("[^");
  const o = n.enter("footnoteDefinition"), a = n.enter("label");
  return i += s.move(
    n.safe(n.associationId(t), {
      ...s.current(),
      before: i,
      after: "]"
    })
  ), a(), i += s.move(
    "]:" + (t.children && t.children.length > 0 ? " " : "")
  ), s.shift(4), i += s.move(
    n.indentLines(n.containerFlow(t, s.current()), GEe)
  ), o(), i;
}
function GEe(t, e, n) {
  return e === 0 ? t : (n ? "" : "    ") + t;
}
const VEe = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
y9.peek = ZEe;
function WEe() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: KEe },
    exit: { strikethrough: YEe }
  };
}
function qEe() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: VEe
      }
    ],
    handlers: { delete: y9 }
  };
}
function KEe(t) {
  this.enter({ type: "delete", children: [] }, t);
}
function YEe(t) {
  this.exit(t);
}
function y9(t, e, n, r) {
  const s = n.createTracker(r), i = n.enter("strikethrough");
  let o = s.move("~~");
  return o += n.containerPhrasing(t, {
    ...s.current(),
    before: o,
    after: "~"
  }), o += s.move("~~"), i(), o;
}
function ZEe() {
  return "~";
}
function JEe(t) {
  return t.length;
}
function XEe(t, e) {
  const n = e || {}, r = (n.align || []).concat(), s = n.stringLength || JEe, i = [], o = [], a = [], l = [];
  let c = 0, u = -1;
  for (; ++u < t.length; ) {
    const y = [], p = [];
    let m = -1;
    for (t[u].length > c && (c = t[u].length); ++m < t[u].length; ) {
      const b = QEe(t[u][m]);
      if (n.alignDelimiters !== !1) {
        const _ = s(b);
        p[m] = _, (l[m] === void 0 || _ > l[m]) && (l[m] = _);
      }
      y.push(b);
    }
    o[u] = y, a[u] = p;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < c; )
      i[h] = HO(r[h]);
  else {
    const y = HO(r);
    for (; ++h < c; )
      i[h] = y;
  }
  h = -1;
  const d = [], f = [];
  for (; ++h < c; ) {
    const y = i[h];
    let p = "", m = "";
    y === 99 ? (p = ":", m = ":") : y === 108 ? p = ":" : y === 114 && (m = ":");
    let b = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[h] - p.length - m.length
    );
    const _ = p + "-".repeat(b) + m;
    n.alignDelimiters !== !1 && (b = p.length + b + m.length, b > l[h] && (l[h] = b), f[h] = b), d[h] = _;
  }
  o.splice(1, 0, d), a.splice(1, 0, f), u = -1;
  const g = [];
  for (; ++u < o.length; ) {
    const y = o[u], p = a[u];
    h = -1;
    const m = [];
    for (; ++h < c; ) {
      const b = y[h] || "";
      let _ = "", v = "";
      if (n.alignDelimiters !== !1) {
        const w = l[h] - (p[h] || 0), E = i[h];
        E === 114 ? _ = " ".repeat(w) : E === 99 ? w % 2 ? (_ = " ".repeat(w / 2 + 0.5), v = " ".repeat(w / 2 - 0.5)) : (_ = " ".repeat(w / 2), v = _) : v = " ".repeat(w);
      }
      n.delimiterStart !== !1 && !h && m.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && b === "") && (n.delimiterStart !== !1 || h) && m.push(" "), n.alignDelimiters !== !1 && m.push(_), m.push(b), n.alignDelimiters !== !1 && m.push(v), n.padding !== !1 && m.push(" "), (n.delimiterEnd !== !1 || h !== c - 1) && m.push("|");
    }
    g.push(
      n.delimiterEnd === !1 ? m.join("").replace(/ +$/, "") : m.join("")
    );
  }
  return g.join(`
`);
}
function QEe(t) {
  return t == null ? "" : String(t);
}
function HO(t) {
  const e = typeof t == "string" ? t.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function eSe(t, e, n, r) {
  const s = n.enter("blockquote"), i = n.createTracker(r);
  i.move("> "), i.shift(2);
  const o = n.indentLines(
    n.containerFlow(t, i.current()),
    tSe
  );
  return s(), o;
}
function tSe(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function nSe(t, e) {
  return zO(t, e.inConstruct, !0) && !zO(t, e.notInConstruct, !1);
}
function zO(t, e, n) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return n;
  let r = -1;
  for (; ++r < e.length; )
    if (t.includes(e[r]))
      return !0;
  return !1;
}
function GO(t, e, n, r) {
  let s = -1;
  for (; ++s < n.unsafe.length; )
    if (n.unsafe[s].character === `
` && nSe(n.stack, n.unsafe[s]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function b9(t, e) {
  const n = String(t);
  let r = n.indexOf(e), s = r, i = 0, o = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === s ? ++i > o && (o = i) : i = 1, s = r + e.length, r = n.indexOf(e, s);
  return o;
}
function rSe(t, e) {
  return !!(e.options.fences === !1 && t.value && // If theres no info
  !t.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(t.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value));
}
function sSe(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function iSe(t, e, n, r) {
  const s = sSe(n), i = t.value || "", o = s === "`" ? "GraveAccent" : "Tilde";
  if (rSe(t, n)) {
    const h = n.enter("codeIndented"), d = n.indentLines(i, oSe);
    return h(), d;
  }
  const a = n.createTracker(r), l = s.repeat(Math.max(b9(i, s) + 1, 3)), c = n.enter("codeFenced");
  let u = a.move(l);
  if (t.lang) {
    const h = n.enter(`codeFencedLang${o}`);
    u += a.move(
      n.safe(t.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  if (t.lang && t.meta) {
    const h = n.enter(`codeFencedMeta${o}`);
    u += a.move(" "), u += a.move(
      n.safe(t.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  return u += a.move(`
`), i && (u += a.move(i + `
`)), u += a.move(l), c(), u;
}
function oSe(t, e, n) {
  return (n ? "" : "    ") + t;
}
function xk(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function aSe(t, e, n, r) {
  const s = xk(n), i = s === '"' ? "Quote" : "Apostrophe", o = n.enter("definition");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(t), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), a(), // If theres no url, or
  !t.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(t.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(
    n.safe(t.url, {
      before: c,
      after: t.title ? " " : `
`,
      ...l.current()
    })
  )), a(), t.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(
    n.safe(t.title, {
      before: c,
      after: s,
      ...l.current()
    })
  ), c += l.move(s), a()), o(), c;
}
function lSe(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function Yd(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function cSe(t) {
  return t !== null && (t < 0 || t === 32);
}
const uSe = _9(/\p{P}|\p{S}/u), hSe = _9(/\s/);
function _9(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function VO(t) {
  if (t === null || cSe(t) || hSe(t))
    return 1;
  if (uSe(t))
    return 2;
}
function q0(t, e, n) {
  const r = VO(t), s = VO(e);
  return r === void 0 ? s === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : s === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? s === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : s === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : s === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : s === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
v9.peek = dSe;
function v9(t, e, n, r) {
  const s = lSe(n), i = n.enter("emphasis"), o = n.createTracker(r), a = o.move(s);
  let l = o.move(
    n.containerPhrasing(t, {
      after: s,
      before: a,
      ...o.current()
    })
  );
  const c = l.charCodeAt(0), u = q0(
    r.before.charCodeAt(r.before.length - 1),
    c,
    s
  );
  u.inside && (l = Yd(c) + l.slice(1));
  const h = l.charCodeAt(l.length - 1), d = q0(r.after.charCodeAt(0), h, s);
  d.inside && (l = l.slice(0, -1) + Yd(h));
  const f = o.move(s);
  return i(), n.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: u.outside
  }, a + l + f;
}
function dSe(t, e, n) {
  return n.options.emphasis || "*";
}
const fSe = {};
function w9(t, e) {
  const n = fSe, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, s = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return E9(t, r, s);
}
function E9(t, e, n) {
  if (pSe(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return WO(t.children, e, n);
  }
  return Array.isArray(t) ? WO(t, e, n) : "";
}
function WO(t, e, n) {
  const r = [];
  let s = -1;
  for (; ++s < t.length; )
    r[s] = E9(t[s], e, n);
  return r.join("");
}
function pSe(t) {
  return !!(t && typeof t == "object");
}
function mSe(t, e) {
  let n = !1;
  return Fl(t, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, V0;
  }), !!((!t.depth || t.depth < 3) && w9(t) && (e.options.setext || n));
}
function gSe(t, e, n, r) {
  const s = Math.max(Math.min(6, t.depth || 1), 1), i = n.createTracker(r);
  if (mSe(t, n)) {
    const u = n.enter("headingSetext"), h = n.enter("phrasing"), d = n.containerPhrasing(t, {
      ...i.current(),
      before: `
`,
      after: `
`
    });
    return h(), u(), d + `
` + (s === 1 ? "=" : "-").repeat(
      // The whole size
      d.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(s), a = n.enter("headingAtx"), l = n.enter("phrasing");
  i.move(o + " ");
  let c = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...i.current()
  });
  return /^[\t ]/.test(c) && (c = Yd(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, n.options.closeAtx && (c += " " + o), l(), a(), c;
}
S9.peek = ySe;
function S9(t) {
  return t.value || "";
}
function ySe() {
  return "<";
}
x9.peek = bSe;
function x9(t, e, n, r) {
  const s = xk(n), i = s === '"' ? "Quote" : "Apostrophe", o = n.enter("image");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(t.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), a(), // If theres no url but there is a title
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(t.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(
    n.safe(t.url, {
      before: c,
      after: t.title ? " " : ")",
      ...l.current()
    })
  )), a(), t.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(
    n.safe(t.title, {
      before: c,
      after: s,
      ...l.current()
    })
  ), c += l.move(s), a()), c += l.move(")"), o(), c;
}
function bSe() {
  return "!";
}
T9.peek = _Se;
function T9(t, e, n, r) {
  const s = t.referenceType, i = n.enter("imageReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("![");
  const c = n.safe(t.alt, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const h = n.safe(n.associationId(t), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = u, i(), s === "full" || !c || c !== h ? l += a.move(h + "]") : s === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function _Se() {
  return "!";
}
C9.peek = vSe;
function C9(t, e, n) {
  let r = t.value || "", s = "`", i = -1;
  for (; new RegExp("(^|[^`])" + s + "([^`]|$)").test(r); )
    s += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
    const o = n.unsafe[i], a = n.compilePattern(o);
    let l;
    if (o.atBreak)
      for (; l = a.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return s + r + s;
}
function vSe() {
  return "`";
}
function k9(t, e) {
  const n = w9(t);
  return !!(!e.options.resourceLink && // If theres a url
  t.url && // And theres a no title
  !t.title && // And the content of `node` is a single text node
  t.children && t.children.length === 1 && t.children[0].type === "text" && // And if the url is the same as the content
  (n === t.url || "mailto:" + n === t.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(t.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(t.url));
}
A9.peek = wSe;
function A9(t, e, n, r) {
  const s = xk(n), i = s === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r);
  let a, l;
  if (k9(t, n)) {
    const u = n.stack;
    n.stack = [], a = n.enter("autolink");
    let h = o.move("<");
    return h += o.move(
      n.containerPhrasing(t, {
        before: h,
        after: ">",
        ...o.current()
      })
    ), h += o.move(">"), a(), n.stack = u, h;
  }
  a = n.enter("link"), l = n.enter("label");
  let c = o.move("[");
  return c += o.move(
    n.containerPhrasing(t, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), l(), // If theres no url but there is a title
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (l = n.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    n.safe(t.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (l = n.enter("destinationRaw"), c += o.move(
    n.safe(t.url, {
      before: c,
      after: t.title ? " " : ")",
      ...o.current()
    })
  )), l(), t.title && (l = n.enter(`title${i}`), c += o.move(" " + s), c += o.move(
    n.safe(t.title, {
      before: c,
      after: s,
      ...o.current()
    })
  ), c += o.move(s), l()), c += o.move(")"), a(), c;
}
function wSe(t, e, n) {
  return k9(t, n) ? "<" : "[";
}
R9.peek = ESe;
function R9(t, e, n, r) {
  const s = t.referenceType, i = n.enter("linkReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("[");
  const c = n.containerPhrasing(t, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const h = n.safe(n.associationId(t), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = u, i(), s === "full" || !c || c !== h ? l += a.move(h + "]") : s === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function ESe() {
  return "[";
}
function Tk(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function SSe(t) {
  const e = Tk(t), n = t.options.bulletOther;
  if (!n)
    return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function xSe(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function I9(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function TSe(t, e, n, r) {
  const s = n.enter("list"), i = n.bulletCurrent;
  let o = t.ordered ? xSe(n) : Tk(n);
  const a = t.ordered ? o === "." ? ")" : "." : SSe(n);
  let l = e && n.bulletLastUsed ? o === n.bulletLastUsed : !1;
  if (!t.ordered) {
    const u = t.children ? t.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), I9(n) === o && u
    ) {
      let h = -1;
      for (; ++h < t.children.length; ) {
        const d = t.children[h];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (o = a), n.bulletCurrent = o;
  const c = n.containerFlow(t, r);
  return n.bulletLastUsed = o, n.bulletCurrent = i, s(), c;
}
function CSe(t) {
  const e = t.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function kSe(t, e, n, r) {
  const s = CSe(n);
  let i = n.bulletCurrent || Tk(n);
  e && e.type === "list" && e.ordered && (i = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + i);
  let o = i.length + 1;
  (s === "tab" || s === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (o = Math.ceil(o / 4) * 4);
  const a = n.createTracker(r);
  a.move(i + " ".repeat(o - i.length)), a.shift(o);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(t, a.current()),
    u
  );
  return l(), c;
  function u(h, d, f) {
    return d ? (f ? "" : " ".repeat(o)) + h : (f ? i : i + " ".repeat(o - i.length)) + h;
  }
}
function ASe(t, e, n, r) {
  const s = n.enter("paragraph"), i = n.enter("phrasing"), o = n.containerPhrasing(t, r);
  return i(), s(), o;
}
const P9 = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return OSe;
    if (typeof t == "function")
      return Fb(t);
    if (typeof t == "object")
      return Array.isArray(t) ? RSe(t) : ISe(t);
    if (typeof t == "string")
      return PSe(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function RSe(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = P9(t[n]);
  return Fb(r);
  function r(...s) {
    let i = -1;
    for (; ++i < e.length; )
      if (e[i].apply(this, s)) return !0;
    return !1;
  }
}
function ISe(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return Fb(n);
  function n(r) {
    const s = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let i;
    for (i in t)
      if (s[i] !== e[i]) return !1;
    return !0;
  }
}
function PSe(t) {
  return Fb(e);
  function e(n) {
    return n && n.type === t;
  }
}
function Fb(t) {
  return e;
  function e(n, r, s) {
    return !!(DSe(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      s || void 0
    ));
  }
}
function OSe() {
  return !0;
}
function DSe(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const NSe = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  P9([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function LSe(t, e, n, r) {
  return (t.children.some(function(o) {
    return NSe(o);
  }) ? n.containerPhrasing : n.containerFlow).call(n, t, r);
}
function MSe(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
O9.peek = BSe;
function O9(t, e, n, r) {
  const s = MSe(n), i = n.enter("strong"), o = n.createTracker(r), a = o.move(s + s);
  let l = o.move(
    n.containerPhrasing(t, {
      after: s,
      before: a,
      ...o.current()
    })
  );
  const c = l.charCodeAt(0), u = q0(
    r.before.charCodeAt(r.before.length - 1),
    c,
    s
  );
  u.inside && (l = Yd(c) + l.slice(1));
  const h = l.charCodeAt(l.length - 1), d = q0(r.after.charCodeAt(0), h, s);
  d.inside && (l = l.slice(0, -1) + Yd(h));
  const f = o.move(s + s);
  return i(), n.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: u.outside
  }, a + l + f;
}
function BSe(t, e, n) {
  return n.options.strong || "*";
}
function FSe(t, e, n, r) {
  return n.safe(t.value, r);
}
function $Se(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function USe(t, e, n) {
  const r = (I9(n) + (n.options.ruleSpaces ? " " : "")).repeat($Se(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const jSe = {
  blockquote: eSe,
  break: GO,
  code: iSe,
  definition: aSe,
  emphasis: v9,
  hardBreak: GO,
  heading: gSe,
  html: S9,
  image: x9,
  imageReference: T9,
  inlineCode: C9,
  link: A9,
  linkReference: R9,
  list: TSe,
  listItem: kSe,
  paragraph: ASe,
  root: LSe,
  strong: O9,
  text: FSe,
  thematicBreak: USe
}, qO = document.createElement("i");
function Ck(t) {
  const e = "&" + t + ";";
  qO.innerHTML = e;
  const n = qO.textContent;
  return n.charCodeAt(n.length - 1) === 59 && t !== "semi" || n === e ? !1 : n;
}
function HSe() {
  return {
    enter: {
      table: zSe,
      tableData: KO,
      tableHeader: KO,
      tableRow: VSe
    },
    exit: {
      codeText: WSe,
      table: GSe,
      tableData: Xv,
      tableHeader: Xv,
      tableRow: Xv
    }
  };
}
function zSe(t) {
  const e = t._align;
  this.enter(
    {
      type: "table",
      align: e.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    t
  ), this.data.inTable = !0;
}
function GSe(t) {
  this.exit(t), this.data.inTable = void 0;
}
function VSe(t) {
  this.enter({ type: "tableRow", children: [] }, t);
}
function Xv(t) {
  this.exit(t);
}
function KO(t) {
  this.enter({ type: "tableCell", children: [] }, t);
}
function WSe(t) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, qSe));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = e, this.exit(t);
}
function qSe(t, e) {
  return e === "|" ? e : t;
}
function KSe(t) {
  const e = t || {}, n = e.tableCellPadding, r = e.tablePipeAlign, s = e.stringLength, i = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: d,
      table: o,
      tableCell: l,
      tableRow: a
    }
  };
  function o(f, g, y, p) {
    return c(u(f, y, p), f.align);
  }
  function a(f, g, y, p) {
    const m = h(f, y, p), b = c([m]);
    return b.slice(0, b.indexOf(`
`));
  }
  function l(f, g, y, p) {
    const m = y.enter("tableCell"), b = y.enter("phrasing"), _ = y.containerPhrasing(f, {
      ...p,
      before: i,
      after: i
    });
    return b(), m(), _;
  }
  function c(f, g) {
    return XEe(f, {
      align: g,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: s
    });
  }
  function u(f, g, y) {
    const p = f.children;
    let m = -1;
    const b = [], _ = g.enter("table");
    for (; ++m < p.length; )
      b[m] = h(p[m], g, y);
    return _(), b;
  }
  function h(f, g, y) {
    const p = f.children;
    let m = -1;
    const b = [], _ = g.enter("tableRow");
    for (; ++m < p.length; )
      b[m] = l(p[m], f, g, y);
    return _(), b;
  }
  function d(f, g, y) {
    let p = jSe.inlineCode(f, g, y);
    return y.stack.includes("tableCell") && (p = p.replace(/\|/g, "\\$&")), p;
  }
}
function YSe(t, e, n, r) {
  const s = n.enter("blockquote"), i = n.createTracker(r);
  i.move("> "), i.shift(2);
  const o = n.indentLines(
    n.containerFlow(t, i.current()),
    ZSe
  );
  return s(), o;
}
function ZSe(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function JSe(t, e) {
  return YO(t, e.inConstruct, !0) && !YO(t, e.notInConstruct, !1);
}
function YO(t, e, n) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return n;
  let r = -1;
  for (; ++r < e.length; )
    if (t.includes(e[r]))
      return !0;
  return !1;
}
function ZO(t, e, n, r) {
  let s = -1;
  for (; ++s < n.unsafe.length; )
    if (n.unsafe[s].character === `
` && JSe(n.stack, n.unsafe[s]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function XSe(t, e) {
  return !!(e.options.fences === !1 && t.value && // If theres no info
  !t.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(t.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value));
}
function QSe(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function exe(t, e, n, r) {
  const s = QSe(n), i = t.value || "", o = s === "`" ? "GraveAccent" : "Tilde";
  if (XSe(t, n)) {
    const h = n.enter("codeIndented"), d = n.indentLines(i, txe);
    return h(), d;
  }
  const a = n.createTracker(r), l = s.repeat(Math.max(b9(i, s) + 1, 3)), c = n.enter("codeFenced");
  let u = a.move(l);
  if (t.lang) {
    const h = n.enter(`codeFencedLang${o}`);
    u += a.move(
      n.safe(t.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  if (t.lang && t.meta) {
    const h = n.enter(`codeFencedMeta${o}`);
    u += a.move(" "), u += a.move(
      n.safe(t.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  return u += a.move(`
`), i && (u += a.move(i + `
`)), u += a.move(l), c(), u;
}
function txe(t, e, n) {
  return (n ? "" : "    ") + t;
}
function kk(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function nxe(t, e, n, r) {
  const s = kk(n), i = s === '"' ? "Quote" : "Apostrophe", o = n.enter("definition");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(t), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), a(), // If theres no url, or
  !t.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(t.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(
    n.safe(t.url, {
      before: c,
      after: t.title ? " " : `
`,
      ...l.current()
    })
  )), a(), t.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(
    n.safe(t.title, {
      before: c,
      after: s,
      ...l.current()
    })
  ), c += l.move(s), a()), o(), c;
}
function rxe(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function Zd(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function sxe(t) {
  return t !== null && (t < 0 || t === 32);
}
const ixe = D9(/\p{P}|\p{S}/u), oxe = D9(/\s/);
function D9(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function JO(t) {
  if (t === null || sxe(t) || oxe(t))
    return 1;
  if (ixe(t))
    return 2;
}
function K0(t, e, n) {
  const r = JO(t), s = JO(e);
  return r === void 0 ? s === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : s === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? s === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : s === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : s === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : s === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
N9.peek = axe;
function N9(t, e, n, r) {
  const s = rxe(n), i = n.enter("emphasis"), o = n.createTracker(r), a = o.move(s);
  let l = o.move(
    n.containerPhrasing(t, {
      after: s,
      before: a,
      ...o.current()
    })
  );
  const c = l.charCodeAt(0), u = K0(
    r.before.charCodeAt(r.before.length - 1),
    c,
    s
  );
  u.inside && (l = Zd(c) + l.slice(1));
  const h = l.charCodeAt(l.length - 1), d = K0(r.after.charCodeAt(0), h, s);
  d.inside && (l = l.slice(0, -1) + Zd(h));
  const f = o.move(s);
  return i(), n.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: u.outside
  }, a + l + f;
}
function axe(t, e, n) {
  return n.options.emphasis || "*";
}
const lxe = {};
function L9(t, e) {
  const n = lxe, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, s = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return M9(t, r, s);
}
function M9(t, e, n) {
  if (cxe(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return XO(t.children, e, n);
  }
  return Array.isArray(t) ? XO(t, e, n) : "";
}
function XO(t, e, n) {
  const r = [];
  let s = -1;
  for (; ++s < t.length; )
    r[s] = M9(t[s], e, n);
  return r.join("");
}
function cxe(t) {
  return !!(t && typeof t == "object");
}
function uxe(t, e) {
  let n = !1;
  return Fl(t, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, V0;
  }), !!((!t.depth || t.depth < 3) && L9(t) && (e.options.setext || n));
}
function hxe(t, e, n, r) {
  const s = Math.max(Math.min(6, t.depth || 1), 1), i = n.createTracker(r);
  if (uxe(t, n)) {
    const u = n.enter("headingSetext"), h = n.enter("phrasing"), d = n.containerPhrasing(t, {
      ...i.current(),
      before: `
`,
      after: `
`
    });
    return h(), u(), d + `
` + (s === 1 ? "=" : "-").repeat(
      // The whole size
      d.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(s), a = n.enter("headingAtx"), l = n.enter("phrasing");
  i.move(o + " ");
  let c = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...i.current()
  });
  return /^[\t ]/.test(c) && (c = Zd(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, n.options.closeAtx && (c += " " + o), l(), a(), c;
}
B9.peek = dxe;
function B9(t) {
  return t.value || "";
}
function dxe() {
  return "<";
}
F9.peek = fxe;
function F9(t, e, n, r) {
  const s = kk(n), i = s === '"' ? "Quote" : "Apostrophe", o = n.enter("image");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(t.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), a(), // If theres no url but there is a title
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(t.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(
    n.safe(t.url, {
      before: c,
      after: t.title ? " " : ")",
      ...l.current()
    })
  )), a(), t.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(
    n.safe(t.title, {
      before: c,
      after: s,
      ...l.current()
    })
  ), c += l.move(s), a()), c += l.move(")"), o(), c;
}
function fxe() {
  return "!";
}
$9.peek = pxe;
function $9(t, e, n, r) {
  const s = t.referenceType, i = n.enter("imageReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("![");
  const c = n.safe(t.alt, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const h = n.safe(n.associationId(t), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = u, i(), s === "full" || !c || c !== h ? l += a.move(h + "]") : s === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function pxe() {
  return "!";
}
U9.peek = mxe;
function U9(t, e, n) {
  let r = t.value || "", s = "`", i = -1;
  for (; new RegExp("(^|[^`])" + s + "([^`]|$)").test(r); )
    s += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
    const o = n.unsafe[i], a = n.compilePattern(o);
    let l;
    if (o.atBreak)
      for (; l = a.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return s + r + s;
}
function mxe() {
  return "`";
}
function j9(t, e) {
  const n = L9(t);
  return !!(!e.options.resourceLink && // If theres a url
  t.url && // And theres a no title
  !t.title && // And the content of `node` is a single text node
  t.children && t.children.length === 1 && t.children[0].type === "text" && // And if the url is the same as the content
  (n === t.url || "mailto:" + n === t.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(t.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(t.url));
}
H9.peek = gxe;
function H9(t, e, n, r) {
  const s = kk(n), i = s === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r);
  let a, l;
  if (j9(t, n)) {
    const u = n.stack;
    n.stack = [], a = n.enter("autolink");
    let h = o.move("<");
    return h += o.move(
      n.containerPhrasing(t, {
        before: h,
        after: ">",
        ...o.current()
      })
    ), h += o.move(">"), a(), n.stack = u, h;
  }
  a = n.enter("link"), l = n.enter("label");
  let c = o.move("[");
  return c += o.move(
    n.containerPhrasing(t, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), l(), // If theres no url but there is a title
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (l = n.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    n.safe(t.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (l = n.enter("destinationRaw"), c += o.move(
    n.safe(t.url, {
      before: c,
      after: t.title ? " " : ")",
      ...o.current()
    })
  )), l(), t.title && (l = n.enter(`title${i}`), c += o.move(" " + s), c += o.move(
    n.safe(t.title, {
      before: c,
      after: s,
      ...o.current()
    })
  ), c += o.move(s), l()), c += o.move(")"), a(), c;
}
function gxe(t, e, n) {
  return j9(t, n) ? "<" : "[";
}
z9.peek = yxe;
function z9(t, e, n, r) {
  const s = t.referenceType, i = n.enter("linkReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("[");
  const c = n.containerPhrasing(t, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const h = n.safe(n.associationId(t), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = u, i(), s === "full" || !c || c !== h ? l += a.move(h + "]") : s === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function yxe() {
  return "[";
}
function Ak(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function bxe(t) {
  const e = Ak(t), n = t.options.bulletOther;
  if (!n)
    return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function _xe(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function G9(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function vxe(t, e, n, r) {
  const s = n.enter("list"), i = n.bulletCurrent;
  let o = t.ordered ? _xe(n) : Ak(n);
  const a = t.ordered ? o === "." ? ")" : "." : bxe(n);
  let l = e && n.bulletLastUsed ? o === n.bulletLastUsed : !1;
  if (!t.ordered) {
    const u = t.children ? t.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), G9(n) === o && u
    ) {
      let h = -1;
      for (; ++h < t.children.length; ) {
        const d = t.children[h];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (o = a), n.bulletCurrent = o;
  const c = n.containerFlow(t, r);
  return n.bulletLastUsed = o, n.bulletCurrent = i, s(), c;
}
function wxe(t) {
  const e = t.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function Exe(t, e, n, r) {
  const s = wxe(n);
  let i = n.bulletCurrent || Ak(n);
  e && e.type === "list" && e.ordered && (i = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + i);
  let o = i.length + 1;
  (s === "tab" || s === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (o = Math.ceil(o / 4) * 4);
  const a = n.createTracker(r);
  a.move(i + " ".repeat(o - i.length)), a.shift(o);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(t, a.current()),
    u
  );
  return l(), c;
  function u(h, d, f) {
    return d ? (f ? "" : " ".repeat(o)) + h : (f ? i : i + " ".repeat(o - i.length)) + h;
  }
}
function Sxe(t, e, n, r) {
  const s = n.enter("paragraph"), i = n.enter("phrasing"), o = n.containerPhrasing(t, r);
  return i(), s(), o;
}
const V9 = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return kxe;
    if (typeof t == "function")
      return $b(t);
    if (typeof t == "object")
      return Array.isArray(t) ? xxe(t) : Txe(t);
    if (typeof t == "string")
      return Cxe(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function xxe(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = V9(t[n]);
  return $b(r);
  function r(...s) {
    let i = -1;
    for (; ++i < e.length; )
      if (e[i].apply(this, s)) return !0;
    return !1;
  }
}
function Txe(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return $b(n);
  function n(r) {
    const s = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let i;
    for (i in t)
      if (s[i] !== e[i]) return !1;
    return !0;
  }
}
function Cxe(t) {
  return $b(e);
  function e(n) {
    return n && n.type === t;
  }
}
function $b(t) {
  return e;
  function e(n, r, s) {
    return !!(Axe(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      s || void 0
    ));
  }
}
function kxe() {
  return !0;
}
function Axe(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const Rxe = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  V9([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function Ixe(t, e, n, r) {
  return (t.children.some(function(o) {
    return Rxe(o);
  }) ? n.containerPhrasing : n.containerFlow).call(n, t, r);
}
function Pxe(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
W9.peek = Oxe;
function W9(t, e, n, r) {
  const s = Pxe(n), i = n.enter("strong"), o = n.createTracker(r), a = o.move(s + s);
  let l = o.move(
    n.containerPhrasing(t, {
      after: s,
      before: a,
      ...o.current()
    })
  );
  const c = l.charCodeAt(0), u = K0(
    r.before.charCodeAt(r.before.length - 1),
    c,
    s
  );
  u.inside && (l = Zd(c) + l.slice(1));
  const h = l.charCodeAt(l.length - 1), d = K0(r.after.charCodeAt(0), h, s);
  d.inside && (l = l.slice(0, -1) + Zd(h));
  const f = o.move(s + s);
  return i(), n.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: u.outside
  }, a + l + f;
}
function Oxe(t, e, n) {
  return n.options.strong || "*";
}
function Dxe(t, e, n, r) {
  return n.safe(t.value, r);
}
function Nxe(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function Lxe(t, e, n) {
  const r = (G9(n) + (n.options.ruleSpaces ? " " : "")).repeat(Nxe(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Mxe = {
  blockquote: YSe,
  break: ZO,
  code: exe,
  definition: nxe,
  emphasis: N9,
  hardBreak: ZO,
  heading: hxe,
  html: B9,
  image: F9,
  imageReference: $9,
  inlineCode: U9,
  link: H9,
  linkReference: z9,
  list: vxe,
  listItem: Exe,
  paragraph: Sxe,
  root: Ixe,
  strong: W9,
  text: Dxe,
  thematicBreak: Lxe
};
function Bxe() {
  return {
    exit: {
      taskListCheckValueChecked: QO,
      taskListCheckValueUnchecked: QO,
      paragraph: $xe
    }
  };
}
function Fxe() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Uxe }
  };
}
function QO(t) {
  const e = this.stack[this.stack.length - 2];
  e.type, e.checked = t.type === "taskListCheckValueChecked";
}
function $xe(t) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const s = e.children;
      let i = -1, o;
      for (; ++i < s.length; ) {
        const a = s[i];
        if (a.type === "paragraph") {
          o = a;
          break;
        }
      }
      o === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(t);
}
function Uxe(t, e, n, r) {
  const s = t.children[0], i = typeof t.checked == "boolean" && s && s.type === "paragraph", o = "[" + (t.checked ? "x" : " ") + "] ", a = n.createTracker(r);
  i && a.move(o);
  let l = Mxe.listItem(t, e, n, {
    ...r,
    ...a.current()
  });
  return i && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(u) {
    return u + o;
  }
}
function jxe() {
  return [
    vEe(),
    OEe(),
    WEe(),
    HSe(),
    Bxe()
  ];
}
function Hxe(t) {
  return {
    extensions: [
      wEe(),
      DEe(),
      qEe(),
      KSe(t),
      Fxe()
    ]
  };
}
function zxe(t, e, n, r) {
  const s = t.length;
  let i = 0, o;
  if (e < 0 ? e = -e > s ? 0 : s + e : e = e > s ? s : e, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, n), t.splice(...o);
  else
    for (n && t.splice(e, n); i < r.length; )
      o = r.slice(i, i + 1e4), o.unshift(e, 0), t.splice(...o), i += 1e4, e += 1e4;
}
const eD = {}.hasOwnProperty;
function Gxe(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    Vxe(e, t[n]);
  return e;
}
function Vxe(t, e) {
  let n;
  for (n in e) {
    const s = (eD.call(t, n) ? t[n] : void 0) || (t[n] = {}), i = e[n];
    let o;
    if (i)
      for (o in i) {
        eD.call(s, o) || (s[o] = []);
        const a = i[o];
        Wxe(
          // @ts-expect-error Looks like a list.
          s[o],
          Array.isArray(a) ? a : a ? [a] : []
        );
      }
  }
}
function Wxe(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  zxe(t, 0, 0, r);
}
const Jd = Ub(/[A-Za-z]/), Rk = Ub(/[\dA-Za-z]/);
function qxe(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
function au(t) {
  return t !== null && (t < 0 || t === 32);
}
const q9 = Ub(/\p{P}|\p{S}/u), Xd = Ub(/\s/);
function Ub(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
const Kxe = {
  tokenize: eTe,
  partial: !0
}, K9 = {
  tokenize: tTe,
  partial: !0
}, Y9 = {
  tokenize: nTe,
  partial: !0
}, Z9 = {
  tokenize: rTe,
  partial: !0
}, Yxe = {
  tokenize: sTe,
  partial: !0
}, J9 = {
  name: "wwwAutolink",
  tokenize: Xxe,
  previous: Q9
}, X9 = {
  name: "protocolAutolink",
  tokenize: Qxe,
  previous: e7
}, yo = {
  name: "emailAutolink",
  tokenize: Jxe,
  previous: t7
}, Di = {};
function Zxe() {
  return {
    text: Di
  };
}
let Ta = 48;
for (; Ta < 123; )
  Di[Ta] = yo, Ta++, Ta === 58 ? Ta = 65 : Ta === 91 && (Ta = 97);
Di[43] = yo;
Di[45] = yo;
Di[46] = yo;
Di[95] = yo;
Di[72] = [yo, X9];
Di[104] = [yo, X9];
Di[87] = [yo, J9];
Di[119] = [yo, J9];
function Jxe(t, e, n) {
  const r = this;
  let s, i;
  return o;
  function o(h) {
    return !OS(h) || !t7.call(r, r.previous) || Ik(r.events) ? n(h) : (t.enter("literalAutolink"), t.enter("literalAutolinkEmail"), a(h));
  }
  function a(h) {
    return OS(h) ? (t.consume(h), a) : h === 64 ? (t.consume(h), l) : n(h);
  }
  function l(h) {
    return h === 46 ? t.check(Yxe, u, c)(h) : h === 45 || h === 95 || Rk(h) ? (i = !0, t.consume(h), l) : u(h);
  }
  function c(h) {
    return t.consume(h), s = !0, l;
  }
  function u(h) {
    return i && s && Jd(r.previous) ? (t.exit("literalAutolinkEmail"), t.exit("literalAutolink"), e(h)) : n(h);
  }
}
function Xxe(t, e, n) {
  const r = this;
  return s;
  function s(o) {
    return o !== 87 && o !== 119 || !Q9.call(r, r.previous) || Ik(r.events) ? n(o) : (t.enter("literalAutolink"), t.enter("literalAutolinkWww"), t.check(Kxe, t.attempt(K9, t.attempt(Y9, i), n), n)(o));
  }
  function i(o) {
    return t.exit("literalAutolinkWww"), t.exit("literalAutolink"), e(o);
  }
}
function Qxe(t, e, n) {
  const r = this;
  let s = "", i = !1;
  return o;
  function o(h) {
    return (h === 72 || h === 104) && e7.call(r, r.previous) && !Ik(r.events) ? (t.enter("literalAutolink"), t.enter("literalAutolinkHttp"), s += String.fromCodePoint(h), t.consume(h), a) : n(h);
  }
  function a(h) {
    if (Jd(h) && s.length < 5)
      return s += String.fromCodePoint(h), t.consume(h), a;
    if (h === 58) {
      const d = s.toLowerCase();
      if (d === "http" || d === "https")
        return t.consume(h), l;
    }
    return n(h);
  }
  function l(h) {
    return h === 47 ? (t.consume(h), i ? c : (i = !0, l)) : n(h);
  }
  function c(h) {
    return h === null || qxe(h) || au(h) || Xd(h) || q9(h) ? n(h) : t.attempt(K9, t.attempt(Y9, u), n)(h);
  }
  function u(h) {
    return t.exit("literalAutolinkHttp"), t.exit("literalAutolink"), e(h);
  }
}
function eTe(t, e, n) {
  let r = 0;
  return s;
  function s(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, t.consume(o), s) : o === 46 && r === 3 ? (t.consume(o), i) : n(o);
  }
  function i(o) {
    return o === null ? n(o) : e(o);
  }
}
function tTe(t, e, n) {
  let r, s, i;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? t.check(Z9, l, a)(c) : c === null || au(c) || Xd(c) || c !== 45 && q9(c) ? l(c) : (i = !0, t.consume(c), o);
  }
  function a(c) {
    return c === 95 ? r = !0 : (s = r, r = void 0), t.consume(c), o;
  }
  function l(c) {
    return s || r || !i ? n(c) : e(c);
  }
}
function nTe(t, e) {
  let n = 0, r = 0;
  return s;
  function s(o) {
    return o === 40 ? (n++, t.consume(o), s) : o === 41 && r < n ? i(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? t.check(Z9, e, i)(o) : o === null || au(o) || Xd(o) ? e(o) : (t.consume(o), s);
  }
  function i(o) {
    return o === 41 && r++, t.consume(o), s;
  }
}
function rTe(t, e, n) {
  return r;
  function r(a) {
    return a === 33 || a === 34 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 63 || a === 95 || a === 126 ? (t.consume(a), r) : a === 38 ? (t.consume(a), i) : a === 93 ? (t.consume(a), s) : (
      // `<` is an end.
      a === 60 || // So is whitespace.
      a === null || au(a) || Xd(a) ? e(a) : n(a)
    );
  }
  function s(a) {
    return a === null || a === 40 || a === 91 || au(a) || Xd(a) ? e(a) : r(a);
  }
  function i(a) {
    return Jd(a) ? o(a) : n(a);
  }
  function o(a) {
    return a === 59 ? (t.consume(a), r) : Jd(a) ? (t.consume(a), o) : n(a);
  }
}
function sTe(t, e, n) {
  return r;
  function r(i) {
    return t.consume(i), s;
  }
  function s(i) {
    return Rk(i) ? n(i) : e(i);
  }
}
function Q9(t) {
  return t === null || t === 40 || t === 42 || t === 95 || t === 91 || t === 93 || t === 126 || au(t);
}
function e7(t) {
  return !Jd(t);
}
function t7(t) {
  return !(t === 47 || OS(t));
}
function OS(t) {
  return t === 43 || t === 45 || t === 46 || t === 95 || Rk(t);
}
function Ik(t) {
  let e = t.length, n = !1;
  for (; e--; ) {
    const r = t[e][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return t.length > 0 && !n && (t[t.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
function iTe(t) {
  return t !== null && t < -2;
}
function Y0(t) {
  return t !== null && (t < 0 || t === 32);
}
function DS(t) {
  return t === -2 || t === -1 || t === 32;
}
function Pk(t, e, n, r) {
  const s = r ? r - 1 : Number.POSITIVE_INFINITY;
  let i = 0;
  return o;
  function o(l) {
    return DS(l) ? (t.enter(n), a(l)) : e(l);
  }
  function a(l) {
    return DS(l) && i++ < s ? (t.consume(l), a) : (t.exit(n), e(l));
  }
}
const oTe = {
  partial: !0,
  tokenize: aTe
};
function aTe(t, e, n) {
  return r;
  function r(i) {
    return DS(i) ? Pk(t, s, "linePrefix")(i) : s(i);
  }
  function s(i) {
    return i === null || iTe(i) ? e(i) : n(i);
  }
}
function Ok(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const lTe = {
  tokenize: gTe,
  partial: !0
};
function cTe() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: fTe,
        continuation: {
          tokenize: pTe
        },
        exit: mTe
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: dTe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: uTe,
        resolveTo: hTe
      }
    }
  };
}
function uTe(t, e, n) {
  const r = this;
  let s = r.events.length;
  const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; s--; ) {
    const l = r.events[s][1];
    if (l.type === "labelImage") {
      o = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return a;
  function a(l) {
    if (!o || !o._balanced)
      return n(l);
    const c = Ok(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !i.includes(c.slice(1)) ? n(l) : (t.enter("gfmFootnoteCallLabelMarker"), t.consume(l), t.exit("gfmFootnoteCallLabelMarker"), e(l));
  }
}
function hTe(t, e) {
  let n = t.length;
  for (; n--; )
    if (t[n][1].type === "labelImage" && t[n][0] === "enter") {
      t[n][1];
      break;
    }
  t[n + 1][1].type = "data", t[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, t[n + 3][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, s = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, t[n + 3][1].end),
    end: Object.assign({}, t[n + 3][1].end)
  };
  s.end.column++, s.end.offset++, s.end._bufferIndex++;
  const i = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, s.end),
    end: Object.assign({}, t[t.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, i.start),
    end: Object.assign({}, i.end)
  }, a = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    t[n + 1],
    t[n + 2],
    ["enter", r, e],
    // The `[`
    t[n + 3],
    t[n + 4],
    // The `^`.
    ["enter", s, e],
    ["exit", s, e],
    // Everything in between.
    ["enter", i, e],
    ["enter", o, e],
    ["exit", o, e],
    ["exit", i, e],
    // The ending (`]`, properly parsed and labelled).
    t[t.length - 2],
    t[t.length - 1],
    ["exit", r, e]
  ];
  return t.splice(n, t.length - n + 1, ...a), t;
}
function dTe(t, e, n) {
  const r = this, s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i = 0, o;
  return a;
  function a(h) {
    return t.enter("gfmFootnoteCall"), t.enter("gfmFootnoteCallLabelMarker"), t.consume(h), t.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(h) {
    return h !== 94 ? n(h) : (t.enter("gfmFootnoteCallMarker"), t.consume(h), t.exit("gfmFootnoteCallMarker"), t.enter("gfmFootnoteCallString"), t.enter("chunkString").contentType = "string", c);
  }
  function c(h) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Y0(h)
    )
      return n(h);
    if (h === 93) {
      t.exit("chunkString");
      const d = t.exit("gfmFootnoteCallString");
      return s.includes(Ok(r.sliceSerialize(d))) ? (t.enter("gfmFootnoteCallLabelMarker"), t.consume(h), t.exit("gfmFootnoteCallLabelMarker"), t.exit("gfmFootnoteCall"), e) : n(h);
    }
    return Y0(h) || (o = !0), i++, t.consume(h), h === 92 ? u : c;
  }
  function u(h) {
    return h === 91 || h === 92 || h === 93 ? (t.consume(h), i++, c) : c(h);
  }
}
function fTe(t, e, n) {
  const r = this, s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i, o = 0, a;
  return l;
  function l(g) {
    return t.enter("gfmFootnoteDefinition")._container = !0, t.enter("gfmFootnoteDefinitionLabel"), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(g), t.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(g) {
    return g === 94 ? (t.enter("gfmFootnoteDefinitionMarker"), t.consume(g), t.exit("gfmFootnoteDefinitionMarker"), t.enter("gfmFootnoteDefinitionLabelString"), t.enter("chunkString").contentType = "string", u) : n(g);
  }
  function u(g) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      g === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      g === null || g === 91 || Y0(g)
    )
      return n(g);
    if (g === 93) {
      t.exit("chunkString");
      const y = t.exit("gfmFootnoteDefinitionLabelString");
      return i = Ok(r.sliceSerialize(y)), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(g), t.exit("gfmFootnoteDefinitionLabelMarker"), t.exit("gfmFootnoteDefinitionLabel"), d;
    }
    return Y0(g) || (a = !0), o++, t.consume(g), g === 92 ? h : u;
  }
  function h(g) {
    return g === 91 || g === 92 || g === 93 ? (t.consume(g), o++, u) : u(g);
  }
  function d(g) {
    return g === 58 ? (t.enter("definitionMarker"), t.consume(g), t.exit("definitionMarker"), s.includes(i) || s.push(i), Pk(t, f, "gfmFootnoteDefinitionWhitespace")) : n(g);
  }
  function f(g) {
    return e(g);
  }
}
function pTe(t, e, n) {
  return t.check(oTe, e, t.attempt(lTe, e, n));
}
function mTe(t) {
  t.exit("gfmFootnoteDefinition");
}
function gTe(t, e, n) {
  const r = this;
  return Pk(t, s, "gfmFootnoteDefinitionIndent", 5);
  function s(i) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? e(i) : n(i);
  }
}
function Qv(t, e, n, r) {
  const s = t.length;
  let i = 0, o;
  if (e < 0 ? e = -e > s ? 0 : s + e : e = e > s ? s : e, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, n), t.splice(...o);
  else
    for (n && t.splice(e, n); i < r.length; )
      o = r.slice(i, i + 1e4), o.unshift(e, 0), t.splice(...o), i += 1e4, e += 1e4;
}
function yTe(t) {
  return t !== null && (t < 0 || t === 32);
}
const bTe = n7(/\p{P}|\p{S}/u), _Te = n7(/\s/);
function n7(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function tD(t) {
  if (t === null || yTe(t) || _Te(t))
    return 1;
  if (bTe(t))
    return 2;
}
function vTe(t, e, n) {
  const r = [];
  let s = -1;
  for (; ++s < t.length; ) {
    const i = t[s].resolveAll;
    i && !r.includes(i) && (e = i(e, n), r.push(i));
  }
  return e;
}
function wTe(t) {
  let n = (t || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: i,
    resolveAll: s
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function s(o, a) {
    let l = -1;
    for (; ++l < o.length; )
      if (o[l][0] === "enter" && o[l][1].type === "strikethroughSequenceTemporary" && o[l][1]._close) {
        let c = l;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[l][1].end.offset - o[l][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[l][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[l][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[l][1].start)
            }, d = [["enter", u, a], ["enter", o[c][1], a], ["exit", o[c][1], a], ["enter", h, a]], f = a.parser.constructs.insideSpan.null;
            f && Qv(d, d.length, 0, vTe(f, o.slice(c + 1, l), a)), Qv(d, d.length, 0, [["exit", h, a], ["enter", o[l][1], a], ["exit", o[l][1], a], ["exit", u, a]]), Qv(o, c - 1, l - c + 3, d), l = c + d.length - 2;
            break;
          }
      }
    for (l = -1; ++l < o.length; )
      o[l][1].type === "strikethroughSequenceTemporary" && (o[l][1].type = "data");
    return o;
  }
  function i(o, a, l) {
    const c = this.previous, u = this.events;
    let h = 0;
    return d;
    function d(g) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(g) : (o.enter("strikethroughSequenceTemporary"), f(g));
    }
    function f(g) {
      const y = tD(c);
      if (g === 126)
        return h > 1 ? l(g) : (o.consume(g), h++, f);
      if (h < 2 && !n) return l(g);
      const p = o.exit("strikethroughSequenceTemporary"), m = tD(g);
      return p._open = !m || m === 2 && !!y, p._close = !y || y === 2 && !!m, a(g);
    }
  }
}
function bm(t) {
  return t !== null && t < -2;
}
function nD(t) {
  return t !== null && (t < 0 || t === 32);
}
function Ma(t) {
  return t === -2 || t === -1 || t === 32;
}
function ih(t, e, n, r) {
  const s = r ? r - 1 : Number.POSITIVE_INFINITY;
  let i = 0;
  return o;
  function o(l) {
    return Ma(l) ? (t.enter(n), a(l)) : e(l);
  }
  function a(l) {
    return Ma(l) && i++ < s ? (t.consume(l), a) : (t.exit(n), e(l));
  }
}
class ETe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(e, n, r) {
    STe(this, e, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(e) {
    if (this.map.sort(function(i, o) {
      return i[0] - o[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(e.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), e.length = this.map[n][0];
    r.push(e.slice()), e.length = 0;
    let s = r.pop();
    for (; s; ) {
      for (const i of s)
        e.push(i);
      s = r.pop();
    }
    this.map.length = 0;
  }
}
function STe(t, e, n, r) {
  let s = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; s < t.map.length; ) {
      if (t.map[s][0] === e) {
        t.map[s][1] += n, t.map[s][2].push(...r);
        return;
      }
      s += 1;
    }
    t.map.push([e, n, r]);
  }
}
function xTe(t, e) {
  let n = !1;
  const r = [];
  for (; e < t.length; ) {
    const s = t[e];
    if (n) {
      if (s[0] === "enter")
        s[1].type === "tableContent" && r.push(t[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (s[1].type === "tableContent") {
        if (t[e - 1][1].type === "tableDelimiterMarker") {
          const i = r.length - 1;
          r[i] = r[i] === "left" ? "center" : "right";
        }
      } else if (s[1].type === "tableDelimiterRow")
        break;
    } else s[0] === "enter" && s[1].type === "tableDelimiterRow" && (n = !0);
    e += 1;
  }
  return r;
}
function TTe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: CTe,
        resolveAll: kTe
      }
    }
  };
}
function CTe(t, e, n) {
  const r = this;
  let s = 0, i = 0, o;
  return a;
  function a(R) {
    let F = r.events.length - 1;
    for (; F > -1; ) {
      const A = r.events[F][1].type;
      if (A === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      A === "linePrefix") F--;
      else break;
    }
    const P = F > -1 ? r.events[F][1].type : null, M = P === "tableHead" || P === "tableRow" ? E : l;
    return M === E && r.parser.lazy[r.now().line] ? n(R) : M(R);
  }
  function l(R) {
    return t.enter("tableHead"), t.enter("tableRow"), c(R);
  }
  function c(R) {
    return R === 124 || (o = !0, i += 1), u(R);
  }
  function u(R) {
    return R === null ? n(R) : bm(R) ? i > 1 ? (i = 0, r.interrupt = !0, t.exit("tableRow"), t.enter("lineEnding"), t.consume(R), t.exit("lineEnding"), f) : n(R) : Ma(R) ? ih(t, u, "whitespace")(R) : (i += 1, o && (o = !1, s += 1), R === 124 ? (t.enter("tableCellDivider"), t.consume(R), t.exit("tableCellDivider"), o = !0, u) : (t.enter("data"), h(R)));
  }
  function h(R) {
    return R === null || R === 124 || nD(R) ? (t.exit("data"), u(R)) : (t.consume(R), R === 92 ? d : h);
  }
  function d(R) {
    return R === 92 || R === 124 ? (t.consume(R), h) : h(R);
  }
  function f(R) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(R) : (t.enter("tableDelimiterRow"), o = !1, Ma(R) ? ih(t, g, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : g(R));
  }
  function g(R) {
    return R === 45 || R === 58 ? p(R) : R === 124 ? (o = !0, t.enter("tableCellDivider"), t.consume(R), t.exit("tableCellDivider"), y) : w(R);
  }
  function y(R) {
    return Ma(R) ? ih(t, p, "whitespace")(R) : p(R);
  }
  function p(R) {
    return R === 58 ? (i += 1, o = !0, t.enter("tableDelimiterMarker"), t.consume(R), t.exit("tableDelimiterMarker"), m) : R === 45 ? (i += 1, m(R)) : R === null || bm(R) ? v(R) : w(R);
  }
  function m(R) {
    return R === 45 ? (t.enter("tableDelimiterFiller"), b(R)) : w(R);
  }
  function b(R) {
    return R === 45 ? (t.consume(R), b) : R === 58 ? (o = !0, t.exit("tableDelimiterFiller"), t.enter("tableDelimiterMarker"), t.consume(R), t.exit("tableDelimiterMarker"), _) : (t.exit("tableDelimiterFiller"), _(R));
  }
  function _(R) {
    return Ma(R) ? ih(t, v, "whitespace")(R) : v(R);
  }
  function v(R) {
    return R === 124 ? g(R) : R === null || bm(R) ? !o || s !== i ? w(R) : (t.exit("tableDelimiterRow"), t.exit("tableHead"), e(R)) : w(R);
  }
  function w(R) {
    return n(R);
  }
  function E(R) {
    return t.enter("tableRow"), x(R);
  }
  function x(R) {
    return R === 124 ? (t.enter("tableCellDivider"), t.consume(R), t.exit("tableCellDivider"), x) : R === null || bm(R) ? (t.exit("tableRow"), e(R)) : Ma(R) ? ih(t, x, "whitespace")(R) : (t.enter("data"), S(R));
  }
  function S(R) {
    return R === null || R === 124 || nD(R) ? (t.exit("data"), x(R)) : (t.consume(R), R === 92 ? T : S);
  }
  function T(R) {
    return R === 92 || R === 124 ? (t.consume(R), S) : S(R);
  }
}
function kTe(t, e) {
  let n = -1, r = !0, s = 0, i = [0, 0, 0, 0], o = [0, 0, 0, 0], a = !1, l = 0, c, u, h;
  const d = new ETe();
  for (; ++n < t.length; ) {
    const f = t[n], g = f[1];
    f[0] === "enter" ? g.type === "tableHead" ? (a = !1, l !== 0 && (rD(d, e, l, c, u), u = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, g.start),
      // Note: correct end is set later.
      end: Object.assign({}, g.end)
    }, d.add(n, 0, [["enter", c, e]])) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (r = !0, h = void 0, i = [0, 0, 0, 0], o = [0, n + 1, 0, 0], a && (a = !1, u = {
      type: "tableBody",
      start: Object.assign({}, g.start),
      // Note: correct end is set later.
      end: Object.assign({}, g.end)
    }, d.add(n, 0, [["enter", u, e]])), s = g.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : s && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (i[1] !== 0 && (o[0] = o[1], h = _m(d, e, i, s, void 0, h), i = [0, 0, 0, 0]), o[2] = n)) : g.type === "tableCellDivider" && (r ? r = !1 : (i[1] !== 0 && (o[0] = o[1], h = _m(d, e, i, s, void 0, h)), i = o, o = [i[1], n, 0, 0])) : g.type === "tableHead" ? (a = !0, l = n) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (l = n, i[1] !== 0 ? (o[0] = o[1], h = _m(d, e, i, s, n, h)) : o[1] !== 0 && (h = _m(d, e, o, s, n, h)), s = 0) : s && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") && (o[3] = n);
  }
  for (l !== 0 && rD(d, e, l, c, u), d.consume(e.events), n = -1; ++n < e.events.length; ) {
    const f = e.events[n];
    f[0] === "enter" && f[1].type === "table" && (f[1]._align = xTe(e.events, n));
  }
  return t;
}
function _m(t, e, n, r, s, i) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", a = "tableContent";
  n[0] !== 0 && (i.end = Object.assign({}, oc(e.events, n[0])), t.add(n[0], 0, [["exit", i, e]]));
  const l = oc(e.events, n[1]);
  if (i = {
    type: o,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, t.add(n[1], 0, [["enter", i, e]]), n[2] !== 0) {
    const c = oc(e.events, n[2]), u = oc(e.events, n[3]), h = {
      type: a,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (t.add(n[2], 0, [["enter", h, e]]), r !== 2) {
      const d = e.events[n[2]], f = e.events[n[3]];
      if (d[1].end = Object.assign({}, f[1].end), d[1].type = "chunkText", d[1].contentType = "text", n[3] > n[2] + 1) {
        const g = n[2] + 1, y = n[3] - n[2] - 1;
        t.add(g, y, []);
      }
    }
    t.add(n[3] + 1, 0, [["exit", h, e]]);
  }
  return s !== void 0 && (i.end = Object.assign({}, oc(e.events, s)), t.add(s, 0, [["exit", i, e]]), i = void 0), i;
}
function rD(t, e, n, r, s) {
  const i = [], o = oc(e.events, n);
  s && (s.end = Object.assign({}, o), i.push(["exit", s, e])), r.end = Object.assign({}, o), i.push(["exit", r, e]), t.add(n + 1, 0, i);
}
function oc(t, e) {
  const n = t[e], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
function ATe(t) {
  return t !== null && t < -2;
}
function RTe(t) {
  return t !== null && (t < 0 || t === 32);
}
function NS(t) {
  return t === -2 || t === -1 || t === 32;
}
function ITe(t, e, n, r) {
  const s = Number.POSITIVE_INFINITY;
  let i = 0;
  return o;
  function o(l) {
    return NS(l) ? (t.enter(n), a(l)) : e(l);
  }
  function a(l) {
    return NS(l) && i++ < s ? (t.consume(l), a) : (t.exit(n), e(l));
  }
}
const PTe = {
  name: "tasklistCheck",
  tokenize: DTe
};
function OTe() {
  return {
    text: {
      91: PTe
    }
  };
}
function DTe(t, e, n) {
  const r = this;
  return s;
  function s(l) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (t.enter("taskListCheck"), t.enter("taskListCheckMarker"), t.consume(l), t.exit("taskListCheckMarker"), i)
    );
  }
  function i(l) {
    return RTe(l) ? (t.enter("taskListCheckValueUnchecked"), t.consume(l), t.exit("taskListCheckValueUnchecked"), o) : l === 88 || l === 120 ? (t.enter("taskListCheckValueChecked"), t.consume(l), t.exit("taskListCheckValueChecked"), o) : n(l);
  }
  function o(l) {
    return l === 93 ? (t.enter("taskListCheckMarker"), t.consume(l), t.exit("taskListCheckMarker"), t.exit("taskListCheck"), a) : n(l);
  }
  function a(l) {
    return ATe(l) ? e(l) : NS(l) ? t.check({
      tokenize: NTe
    }, e, n)(l) : n(l);
  }
}
function NTe(t, e, n) {
  return ITe(t, r, "whitespace");
  function r(s) {
    return s === null ? n(s) : e(s);
  }
}
function LTe(t) {
  return Gxe([
    Zxe(),
    cTe(),
    wTe(t),
    TTe(),
    OTe()
  ]);
}
const MTe = {};
function BTe(t) {
  const e = (
    /** @type {Processor} */
    this
  ), n = t || MTe, r = e.data(), s = r.micromarkExtensions || (r.micromarkExtensions = []), i = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  s.push(LTe(n)), i.push(jxe()), o.push(Hxe(n));
}
const FTe = r7("end"), $Te = r7("start");
function r7(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function UTe(t) {
  const e = $Te(t), n = FTe(t);
  if (e && n)
    return { start: e, end: n };
}
const Ca = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"], rd = {
  ancestors: {
    tbody: ["table"],
    td: ["table"],
    th: ["table"],
    thead: ["table"],
    tfoot: ["table"],
    tr: ["table"]
  },
  attributes: {
    a: [
      ...Ca,
      // Note: these 3 are used by GFM footnotes, they do work on all links.
      "dataFootnoteBackref",
      "dataFootnoteRef",
      ["className", "data-footnote-backref"],
      "href"
    ],
    blockquote: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `code` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    code: [["className", /^language-./]],
    del: ["cite"],
    div: ["itemScope", "itemType"],
    dl: [...Ca],
    // Note: this is used by GFM footnotes.
    h2: [["className", "sr-only"]],
    img: [...Ca, "longDesc", "src"],
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    input: [
      ["disabled", !0],
      ["type", "checkbox"]
    ],
    ins: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `li` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    li: [["className", "task-list-item"]],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ol: [...Ca, ["className", "contains-task-list"]],
    q: ["cite"],
    section: ["dataFootnotes", ["className", "footnotes"]],
    source: ["srcSet"],
    summary: [...Ca],
    table: [...Ca],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ul: [...Ca, ["className", "contains-task-list"]],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "colSpan",
      "color",
      "cols",
      "compact",
      "coords",
      "dateTime",
      "dir",
      // Note: `disabled` is technically allowed on all elements by GH.
      // But it is useless on everything except `input`.
      // Because `input`s are normally not allowed, but we allow them for
      // checkboxes due to tasklists, we allow `disabled` only there.
      "encType",
      "frame",
      "hSpace",
      "headers",
      "height",
      "hrefLang",
      "htmlFor",
      "id",
      "isMap",
      "itemProp",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rev",
      "rowSpan",
      "rows",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "title",
      "useMap",
      "vAlign",
      "value",
      "width"
    ]
  },
  clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
  clobberPrefix: "user-content-",
  protocols: {
    cite: ["http", "https"],
    href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
    longDesc: ["http", "https"],
    src: ["http", "https"]
  },
  required: {
    input: { disabled: !0, type: "checkbox" }
  },
  strip: ["script"],
  tagNames: [
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "del",
    "details",
    "div",
    "dl",
    "dt",
    "em",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    "input",
    "ins",
    "kbd",
    "li",
    "ol",
    "p",
    "picture",
    "pre",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "source",
    "span",
    "strike",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr",
    "tt",
    "ul",
    "var"
  ]
}, Do = {}.hasOwnProperty;
function jTe(t, e) {
  let n = { type: "root", children: [] };
  const r = {
    schema: e ? { ...rd, ...e } : rd,
    stack: []
  }, s = s7(r, t);
  return s && (Array.isArray(s) ? s.length === 1 ? n = s[0] : n.children = s : n = s), n;
}
function s7(t, e) {
  if (e && typeof e == "object") {
    const n = (
      /** @type {Record<string, Readonly<unknown>>} */
      e
    );
    switch (typeof n.type == "string" ? n.type : "") {
      case "comment":
        return HTe(t, n);
      case "doctype":
        return zTe(t, n);
      case "element":
        return GTe(t, n);
      case "root":
        return VTe(t, n);
      case "text":
        return WTe(t, n);
    }
  }
}
function HTe(t, e) {
  if (t.schema.allowComments) {
    const n = typeof e.value == "string" ? e.value : "", r = n.indexOf("-->"), i = { type: "comment", value: r < 0 ? n : n.slice(0, r) };
    return up(i, e), i;
  }
}
function zTe(t, e) {
  if (t.schema.allowDoctypes) {
    const n = { type: "doctype" };
    return up(n, e), n;
  }
}
function GTe(t, e) {
  const n = typeof e.tagName == "string" ? e.tagName : "";
  t.stack.push(n);
  const r = (
    /** @type {Array<ElementContent>} */
    i7(t, e.children)
  ), s = qTe(t, e.properties);
  t.stack.pop();
  let i = !1;
  if (n && n !== "*" && (!t.schema.tagNames || t.schema.tagNames.includes(n)) && (i = !0, t.schema.ancestors && Do.call(t.schema.ancestors, n))) {
    const a = t.schema.ancestors[n];
    let l = -1;
    for (i = !1; ++l < a.length; )
      t.stack.includes(a[l]) && (i = !0);
  }
  if (!i)
    return t.schema.strip && !t.schema.strip.includes(n) ? r : void 0;
  const o = {
    type: "element",
    tagName: n,
    properties: s,
    children: r
  };
  return up(o, e), o;
}
function VTe(t, e) {
  const r = { type: "root", children: (
    /** @type {Array<RootContent>} */
    i7(t, e.children)
  ) };
  return up(r, e), r;
}
function WTe(t, e) {
  const r = { type: "text", value: typeof e.value == "string" ? e.value : "" };
  return up(r, e), r;
}
function i7(t, e) {
  const n = [];
  if (Array.isArray(e)) {
    const r = (
      /** @type {Array<Readonly<unknown>>} */
      e
    );
    let s = -1;
    for (; ++s < r.length; ) {
      const i = s7(t, r[s]);
      i && (Array.isArray(i) ? n.push(...i) : n.push(i));
    }
  }
  return n;
}
function qTe(t, e) {
  const n = t.stack[t.stack.length - 1], r = t.schema.attributes, s = t.schema.required, i = r && Do.call(r, n) ? r[n] : void 0, o = r && Do.call(r, "*") ? r["*"] : void 0, a = (
    /** @type {Readonly<Record<string, Readonly<unknown>>>} */
    e && typeof e == "object" ? e : {}
  ), l = {};
  let c;
  for (c in a)
    if (Do.call(a, c)) {
      const u = a[c];
      let h = sD(
        t,
        iD(i, c),
        c,
        u
      );
      h == null && (h = sD(t, iD(o, c), c, u)), h != null && (l[c] = h);
    }
  if (s && Do.call(s, n)) {
    const u = s[n];
    for (c in u)
      Do.call(u, c) && !Do.call(l, c) && (l[c] = u[c]);
  }
  return l;
}
function sD(t, e, n, r) {
  return e ? Array.isArray(r) ? KTe(t, e, n, r) : o7(t, e, n, r) : void 0;
}
function KTe(t, e, n, r) {
  let s = -1;
  const i = [];
  for (; ++s < r.length; ) {
    const o = o7(t, e, n, r[s]);
    (typeof o == "number" || typeof o == "string") && i.push(o);
  }
  return i;
}
function o7(t, e, n, r) {
  if (!(typeof r != "boolean" && typeof r != "number" && typeof r != "string") && YTe(t, n, r)) {
    if (typeof e == "object" && e.length > 1) {
      let s = !1, i = 0;
      for (; ++i < e.length; ) {
        const o = e[i];
        if (o && typeof o == "object" && "flags" in o) {
          if (o.test(String(r))) {
            s = !0;
            break;
          }
        } else if (o === r) {
          s = !0;
          break;
        }
      }
      if (!s) return;
    }
    return t.schema.clobber && t.schema.clobberPrefix && t.schema.clobber.includes(n) ? t.schema.clobberPrefix + r : r;
  }
}
function YTe(t, e, n) {
  const r = t.schema.protocols && Do.call(t.schema.protocols, e) ? t.schema.protocols[e] : void 0;
  if (!r || r.length === 0)
    return !0;
  const s = String(n), i = s.indexOf(":"), o = s.indexOf("?"), a = s.indexOf("#"), l = s.indexOf("/");
  if (i < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
  l > -1 && i > l || o > -1 && i > o || a > -1 && i > a)
    return !0;
  let c = -1;
  for (; ++c < r.length; ) {
    const u = r[c];
    if (i === u.length && s.slice(0, u.length) === u)
      return !0;
  }
  return !1;
}
function up(t, e) {
  const n = UTe(
    // @ts-expect-error: looks like a node.
    e
  );
  e.data && (t.data = bl(e.data)), n && (t.position = n);
}
function iD(t, e) {
  let n, r = -1;
  if (t)
    for (; ++r < t.length; ) {
      const s = t[r], i = typeof s == "string" ? s : s[0];
      if (i === e)
        return s;
      i === "data*" && (n = s);
    }
  if (e.length > 4 && e.slice(0, 4).toLowerCase() === "data")
    return n;
}
function ZTe(t) {
  return function(e) {
    return (
      /** @type {Root} */
      jTe(e, t)
    );
  };
}
const a7 = [
  "a",
  "b",
  "blockquote",
  "br",
  "code",
  "dd",
  "del",
  "details",
  "div",
  "dl",
  "dt",
  "em",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "i",
  "ins",
  "kbd",
  "li",
  "ol",
  "p",
  "pre",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "source",
  "span",
  "strike",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "tr",
  "ul",
  "var",
  "think"
];
function JTe() {
  return (t) => {
    Fl(t, (e) => {
      if (e.type === "html" && e.value && e.value.startsWith("<think>")) {
        const n = e.value.slice(7);
        e.value = `<div class="__boltThought__">${n}`;
        return;
      }
      if (e.type === "html" && e.value && e.value.startsWith("</think>")) {
        const n = e.value.slice(8);
        e.value = `</div>${n}`;
      }
    });
  };
}
const XTe = {
  ...rd,
  tagNames: a7,
  attributes: {
    ...rd.attributes,
    div: [
      ...rd.attributes?.div ?? [],
      "data*",
      ["className", "__boltArtifact__", "__boltThought__"]
      // ['className', '__boltThought__']
    ]
  },
  strip: []
};
function QTe(t) {
  const e = [BTe];
  return t && e.unshift(tCe), e.unshift(JTe), e;
}
function eCe(t) {
  const e = [];
  return t && e.push(aEe, [ZTe, XTe]), e;
}
const tCe = () => (t, e) => {
  const n = e.toString();
  Fl(t, (r, s, i) => {
    if (s == null || ["paragraph", "text", "inlineCode", "code", "strong", "emphasis"].includes(r.type) || !r.position)
      return !0;
    let o = n.slice(r.position.start.offset, r.position.end.offset);
    return r.type === "heading" && (o = `
${o}`), i.children[s] = {
      type: "text",
      value: o
    }, [o9, s];
  });
};
wZ`
  Continue your prior response. IMPORTANT: Immediately begin from where you left off without any interruptions.
  Do not repeat any content, including artifact and action tags.
`;
I.memo(({ onClick: t }) => /* @__PURE__ */ k.jsx(
  Vt,
  {
    onClick: t,
    icon: "i-ph:gear",
    size: "xl",
    title: "Settings",
    className: "text-[#666] hover:text-bolt-elements-textPrimary hover:bg-bolt-elements-item-backgroundActive/10 transition-colors"
  }
));
const nCe = ["top", "right", "bottom", "left"], oa = Math.min, Ar = Math.max, Z0 = Math.round, vm = Math.floor, wi = (t) => ({
  x: t,
  y: t
}), rCe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, sCe = {
  start: "end",
  end: "start"
};
function LS(t, e, n) {
  return Ar(t, oa(e, n));
}
function uo(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function ho(t) {
  return t.split("-")[0];
}
function Lu(t) {
  return t.split("-")[1];
}
function Dk(t) {
  return t === "x" ? "y" : "x";
}
function Nk(t) {
  return t === "y" ? "height" : "width";
}
function aa(t) {
  return ["top", "bottom"].includes(ho(t)) ? "y" : "x";
}
function Lk(t) {
  return Dk(aa(t));
}
function iCe(t, e, n) {
  n === void 0 && (n = !1);
  const r = Lu(t), s = Lk(t), i = Nk(s);
  let o = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (o = J0(o)), [o, J0(o)];
}
function oCe(t) {
  const e = J0(t);
  return [MS(t), e, MS(e)];
}
function MS(t) {
  return t.replace(/start|end/g, (e) => sCe[e]);
}
function aCe(t, e, n) {
  const r = ["left", "right"], s = ["right", "left"], i = ["top", "bottom"], o = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? s : r : e ? r : s;
    case "left":
    case "right":
      return e ? i : o;
    default:
      return [];
  }
}
function lCe(t, e, n, r) {
  const s = Lu(t);
  let i = aCe(ho(t), n === "start", r);
  return s && (i = i.map((o) => o + "-" + s), e && (i = i.concat(i.map(MS)))), i;
}
function J0(t) {
  return t.replace(/left|right|bottom|top/g, (e) => rCe[e]);
}
function cCe(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function l7(t) {
  return typeof t != "number" ? cCe(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function X0(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: s
  } = t;
  return {
    width: r,
    height: s,
    top: n,
    left: e,
    right: e + r,
    bottom: n + s,
    x: e,
    y: n
  };
}
function oD(t, e, n) {
  let {
    reference: r,
    floating: s
  } = t;
  const i = aa(e), o = Lk(e), a = Nk(o), l = ho(e), c = i === "y", u = r.x + r.width / 2 - s.width / 2, h = r.y + r.height / 2 - s.height / 2, d = r[a] / 2 - s[a] / 2;
  let f;
  switch (l) {
    case "top":
      f = {
        x: u,
        y: r.y - s.height
      };
      break;
    case "bottom":
      f = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      f = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      f = {
        x: r.x - s.width,
        y: h
      };
      break;
    default:
      f = {
        x: r.x,
        y: r.y
      };
  }
  switch (Lu(e)) {
    case "start":
      f[o] -= d * (n && c ? -1 : 1);
      break;
    case "end":
      f[o] += d * (n && c ? -1 : 1);
      break;
  }
  return f;
}
const uCe = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: s = "absolute",
    middleware: i = [],
    platform: o
  } = n, a = i.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: t,
    floating: e,
    strategy: s
  }), {
    x: u,
    y: h
  } = oD(c, r, l), d = r, f = {}, g = 0;
  for (let y = 0; y < a.length; y++) {
    const {
      name: p,
      fn: m
    } = a[y], {
      x: b,
      y: _,
      data: v,
      reset: w
    } = await m({
      x: u,
      y: h,
      initialPlacement: r,
      placement: d,
      strategy: s,
      middlewareData: f,
      rects: c,
      platform: o,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = b ?? u, h = _ ?? h, f = {
      ...f,
      [p]: {
        ...f[p],
        ...v
      }
    }, w && g <= 50 && (g++, typeof w == "object" && (w.placement && (d = w.placement), w.rects && (c = w.rects === !0 ? await o.getElementRects({
      reference: t,
      floating: e,
      strategy: s
    }) : w.rects), {
      x: u,
      y: h
    } = oD(c, d, l)), y = -1);
  }
  return {
    x: u,
    y: h,
    placement: d,
    strategy: s,
    middlewareData: f
  };
};
async function Qd(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: s,
    platform: i,
    rects: o,
    elements: a,
    strategy: l
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: d = !1,
    padding: f = 0
  } = uo(e, t), g = l7(f), p = a[d ? h === "floating" ? "reference" : "floating" : h], m = X0(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(p))) == null || n ? p : p.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), b = h === "floating" ? {
    x: r,
    y: s,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, _ = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), v = await (i.isElement == null ? void 0 : i.isElement(_)) ? await (i.getScale == null ? void 0 : i.getScale(_)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = X0(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: b,
    offsetParent: _,
    strategy: l
  }) : b);
  return {
    top: (m.top - w.top + g.top) / v.y,
    bottom: (w.bottom - m.bottom + g.bottom) / v.y,
    left: (m.left - w.left + g.left) / v.x,
    right: (w.right - m.right + g.right) / v.x
  };
}
const hCe = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: s,
      rects: i,
      platform: o,
      elements: a,
      middlewareData: l
    } = e, {
      element: c,
      padding: u = 0
    } = uo(t, e) || {};
    if (c == null)
      return {};
    const h = l7(u), d = {
      x: n,
      y: r
    }, f = Lk(s), g = Nk(f), y = await o.getDimensions(c), p = f === "y", m = p ? "top" : "left", b = p ? "bottom" : "right", _ = p ? "clientHeight" : "clientWidth", v = i.reference[g] + i.reference[f] - d[f] - i.floating[g], w = d[f] - i.reference[f], E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
    let x = E ? E[_] : 0;
    (!x || !await (o.isElement == null ? void 0 : o.isElement(E))) && (x = a.floating[_] || i.floating[g]);
    const S = v / 2 - w / 2, T = x / 2 - y[g] / 2 - 1, R = oa(h[m], T), F = oa(h[b], T), P = R, M = x - y[g] - F, A = x / 2 - y[g] / 2 + S, V = LS(P, A, M), ee = !l.arrow && Lu(s) != null && A !== V && i.reference[g] / 2 - (A < P ? R : F) - y[g] / 2 < 0, K = ee ? A < P ? A - P : A - M : 0;
    return {
      [f]: d[f] + K,
      data: {
        [f]: V,
        centerOffset: A - V - K,
        ...ee && {
          alignmentOffset: K
        }
      },
      reset: ee
    };
  }
}), dCe = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: s,
        middlewareData: i,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: h = !0,
        fallbackPlacements: d,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: y = !0,
        ...p
      } = uo(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const m = ho(s), b = aa(a), _ = ho(a) === a, v = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), w = d || (_ || !y ? [J0(a)] : oCe(a)), E = g !== "none";
      !d && E && w.push(...lCe(a, y, g, v));
      const x = [a, ...w], S = await Qd(e, p), T = [];
      let R = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (u && T.push(S[m]), h) {
        const A = iCe(s, o, v);
        T.push(S[A[0]], S[A[1]]);
      }
      if (R = [...R, {
        placement: s,
        overflows: T
      }], !T.every((A) => A <= 0)) {
        var F, P;
        const A = (((F = i.flip) == null ? void 0 : F.index) || 0) + 1, V = x[A];
        if (V)
          return {
            data: {
              index: A,
              overflows: R
            },
            reset: {
              placement: V
            }
          };
        let ee = (P = R.filter((K) => K.overflows[0] <= 0).sort((K, te) => K.overflows[1] - te.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!ee)
          switch (f) {
            case "bestFit": {
              var M;
              const K = (M = R.filter((te) => {
                if (E) {
                  const N = aa(te.placement);
                  return N === b || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  N === "y";
                }
                return !0;
              }).map((te) => [te.placement, te.overflows.filter((N) => N > 0).reduce((N, L) => N + L, 0)]).sort((te, N) => te[1] - N[1])[0]) == null ? void 0 : M[0];
              K && (ee = K);
              break;
            }
            case "initialPlacement":
              ee = a;
              break;
          }
        if (s !== ee)
          return {
            reset: {
              placement: ee
            }
          };
      }
      return {};
    }
  };
};
function aD(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function lD(t) {
  return nCe.some((e) => t[e] >= 0);
}
const fCe = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: r = "referenceHidden",
        ...s
      } = uo(t, e);
      switch (r) {
        case "referenceHidden": {
          const i = await Qd(e, {
            ...s,
            elementContext: "reference"
          }), o = aD(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: lD(o)
            }
          };
        }
        case "escaped": {
          const i = await Qd(e, {
            ...s,
            altBoundary: !0
          }), o = aD(i, n.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: lD(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function pCe(t, e) {
  const {
    placement: n,
    platform: r,
    elements: s
  } = t, i = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), o = ho(n), a = Lu(n), l = aa(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = i && l ? -1 : 1, h = uo(e, t);
  let {
    mainAxis: d,
    crossAxis: f,
    alignmentAxis: g
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof g == "number" && (f = a === "end" ? g * -1 : g), l ? {
    x: f * u,
    y: d * c
  } : {
    x: d * c,
    y: f * u
  };
}
const mCe = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: s,
        y: i,
        placement: o,
        middlewareData: a
      } = e, l = await pCe(e, t);
      return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: s + l.x,
        y: i + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, gCe = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: s
      } = e, {
        mainAxis: i = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (p) => {
            let {
              x: m,
              y: b
            } = p;
            return {
              x: m,
              y: b
            };
          }
        },
        ...l
      } = uo(t, e), c = {
        x: n,
        y: r
      }, u = await Qd(e, l), h = aa(ho(s)), d = Dk(h);
      let f = c[d], g = c[h];
      if (i) {
        const p = d === "y" ? "top" : "left", m = d === "y" ? "bottom" : "right", b = f + u[p], _ = f - u[m];
        f = LS(b, f, _);
      }
      if (o) {
        const p = h === "y" ? "top" : "left", m = h === "y" ? "bottom" : "right", b = g + u[p], _ = g - u[m];
        g = LS(b, g, _);
      }
      const y = a.fn({
        ...e,
        [d]: f,
        [h]: g
      });
      return {
        ...y,
        data: {
          x: y.x - n,
          y: y.y - r,
          enabled: {
            [d]: i,
            [h]: o
          }
        }
      };
    }
  };
}, yCe = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: s,
        rects: i,
        middlewareData: o
      } = e, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = uo(t, e), u = {
        x: n,
        y: r
      }, h = aa(s), d = Dk(h);
      let f = u[d], g = u[h];
      const y = uo(a, e), p = typeof y == "number" ? {
        mainAxis: y,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...y
      };
      if (l) {
        const _ = d === "y" ? "height" : "width", v = i.reference[d] - i.floating[_] + p.mainAxis, w = i.reference[d] + i.reference[_] - p.mainAxis;
        f < v ? f = v : f > w && (f = w);
      }
      if (c) {
        var m, b;
        const _ = d === "y" ? "width" : "height", v = ["top", "left"].includes(ho(s)), w = i.reference[h] - i.floating[_] + (v && ((m = o.offset) == null ? void 0 : m[h]) || 0) + (v ? 0 : p.crossAxis), E = i.reference[h] + i.reference[_] + (v ? 0 : ((b = o.offset) == null ? void 0 : b[h]) || 0) - (v ? p.crossAxis : 0);
        g < w ? g = w : g > E && (g = E);
      }
      return {
        [d]: f,
        [h]: g
      };
    }
  };
}, bCe = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: s,
        rects: i,
        platform: o,
        elements: a
      } = e, {
        apply: l = () => {
        },
        ...c
      } = uo(t, e), u = await Qd(e, c), h = ho(s), d = Lu(s), f = aa(s) === "y", {
        width: g,
        height: y
      } = i.floating;
      let p, m;
      h === "top" || h === "bottom" ? (p = h, m = d === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (m = h, p = d === "end" ? "top" : "bottom");
      const b = y - u.top - u.bottom, _ = g - u.left - u.right, v = oa(y - u[p], b), w = oa(g - u[m], _), E = !e.middlewareData.shift;
      let x = v, S = w;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (S = _), (r = e.middlewareData.shift) != null && r.enabled.y && (x = b), E && !d) {
        const R = Ar(u.left, 0), F = Ar(u.right, 0), P = Ar(u.top, 0), M = Ar(u.bottom, 0);
        f ? S = g - 2 * (R !== 0 || F !== 0 ? R + F : Ar(u.left, u.right)) : x = y - 2 * (P !== 0 || M !== 0 ? P + M : Ar(u.top, u.bottom));
      }
      await l({
        ...e,
        availableWidth: S,
        availableHeight: x
      });
      const T = await o.getDimensions(a.floating);
      return g !== T.width || y !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function jb() {
  return typeof window < "u";
}
function Mu(t) {
  return c7(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Lr(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Ni(t) {
  var e;
  return (e = (c7(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function c7(t) {
  return jb() ? t instanceof Node || t instanceof Lr(t).Node : !1;
}
function Cs(t) {
  return jb() ? t instanceof Element || t instanceof Lr(t).Element : !1;
}
function Ci(t) {
  return jb() ? t instanceof HTMLElement || t instanceof Lr(t).HTMLElement : !1;
}
function cD(t) {
  return !jb() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Lr(t).ShadowRoot;
}
function hp(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: s
  } = ks(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(s);
}
function _Ce(t) {
  return ["table", "td", "th"].includes(Mu(t));
}
function Hb(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function Mk(t) {
  const e = Bk(), n = Cs(t) ? ks(t) : t;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function vCe(t) {
  let e = la(t);
  for (; Ci(e) && !lu(e); ) {
    if (Mk(e))
      return e;
    if (Hb(e))
      return null;
    e = la(e);
  }
  return null;
}
function Bk() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function lu(t) {
  return ["html", "body", "#document"].includes(Mu(t));
}
function ks(t) {
  return Lr(t).getComputedStyle(t);
}
function zb(t) {
  return Cs(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function la(t) {
  if (Mu(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    cD(t) && t.host || // Fallback.
    Ni(t)
  );
  return cD(e) ? e.host : e;
}
function u7(t) {
  const e = la(t);
  return lu(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Ci(e) && hp(e) ? e : u7(e);
}
function ef(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const s = u7(t), i = s === ((r = t.ownerDocument) == null ? void 0 : r.body), o = Lr(s);
  if (i) {
    const a = BS(o);
    return e.concat(o, o.visualViewport || [], hp(s) ? s : [], a && n ? ef(a) : []);
  }
  return e.concat(s, ef(s, [], n));
}
function BS(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function h7(t) {
  const e = ks(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const s = Ci(t), i = s ? t.offsetWidth : n, o = s ? t.offsetHeight : r, a = Z0(n) !== i || Z0(r) !== o;
  return a && (n = i, r = o), {
    width: n,
    height: r,
    $: a
  };
}
function Fk(t) {
  return Cs(t) ? t : t.contextElement;
}
function Nc(t) {
  const e = Fk(t);
  if (!Ci(e))
    return wi(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: s,
    $: i
  } = h7(e);
  let o = (i ? Z0(n.width) : n.width) / r, a = (i ? Z0(n.height) : n.height) / s;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const wCe = /* @__PURE__ */ wi(0);
function d7(t) {
  const e = Lr(t);
  return !Bk() || !e.visualViewport ? wCe : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function ECe(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Lr(t) ? !1 : e;
}
function _l(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const s = t.getBoundingClientRect(), i = Fk(t);
  let o = wi(1);
  e && (r ? Cs(r) && (o = Nc(r)) : o = Nc(t));
  const a = ECe(i, n, r) ? d7(i) : wi(0);
  let l = (s.left + a.x) / o.x, c = (s.top + a.y) / o.y, u = s.width / o.x, h = s.height / o.y;
  if (i) {
    const d = Lr(i), f = r && Cs(r) ? Lr(r) : r;
    let g = d, y = BS(g);
    for (; y && r && f !== g; ) {
      const p = Nc(y), m = y.getBoundingClientRect(), b = ks(y), _ = m.left + (y.clientLeft + parseFloat(b.paddingLeft)) * p.x, v = m.top + (y.clientTop + parseFloat(b.paddingTop)) * p.y;
      l *= p.x, c *= p.y, u *= p.x, h *= p.y, l += _, c += v, g = Lr(y), y = BS(g);
    }
  }
  return X0({
    width: u,
    height: h,
    x: l,
    y: c
  });
}
function $k(t, e) {
  const n = zb(t).scrollLeft;
  return e ? e.left + n : _l(Ni(t)).left + n;
}
function f7(t, e, n) {
  n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), s = r.left + e.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    $k(t, r)
  )), i = r.top + e.scrollTop;
  return {
    x: s,
    y: i
  };
}
function SCe(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: s
  } = t;
  const i = s === "fixed", o = Ni(r), a = e ? Hb(e.floating) : !1;
  if (r === o || a && i)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = wi(1);
  const u = wi(0), h = Ci(r);
  if ((h || !h && !i) && ((Mu(r) !== "body" || hp(o)) && (l = zb(r)), Ci(r))) {
    const f = _l(r);
    c = Nc(r), u.x = f.x + r.clientLeft, u.y = f.y + r.clientTop;
  }
  const d = o && !h && !i ? f7(o, l, !0) : wi(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + d.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + d.y
  };
}
function xCe(t) {
  return Array.from(t.getClientRects());
}
function TCe(t) {
  const e = Ni(t), n = zb(t), r = t.ownerDocument.body, s = Ar(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), i = Ar(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + $k(t);
  const a = -n.scrollTop;
  return ks(r).direction === "rtl" && (o += Ar(e.clientWidth, r.clientWidth) - s), {
    width: s,
    height: i,
    x: o,
    y: a
  };
}
function CCe(t, e) {
  const n = Lr(t), r = Ni(t), s = n.visualViewport;
  let i = r.clientWidth, o = r.clientHeight, a = 0, l = 0;
  if (s) {
    i = s.width, o = s.height;
    const c = Bk();
    (!c || c && e === "fixed") && (a = s.offsetLeft, l = s.offsetTop);
  }
  return {
    width: i,
    height: o,
    x: a,
    y: l
  };
}
function kCe(t, e) {
  const n = _l(t, !0, e === "fixed"), r = n.top + t.clientTop, s = n.left + t.clientLeft, i = Ci(t) ? Nc(t) : wi(1), o = t.clientWidth * i.x, a = t.clientHeight * i.y, l = s * i.x, c = r * i.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function uD(t, e, n) {
  let r;
  if (e === "viewport")
    r = CCe(t, n);
  else if (e === "document")
    r = TCe(Ni(t));
  else if (Cs(e))
    r = kCe(e, n);
  else {
    const s = d7(t);
    r = {
      x: e.x - s.x,
      y: e.y - s.y,
      width: e.width,
      height: e.height
    };
  }
  return X0(r);
}
function p7(t, e) {
  const n = la(t);
  return n === e || !Cs(n) || lu(n) ? !1 : ks(n).position === "fixed" || p7(n, e);
}
function ACe(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = ef(t, [], !1).filter((a) => Cs(a) && Mu(a) !== "body"), s = null;
  const i = ks(t).position === "fixed";
  let o = i ? la(t) : t;
  for (; Cs(o) && !lu(o); ) {
    const a = ks(o), l = Mk(o);
    !l && a.position === "fixed" && (s = null), (i ? !l && !s : !l && a.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || hp(o) && !l && p7(t, o)) ? r = r.filter((u) => u !== o) : s = a, o = la(o);
  }
  return e.set(t, r), r;
}
function RCe(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: s
  } = t;
  const o = [...n === "clippingAncestors" ? Hb(e) ? [] : ACe(e, this._c) : [].concat(n), r], a = o[0], l = o.reduce((c, u) => {
    const h = uD(e, u, s);
    return c.top = Ar(h.top, c.top), c.right = oa(h.right, c.right), c.bottom = oa(h.bottom, c.bottom), c.left = Ar(h.left, c.left), c;
  }, uD(e, a, s));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function ICe(t) {
  const {
    width: e,
    height: n
  } = h7(t);
  return {
    width: e,
    height: n
  };
}
function PCe(t, e, n) {
  const r = Ci(e), s = Ni(e), i = n === "fixed", o = _l(t, !0, i, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = wi(0);
  if (r || !r && !i)
    if ((Mu(e) !== "body" || hp(s)) && (a = zb(e)), r) {
      const d = _l(e, !0, i, e);
      l.x = d.x + e.clientLeft, l.y = d.y + e.clientTop;
    } else s && (l.x = $k(s));
  const c = s && !r && !i ? f7(s, a) : wi(0), u = o.left + a.scrollLeft - l.x - c.x, h = o.top + a.scrollTop - l.y - c.y;
  return {
    x: u,
    y: h,
    width: o.width,
    height: o.height
  };
}
function ew(t) {
  return ks(t).position === "static";
}
function hD(t, e) {
  if (!Ci(t) || ks(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return Ni(t) === n && (n = n.ownerDocument.body), n;
}
function m7(t, e) {
  const n = Lr(t);
  if (Hb(t))
    return n;
  if (!Ci(t)) {
    let s = la(t);
    for (; s && !lu(s); ) {
      if (Cs(s) && !ew(s))
        return s;
      s = la(s);
    }
    return n;
  }
  let r = hD(t, e);
  for (; r && _Ce(r) && ew(r); )
    r = hD(r, e);
  return r && lu(r) && ew(r) && !Mk(r) ? n : r || vCe(t) || n;
}
const OCe = async function(t) {
  const e = this.getOffsetParent || m7, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: PCe(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function DCe(t) {
  return ks(t).direction === "rtl";
}
const NCe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: SCe,
  getDocumentElement: Ni,
  getClippingRect: RCe,
  getOffsetParent: m7,
  getElementRects: OCe,
  getClientRects: xCe,
  getDimensions: ICe,
  getScale: Nc,
  isElement: Cs,
  isRTL: DCe
};
function g7(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function LCe(t, e) {
  let n = null, r;
  const s = Ni(t);
  function i() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function o(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), i();
    const c = t.getBoundingClientRect(), {
      left: u,
      top: h,
      width: d,
      height: f
    } = c;
    if (a || e(), !d || !f)
      return;
    const g = vm(h), y = vm(s.clientWidth - (u + d)), p = vm(s.clientHeight - (h + f)), m = vm(u), _ = {
      rootMargin: -g + "px " + -y + "px " + -p + "px " + -m + "px",
      threshold: Ar(0, oa(1, l)) || 1
    };
    let v = !0;
    function w(E) {
      const x = E[0].intersectionRatio;
      if (x !== l) {
        if (!v)
          return o();
        x ? o(!1, x) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      x === 1 && !g7(c, t.getBoundingClientRect()) && o(), v = !1;
    }
    try {
      n = new IntersectionObserver(w, {
        ..._,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(w, _);
    }
    n.observe(t);
  }
  return o(!0), i;
}
function MCe(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: i = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Fk(t), u = s || i ? [...c ? ef(c) : [], ...ef(e)] : [];
  u.forEach((m) => {
    s && m.addEventListener("scroll", n, {
      passive: !0
    }), i && m.addEventListener("resize", n);
  });
  const h = c && a ? LCe(c, n) : null;
  let d = -1, f = null;
  o && (f = new ResizeObserver((m) => {
    let [b] = m;
    b && b.target === c && f && (f.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var _;
      (_ = f) == null || _.observe(e);
    })), n();
  }), c && !l && f.observe(c), f.observe(e));
  let g, y = l ? _l(t) : null;
  l && p();
  function p() {
    const m = _l(t);
    y && !g7(y, m) && n(), y = m, g = requestAnimationFrame(p);
  }
  return n(), () => {
    var m;
    u.forEach((b) => {
      s && b.removeEventListener("scroll", n), i && b.removeEventListener("resize", n);
    }), h?.(), (m = f) == null || m.disconnect(), f = null, l && cancelAnimationFrame(g);
  };
}
const BCe = mCe, FCe = gCe, $Ce = dCe, UCe = bCe, jCe = fCe, dD = hCe, HCe = yCe, zCe = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), s = {
    platform: NCe,
    ...n
  }, i = {
    ...s.platform,
    _c: r
  };
  return uCe(t, e, {
    ...s,
    platform: i
  });
};
var Sg = typeof document < "u" ? I.useLayoutEffect : I.useEffect;
function Q0(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, s;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Q0(t[r], e[r]))
          return !1;
      return !0;
    }
    if (s = Object.keys(t), n = s.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, s[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = s[r];
      if (!(i === "_owner" && t.$$typeof) && !Q0(t[i], e[i]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function y7(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function fD(t, e) {
  const n = y7(t);
  return Math.round(e * n) / n;
}
function tw(t) {
  const e = I.useRef(t);
  return Sg(() => {
    e.current = t;
  }), e;
}
function GCe(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: s,
    elements: {
      reference: i,
      floating: o
    } = {},
    transform: a = !0,
    whileElementsMounted: l,
    open: c
  } = t, [u, h] = I.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [d, f] = I.useState(r);
  Q0(d, r) || f(r);
  const [g, y] = I.useState(null), [p, m] = I.useState(null), b = I.useCallback((te) => {
    te !== E.current && (E.current = te, y(te));
  }, []), _ = I.useCallback((te) => {
    te !== x.current && (x.current = te, m(te));
  }, []), v = i || g, w = o || p, E = I.useRef(null), x = I.useRef(null), S = I.useRef(u), T = l != null, R = tw(l), F = tw(s), P = tw(c), M = I.useCallback(() => {
    if (!E.current || !x.current)
      return;
    const te = {
      placement: e,
      strategy: n,
      middleware: d
    };
    F.current && (te.platform = F.current), zCe(E.current, x.current, te).then((N) => {
      const L = {
        ...N,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: P.current !== !1
      };
      A.current && !Q0(S.current, L) && (S.current = L, _B.flushSync(() => {
        h(L);
      }));
    });
  }, [d, e, n, F, P]);
  Sg(() => {
    c === !1 && S.current.isPositioned && (S.current.isPositioned = !1, h((te) => ({
      ...te,
      isPositioned: !1
    })));
  }, [c]);
  const A = I.useRef(!1);
  Sg(() => (A.current = !0, () => {
    A.current = !1;
  }), []), Sg(() => {
    if (v && (E.current = v), w && (x.current = w), v && w) {
      if (R.current)
        return R.current(v, w, M);
      M();
    }
  }, [v, w, M, R, T]);
  const V = I.useMemo(() => ({
    reference: E,
    floating: x,
    setReference: b,
    setFloating: _
  }), [b, _]), ee = I.useMemo(() => ({
    reference: v,
    floating: w
  }), [v, w]), K = I.useMemo(() => {
    const te = {
      position: n,
      left: 0,
      top: 0
    };
    if (!ee.floating)
      return te;
    const N = fD(ee.floating, u.x), L = fD(ee.floating, u.y);
    return a ? {
      ...te,
      transform: "translate(" + N + "px, " + L + "px)",
      ...y7(ee.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: N,
      top: L
    };
  }, [n, a, ee.floating, u.x, u.y]);
  return I.useMemo(() => ({
    ...u,
    update: M,
    refs: V,
    elements: ee,
    floatingStyles: K
  }), [u, M, V, ee, K]);
}
const VCe = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: s
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? dD({
        element: r.current,
        padding: s
      }).fn(n) : {} : r ? dD({
        element: r,
        padding: s
      }).fn(n) : {};
    }
  };
}, WCe = (t, e) => ({
  ...BCe(t),
  options: [t, e]
}), qCe = (t, e) => ({
  ...FCe(t),
  options: [t, e]
}), KCe = (t, e) => ({
  ...HCe(t),
  options: [t, e]
}), YCe = (t, e) => ({
  ...$Ce(t),
  options: [t, e]
}), ZCe = (t, e) => ({
  ...UCe(t),
  options: [t, e]
}), JCe = (t, e) => ({
  ...jCe(t),
  options: [t, e]
}), XCe = (t, e) => ({
  ...VCe(t),
  options: [t, e]
});
var QCe = "Arrow", b7 = I.forwardRef((t, e) => {
  const { children: n, width: r = 10, height: s = 5, ...i } = t;
  return /* @__PURE__ */ k.jsx(
    Pt.svg,
    {
      ...i,
      ref: e,
      width: r,
      height: s,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ k.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
b7.displayName = QCe;
var eke = b7, Uk = "Popper", [_7, Bu] = Ii(Uk), [tke, v7] = _7(Uk), w7 = (t) => {
  const { __scopePopper: e, children: n } = t, [r, s] = I.useState(null);
  return /* @__PURE__ */ k.jsx(tke, { scope: e, anchor: r, onAnchorChange: s, children: n });
};
w7.displayName = Uk;
var E7 = "PopperAnchor", S7 = I.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: r, ...s } = t, i = v7(E7, n), o = I.useRef(null), a = Yt(e, o);
    return I.useEffect(() => {
      i.onAnchorChange(r?.current || o.current);
    }), r ? null : /* @__PURE__ */ k.jsx(Pt.div, { ...s, ref: a });
  }
);
S7.displayName = E7;
var jk = "PopperContent", [nke, rke] = _7(jk), x7 = I.forwardRef(
  (t, e) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: s = 0,
      align: i = "center",
      alignOffset: o = 0,
      arrowPadding: a = 0,
      avoidCollisions: l = !0,
      collisionBoundary: c = [],
      collisionPadding: u = 0,
      sticky: h = "partial",
      hideWhenDetached: d = !1,
      updatePositionStrategy: f = "optimized",
      onPlaced: g,
      ...y
    } = t, p = v7(jk, n), [m, b] = I.useState(null), _ = Yt(e, (X) => b(X)), [v, w] = I.useState(null), E = U4(v), x = E?.width ?? 0, S = E?.height ?? 0, T = r + (i !== "center" ? "-" + i : ""), R = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, F = Array.isArray(c) ? c : [c], P = F.length > 0, M = {
      padding: R,
      boundary: F.filter(ike),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: P
    }, { refs: A, floatingStyles: V, placement: ee, isPositioned: K, middlewareData: te } = GCe({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: T,
      whileElementsMounted: (...X) => MCe(...X, {
        animationFrame: f === "always"
      }),
      elements: {
        reference: p.anchor
      },
      middleware: [
        WCe({ mainAxis: s + S, alignmentAxis: o }),
        l && qCe({
          mainAxis: !0,
          crossAxis: !1,
          limiter: h === "partial" ? KCe() : void 0,
          ...M
        }),
        l && YCe({ ...M }),
        ZCe({
          ...M,
          apply: ({ elements: X, rects: z, availableWidth: ue, availableHeight: ae }) => {
            const { width: be, height: de } = z.reference, _e = X.floating.style;
            _e.setProperty("--radix-popper-available-width", `${ue}px`), _e.setProperty("--radix-popper-available-height", `${ae}px`), _e.setProperty("--radix-popper-anchor-width", `${be}px`), _e.setProperty("--radix-popper-anchor-height", `${de}px`);
          }
        }),
        v && XCe({ element: v, padding: a }),
        oke({ arrowWidth: x, arrowHeight: S }),
        d && JCe({ strategy: "referenceHidden", ...M })
      ]
    }), [N, L] = k7(ee), j = rs(g);
    hl(() => {
      K && j?.();
    }, [K, j]);
    const H = te.arrow?.x, U = te.arrow?.y, Y = te.arrow?.centerOffset !== 0, [ne, he] = I.useState();
    return hl(() => {
      m && he(window.getComputedStyle(m).zIndex);
    }, [m]), /* @__PURE__ */ k.jsx(
      "div",
      {
        ref: A.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...V,
          transform: K ? V.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ne,
          "--radix-popper-transform-origin": [
            te.transformOrigin?.x,
            te.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...te.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ k.jsx(
          nke,
          {
            scope: n,
            placedSide: N,
            onArrowChange: w,
            arrowX: H,
            arrowY: U,
            shouldHideArrow: Y,
            children: /* @__PURE__ */ k.jsx(
              Pt.div,
              {
                "data-side": N,
                "data-align": L,
                ...y,
                ref: _,
                style: {
                  ...y.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: K ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
x7.displayName = jk;
var T7 = "PopperArrow", ske = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, C7 = I.forwardRef(function(e, n) {
  const { __scopePopper: r, ...s } = e, i = rke(T7, r), o = ske[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ k.jsx(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [o]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ k.jsx(
          eke,
          {
            ...s,
            ref: n,
            style: {
              ...s.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
C7.displayName = T7;
function ike(t) {
  return t !== null;
}
var oke = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    const { placement: n, rects: r, middlewareData: s } = e, o = s.arrow?.centerOffset !== 0, a = o ? 0 : t.arrowWidth, l = o ? 0 : t.arrowHeight, [c, u] = k7(n), h = { start: "0%", center: "50%", end: "100%" }[u], d = (s.arrow?.x ?? 0) + a / 2, f = (s.arrow?.y ?? 0) + l / 2;
    let g = "", y = "";
    return c === "bottom" ? (g = o ? h : `${d}px`, y = `${-l}px`) : c === "top" ? (g = o ? h : `${d}px`, y = `${r.floating.height + l}px`) : c === "right" ? (g = `${-l}px`, y = o ? h : `${f}px`) : c === "left" && (g = `${r.floating.width + l}px`, y = o ? h : `${f}px`), { data: { x: g, y } };
  }
});
function k7(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var Hk = w7, Gb = S7, zk = x7, Gk = C7, ake = "VisuallyHidden", A7 = I.forwardRef(
  (t, e) => /* @__PURE__ */ k.jsx(
    Pt.span,
    {
      ...t,
      ref: e,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...t.style
      }
    }
  )
);
A7.displayName = ake;
var lke = A7, [Vb, HVe] = Ii("Tooltip", [
  Bu
]), Wb = Bu(), R7 = "TooltipProvider", cke = 700, FS = "tooltip.open", [uke, Vk] = Vb(R7), ey = (t) => {
  const {
    __scopeTooltip: e,
    delayDuration: n = cke,
    skipDelayDuration: r = 300,
    disableHoverableContent: s = !1,
    children: i
  } = t, [o, a] = I.useState(!0), l = I.useRef(!1), c = I.useRef(0);
  return I.useEffect(() => {
    const u = c.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ k.jsx(
    uke,
    {
      scope: e,
      isOpenDelayed: o,
      delayDuration: n,
      onOpen: I.useCallback(() => {
        window.clearTimeout(c.current), a(!1);
      }, []),
      onClose: I.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => a(!0),
          r
        );
      }, [r]),
      isPointerInTransitRef: l,
      onPointerInTransitChange: I.useCallback((u) => {
        l.current = u;
      }, []),
      disableHoverableContent: s,
      children: i
    }
  );
};
ey.displayName = R7;
var qb = "Tooltip", [hke, dp] = Vb(qb), I7 = (t) => {
  const {
    __scopeTooltip: e,
    children: n,
    open: r,
    defaultOpen: s = !1,
    onOpenChange: i,
    disableHoverableContent: o,
    delayDuration: a
  } = t, l = Vk(qb, t.__scopeTooltip), c = Wb(e), [u, h] = I.useState(null), d = Ad(), f = I.useRef(0), g = o ?? l.disableHoverableContent, y = a ?? l.delayDuration, p = I.useRef(!1), [m = !1, b] = tp({
    prop: r,
    defaultProp: s,
    onChange: (x) => {
      x ? (l.onOpen(), document.dispatchEvent(new CustomEvent(FS))) : l.onClose(), i?.(x);
    }
  }), _ = I.useMemo(() => m ? p.current ? "delayed-open" : "instant-open" : "closed", [m]), v = I.useCallback(() => {
    window.clearTimeout(f.current), f.current = 0, p.current = !1, b(!0);
  }, [b]), w = I.useCallback(() => {
    window.clearTimeout(f.current), f.current = 0, b(!1);
  }, [b]), E = I.useCallback(() => {
    window.clearTimeout(f.current), f.current = window.setTimeout(() => {
      p.current = !0, b(!0), f.current = 0;
    }, y);
  }, [y, b]);
  return I.useEffect(() => () => {
    f.current && (window.clearTimeout(f.current), f.current = 0);
  }, []), /* @__PURE__ */ k.jsx(Hk, { ...c, children: /* @__PURE__ */ k.jsx(
    hke,
    {
      scope: e,
      contentId: d,
      open: m,
      stateAttribute: _,
      trigger: u,
      onTriggerChange: h,
      onTriggerEnter: I.useCallback(() => {
        l.isOpenDelayed ? E() : v();
      }, [l.isOpenDelayed, E, v]),
      onTriggerLeave: I.useCallback(() => {
        g ? w() : (window.clearTimeout(f.current), f.current = 0);
      }, [w, g]),
      onOpen: v,
      onClose: w,
      disableHoverableContent: g,
      children: n
    }
  ) });
};
I7.displayName = qb;
var $S = "TooltipTrigger", P7 = I.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, s = dp($S, n), i = Vk($S, n), o = Wb(n), a = I.useRef(null), l = Yt(e, a, s.onTriggerChange), c = I.useRef(!1), u = I.useRef(!1), h = I.useCallback(() => c.current = !1, []);
    return I.useEffect(() => () => document.removeEventListener("pointerup", h), [h]), /* @__PURE__ */ k.jsx(Gb, { asChild: !0, ...o, children: /* @__PURE__ */ k.jsx(
      Pt.button,
      {
        "aria-describedby": s.open ? s.contentId : void 0,
        "data-state": s.stateAttribute,
        ...r,
        ref: l,
        onPointerMove: Ke(t.onPointerMove, (d) => {
          d.pointerType !== "touch" && !u.current && !i.isPointerInTransitRef.current && (s.onTriggerEnter(), u.current = !0);
        }),
        onPointerLeave: Ke(t.onPointerLeave, () => {
          s.onTriggerLeave(), u.current = !1;
        }),
        onPointerDown: Ke(t.onPointerDown, () => {
          c.current = !0, document.addEventListener("pointerup", h, { once: !0 });
        }),
        onFocus: Ke(t.onFocus, () => {
          c.current || s.onOpen();
        }),
        onBlur: Ke(t.onBlur, s.onClose),
        onClick: Ke(t.onClick, s.onClose)
      }
    ) });
  }
);
P7.displayName = $S;
var Wk = "TooltipPortal", [dke, fke] = Vb(Wk, {
  forceMount: void 0
}), O7 = (t) => {
  const { __scopeTooltip: e, forceMount: n, children: r, container: s } = t, i = dp(Wk, e);
  return /* @__PURE__ */ k.jsx(dke, { scope: e, forceMount: n, children: /* @__PURE__ */ k.jsx(ls, { present: n || i.open, children: /* @__PURE__ */ k.jsx(rp, { asChild: !0, container: s, children: r }) }) });
};
O7.displayName = Wk;
var cu = "TooltipContent", D7 = I.forwardRef(
  (t, e) => {
    const n = fke(cu, t.__scopeTooltip), { forceMount: r = n.forceMount, side: s = "top", ...i } = t, o = dp(cu, t.__scopeTooltip);
    return /* @__PURE__ */ k.jsx(ls, { present: r || o.open, children: o.disableHoverableContent ? /* @__PURE__ */ k.jsx(N7, { side: s, ...i, ref: e }) : /* @__PURE__ */ k.jsx(pke, { side: s, ...i, ref: e }) });
  }
), pke = I.forwardRef((t, e) => {
  const n = dp(cu, t.__scopeTooltip), r = Vk(cu, t.__scopeTooltip), s = I.useRef(null), i = Yt(e, s), [o, a] = I.useState(null), { trigger: l, onClose: c } = n, u = s.current, { onPointerInTransitChange: h } = r, d = I.useCallback(() => {
    a(null), h(!1);
  }, [h]), f = I.useCallback(
    (g, y) => {
      const p = g.currentTarget, m = { x: g.clientX, y: g.clientY }, b = yke(m, p.getBoundingClientRect()), _ = bke(m, b), v = _ke(y.getBoundingClientRect()), w = wke([..._, ...v]);
      a(w), h(!0);
    },
    [h]
  );
  return I.useEffect(() => () => d(), [d]), I.useEffect(() => {
    if (l && u) {
      const g = (p) => f(p, u), y = (p) => f(p, l);
      return l.addEventListener("pointerleave", g), u.addEventListener("pointerleave", y), () => {
        l.removeEventListener("pointerleave", g), u.removeEventListener("pointerleave", y);
      };
    }
  }, [l, u, f, d]), I.useEffect(() => {
    if (o) {
      const g = (y) => {
        const p = y.target, m = { x: y.clientX, y: y.clientY }, b = l?.contains(p) || u?.contains(p), _ = !vke(m, o);
        b ? d() : _ && (d(), c());
      };
      return document.addEventListener("pointermove", g), () => document.removeEventListener("pointermove", g);
    }
  }, [l, u, o, c, d]), /* @__PURE__ */ k.jsx(N7, { ...t, ref: i });
}), [mke, gke] = Vb(qb, { isInside: !1 }), N7 = I.forwardRef(
  (t, e) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": s,
      onEscapeKeyDown: i,
      onPointerDownOutside: o,
      ...a
    } = t, l = dp(cu, n), c = Wb(n), { onClose: u } = l;
    return I.useEffect(() => (document.addEventListener(FS, u), () => document.removeEventListener(FS, u)), [u]), I.useEffect(() => {
      if (l.trigger) {
        const h = (d) => {
          d.target?.contains(l.trigger) && u();
        };
        return window.addEventListener("scroll", h, { capture: !0 }), () => window.removeEventListener("scroll", h, { capture: !0 });
      }
    }, [l.trigger, u]), /* @__PURE__ */ k.jsx(
      np,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: o,
        onFocusOutside: (h) => h.preventDefault(),
        onDismiss: u,
        children: /* @__PURE__ */ k.jsxs(
          zk,
          {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: e,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ k.jsx(h4, { children: r }),
              /* @__PURE__ */ k.jsx(mke, { scope: n, isInside: !0, children: /* @__PURE__ */ k.jsx(lke, { id: l.contentId, role: "tooltip", children: s || r }) })
            ]
          }
        )
      }
    );
  }
);
D7.displayName = cu;
var L7 = "TooltipArrow", M7 = I.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, s = Wb(n);
    return gke(
      L7,
      n
    ).isInside ? null : /* @__PURE__ */ k.jsx(Gk, { ...s, ...r, ref: e });
  }
);
M7.displayName = L7;
function yke(t, e) {
  const n = Math.abs(e.top - t.y), r = Math.abs(e.bottom - t.y), s = Math.abs(e.right - t.x), i = Math.abs(e.left - t.x);
  switch (Math.min(n, r, s, i)) {
    case i:
      return "left";
    case s:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function bke(t, e, n = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push(
        { x: t.x - n, y: t.y + n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x + n, y: t.y - n }
      );
      break;
    case "left":
      r.push(
        { x: t.x + n, y: t.y - n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "right":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x - n, y: t.y + n }
      );
      break;
  }
  return r;
}
function _ke(t) {
  const { top: e, right: n, bottom: r, left: s } = t;
  return [
    { x: s, y: e },
    { x: n, y: e },
    { x: n, y: r },
    { x: s, y: r }
  ];
}
function vke(t, e) {
  const { x: n, y: r } = t;
  let s = !1;
  for (let i = 0, o = e.length - 1; i < e.length; o = i++) {
    const a = e[i].x, l = e[i].y, c = e[o].x, u = e[o].y;
    l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (s = !s);
  }
  return s;
}
function wke(t) {
  const e = t.slice();
  return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), Eke(e);
}
function Eke(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1], o = e[e.length - 2];
      if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) e.pop();
      else break;
    }
    e.push(s);
  }
  e.pop();
  const n = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const s = t[r];
    for (; n.length >= 2; ) {
      const i = n[n.length - 1], o = n[n.length - 2];
      if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) n.pop();
      else break;
    }
    n.push(s);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var Ske = ey, xke = I7, Tke = P7, Cke = O7, kke = D7, Ake = M7;
const uu = I.forwardRef(
  ({
    tooltip: t,
    children: e,
    sideOffset: n = 5,
    className: r = "",
    arrowClassName: s = "",
    tooltipStyle: i = {},
    position: o = "top",
    maxWidth: a = 250,
    delay: l = 0
  }, c) => /* @__PURE__ */ k.jsxs(xke, { delayDuration: l, children: [
    /* @__PURE__ */ k.jsx(Tke, { asChild: !0, children: e }),
    /* @__PURE__ */ k.jsx(Cke, { children: /* @__PURE__ */ k.jsxs(
      kke,
      {
        side: o,
        className: `
              z-[2000]
              px-2.5
              py-1.5
              max-h-[300px]
              select-none
              rounded-md
              bg-bolt-elements-background-depth-3
              text-bolt-elements-textPrimary
              text-sm
              leading-tight
              shadow-lg
              animate-in
              fade-in-0
              zoom-in-95
              data-[state=closed]:animate-out
              data-[state=closed]:fade-out-0
              data-[state=closed]:zoom-out-95
              ${r}
            `,
        sideOffset: n,
        style: {
          maxWidth: a,
          ...i
        },
        children: [
          /* @__PURE__ */ k.jsx("div", { className: "break-words", children: t }),
          /* @__PURE__ */ k.jsx(
            Ake,
            {
              className: `
                fill-bolt-elements-background-depth-3
                ${s}
              `,
              width: 12,
              height: 6
            }
          )
        ]
      }
    ) })
  ] })
), wm = "<boltArtifact", pD = "</boltArtifact>", Rke = "<boltAction", mD = "</boltAction>", Em = Sr("MessageParser");
function gD(t) {
  const e = /^\s*```\w*\n([\s\S]*?)\n\s*```\s*$/, n = t.match(e);
  return n ? n[1] : t;
}
function yD(t) {
  return t.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
}
class Ike {
  constructor(e = {}) {
    this._options = e;
  }
  #t = /* @__PURE__ */ new Map();
  parse(e, n) {
    let r = this.#t.get(e);
    r || (r = {
      position: 0,
      insideAction: !1,
      insideArtifact: !1,
      currentAction: { content: "" },
      actionId: 0
    }, this.#t.set(e, r));
    let s = "", i = r.position, o = !1;
    for (; i < n.length; ) {
      if (r.insideArtifact) {
        const a = r.currentArtifact;
        if (a === void 0 && ps("Artifact not initialized"), r.insideAction) {
          const l = n.indexOf(mD, i), c = r.currentAction;
          if (l !== -1) {
            c.content += n.slice(i, l);
            let u = c.content.trim();
            "type" in c && c.type === "file" && (c.filePath.endsWith(".md") || (u = gD(u), u = yD(u)), u += `
`), c.content = u, this._options.callbacks?.onActionClose?.({
              artifactId: a.id,
              messageId: e,
              /**
               * We decrement the id because it's been incremented already
               * when `onActionOpen` was emitted to make sure the ids are
               * the same.
               */
              actionId: String(r.actionId - 1),
              action: c
            }), r.insideAction = !1, r.currentAction = { content: "" }, i = l + mD.length;
          } else {
            if ("type" in c && c.type === "file") {
              let u = n.slice(i);
              c.filePath.endsWith(".md") || (u = gD(u), u = yD(u)), this._options.callbacks?.onActionStream?.({
                artifactId: a.id,
                messageId: e,
                actionId: String(r.actionId - 1),
                action: {
                  ...c,
                  content: u,
                  filePath: c.filePath
                }
              });
            }
            break;
          }
        } else {
          const l = n.indexOf(Rke, i), c = n.indexOf(pD, i);
          if (l !== -1 && (c === -1 || l < c)) {
            const u = n.indexOf(">", l);
            if (u !== -1)
              r.insideAction = !0, r.currentAction = this.#n(n, l, u), this._options.callbacks?.onActionOpen?.({
                artifactId: a.id,
                messageId: e,
                actionId: String(r.actionId++),
                action: r.currentAction
              }), i = u + 1;
            else
              break;
          } else if (c !== -1)
            this._options.callbacks?.onArtifactClose?.({ messageId: e, ...a }), r.insideArtifact = !1, r.currentArtifact = void 0, i = c + pD.length;
          else
            break;
        }
      } else if (n[i] === "<" && n[i + 1] !== "/") {
        let a = i, l = "";
        for (; a < n.length && l.length < wm.length; ) {
          if (l += n[a], l === wm) {
            const c = n[a + 1];
            if (c && c !== ">" && c !== " ") {
              s += n.slice(i, a + 1), i = a + 1;
              break;
            }
            const u = n.indexOf(">", a);
            if (u !== -1) {
              const h = n.slice(i, u + 1), d = this.#e(h, "title"), f = this.#e(h, "type"), g = this.#e(h, "id");
              d || Em.warn("Artifact title missing"), g || Em.warn("Artifact id missing"), r.insideArtifact = !0;
              const y = {
                id: g,
                title: d,
                type: f
              };
              r.currentArtifact = y, this._options.callbacks?.onArtifactOpen?.({ messageId: e, ...y });
              const p = this._options.artifactElement ?? Pke;
              s += p({ messageId: e }), i = u + 1;
            } else
              o = !0;
            break;
          } else if (!wm.startsWith(l)) {
            s += n.slice(i, a + 1), i = a + 1;
            break;
          }
          a++;
        }
        if (a === n.length && wm.startsWith(l))
          break;
      } else
        s += n[i], i++;
      if (o)
        break;
    }
    return r.position = i, s;
  }
  reset() {
    this.#t.clear();
  }
  #n(e, n, r) {
    const s = e.slice(n, r + 1), i = this.#e(s, "type"), o = {
      type: i,
      content: ""
    };
    if (i === "file") {
      const a = this.#e(s, "filePath");
      a || Em.debug("File path not specified"), o.filePath = a;
    } else ["shell", "start"].includes(i) || Em.warn(`Unknown action type '${i}'`);
    return o;
  }
  #e(e, n) {
    const r = e.match(new RegExp(`${n}="([^"]*)"`, "i"));
    return r ? r[1] : void 0;
  }
}
const Pke = (t) => `<div ${[
  'class="__boltArtifact__"',
  ...Object.entries(t).map(([n, r]) => `data-${Oke(n)}=${JSON.stringify(r)}`)
].join(" ")}></div>`;
function Oke(t) {
  return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
const oh = Sr("useMessageParser"), Dke = new Ike({
  callbacks: {
    onArtifactOpen: (t) => {
      oh.trace("onArtifactOpen", t), We.showWorkbench.set(!0), We.addArtifact(t);
    },
    onArtifactClose: (t) => {
      oh.trace("onArtifactClose"), We.updateArtifact(t, { closed: !0 });
    },
    onActionOpen: (t) => {
      oh.trace("onActionOpen", t.action), t.action.type === "file" && We.addAction(t);
    },
    onActionClose: (t) => {
      oh.trace("onActionClose", t.action), t.action.type !== "file" && We.addAction(t), We.runAction(t);
    },
    onActionStream: (t) => {
      oh.trace("onActionStream", t.action), We.runAction(t, !0);
    }
  }
});
function Nke() {
  const [t, e] = I.useState({}), n = I.useCallback((r, s) => {
    for (const [i, o] of r.entries())
      if (o.role === "assistant") {
        const a = Dke.parse(o.id, o.content);
        e((l) => ({
          ...l,
          [i]: (l[i] || "") + a
        }));
      }
  }, []);
  return { parsedMessages: t, parseMessages: n };
}
const bD = Sr("usePromptEnhancement");
function Lke() {
  const [t, e] = I.useState(!1), [n, r] = I.useState(!1);
  return { enhancingPrompt: t, promptEnhanced: n, enhancePrompt: async (o, a, l, c, u) => {
    e(!0), r(!1);
    const h = {
      message: o,
      model: l,
      provider: c
    };
    u && (h.apiKeys = u);
    const f = (await fetch("/api/enhancer", {
      method: "POST",
      body: JSON.stringify(h)
    })).body?.getReader(), g = o;
    if (f) {
      const y = new TextDecoder();
      let p = "", m;
      try {
        for (a(""); ; ) {
          const { value: b, done: _ } = await f.read();
          if (_)
            break;
          p += y.decode(b), bD.trace("Set input", p), a(p);
        }
      } catch (b) {
        m = b, a(g);
      } finally {
        m && bD.error(m), e(!1), r(!0), setTimeout(() => {
          a(p);
        });
      }
    }
  }, resetEnhancer: () => {
    e(!1), r(!1);
  } };
}
class Mke {
  #t = new EventTarget();
  dispatch(e) {
    this.#t.dispatchEvent(new Event(e));
  }
  on(e, n) {
    return this.#t.addEventListener(e, n), () => {
      this.#t.removeEventListener(e, n);
    };
  }
}
const B7 = new Mke();
function Bke() {
  const t = mt(R_e);
  I.useEffect(() => {
    const e = (n) => {
      const { key: r, ctrlKey: s, shiftKey: i, altKey: o, metaKey: a } = n;
      for (const l in t) {
        const c = t[l];
        if (c.key.toLowerCase() === r.toLowerCase() && (c.ctrlOrMetaKey ? s || a : (c.ctrlKey === void 0 || c.ctrlKey === s) && (c.metaKey === void 0 || c.metaKey === a)) && (c.shiftKey === void 0 || c.shiftKey === i) && (c.altKey === void 0 || c.altKey === o)) {
          B7.dispatch(l), n.preventDefault(), n.stopPropagation(), c.action();
          break;
        }
      }
    };
    return window.addEventListener("keydown", e), () => {
      window.removeEventListener("keydown", e);
    };
  }, [t]);
}
function Fke() {
  const t = I.useRef(!0), e = I.useRef(), n = I.useRef(), r = I.useRef(), s = I.useCallback((o) => {
    o ? new ResizeObserver(() => {
      if (t.current && e.current) {
        const { scrollHeight: l, clientHeight: c } = e.current, u = l - c;
        e.current.scrollTo({
          top: u
        });
      }
    }).observe(o) : (r.current?.disconnect(), r.current = void 0);
  }, []), i = I.useCallback((o) => {
    o ? (n.current = () => {
      const { scrollTop: a, scrollHeight: l, clientHeight: c } = o, u = l - c;
      t.current = Math.abs(a - u) <= 10;
    }, o.addEventListener("scroll", n.current), e.current = o) : (n.current && e.current?.removeEventListener("scroll", n.current), e.current = void 0, n.current = void 0);
  }, []);
  return [s, i];
}
function $ke({
  initialDescription: t = oi.get(),
  customChatId: e,
  syncWithGlobalStore: n
}) {
  const r = mt(Mo), [s, i] = I.useState(!1), [o, a] = I.useState(t), [l, c] = I.useState();
  I.useEffect(() => {
    c(e || r);
  }, [e, r]), I.useEffect(() => {
    a(t);
  }, [t]);
  const u = I.useCallback(() => i((m) => !m), []), h = I.useCallback((m) => {
    a(m.target.value);
  }, []), d = I.useCallback(async () => {
    if (!Kt || !l)
      return t;
    try {
      return (await iu(Kt, l))?.description || t;
    } catch (m) {
      return console.error("Failed to fetch latest description:", m), t;
    }
  }, [Kt, l, t]), f = I.useCallback(async () => {
    const m = await d();
    a(m), u();
  }, [d, u]), g = I.useCallback((m) => {
    const b = m.trim();
    if (b === t)
      return u(), !1;
    const _ = b.length > 0 && b.length <= 100, v = /^[a-zA-Z0-9\s\-_.,!?()[\]{}'"]+$/.test(b);
    return _ ? v ? !0 : ($e.error("Description can only contain letters, numbers, spaces, and basic punctuation."), !1) : ($e.error("Description must be between 1 and 100 characters."), !1);
  }, []), y = I.useCallback(
    async (m) => {
      if (m.preventDefault(), !!g(o)) {
        try {
          if (!Kt) {
            $e.error("Chat persistence is not available");
            return;
          }
          if (!l) {
            $e.error("Chat Id is not available");
            return;
          }
          await C_e(Kt, l, o), n && oi.set(o), $e.success("Chat description updated successfully");
        } catch (b) {
          $e.error("Failed to update chat description: " + b.message);
        }
        u();
      }
    },
    [o, Kt, l, t, e]
  ), p = I.useCallback(
    async (m) => {
      m.key === "Escape" && await f();
    },
    [f]
  );
  return {
    editing: s,
    handleChange: h,
    handleBlur: f,
    handleSubmit: y,
    handleKeyDown: p,
    currentDescription: o,
    toggleEditMode: u
  };
}
const F7 = (t = 1024) => {
  const [e, n] = I.useState(window.innerWidth < t);
  return I.useEffect(() => {
    const r = () => n(window.innerWidth < t);
    return window.addEventListener("resize", r), () => {
      window.removeEventListener("resize", r);
    };
  }, [t]), e;
};
I.forwardRef(
  ({
    toolTipContent: t,
    icon: e,
    className: n,
    onClick: r
  }, s) => /* @__PURE__ */ k.jsx(uu, { tooltip: t, children: /* @__PURE__ */ k.jsx(
    "button",
    {
      ref: s,
      type: "button",
      className: `scale-110 mr-2 hover:text-bolt-elements-item-contentAccent ${e} ${n || ""}`,
      onClick: r
    }
  ) })
);
function qk(t, e = 100) {
  if (e === 0)
    return t;
  let n;
  return function(...r) {
    const s = this;
    clearTimeout(n), n = window.setTimeout(() => {
      t.apply(s, r);
    }, e);
  };
}
let US = [], $7 = [];
(() => {
  let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, n = 0; e < t.length; e++)
    (e % 2 ? $7 : US).push(n = n + t[e]);
})();
function Uke(t) {
  if (t < 768) return !1;
  for (let e = 0, n = US.length; ; ) {
    let r = e + n >> 1;
    if (t < US[r]) n = r;
    else if (t >= $7[r]) e = r + 1;
    else return !0;
    if (e == n) return !1;
  }
}
function _D(t) {
  return t >= 127462 && t <= 127487;
}
const vD = 8205;
function jke(t, e, n = !0, r = !0) {
  return (n ? U7 : Hke)(t, e, r);
}
function U7(t, e, n) {
  if (e == t.length) return e;
  e && j7(t.charCodeAt(e)) && H7(t.charCodeAt(e - 1)) && e--;
  let r = nw(t, e);
  for (e += wD(r); e < t.length; ) {
    let s = nw(t, e);
    if (r == vD || s == vD || n && Uke(s))
      e += wD(s), r = s;
    else if (_D(s)) {
      let i = 0, o = e - 2;
      for (; o >= 0 && _D(nw(t, o)); )
        i++, o -= 2;
      if (i % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function Hke(t, e, n) {
  for (; e > 0; ) {
    let r = U7(t, e - 2, n);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function nw(t, e) {
  let n = t.charCodeAt(e);
  if (!H7(n) || e + 1 == t.length) return n;
  let r = t.charCodeAt(e + 1);
  return j7(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function j7(t) {
  return t >= 56320 && t < 57344;
}
function H7(t) {
  return t >= 55296 && t < 56320;
}
function wD(t) {
  return t < 65536 ? 1 : 2;
}
let Et = class z7 {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, n, r) {
    [e, n] = hu(this, e, n);
    let s = [];
    return this.decompose(
      0,
      e,
      s,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      s,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      s,
      1
      /* Open.From */
    ), ai.from(s, this.length - (n - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, n = this.length) {
    [e, n] = hu(this, e, n);
    let r = [];
    return this.decompose(e, n, r, 0), ai.from(r, n - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), s = new sd(this), i = new sd(e);
    for (let o = n, a = n; ; ) {
      if (s.next(o), i.next(o), o = 0, s.lineBreak != i.lineBreak || s.done != i.done || s.value != i.value)
        return !1;
      if (a += s.value.length, s.done || a >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new sd(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, n = this.length) {
    return new G7(this, e, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, n) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let s = this.line(e).from;
      r = this.iterRange(s, Math.max(s, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new V7(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? z7.empty : e.length <= 32 ? new Xt(e) : ai.from(Xt.split(e, []));
  }
};
class Xt extends Et {
  constructor(e, n = zke(e)) {
    super(), this.text = e, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, r, s) {
    for (let i = 0; ; i++) {
      let o = this.text[i], a = s + o.length;
      if ((n ? r : a) >= e)
        return new Gke(s, a, r, o);
      s = a + 1, r++;
    }
  }
  decompose(e, n, r, s) {
    let i = e <= 0 && n >= this.length ? this : new Xt(ED(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (s & 1) {
      let o = r.pop(), a = xg(i.text, o.text.slice(), 0, i.length);
      if (a.length <= 32)
        r.push(new Xt(a, o.length + i.length));
      else {
        let l = a.length >> 1;
        r.push(new Xt(a.slice(0, l)), new Xt(a.slice(l)));
      }
    } else
      r.push(i);
  }
  replace(e, n, r) {
    if (!(r instanceof Xt))
      return super.replace(e, n, r);
    [e, n] = hu(this, e, n);
    let s = xg(this.text, xg(r.text, ED(this.text, 0, e)), n), i = this.length + r.length - (n - e);
    return s.length <= 32 ? new Xt(s, i) : ai.from(Xt.split(s, []), i);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = hu(this, e, n);
    let s = "";
    for (let i = 0, o = 0; i <= n && o < this.text.length; o++) {
      let a = this.text[o], l = i + a.length;
      i > e && o && (s += r), e < l && n > i && (s += a.slice(Math.max(0, e - i), n - i)), i = l + 1;
    }
    return s;
  }
  flatten(e) {
    for (let n of this.text)
      e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let r = [], s = -1;
    for (let i of e)
      r.push(i), s += i.length + 1, r.length == 32 && (n.push(new Xt(r, s)), r = [], s = -1);
    return s > -1 && n.push(new Xt(r, s)), n;
  }
}
class ai extends Et {
  constructor(e, n) {
    super(), this.children = e, this.length = n, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, n, r, s) {
    for (let i = 0; ; i++) {
      let o = this.children[i], a = s + o.length, l = r + o.lines - 1;
      if ((n ? l : a) >= e)
        return o.lineInner(e, n, r, s);
      s = a + 1, r = l + 1;
    }
  }
  decompose(e, n, r, s) {
    for (let i = 0, o = 0; o <= n && i < this.children.length; i++) {
      let a = this.children[i], l = o + a.length;
      if (e <= l && n >= o) {
        let c = s & ((o <= e ? 1 : 0) | (l >= n ? 2 : 0));
        o >= e && l <= n && !c ? r.push(a) : a.decompose(e - o, n - o, r, c);
      }
      o = l + 1;
    }
  }
  replace(e, n, r) {
    if ([e, n] = hu(this, e, n), r.lines < this.lines)
      for (let s = 0, i = 0; s < this.children.length; s++) {
        let o = this.children[s], a = i + o.length;
        if (e >= i && n <= a) {
          let l = o.replace(e - i, n - i, r), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let u = this.children.slice();
            return u[s] = l, new ai(u, this.length - (n - e) + r.length);
          }
          return super.replace(i, a, l);
        }
        i = a + 1;
      }
    return super.replace(e, n, r);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = hu(this, e, n);
    let s = "";
    for (let i = 0, o = 0; i < this.children.length && o <= n; i++) {
      let a = this.children[i], l = o + a.length;
      o > e && i && (s += r), e < l && n > o && (s += a.sliceString(e - o, n - o, r)), o = l + 1;
    }
    return s;
  }
  flatten(e) {
    for (let n of this.children)
      n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof ai))
      return 0;
    let r = 0, [s, i, o, a] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; s += n, i += n) {
      if (s == o || i == a)
        return r;
      let l = this.children[s], c = e.children[i];
      if (l != c)
        return r + l.scanIdentical(c, n);
      r += l.length + 1;
    }
  }
  static from(e, n = e.reduce((r, s) => r + s.length + 1, -1)) {
    let r = 0;
    for (let f of e)
      r += f.lines;
    if (r < 32) {
      let f = [];
      for (let g of e)
        g.flatten(f);
      return new Xt(f, n);
    }
    let s = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), i = s << 1, o = s >> 1, a = [], l = 0, c = -1, u = [];
    function h(f) {
      let g;
      if (f.lines > i && f instanceof ai)
        for (let y of f.children)
          h(y);
      else f.lines > o && (l > o || !l) ? (d(), a.push(f)) : f instanceof Xt && l && (g = u[u.length - 1]) instanceof Xt && f.lines + g.lines <= 32 ? (l += f.lines, c += f.length + 1, u[u.length - 1] = new Xt(g.text.concat(f.text), g.length + 1 + f.length)) : (l + f.lines > s && d(), l += f.lines, c += f.length + 1, u.push(f));
    }
    function d() {
      l != 0 && (a.push(u.length == 1 ? u[0] : ai.from(u, c)), c = -1, l = u.length = 0);
    }
    for (let f of e)
      h(f);
    return d(), a.length == 1 ? a[0] : new ai(a, n);
  }
}
Et.empty = /* @__PURE__ */ new Xt([""], 0);
function zke(t) {
  let e = -1;
  for (let n of t)
    e += n.length + 1;
  return e;
}
function xg(t, e, n = 0, r = 1e9) {
  for (let s = 0, i = 0, o = !0; i < t.length && s <= r; i++) {
    let a = t[i], l = s + a.length;
    l >= n && (l > r && (a = a.slice(0, r - s)), s < n && (a = a.slice(n - s)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), s = l + 1;
  }
  return e;
}
function ED(t, e, n) {
  return xg(t, [""], e, n);
}
class sd {
  constructor(e, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof Xt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, s = this.nodes[r], i = this.offsets[r], o = i >> 1, a = s instanceof Xt ? s.text.length : s.children.length;
      if (o == (n > 0 ? a : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((i & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[r] += n, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (s instanceof Xt) {
        let l = s.text[o + (n < 0 ? -1 : 0)];
        if (this.offsets[r] += n, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = s.children[o + (n < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof Xt ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class G7 {
  constructor(e, n, r) {
    this.value = "", this.done = !1, this.cursor = new sd(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: s } = this.cursor.next(e);
    return this.pos += (s.length + e) * n, this.value = s.length <= r ? s : n < 0 ? s.slice(s.length - r) : s.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class V7 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: n, lineBreak: r, value: s } = this.inner.next(e);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Et.prototype[Symbol.iterator] = function() {
  return this.iter();
}, sd.prototype[Symbol.iterator] = G7.prototype[Symbol.iterator] = V7.prototype[Symbol.iterator] = function() {
  return this;
});
class Gke {
  /**
  @internal
  */
  constructor(e, n, r, s) {
    this.from = e, this.to = n, this.number = r, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function hu(t, e, n) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, n))];
}
function An(t, e, n = !0, r = !0) {
  return jke(t, e, n, r);
}
function Vke(t) {
  return t >= 56320 && t < 57344;
}
function Wke(t) {
  return t >= 55296 && t < 56320;
}
function ms(t, e) {
  let n = t.charCodeAt(e);
  if (!Wke(n) || e + 1 == t.length)
    return n;
  let r = t.charCodeAt(e + 1);
  return Vke(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function Kk(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Qi(t) {
  return t < 65536 ? 1 : 2;
}
const jS = /\r\n?|\n/;
var Fn = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Fn || (Fn = {}));
class Ei {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      e += this.sections[n];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      e += r < 0 ? this.sections[n] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let n = 0, r = 0, s = 0; n < this.sections.length; ) {
      let i = this.sections[n++], o = this.sections[n++];
      o < 0 ? (e(r, s, i), s += i) : s += o, r += i;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, n = !1) {
    HS(this, e, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], s = this.sections[n++];
      s < 0 ? e.push(r, s) : e.push(s, r);
    }
    return new Ei(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : W7(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, n = !1) {
    return e.empty ? this : zS(this, e, n);
  }
  mapPos(e, n = -1, r = Fn.Simple) {
    let s = 0, i = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = s + a;
      if (l < 0) {
        if (c > e)
          return i + (e - s);
        i += a;
      } else {
        if (r != Fn.Simple && c >= e && (r == Fn.TrackDel && s < e && c > e || r == Fn.TrackBefore && s < e || r == Fn.TrackAfter && c > e))
          return null;
        if (c > e || c == e && n < 0 && !a)
          return e == s || n < 0 ? i : i + l;
        i += l;
      }
      s = c;
    }
    if (e > s)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${s}`);
    return i;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, n = e) {
    for (let r = 0, s = 0; r < this.sections.length && s <= n; ) {
      let i = this.sections[r++], o = this.sections[r++], a = s + i;
      if (o >= 0 && s <= n && a >= e)
        return s < e && a > n ? "cover" : !0;
      s = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], s = this.sections[n++];
      e += (e ? " " : "") + r + (s >= 0 ? ":" + s : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Ei(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Ei(e);
  }
}
class un extends Ei {
  constructor(e, n) {
    super(e), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return HS(this, (n, r, s, i, o) => e = e.replace(s, s + (r - n), o), !1), e;
  }
  mapDesc(e, n = !1) {
    return zS(this, e, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let n = this.sections.slice(), r = [];
    for (let s = 0, i = 0; s < n.length; s += 2) {
      let o = n[s], a = n[s + 1];
      if (a >= 0) {
        n[s] = a, n[s + 1] = o;
        let l = s >> 1;
        for (; r.length < l; )
          r.push(Et.empty);
        r.push(o ? e.slice(i, i + o) : Et.empty);
      }
      i += o;
    }
    return new un(n, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : W7(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, n = !1) {
    return e.empty ? this : zS(this, e, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, n = !1) {
    HS(this, e, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Ei.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let n = [], r = [], s = [], i = new tf(this);
    e: for (let o = 0, a = 0; ; ) {
      let l = o == e.length ? 1e9 : e[o++];
      for (; a < l || a == l && i.len == 0; ) {
        if (i.done)
          break e;
        let u = Math.min(i.len, l - a);
        Bn(s, u, -1);
        let h = i.ins == -1 ? -1 : i.off == 0 ? i.ins : 0;
        Bn(n, u, h), h > 0 && Ho(r, n, i.text), i.forward(u), a += u;
      }
      let c = e[o++];
      for (; a < c; ) {
        if (i.done)
          break e;
        let u = Math.min(i.len, c - a);
        Bn(n, u, -1), Bn(s, u, i.ins == -1 ? -1 : i.off == 0 ? i.ins : 0), i.forward(u), a += u;
      }
    }
    return {
      changes: new un(n, r),
      filtered: Ei.create(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n], s = this.sections[n + 1];
      s < 0 ? e.push(r) : s == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, n, r) {
    let s = [], i = [], o = 0, a = null;
    function l(u = !1) {
      if (!u && !s.length)
        return;
      o < n && Bn(s, n - o, -1);
      let h = new un(s, i);
      a = a ? a.compose(h.map(a)) : h, s = [], i = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let h of u)
          c(h);
      else if (u instanceof un) {
        if (u.length != n)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: h, to: d = h, insert: f } = u;
        if (h > d || h < 0 || d > n)
          throw new RangeError(`Invalid change range ${h} to ${d} (in doc of length ${n})`);
        let g = f ? typeof f == "string" ? Et.of(f.split(r || jS)) : f : Et.empty, y = g.length;
        if (h == d && y == 0)
          return;
        h < o && l(), h > o && Bn(s, h - o, -1), Bn(s, d - h, y), Ho(i, s, g), o = d;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new un(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], r = [];
    for (let s = 0; s < e.length; s++) {
      let i = e[s];
      if (typeof i == "number")
        n.push(i, -1);
      else {
        if (!Array.isArray(i) || typeof i[0] != "number" || i.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (i.length == 1)
          n.push(i[0], 0);
        else {
          for (; r.length < s; )
            r.push(Et.empty);
          r[s] = Et.of(i.slice(1)), n.push(i[0], r[s].length);
        }
      }
    }
    return new un(n, r);
  }
  /**
  @internal
  */
  static createSet(e, n) {
    return new un(e, n);
  }
}
function Bn(t, e, n, r = !1) {
  if (e == 0 && n <= 0)
    return;
  let s = t.length - 2;
  s >= 0 && n <= 0 && n == t[s + 1] ? t[s] += e : s >= 0 && e == 0 && t[s] == 0 ? t[s + 1] += n : r ? (t[s] += e, t[s + 1] += n) : t.push(e, n);
}
function Ho(t, e, n) {
  if (n.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < t.length)
    t[t.length - 1] = t[t.length - 1].append(n);
  else {
    for (; t.length < r; )
      t.push(Et.empty);
    t.push(n);
  }
}
function HS(t, e, n) {
  let r = t.inserted;
  for (let s = 0, i = 0, o = 0; o < t.sections.length; ) {
    let a = t.sections[o++], l = t.sections[o++];
    if (l < 0)
      s += a, i += a;
    else {
      let c = s, u = i, h = Et.empty;
      for (; c += a, u += l, l && r && (h = h.append(r[o - 2 >> 1])), !(n || o == t.sections.length || t.sections[o + 1] < 0); )
        a = t.sections[o++], l = t.sections[o++];
      e(s, c, i, u, h), s = c, i = u;
    }
  }
}
function zS(t, e, n, r = !1) {
  let s = [], i = r ? [] : null, o = new tf(t), a = new tf(e);
  for (let l = -1; ; ) {
    if (o.done && a.len || a.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      Bn(s, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !n))) {
      let c = a.len;
      for (Bn(s, a.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= u && (Bn(s, 0, o.ins), i && Ho(i, s, o.text), l = o.i), o.forward(u), c -= u;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (a.ins == -1) {
          let h = Math.min(u, a.len);
          c += h, u -= h, a.forward(h);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      Bn(s, c, l < o.i ? o.ins : 0), i && l < o.i && Ho(i, s, o.text), l = o.i, o.forward(o.len - u);
    } else {
      if (o.done && a.done)
        return i ? un.createSet(s, i) : Ei.create(s);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function W7(t, e, n = !1) {
  let r = [], s = n ? [] : null, i = new tf(t), o = new tf(e);
  for (let a = !1; ; ) {
    if (i.done && o.done)
      return s ? un.createSet(r, s) : Ei.create(r);
    if (i.ins == 0)
      Bn(r, i.len, 0, a), i.next();
    else if (o.len == 0 && !o.done)
      Bn(r, 0, o.ins, a), s && Ho(s, r, o.text), o.next();
    else {
      if (i.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(i.len2, o.len), c = r.length;
        if (i.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Bn(r, l, u, a), s && u && Ho(s, r, o.text);
        } else o.ins == -1 ? (Bn(r, i.off ? 0 : i.len, l, a), s && Ho(s, r, i.textBit(l))) : (Bn(r, i.off ? 0 : i.len, o.off ? 0 : o.ins, a), s && !o.off && Ho(s, r, o.text));
        a = (i.ins > l || o.ins >= 0 && o.len > l) && (a || r.length > c), i.forward2(l), o.forward(l);
      }
    }
  }
}
class tf {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, n = this.i - 2 >> 1;
    return n >= e.length ? Et.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set, r = this.i - 2 >> 1;
    return r >= n.length && !e ? Et.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class Ga {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.flags = r;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, n = -1) {
    let r, s;
    return this.empty ? r = s = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), s = e.mapPos(this.to, -1)), r == this.from && s == this.to ? this : new Ga(r, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor)
      return Ae.range(e, n);
    let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return Ae.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, n = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return Ae.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new Ga(e, n, r);
  }
}
class Ae {
  constructor(e, n) {
    this.ranges = e, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, n = -1) {
    return e.empty ? this : Ae.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, n = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new Ae([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, n = !0) {
    return Ae.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, n = this.mainIndex) {
    let r = this.ranges.slice();
    return r[n] = e, Ae.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new Ae(e.ranges.map((n) => Ga.fromJSON(n)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, n = e) {
    return new Ae([Ae.range(e, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, n = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, s = 0; s < e.length; s++) {
      let i = e[s];
      if (i.empty ? i.from <= r : i.from < r)
        return Ae.normalized(e.slice(), n);
      r = i.to;
    }
    return new Ae(e, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, n = 0, r, s) {
    return Ga.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (s ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, n, r, s) {
    let i = (r ?? 16777215) << 6 | (s == null ? 7 : Math.min(6, s));
    return n < e ? Ga.create(n, e, 48 | i) : Ga.create(e, n, (n > e ? 8 : 0) | i);
  }
  /**
  @internal
  */
  static normalized(e, n = 0) {
    let r = e[n];
    e.sort((s, i) => s.from - i.from), n = e.indexOf(r);
    for (let s = 1; s < e.length; s++) {
      let i = e[s], o = e[s - 1];
      if (i.empty ? i.from <= o.to : i.from < o.to) {
        let a = o.from, l = Math.max(i.to, o.to);
        s <= n && n--, e.splice(--s, 2, i.anchor > i.head ? Ae.range(l, a) : Ae.range(a, l));
      }
    }
    return new Ae(e, n);
  }
}
function q7(t, e) {
  for (let n of t.ranges)
    if (n.to > e)
      throw new RangeError("Selection points outside of document");
}
let Yk = 0;
class ze {
  constructor(e, n, r, s, i) {
    this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = s, this.id = Yk++, this.default = e([]), this.extensions = typeof i == "function" ? i(this) : i;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new ze(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : Zk), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Tg([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Tg(e, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Tg(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (r) => r), this.compute([e], (r) => n(r.field(e)));
  }
}
function Zk(t, e) {
  return t == e || t.length == e.length && t.every((n, r) => n === e[r]);
}
class Tg {
  constructor(e, n, r, s) {
    this.dependencies = e, this.facet = n, this.type = r, this.value = s, this.id = Yk++;
  }
  dynamicSlot(e) {
    var n;
    let r = this.value, s = this.facet.compareInput, i = this.id, o = e[i] >> 1, a = this.type == 2, l = !1, c = !1, u = [];
    for (let h of this.dependencies)
      h == "doc" ? l = !0 : h == "selection" ? c = !0 : ((n = e[h.id]) !== null && n !== void 0 ? n : 1) & 1 || u.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = r(h), 1;
      },
      update(h, d) {
        if (l && d.docChanged || c && (d.docChanged || d.selection) || GS(h, u)) {
          let f = r(h);
          if (a ? !SD(f, h.values[o], s) : !s(f, h.values[o]))
            return h.values[o] = f, 1;
        }
        return 0;
      },
      reconfigure: (h, d) => {
        let f, g = d.config.address[i];
        if (g != null) {
          let y = ny(d, g);
          if (this.dependencies.every((p) => p instanceof ze ? d.facet(p) === h.facet(p) : p instanceof En ? d.field(p, !1) == h.field(p, !1) : !0) || (a ? SD(f = r(h), y, s) : s(f = r(h), y)))
            return h.values[o] = y, 0;
        } else
          f = r(h);
        return h.values[o] = f, 1;
      }
    };
  }
}
function SD(t, e, n) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!n(t[r], e[r]))
      return !1;
  return !0;
}
function GS(t, e) {
  let n = !1;
  for (let r of e)
    id(t, r) & 1 && (n = !0);
  return n;
}
function qke(t, e, n) {
  let r = n.map((l) => t[l.id]), s = n.map((l) => l.type), i = r.filter((l) => !(l & 1)), o = t[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let h = ny(l, r[u]);
      if (s[u] == 2)
        for (let d of h)
          c.push(d);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of r)
        id(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!GS(l, i))
        return 0;
      let u = a(l);
      return e.compare(u, l.values[o]) ? 0 : (l.values[o] = u, 1);
    },
    reconfigure(l, c) {
      let u = GS(l, r), h = c.config.facets[e.id], d = c.facet(e);
      if (h && !u && Zk(n, h))
        return l.values[o] = d, 0;
      let f = a(l);
      return e.compare(f, d) ? (l.values[o] = d, 0) : (l.values[o] = f, 1);
    }
  };
}
const Sm = /* @__PURE__ */ ze.define({ static: !0 });
class En {
  constructor(e, n, r, s, i) {
    this.id = e, this.createF = n, this.updateF = r, this.compareF = s, this.spec = i, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let n = new En(Yk++, e.create, e.update, e.compare || ((r, s) => r === s), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(Sm).find((r) => r.field == this);
    return (n?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (r) => (r.values[n] = this.create(r), 1),
      update: (r, s) => {
        let i = r.values[n], o = this.updateF(i, s);
        return this.compareF(i, o) ? 0 : (r.values[n] = o, 1);
      },
      reconfigure: (r, s) => {
        let i = r.facet(Sm), o = s.facet(Sm), a;
        return (a = i.find((l) => l.field == this)) && a != o.find((l) => l.field == this) ? (r.values[n] = a.create(r), 1) : s.config.address[this.id] != null ? (r.values[n] = s.field(this), 0) : (r.values[n] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Sm.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Ba = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ah(t) {
  return (e) => new K7(e, t);
}
const _a = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ ah(Ba.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ ah(Ba.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ ah(Ba.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ ah(Ba.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ ah(Ba.lowest)
};
class K7 {
  constructor(e, n) {
    this.inner = e, this.prec = n;
  }
}
class Fu {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new VS(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Fu.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class VS {
  constructor(e, n) {
    this.compartment = e, this.inner = n;
  }
}
class ty {
  constructor(e, n, r, s, i, o) {
    for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = s, this.staticValues = i, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, r) {
    let s = [], i = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let d of Kke(e, n, o))
      d instanceof En ? s.push(d) : (i[d.facet.id] || (i[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let d of s)
      a[d.id] = c.length << 1, c.push((f) => d.slot(f));
    let u = r?.config.facets;
    for (let d in i) {
      let f = i[d], g = f[0].facet, y = u && u[d] || [];
      if (f.every(
        (p) => p.type == 0
        /* Provider.Static */
      ))
        if (a[g.id] = l.length << 1 | 1, Zk(y, f))
          l.push(r.facet(g));
        else {
          let p = g.combine(f.map((m) => m.value));
          l.push(r && g.compare(p, r.facet(g)) ? r.facet(g) : p);
        }
      else {
        for (let p of f)
          p.type == 0 ? (a[p.id] = l.length << 1 | 1, l.push(p.value)) : (a[p.id] = c.length << 1, c.push((m) => p.dynamicSlot(m)));
        a[g.id] = c.length << 1, c.push((p) => qke(p, g, f));
      }
    }
    let h = c.map((d) => d(a));
    return new ty(e, o, h, a, l, i);
  }
}
function Kke(t, e, n) {
  let r = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function i(o, a) {
    let l = s.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = r[l].indexOf(o);
      c > -1 && r[l].splice(c, 1), o instanceof VS && n.delete(o.compartment);
    }
    if (s.set(o, a), Array.isArray(o))
      for (let c of o)
        i(c, a);
    else if (o instanceof VS) {
      if (n.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      n.set(o.compartment, c), i(c, a);
    } else if (o instanceof K7)
      i(o.inner, o.prec);
    else if (o instanceof En)
      r[a].push(o), o.provides && i(o.provides, a);
    else if (o instanceof Tg)
      r[a].push(o), o.facet.extensions && i(o.facet.extensions, Ba.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      i(c, a);
    }
  }
  return i(t, Ba.default), r.reduce((o, a) => o.concat(a));
}
function id(t, e) {
  if (e & 1)
    return 2;
  let n = e >> 1, r = t.status[n];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  t.status[n] = 4;
  let s = t.computeSlot(t, t.config.dynamicSlots[n]);
  return t.status[n] = 2 | s;
}
function ny(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const Y7 = /* @__PURE__ */ ze.define(), WS = /* @__PURE__ */ ze.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), Z7 = /* @__PURE__ */ ze.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), J7 = /* @__PURE__ */ ze.define(), X7 = /* @__PURE__ */ ze.define(), Q7 = /* @__PURE__ */ ze.define(), ez = /* @__PURE__ */ ze.define({
  combine: (t) => t.length ? t[0] : !1
});
class bo {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new Yke();
  }
}
class Yke {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new bo(this, e);
  }
}
class Zke {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new at(this, e);
  }
}
class at {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new at(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new Zke(e.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, n) {
    if (!e.length)
      return e;
    let r = [];
    for (let s of e) {
      let i = s.map(n);
      i && r.push(i);
    }
    return r;
  }
}
at.reconfigure = /* @__PURE__ */ at.define();
at.appendConfig = /* @__PURE__ */ at.define();
class sn {
  constructor(e, n, r, s, i, o) {
    this.startState = e, this.changes = n, this.selection = r, this.effects = s, this.annotations = i, this.scrollIntoView = o, this._doc = null, this._state = null, r && q7(r, n.newLength), i.some((a) => a.type == sn.time) || (this.annotations = i.concat(sn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, n, r, s, i, o) {
    return new sn(e, n, r, s, i, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let n of this.annotations)
      if (n.type == e)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let n = this.annotation(sn.userEvent);
    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
  }
}
sn.time = /* @__PURE__ */ bo.define();
sn.userEvent = /* @__PURE__ */ bo.define();
sn.addToHistory = /* @__PURE__ */ bo.define();
sn.remote = /* @__PURE__ */ bo.define();
function Jke(t, e) {
  let n = [];
  for (let r = 0, s = 0; ; ) {
    let i, o;
    if (r < t.length && (s == e.length || e[s] >= t[r]))
      i = t[r++], o = t[r++];
    else if (s < e.length)
      i = e[s++], o = e[s++];
    else
      return n;
    !n.length || n[n.length - 1] < i ? n.push(i, o) : n[n.length - 1] < o && (n[n.length - 1] = o);
  }
}
function tz(t, e, n) {
  var r;
  let s, i, o;
  return n ? (s = e.changes, i = un.empty(e.changes.length), o = t.changes.compose(e.changes)) : (s = e.changes.map(t.changes), i = t.changes.mapDesc(e.changes, !0), o = t.changes.compose(s)), {
    changes: o,
    selection: e.selection ? e.selection.map(i) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(s),
    effects: at.mapEffects(t.effects, s).concat(at.mapEffects(e.effects, i)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function qS(t, e, n) {
  let r = e.selection, s = Lc(e.annotations);
  return e.userEvent && (s = s.concat(sn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof un ? e.changes : un.of(e.changes || [], n, t.facet(Z7)),
    selection: r && (r instanceof Ae ? r : Ae.single(r.anchor, r.head)),
    effects: Lc(e.effects),
    annotations: s,
    scrollIntoView: !!e.scrollIntoView
  };
}
function nz(t, e, n) {
  let r = qS(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let i = 1; i < e.length; i++) {
    e[i].filter === !1 && (n = !1);
    let o = !!e[i].sequential;
    r = tz(r, qS(t, e[i], o ? r.changes.newLength : t.doc.length), o);
  }
  let s = sn.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return Qke(n ? Xke(s) : s);
}
function Xke(t) {
  let e = t.startState, n = !0;
  for (let s of e.facet(J7)) {
    let i = s(t);
    if (i === !1) {
      n = !1;
      break;
    }
    Array.isArray(i) && (n = n === !0 ? i : Jke(n, i));
  }
  if (n !== !0) {
    let s, i;
    if (n === !1)
      i = t.changes.invertedDesc, s = un.empty(e.doc.length);
    else {
      let o = t.changes.filter(n);
      s = o.changes, i = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    t = sn.create(e, s, t.selection && t.selection.map(i), at.mapEffects(t.effects, i), t.annotations, t.scrollIntoView);
  }
  let r = e.facet(X7);
  for (let s = r.length - 1; s >= 0; s--) {
    let i = r[s](t);
    i instanceof sn ? t = i : Array.isArray(i) && i.length == 1 && i[0] instanceof sn ? t = i[0] : t = nz(e, Lc(i), !1);
  }
  return t;
}
function Qke(t) {
  let e = t.startState, n = e.facet(Q7), r = t;
  for (let s = n.length - 1; s >= 0; s--) {
    let i = n[s](t);
    i && Object.keys(i).length && (r = tz(r, qS(e, i, t.changes.newLength), !0));
  }
  return r == t ? t : sn.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
}
const eAe = [];
function Lc(t) {
  return t == null ? eAe : Array.isArray(t) ? t : [t];
}
var on = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(on || (on = {}));
const tAe = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let KS;
try {
  KS = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function nAe(t) {
  if (KS)
    return KS.test(t);
  for (let e = 0; e < t.length; e++) {
    let n = t[e];
    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || tAe.test(n)))
      return !0;
  }
  return !1;
}
function rAe(t) {
  return (e) => {
    if (!/\S/.test(e))
      return on.Space;
    if (nAe(e))
      return on.Word;
    for (let n = 0; n < t.length; n++)
      if (e.indexOf(t[n]) > -1)
        return on.Word;
    return on.Other;
  };
}
class pt {
  constructor(e, n, r, s, i, o) {
    this.config = e, this.doc = n, this.selection = r, this.values = s, this.status = e.statusTemplate.slice(), this.computeSlot = i, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      id(this, a << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return id(this, r), ny(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return nz(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let n = this.config, { base: r, compartments: s } = n;
    for (let a of e.effects)
      a.is(Fu.reconfigure) ? (n && (s = /* @__PURE__ */ new Map(), n.compartments.forEach((l, c) => s.set(c, l)), n = null), s.set(a.value.compartment, a.value.extension)) : a.is(at.reconfigure) ? (n = null, r = a.value) : a.is(at.appendConfig) && (n = null, r = Lc(r).concat(a.value));
    let i;
    n ? i = e.startState.values.slice() : (n = ty.resolve(r, s, this), i = new pt(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(WS) ? e.newSelection : e.newSelection.asSingle();
    new pt(n, e.newDoc, o, i, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: e },
      range: Ae.cursor(n.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let n = this.selection, r = e(n.ranges[0]), s = this.changes(r.changes), i = [r.range], o = Lc(r.effects);
    for (let a = 1; a < n.ranges.length; a++) {
      let l = e(n.ranges[a]), c = this.changes(l.changes), u = c.map(s);
      for (let d = 0; d < a; d++)
        i[d] = i[d].map(u);
      let h = s.mapDesc(c, !0);
      i.push(l.range.map(h)), s = s.compose(u), o = at.mapEffects(o, u).concat(at.mapEffects(Lc(l.effects), h));
    }
    return {
      changes: s,
      selection: Ae.create(i, n.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof un ? e : un.of(e, this.doc.length, this.facet(pt.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Et.of(e.split(this.facet(pt.lineSeparator) || jS));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (id(this, n), ny(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let s = e[r];
        s instanceof En && this.config.address[s.id] != null && (n[r] = s.spec.toJSON(this.field(e[r]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, n = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (r) {
      for (let i in r)
        if (Object.prototype.hasOwnProperty.call(e, i)) {
          let o = r[i], a = e[i];
          s.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return pt.create({
      doc: e.doc,
      selection: Ae.fromJSON(e.selection),
      extensions: n.extensions ? s.concat([n.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let n = ty.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof Et ? e.doc : Et.of((e.doc || "").split(n.staticFacet(pt.lineSeparator) || jS)), s = e.selection ? e.selection instanceof Ae ? e.selection : Ae.single(e.selection.anchor, e.selection.head) : Ae.single(0);
    return q7(s, r.length), n.staticFacet(WS) || (s = s.asSingle()), new pt(n, r, s, n.dynamicSlots.map(() => null), (i, o) => o.create(i), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(pt.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(pt.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(ez);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...n) {
    for (let r of this.facet(pt.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, s) => {
      if (s == "$")
        return "$";
      let i = +(s || 1);
      return !i || i > n.length ? r : n[i - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, n, r = -1) {
    let s = [];
    for (let i of this.facet(Y7))
      for (let o of i(this, n, r))
        Object.prototype.hasOwnProperty.call(o, e) && s.push(o[e]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return rAe(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: n, from: r, length: s } = this.doc.lineAt(e), i = this.charCategorizer(e), o = e - r, a = e - r;
    for (; o > 0; ) {
      let l = An(n, o, !1);
      if (i(n.slice(l, o)) != on.Word)
        break;
      o = l;
    }
    for (; a < s; ) {
      let l = An(n, a);
      if (i(n.slice(a, l)) != on.Word)
        break;
      a = l;
    }
    return o == a ? null : Ae.range(o + r, a + r);
  }
}
pt.allowMultipleSelections = WS;
pt.tabSize = /* @__PURE__ */ ze.define({
  combine: (t) => t.length ? t[0] : 4
});
pt.lineSeparator = Z7;
pt.readOnly = ez;
pt.phrases = /* @__PURE__ */ ze.define({
  compare(t, e) {
    let n = Object.keys(t), r = Object.keys(e);
    return n.length == r.length && n.every((s) => t[s] == e[s]);
  }
});
pt.languageData = Y7;
pt.changeFilter = J7;
pt.transactionFilter = X7;
pt.transactionExtender = Q7;
Fu.reconfigure = /* @__PURE__ */ at.define();
function $l(t, e, n = {}) {
  let r = {};
  for (let s of t)
    for (let i of Object.keys(s)) {
      let o = s[i], a = r[i];
      if (a === void 0)
        r[i] = o;
      else if (!(a === o || o === void 0)) if (Object.hasOwnProperty.call(n, i))
        r[i] = n[i](a, o);
      else
        throw new Error("Config merge conflict for field " + i);
    }
  for (let s in e)
    r[s] === void 0 && (r[s] = e[s]);
  return r;
}
class vl {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, n = e) {
    return YS.create(e, n, this);
  }
}
vl.prototype.startSide = vl.prototype.endSide = 0;
vl.prototype.point = !1;
vl.prototype.mapMode = Fn.TrackDel;
let YS = class rz {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.value = r;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new rz(e, n, r);
  }
};
function ZS(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class Jk {
  constructor(e, n, r, s) {
    this.from = e, this.to = n, this.value = r, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, n, r, s = 0) {
    let i = r ? this.to : this.from;
    for (let o = s, a = i.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = i[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - n;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, n, r, s) {
    for (let i = this.findIndex(n, -1e9, !0), o = this.findIndex(r, 1e9, !1, i); i < o; i++)
      if (s(this.from[i] + e, this.to[i] + e, this.value[i]) === !1)
        return !1;
  }
  map(e, n) {
    let r = [], s = [], i = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], u = this.from[l] + e, h = this.to[l] + e, d, f;
      if (u == h) {
        let g = n.mapPos(u, c.startSide, c.mapMode);
        if (g == null || (d = f = g, c.startSide != c.endSide && (f = n.mapPos(u, c.endSide), f < d)))
          continue;
      } else if (d = n.mapPos(u, c.startSide), f = n.mapPos(h, c.endSide), d > f || d == f && c.startSide > 0 && c.endSide <= 0)
        continue;
      (f - d || c.endSide - c.startSide) < 0 || (o < 0 && (o = d), c.point && (a = Math.max(a, f - d)), r.push(c), s.push(d - o), i.push(f - o));
    }
    return { mapped: r.length ? new Jk(s, i, r, a) : null, pos: o };
  }
}
class _t {
  constructor(e, n, r, s) {
    this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = s;
  }
  /**
  @internal
  */
  static create(e, n, r, s) {
    return new _t(e, n, r, s);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk)
      e += n.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: n = [], sort: r = !1, filterFrom: s = 0, filterTo: i = this.length } = e, o = e.filter;
    if (n.length == 0 && !o)
      return this;
    if (r && (n = n.slice().sort(ZS)), this.isEmpty)
      return n.length ? _t.of(n) : this;
    let a = new sz(this, null, -1).goto(0), l = 0, c = [], u = new wl();
    for (; a.value || l < n.length; )
      if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
        let h = n[l++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!o || s > this.chunkEnd(a.chunkIndex) || i < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || s > a.to || i < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(YS.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? _t.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: s, filterTo: i }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let n = [], r = [], s = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        s = Math.max(s, l.maxPoint), n.push(l), r.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: u, pos: h } = l.map(a, e);
        u && (s = Math.max(s, u.maxPoint), n.push(u), r.push(h));
      }
    }
    let i = this.nextLayer.map(e);
    return n.length == 0 ? i : new _t(r, n, i || _t.empty, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, n, r) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let i = this.chunkPos[s], o = this.chunk[s];
        if (n >= i && e <= i + o.length && o.between(i, e - i, n - i, r) === !1)
          return;
      }
      this.nextLayer.between(e, n, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return nf.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, n = 0) {
    return nf.from(e).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, n, r, s, i = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= i), a = n.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= i), l = xD(o, a, r), c = new lh(o, l, i), u = new lh(a, l, i);
    r.iterGaps((h, d, f) => TD(c, h, u, d, f, s)), r.empty && r.length == 0 && TD(c, 0, u, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, n, r = 0, s) {
    s == null && (s = 999999999);
    let i = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0), o = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (i.length != o.length)
      return !1;
    if (!i.length)
      return !0;
    let a = xD(i, o), l = new lh(i, a, 0).goto(r), c = new lh(o, a, 0).goto(r);
    for (; ; ) {
      if (l.to != c.to || !JS(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > s)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, n, r, s, i = -1) {
    let o = new lh(e, null, i).goto(n), a = n, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let u = o.activeForPoint(o.to), h = o.pointFrom < n ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, l);
        s.point(a, c, o.point, u, h, o.pointRank), l = Math.min(o.openEnd(c), u.length);
      } else c > a && (s.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > r)
        return l + (o.point && o.to > r ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, n = !1) {
    let r = new wl();
    for (let s of e instanceof YS ? [e] : n ? sAe(e) : e)
      r.add(s.from, s.to, s.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return _t.empty;
    let n = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let s = e[r]; s != _t.empty; s = s.nextLayer)
        n = new _t(s.chunkPos, s.chunk, n, Math.max(s.maxPoint, n.maxPoint));
    return n;
  }
}
_t.empty = /* @__PURE__ */ new _t([], [], null, -1);
function sAe(t) {
  if (t.length > 1)
    for (let e = t[0], n = 1; n < t.length; n++) {
      let r = t[n];
      if (ZS(e, r) > 0)
        return t.slice().sort(ZS);
      e = r;
    }
  return t;
}
_t.empty.nextLayer = _t.empty;
class wl {
  finishChunk(e) {
    this.chunks.push(new Jk(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, n, r) {
    this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new wl())).add(e, n, r);
  }
  /**
  @internal
  */
  addInner(e, n, r) {
    let s = e - this.lastTo || r.startSide - this.last.endSide;
    if (s <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
    let r = n.value.length - 1;
    return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(_t.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let n = _t.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, n;
  }
}
function xD(t, e, n) {
  let r = /* @__PURE__ */ new Map();
  for (let i of t)
    for (let o = 0; o < i.chunk.length; o++)
      i.chunk[o].maxPoint <= 0 && r.set(i.chunk[o], i.chunkPos[o]);
  let s = /* @__PURE__ */ new Set();
  for (let i of e)
    for (let o = 0; o < i.chunk.length; o++) {
      let a = r.get(i.chunk[o]);
      a != null && (n ? n.mapPos(a) : a) == i.chunkPos[o] && !n?.touchesRange(a, a + i.chunk[o].length) && s.add(i.chunk[o]);
    }
  return s;
}
class sz {
  constructor(e, n, r, s = 0) {
    this.layer = e, this.skip = n, this.minPoint = r, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < e || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!r || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];
        if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class nf {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, r = -1) {
    let s = [];
    for (let i = 0; i < e.length; i++)
      for (let o = e[i]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && s.push(new sz(o, n, r, i));
    return s.length == 1 ? s[0] : new nf(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let r of this.heap)
      r.goto(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      rw(this.heap, r);
    return this.next(), this;
  }
  forward(e, n) {
    for (let r of this.heap)
      r.forward(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      rw(this.heap, r);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), rw(this.heap, 0);
    }
  }
}
function rw(t, e) {
  for (let n = t[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= t.length)
      break;
    let s = t[r];
    if (r + 1 < t.length && s.compare(t[r + 1]) >= 0 && (s = t[r + 1], r++), n.compare(s) < 0)
      break;
    t[r] = n, t[e] = s, e = r;
  }
}
class lh {
  constructor(e, n, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = nf.from(e, n, r);
  }
  goto(e, n = -1e9) {
    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    xm(this.active, e), xm(this.activeTo, e), xm(this.activeRank, e), this.minActive = CD(this.active, this.activeTo);
  }
  addActive(e) {
    let n = 0, { value: r, to: s, rank: i } = this.cursor;
    for (; n < this.activeRank.length && (i - this.activeRank[n] || s - this.activeTo[n]) > 0; )
      n++;
    Tm(this.active, n, r), Tm(this.activeTo, n, s), Tm(this.activeRank, n, i), e && Tm(e, n, this.cursor.from), this.minActive = CD(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s = this.minActive;
      if (s > -1 && (this.activeTo[s] - this.cursor.from || this.active[s].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[s] > e) {
          this.to = this.activeTo[s], this.endSide = this.active[s].endSide;
          break;
        }
        this.removeActive(s), r && xm(r, s);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let i = this.cursor.value;
          if (!i.point)
            this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = i, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = i.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let s = r.length - 1; s >= 0 && r[s] < e; s--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      n++;
    return n;
  }
}
function TD(t, e, n, r, s, i) {
  t.goto(e), n.goto(r);
  let o = r + s, a = r, l = r - e;
  for (; ; ) {
    let c = t.to + l - n.to, u = c || t.endSide - n.endSide, h = u < 0 ? t.to + l : n.to, d = Math.min(h, o);
    if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && JS(t.activeForPoint(t.to), n.activeForPoint(n.to)) || i.comparePoint(a, d, t.point, n.point) : d > a && !JS(t.active, n.active) && i.compareRange(a, d, t.active, n.active), h > o)
      break;
    (c || t.openEnd != n.openEnd) && i.boundChange && i.boundChange(h), a = h, u <= 0 && t.next(), u >= 0 && n.next();
  }
}
function JS(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] != e[n] && !t[n].eq(e[n]))
      return !1;
  return !0;
}
function xm(t, e) {
  for (let n = e, r = t.length - 1; n < r; n++)
    t[n] = t[n + 1];
  t.pop();
}
function Tm(t, e, n) {
  for (let r = t.length - 1; r >= e; r--)
    t[r + 1] = t[r];
  t[e] = n;
}
function CD(t, e) {
  let n = -1, r = 1e9;
  for (let s = 0; s < e.length; s++)
    (e[s] - r || t[s].endSide - t[n].endSide) < 0 && (n = s, r = e[s]);
  return n;
}
function Kb(t, e, n = t.length) {
  let r = 0;
  for (let s = 0; s < n && s < t.length; )
    t.charCodeAt(s) == 9 ? (r += e - r % e, s++) : (r++, s = An(t, s));
  return r;
}
function iAe(t, e, n, r) {
  for (let s = 0, i = 0; ; ) {
    if (i >= e)
      return s;
    if (s == t.length)
      break;
    i += t.charCodeAt(s) == 9 ? n - i % n : 1, s = An(t, s);
  }
  return t.length;
}
const XS = "", kD = typeof Symbol > "u" ? "__" + XS : Symbol.for(XS), QS = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), AD = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class ca {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function s(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function i(o, a, l, c) {
      let u = [], h = /^@(\w+)\b/.exec(o[0]), d = h && h[1] == "keyframes";
      if (h && a == null) return l.push(o[0] + ";");
      for (let f in a) {
        let g = a[f];
        if (/&/.test(f))
          i(
            f.split(/,\s*/).map((y) => o.map((p) => y.replace(/&/, p))).reduce((y, p) => y.concat(p)),
            g,
            l
          );
        else if (g && typeof g == "object") {
          if (!h) throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          i(s(f), g, u, d);
        } else g != null && u.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (y) => "-" + y.toLowerCase()) + ": " + g + ";");
      }
      (u.length || d) && l.push((r && !h && !c ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e) i(s(o), e[o], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = AD[kD] || 1;
    return AD[kD] = e + 1, XS + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, n, r) {
    let s = e[QS], i = r && r.nonce;
    s ? i && s.setNonce(i) : s = new oAe(e, i), s.mount(Array.isArray(n) ? n : [n], e);
  }
}
let RD = /* @__PURE__ */ new Map();
class oAe {
  constructor(e, n) {
    let r = e.ownerDocument || e, s = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && s.CSSStyleSheet) {
      let i = RD.get(r);
      if (i) return e[QS] = i;
      this.sheet = new s.CSSStyleSheet(), RD.set(r, this);
    } else
      this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], e[QS] = this;
  }
  mount(e, n) {
    let r = this.sheet, s = 0, i = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = this.modules.indexOf(a);
      if (l < i && l > -1 && (this.modules.splice(l, 1), i--, l = -1), l == -1) {
        if (this.modules.splice(i++, 0, a), r) for (let c = 0; c < a.rules.length; c++)
          r.insertRule(a.rules[c], s++);
      } else {
        for (; i < l; ) s += this.modules[i++].rules.length;
        s += a.rules.length, i++;
      }
    }
    if (r)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let o = "";
      for (let l = 0; l < this.modules.length; l++)
        o += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = o;
      let a = n.head || n;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var ua = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, rf = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, aAe = typeof navigator < "u" && /Mac/.test(navigator.platform), lAe = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var kn = 0; kn < 10; kn++) ua[48 + kn] = ua[96 + kn] = String(kn);
for (var kn = 1; kn <= 24; kn++) ua[kn + 111] = "F" + kn;
for (var kn = 65; kn <= 90; kn++)
  ua[kn] = String.fromCharCode(kn + 32), rf[kn] = String.fromCharCode(kn);
for (var sw in ua) rf.hasOwnProperty(sw) || (rf[sw] = ua[sw]);
function cAe(t) {
  var e = aAe && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || lAe && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? rf : ua)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function sf(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function ex(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Cg(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return ex(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function of(t) {
  return t.nodeType == 3 ? Sl(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function od(t, e, n, r) {
  return n ? ID(t, e, n, r, -1) || ID(t, e, n, r, 1) : !1;
}
function El(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function ry(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function ID(t, e, n, r, s) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (s < 0 ? 0 : ki(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let i = t.parentNode;
      if (!i || i.nodeType != 1)
        return !1;
      e = El(t) + (s < 0 ? 0 : 1), t = i;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (s < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = s < 0 ? ki(t) : 0;
    } else
      return !1;
  }
}
function ki(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Yb(t, e) {
  let n = e ? t.left : t.right;
  return { left: n, right: n, top: t.top, bottom: t.bottom };
}
function uAe(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function iz(t, e) {
  let n = e.width / t.offsetWidth, r = e.height / t.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), { scaleX: n, scaleY: r };
}
function hAe(t, e, n, r, s, i, o, a) {
  let l = t.ownerDocument, c = l.defaultView || window;
  for (let u = t, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let d, f = u == l.body, g = 1, y = 1;
      if (f)
        d = uAe(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let b = u.getBoundingClientRect();
        ({ scaleX: g, scaleY: y } = iz(u, b)), d = {
          left: b.left,
          right: b.left + u.clientWidth * g,
          top: b.top,
          bottom: b.top + u.clientHeight * y
        };
      }
      let p = 0, m = 0;
      if (s == "nearest")
        e.top < d.top ? (m = -(d.top - e.top + o), n > 0 && e.bottom > d.bottom + m && (m = e.bottom - d.bottom + m + o)) : e.bottom > d.bottom && (m = e.bottom - d.bottom + o, n < 0 && e.top - m < d.top && (m = -(d.top + m - e.top + o)));
      else {
        let b = e.bottom - e.top, _ = d.bottom - d.top;
        m = (s == "center" && b <= _ ? e.top + b / 2 - _ / 2 : s == "start" || s == "center" && n < 0 ? e.top - o : e.bottom - _ + o) - d.top;
      }
      if (r == "nearest" ? e.left < d.left ? (p = -(d.left - e.left + i), n > 0 && e.right > d.right + p && (p = e.right - d.right + p + i)) : e.right > d.right && (p = e.right - d.right + i, n < 0 && e.left < d.left + p && (p = -(d.left + p - e.left + i))) : p = (r == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : r == "start" == a ? e.left - i : e.right - (d.right - d.left) + i) - d.left, p || m)
        if (f)
          c.scrollBy(p, m);
        else {
          let b = 0, _ = 0;
          if (m) {
            let v = u.scrollTop;
            u.scrollTop += m / y, _ = (u.scrollTop - v) * y;
          }
          if (p) {
            let v = u.scrollLeft;
            u.scrollLeft += p / g, b = (u.scrollLeft - v) * g;
          }
          e = {
            left: e.left - b,
            top: e.top - _,
            right: e.right - b,
            bottom: e.bottom - _
          }, b && Math.abs(b - p) < 1 && (r = "nearest"), _ && Math.abs(_ - m) < 1 && (s = "nearest");
        }
      if (f)
        break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function dAe(t) {
  let e = t.ownerDocument, n, r;
  for (let s = t.parentNode; s && !(s == e.body || n && r); )
    if (s.nodeType == 1)
      !r && s.scrollHeight > s.clientHeight && (r = s), !n && s.scrollWidth > s.clientWidth && (n = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: n, y: r };
}
class fAe {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: n, focusNode: r } = e;
    this.set(n, Math.min(e.anchorOffset, n ? ki(n) : 0), r, Math.min(e.focusOffset, r ? ki(r) : 0));
  }
  set(e, n, r, s) {
    this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = s;
  }
}
let Ql = null;
function oz(t) {
  if (t.setActive)
    return t.setActive();
  if (Ql)
    return t.focus(Ql);
  let e = [];
  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (t.focus(Ql == null ? {
    get preventScroll() {
      return Ql = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ql) {
    Ql = !1;
    for (let n = 0; n < e.length; ) {
      let r = e[n++], s = e[n++], i = e[n++];
      r.scrollTop != s && (r.scrollTop = s), r.scrollLeft != i && (r.scrollLeft = i);
    }
  }
}
let PD;
function Sl(t, e, n = e) {
  let r = PD || (PD = document.createRange());
  return r.setEnd(t, n), r.setStart(t, e), r;
}
function Mc(t, e, n, r) {
  let s = { key: e, code: e, keyCode: n, which: n, cancelable: !0 };
  r && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = r);
  let i = new KeyboardEvent("keydown", s);
  i.synthetic = !0, t.dispatchEvent(i);
  let o = new KeyboardEvent("keyup", s);
  return o.synthetic = !0, t.dispatchEvent(o), i.defaultPrevented || o.defaultPrevented;
}
function pAe(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function az(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function mAe(t, e) {
  let n = e.focusNode, r = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, ki(n)); ; )
    if (r) {
      if (n.nodeType != 1)
        return !1;
      let s = n.childNodes[r - 1];
      s.contentEditable == "false" ? r-- : (n = s, r = ki(n));
    } else {
      if (n == t)
        return !0;
      r = El(n), n = n.parentNode;
    }
}
function lz(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function cz(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r > 0)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r - 1], r = ki(n);
    } else if (n.parentNode && !ry(n))
      r = El(n), n = n.parentNode;
    else
      return null;
  }
}
function uz(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r < n.nodeValue.length)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r], r = 0;
    } else if (n.parentNode && !ry(n))
      r = El(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class $n {
  constructor(e, n, r = !0) {
    this.node = e, this.offset = n, this.precise = r;
  }
  static before(e, n) {
    return new $n(e.parentNode, El(e), n);
  }
  static after(e, n) {
    return new $n(e.parentNode, El(e) + 1, n);
  }
}
const Xk = [];
class It {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let r = this.dom, s = null, i;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (i = s ? s.nextSibling : r.firstChild)) {
            let a = It.get(i);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(i);
          }
          o.sync(e, n), o.flags &= -8;
        }
        if (i = s ? s.nextSibling : r.firstChild, n && !n.written && n.node == r && i != o.dom && (n.written = !0), o.dom.parentNode == r)
          for (; i && i != o.dom; )
            i = OD(i);
        else
          r.insertBefore(o.dom, i);
        s = o.dom;
      }
      for (i = s ? s.nextSibling : r.firstChild, i && n && n.node == r && (n.written = !0); i; )
        i = OD(i);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, n), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, n) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[n];
    else {
      let s = ki(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let i = e.parentNode;
        if (i == this.dom)
          break;
        s == 0 && i.firstChild != i.lastChild && (e == i.firstChild ? s = -1 : s = 1), e = i;
      }
      s < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !It.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let s = 0, i = 0; ; s++) {
      let o = this.children[s];
      if (o.dom == r)
        return i;
      i += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, n, r = 0) {
    let s = -1, i = -1, o = -1, a = -1;
    for (let l = 0, c = r, u = r; l < this.children.length; l++) {
      let h = this.children[l], d = c + h.length;
      if (c < e && d > n)
        return h.domBoundsAround(e, n, c);
      if (d >= e && s == -1 && (s = l, i = c), c > n && h.dom.parentNode == this.dom) {
        o = l, a = u;
        break;
      }
      u = d, c = d + h.breakAfter;
    }
    return {
      from: i,
      to: a < 0 ? r + this.length : a,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if (e && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n)
        return e;
      e = n;
    }
  }
  replaceChildren(e, n, r = Xk) {
    this.markDirty();
    for (let s = e; s < n; s++) {
      let i = this.children[s];
      i.parent == this && r.indexOf(i) < 0 && i.destroy();
    }
    r.length < 250 ? this.children.splice(e, n - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(n));
    for (let s = 0; s < r.length; s++)
      r[s].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new hz(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, r, s, i, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
It.prototype.breakAfter = 0;
function OD(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class hz {
  constructor(e, n, r) {
    this.children = e, this.pos = n, this.i = r, this.off = 0;
  }
  findPos(e, n = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function dz(t, e, n, r, s, i, o, a, l) {
  let { children: c } = t, u = c.length ? c[e] : null, h = i.length ? i[i.length - 1] : null, d = h ? h.breakAfter : o;
  if (!(e == r && u && !o && !d && i.length < 2 && u.merge(n, s, i.length ? h : null, n == 0, a, l))) {
    if (r < c.length) {
      let f = c[r];
      f && (s < f.length || f.breakAfter && h?.breakAfter) ? (e == r && (f = f.split(s), s = 0), !d && h && f.merge(0, s, h, !0, 0, l) ? i[i.length - 1] = f : ((s || f.children.length && !f.children[0].length) && f.merge(0, s, null, !1, 0, l), i.push(f))) : f?.breakAfter && (h ? h.breakAfter = 1 : o = 1), r++;
    }
    for (u && (u.breakAfter = o, n > 0 && (!o && i.length && u.merge(n, u.length, i[0], !1, a, 0) ? u.breakAfter = i.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, !1, a, 0), e++)); e < r && i.length; )
      if (c[r - 1].become(i[i.length - 1]))
        r--, i.pop(), l = i.length ? 0 : a;
      else if (c[e].become(i[0]))
        e++, i.shift(), a = i.length ? 0 : l;
      else
        break;
    !i.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < r || i.length) && t.replaceChildren(e, r, i);
  }
}
function fz(t, e, n, r, s, i) {
  let o = t.childCursor(), { i: a, off: l } = o.findPos(n, 1), { i: c, off: u } = o.findPos(e, -1), h = e - n;
  for (let d of r)
    h += d.length;
  t.length += h, dz(t, c, u, a, l, r, 0, s, i);
}
let dr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, tx = typeof document < "u" ? document : { documentElement: { style: {} } };
const nx = /* @__PURE__ */ /Edge\/(\d+)/.exec(dr.userAgent), pz = /* @__PURE__ */ /MSIE \d/.test(dr.userAgent), rx = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(dr.userAgent), Zb = !!(pz || rx || nx), DD = !Zb && /* @__PURE__ */ /gecko\/(\d+)/i.test(dr.userAgent), iw = !Zb && /* @__PURE__ */ /Chrome\/(\d+)/.exec(dr.userAgent), ND = "webkitFontSmoothing" in tx.documentElement.style, mz = !Zb && /* @__PURE__ */ /Apple Computer/.test(dr.vendor), LD = mz && (/* @__PURE__ */ /Mobile\/\w+/.test(dr.userAgent) || dr.maxTouchPoints > 2);
var Fe = {
  mac: LD || /* @__PURE__ */ /Mac/.test(dr.platform),
  windows: /* @__PURE__ */ /Win/.test(dr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(dr.platform),
  ie: Zb,
  ie_version: pz ? tx.documentMode || 6 : rx ? +rx[1] : nx ? +nx[1] : 0,
  gecko: DD,
  gecko_version: DD ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(dr.userAgent) || [0, 0])[1] : 0,
  chrome: !!iw,
  chrome_version: iw ? +iw[1] : 0,
  ios: LD,
  android: /* @__PURE__ */ /Android\b/.test(dr.userAgent),
  webkit: ND,
  safari: mz,
  webkit_version: ND ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(dr.userAgent) || [0, 0])[1] : 0,
  tabSize: tx.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const gAe = 256;
class As extends It {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, r) {
    return this.flags & 8 || r && (!(r instanceof As) || this.length - (n - e) + r.length > gAe || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(e) {
    let n = new As(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new $n(this.dom, e);
  }
  domBoundsAround(e, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return yAe(this.dom, e, n);
  }
}
class fo extends It {
  constructor(e, n = [], r = 0) {
    super(), this.mark = e, this.children = n, this.length = r;
    for (let s of n)
      s.setParent(this);
  }
  setAttrs(e) {
    if (az(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
  }
  merge(e, n, r, s, i, o) {
    return r && (!(r instanceof fo && r.mark.eq(this.mark)) || e && i <= 0 || n < this.length && o <= 0) ? !1 : (fz(this, e, n, r ? r.children.slice() : [], i - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [], r = 0, s = -1, i = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > e && n.push(r < e ? a.split(e - r) : a), s < 0 && r >= e && (s = i), r = l, i++;
    }
    let o = this.length - e;
    return this.length = e, s > -1 && (this.children.length = s, this.markDirty()), new fo(this.mark, n, o);
  }
  domAtPos(e) {
    return gz(this, e);
  }
  coordsAt(e, n) {
    return bz(this, e, n);
  }
}
function yAe(t, e, n) {
  let r = t.nodeValue.length;
  e > r && (e = r);
  let s = e, i = e, o = 0;
  e == 0 && n < 0 || e == r && n >= 0 ? Fe.chrome || Fe.gecko || (e ? (s--, o = 1) : i < r && (i++, o = -1)) : n < 0 ? s-- : i < r && i++;
  let a = Sl(t, s, i).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : n >= 0) ? 0 : a.length - 1];
  return Fe.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? Yb(l, o < 0) : l || null;
}
class Va extends It {
  static create(e, n, r) {
    return new Va(e, n, r);
  }
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let n = Va.create(this.widget, this.length - e, this.side);
    return this.length -= e, n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, r, s, i, o) {
    return r && (!(r instanceof Va) || !this.widget.compare(r.widget) || e > 0 && i <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);
  }
  become(e) {
    return e instanceof Va && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Et.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: n } = e, r = n && n.state.doc, s = this.posAtStart;
    return r ? r.slice(s, s + this.length) : Et.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? $n.before(this.dom) : $n.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    if (r)
      return r;
    let s = this.dom.getClientRects(), i = null;
    if (!s.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? s.length - 1 : 0; i = s[a], !(e > 0 ? a == 0 : a == s.length - 1 || i.top < i.bottom); a += o ? -1 : 1)
      ;
    return Yb(i, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class du extends It {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof du && e.side == this.side;
  }
  split() {
    return new du(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? $n.before(this.dom) : $n.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Et.empty;
  }
  get isHidden() {
    return !0;
  }
}
As.prototype.children = Va.prototype.children = du.prototype.children = Xk;
function gz(t, e) {
  let n = t.dom, { children: r } = t, s = 0;
  for (let i = 0; s < r.length; s++) {
    let o = r[s], a = i + o.length;
    if (!(a == i && o.getSide() <= 0)) {
      if (e > i && e < a && o.dom.parentNode == n)
        return o.domAtPos(e - i);
      if (e <= i)
        break;
      i = a;
    }
  }
  for (let i = s; i > 0; i--) {
    let o = r[i - 1];
    if (o.dom.parentNode == n)
      return o.domAtPos(o.length);
  }
  for (let i = s; i < r.length; i++) {
    let o = r[i];
    if (o.dom.parentNode == n)
      return o.domAtPos(0);
  }
  return new $n(n, 0);
}
function yz(t, e, n) {
  let r, { children: s } = t;
  n > 0 && e instanceof fo && s.length && (r = s[s.length - 1]) instanceof fo && r.mark.eq(e.mark) ? yz(r, e.children[0], n - 1) : (s.push(e), e.setParent(t)), t.length += e.length;
}
function bz(t, e, n) {
  let r = null, s = -1, i = null, o = -1;
  function a(c, u) {
    for (let h = 0, d = 0; h < c.children.length && d <= u; h++) {
      let f = c.children[h], g = d + f.length;
      g >= u && (f.children.length ? a(f, u - d) : (!i || i.isHidden && n > 0) && (g > u || d == g && f.getSide() > 0) ? (i = f, o = u - d) : (d < u || d == g && f.getSide() < 0 && !f.isHidden) && (r = f, s = u - d)), d = g;
    }
  }
  a(t, e);
  let l = (n < 0 ? r : i) || r || i;
  return l ? l.coordsAt(Math.max(0, l == r ? s : o), n) : bAe(t);
}
function bAe(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let n = of(e);
  return n[n.length - 1] || null;
}
function sx(t, e) {
  for (let n in t)
    n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
  return e;
}
const MD = /* @__PURE__ */ Object.create(null);
function sy(t, e, n) {
  if (t == e)
    return !0;
  t || (t = MD), e || (e = MD);
  let r = Object.keys(t), s = Object.keys(e);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != s.length - (n && s.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let i of r)
    if (i != n && (s.indexOf(i) == -1 || t[i] !== e[i]))
      return !1;
  return !0;
}
function ix(t, e, n) {
  let r = !1;
  if (e)
    for (let s in e)
      n && s in n || (r = !0, s == "style" ? t.style.cssText = "" : t.removeAttribute(s));
  if (n)
    for (let s in n)
      e && e[s] == n[s] || (r = !0, s == "style" ? t.style.cssText = n[s] : t.setAttribute(s, n[s]));
  return r;
}
function _Ae(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < t.attributes.length; n++) {
    let r = t.attributes[n];
    e[r.name] = r.value;
  }
  return e;
}
class $u {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, n, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Qn = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Qn || (Qn = {}));
class yt extends vl {
  constructor(e, n, r, s) {
    super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new fp(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new ha(e, n, n, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let n = !!e.block, r, s;
    if (e.isBlockGap)
      r = -5e8, s = 4e8;
    else {
      let { start: i, end: o } = _z(e, n);
      r = (i ? n ? -3e8 : -1 : 5e8) - 1, s = (o ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new ha(e, r, s, n, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new pp(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, n = !1) {
    return _t.of(e, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
yt.none = _t.empty;
class fp extends yt {
  constructor(e) {
    let { start: n, end: r } = _z(e);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var n, r;
    return this == e || e instanceof fp && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && sy(this.attrs, e.attrs, "class");
  }
  range(e, n = e) {
    if (e >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
fp.prototype.point = !1;
class pp extends yt {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof pp && this.spec.class == e.spec.class && sy(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
pp.prototype.mapMode = Fn.TrackBefore;
pp.prototype.point = !0;
class ha extends yt {
  constructor(e, n, r, s, i, o) {
    super(n, r, i, e), this.block = s, this.isReplace = o, this.mapMode = s ? n <= 0 ? Fn.TrackBefore : Fn.TrackAfter : Fn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Qn.WidgetRange : this.startSide <= 0 ? Qn.WidgetBefore : Qn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof ha && vAe(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
ha.prototype.point = !0;
function _z(t, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: r } = t;
  return n == null && (n = t.inclusive), r == null && (r = t.inclusive), { start: n ?? e, end: r ?? e };
}
function vAe(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function kg(t, e, n, r = 0) {
  let s = n.length - 1;
  s >= 0 && n[s] + r >= t ? n[s] = Math.max(n[s], e) : n.push(t, e);
}
class tn extends It {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, n, r, s, i, o) {
    if (r) {
      if (!(r instanceof tn))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return s && this.setDeco(r ? r.attrs : null), fz(this, e, n, r ? r.children.slice() : [], i, o), !0;
  }
  split(e) {
    let n = new tn();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: r, off: s } = this.childPos(e);
    s && (n.append(this.children[r].split(s), 0), this.children[r].merge(s, this.children[r].length, null, !1, 0, 0), r++);
    for (let i = r; i < this.children.length; i++)
      n.append(this.children[i], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, n;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    sy(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, n) {
    yz(this, e, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let n = e.spec.attributes, r = e.spec.class;
    n && (this.attrs = sx(n, this.attrs || {})), r && (this.attrs = sx({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return gz(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    var r;
    this.dom ? this.flags & 4 && (az(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (ix(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
    let s = this.dom.lastChild;
    for (; s && It.get(s) instanceof fo; )
      s = s.lastChild;
    if (!s || !this.length || s.nodeName != "BR" && ((r = It.get(s)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!Fe.ios || !this.children.some((i) => i instanceof As))) {
      let i = document.createElement("BR");
      i.cmIgnore = !0, this.dom.appendChild(i);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, n;
    for (let r of this.children) {
      if (!(r instanceof As) || /[^ -~]/.test(r.text))
        return null;
      let s = of(r.dom);
      if (s.length != 1)
        return null;
      e += s[0].width, n = s[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(e, n) {
    let r = bz(this, e, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: s } = this.parent.view.viewState, i = r.bottom - r.top;
      if (Math.abs(i - s.lineHeight) < 2 && s.textHeight < i) {
        let o = (i - s.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof tn && this.children.length == 0 && e.children.length == 0 && sy(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let r = 0, s = 0; r < e.children.length; r++) {
      let i = e.children[r], o = s + i.length;
      if (o >= n) {
        if (i instanceof tn)
          return i;
        if (o > n)
          break;
      }
      s = o + i.breakAfter;
    }
    return null;
  }
}
class io extends It {
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, n, r, s, i, o) {
    return r && (!(r instanceof io) || !this.widget.compare(r.widget) || e > 0 && i <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);
  }
  domAtPos(e) {
    return e == 0 ? $n.before(this.dom) : $n.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let r = new io(this.widget, n, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return Xk;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Et.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof io && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    return r || (this.widget instanceof ox ? null : Yb(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? !1 : e < 0 ? n < 0 : r > 0;
  }
}
class ox extends $u {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class ad {
  constructor(e, n, r, s) {
    this.doc = e, this.pos = n, this.end = r, this.disallowBlockEffectsFor = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof io && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new tn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Cm(new du(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof io) && this.getLine();
  }
  buildText(e, n, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: i, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = i, this.textOff = 0;
      }
      let s = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - r)), this.getLine().append(Cm(new As(this.text.slice(this.textOff, this.textOff + s)), n), r), this.atCursorPos = !0, this.textOff += s, e -= s, r = 0;
    }
  }
  span(e, n, r, s) {
    this.buildText(n - e, r, s), this.pos = n, this.openStart < 0 && (this.openStart = s);
  }
  point(e, n, r, s, i, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof ha) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = n - e;
    if (r instanceof ha)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new io(r.widget || fu.block, a, r));
      else {
        let l = Va.create(r.widget || fu.inline, a, a ? 0 : r.startSide), c = this.atCursorPos && !l.isEditable && i <= s.length && (e < n || r.startSide > 0), u = !l.isEditable && (e < n || i > s.length || r.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(s), c && (h.append(Cm(new du(1), s), i), i = s.length + Math.max(0, i - s.length)), h.append(Cm(l, s), i), this.atCursorPos = u, this.pendingBuffer = u ? e < n || i > s.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = i);
  }
  static build(e, n, r, s, i) {
    let o = new ad(e, n, r, i);
    return o.openEnd = _t.spans(s, n, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Cm(t, e) {
  for (let n of e)
    t = new fo(n, [t], t.length);
  return t;
}
class fu extends $u {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
fu.inline = /* @__PURE__ */ new fu("span");
fu.block = /* @__PURE__ */ new fu("div");
var jt = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(jt || (jt = {}));
const xl = jt.LTR, Qk = jt.RTL;
function vz(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    e.push(1 << +t[n]);
  return e;
}
const wAe = /* @__PURE__ */ vz("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), EAe = /* @__PURE__ */ vz("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), ax = /* @__PURE__ */ Object.create(null), Us = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), n = /* @__PURE__ */ t.charCodeAt(1);
  ax[e] = n, ax[n] = -e;
}
function wz(t) {
  return t <= 247 ? wAe[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? EAe[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const SAe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class zo {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? Qk : xl;
  }
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.level = r;
  }
  /**
  @internal
  */
  side(e, n) {
    return this.dir == n == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, n) {
    return e == (this.dir == n);
  }
  /**
  @internal
  */
  static find(e, n, r, s) {
    let i = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= n && a.to >= n) {
        if (a.level == r)
          return o;
        (i < 0 || (s != 0 ? s < 0 ? a.from < n : a.to > n : e[i].level > a.level)) && (i = o);
      }
    }
    if (i < 0)
      throw new RangeError("Index out of range");
    return i;
  }
}
function Ez(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++) {
    let r = t[n], s = e[n];
    if (r.from != s.from || r.to != s.to || r.direction != s.direction || !Ez(r.inner, s.inner))
      return !1;
  }
  return !0;
}
const Rt = [];
function xAe(t, e, n, r, s) {
  for (let i = 0; i <= r.length; i++) {
    let o = i ? r[i - 1].to : e, a = i < r.length ? r[i].from : n, l = i ? 256 : s;
    for (let c = o, u = l, h = l; c < a; c++) {
      let d = wz(t.charCodeAt(c));
      d == 512 ? d = u : d == 8 && h == 4 && (d = 16), Rt[c] = d == 4 ? 2 : d, d & 7 && (h = d), u = d;
    }
    for (let c = o, u = l, h = l; c < a; c++) {
      let d = Rt[c];
      if (d == 128)
        c < a - 1 && u == Rt[c + 1] && u & 24 ? d = Rt[c] = u : Rt[c] = 256;
      else if (d == 64) {
        let f = c + 1;
        for (; f < a && Rt[f] == 64; )
          f++;
        let g = c && u == 8 || f < n && Rt[f] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let y = c; y < f; y++)
          Rt[y] = g;
        c = f - 1;
      } else d == 8 && h == 1 && (Rt[c] = 1);
      u = d, d & 7 && (h = d);
    }
  }
}
function TAe(t, e, n, r, s) {
  let i = s == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, u = o < r.length ? r[o].from : n;
    for (let h = c, d, f, g; h < u; h++)
      if (f = ax[d = t.charCodeAt(h)])
        if (f < 0) {
          for (let y = a - 3; y >= 0; y -= 3)
            if (Us[y + 1] == -f) {
              let p = Us[y + 2], m = p & 2 ? s : p & 4 ? p & 1 ? i : s : 0;
              m && (Rt[h] = Rt[Us[y]] = m), a = y;
              break;
            }
        } else {
          if (Us.length == 189)
            break;
          Us[a++] = h, Us[a++] = d, Us[a++] = l;
        }
      else if ((g = Rt[h]) == 2 || g == 1) {
        let y = g == s;
        l = y ? 0 : 1;
        for (let p = a - 3; p >= 0; p -= 3) {
          let m = Us[p + 2];
          if (m & 2)
            break;
          if (y)
            Us[p + 2] |= 2;
          else {
            if (m & 4)
              break;
            Us[p + 2] |= 4;
          }
        }
      }
  }
}
function CAe(t, e, n, r) {
  for (let s = 0, i = r; s <= n.length; s++) {
    let o = s ? n[s - 1].to : t, a = s < n.length ? n[s].from : e;
    for (let l = o; l < a; ) {
      let c = Rt[l];
      if (c == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (s == n.length)
              break;
            u = n[s++].to, a = s < n.length ? n[s].from : e;
          } else if (Rt[u] == 256)
            u++;
          else
            break;
        let h = i == 1, d = (u < e ? Rt[u] : r) == 1, f = h == d ? h ? 1 : 2 : r;
        for (let g = u, y = s, p = y ? n[y - 1].to : t; g > l; )
          g == p && (g = n[--y].from, p = y ? n[y - 1].to : t), Rt[--g] = f;
        l = u;
      } else
        i = c, l++;
    }
  }
}
function lx(t, e, n, r, s, i, o) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == s % 2)
    for (let l = e, c = 0; l < n; ) {
      let u = !0, h = !1;
      if (c == i.length || l < i[c].from) {
        let y = Rt[l];
        y != a && (u = !1, h = y == 16);
      }
      let d = !u && a == 1 ? [] : null, f = u ? r : r + 1, g = l;
      e: for (; ; )
        if (c < i.length && g == i[c].from) {
          if (h)
            break e;
          let y = i[c];
          if (!u)
            for (let p = y.to, m = c + 1; ; ) {
              if (p == n)
                break e;
              if (m < i.length && i[m].from == p)
                p = i[m++].to;
              else {
                if (Rt[p] == a)
                  break e;
                break;
              }
            }
          if (c++, d)
            d.push(y);
          else {
            y.from > l && o.push(new zo(l, y.from, f));
            let p = y.direction == xl != !(f % 2);
            cx(t, p ? r + 1 : r, s, y.inner, y.from, y.to, o), l = y.to;
          }
          g = y.to;
        } else {
          if (g == n || (u ? Rt[g] != a : Rt[g] == a))
            break;
          g++;
        }
      d ? lx(t, l, g, r + 1, s, d, o) : l < g && o.push(new zo(l, g, f)), l = g;
    }
  else
    for (let l = n, c = i.length; l > e; ) {
      let u = !0, h = !1;
      if (!c || l > i[c - 1].to) {
        let y = Rt[l - 1];
        y != a && (u = !1, h = y == 16);
      }
      let d = !u && a == 1 ? [] : null, f = u ? r : r + 1, g = l;
      e: for (; ; )
        if (c && g == i[c - 1].to) {
          if (h)
            break e;
          let y = i[--c];
          if (!u)
            for (let p = y.from, m = c; ; ) {
              if (p == e)
                break e;
              if (m && i[m - 1].to == p)
                p = i[--m].from;
              else {
                if (Rt[p - 1] == a)
                  break e;
                break;
              }
            }
          if (d)
            d.push(y);
          else {
            y.to < l && o.push(new zo(y.to, l, f));
            let p = y.direction == xl != !(f % 2);
            cx(t, p ? r + 1 : r, s, y.inner, y.from, y.to, o), l = y.from;
          }
          g = y.from;
        } else {
          if (g == e || (u ? Rt[g - 1] != a : Rt[g - 1] == a))
            break;
          g--;
        }
      d ? lx(t, g, l, r + 1, s, d, o) : g < l && o.push(new zo(g, l, f)), l = g;
    }
}
function cx(t, e, n, r, s, i, o) {
  let a = e % 2 ? 2 : 1;
  xAe(t, s, i, r, a), TAe(t, s, i, r, a), CAe(s, i, r, a), lx(t, s, i, e, n, r, o);
}
function kAe(t, e, n) {
  if (!t)
    return [new zo(0, 0, e == Qk ? 1 : 0)];
  if (e == xl && !n.length && !SAe.test(t))
    return Sz(t.length);
  if (n.length)
    for (; t.length > Rt.length; )
      Rt[Rt.length] = 256;
  let r = [], s = e == xl ? 0 : 1;
  return cx(t, s, s, n, 0, t.length, r), r;
}
function Sz(t) {
  return [new zo(0, t, 0)];
}
let xz = "";
function AAe(t, e, n, r, s) {
  var i;
  let o = r.head - t.from, a = zo.find(e, o, (i = r.bidiLevel) !== null && i !== void 0 ? i : -1, r.assoc), l = e[a], c = l.side(s, n);
  if (o == c) {
    let d = a += s ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    l = e[a = d], o = l.side(!s, n), c = l.side(s, n);
  }
  let u = An(t.text, o, l.forward(s, n));
  (u < l.from || u > l.to) && (u = c), xz = t.text.slice(Math.min(o, u), Math.max(o, u));
  let h = a == (s ? e.length - 1 : 0) ? null : e[a + (s ? 1 : -1)];
  return h && u == c && h.level + (s ? 0 : 1) < l.level ? Ae.cursor(h.side(!s, n) + t.from, h.forward(s, n) ? 1 : -1, h.level) : Ae.cursor(u + t.from, l.forward(s, n) ? -1 : 1, l.level);
}
function RAe(t, e, n) {
  for (let r = e; r < n; r++) {
    let s = wz(t.charCodeAt(r));
    if (s == 1)
      return xl;
    if (s == 2 || s == 4)
      return Qk;
  }
  return xl;
}
const Tz = /* @__PURE__ */ ze.define(), Cz = /* @__PURE__ */ ze.define(), kz = /* @__PURE__ */ ze.define(), Az = /* @__PURE__ */ ze.define(), ux = /* @__PURE__ */ ze.define(), Rz = /* @__PURE__ */ ze.define(), Iz = /* @__PURE__ */ ze.define(), eA = /* @__PURE__ */ ze.define(), tA = /* @__PURE__ */ ze.define(), Pz = /* @__PURE__ */ ze.define({
  combine: (t) => t.some((e) => e)
}), Oz = /* @__PURE__ */ ze.define({
  combine: (t) => t.some((e) => e)
}), Dz = /* @__PURE__ */ ze.define();
class Bc {
  constructor(e, n = "nearest", r = "nearest", s = 5, i = 5, o = !1) {
    this.range = e, this.y = n, this.x = r, this.yMargin = s, this.xMargin = i, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new Bc(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Bc(Ae.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const km = /* @__PURE__ */ at.define({ map: (t, e) => t.map(e) }), Nz = /* @__PURE__ */ at.define();
function Pr(t, e, n) {
  let r = t.facet(Az);
  r.length ? r[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
}
const eo = /* @__PURE__ */ ze.define({ combine: (t) => t.length ? t[0] : !0 });
let IAe = 0;
const Ah = /* @__PURE__ */ ze.define();
class In {
  constructor(e, n, r, s, i) {
    this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = s, this.extension = i(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, n) {
    const { eventHandlers: r, eventObservers: s, provide: i, decorations: o } = n || {};
    return new In(IAe++, e, r, s, (a) => {
      let l = [Ah.of(a)];
      return o && l.push(af.of((c) => {
        let u = c.plugin(a);
        return u ? o(u) : yt.none;
      })), i && l.push(i(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, n) {
    return In.define((r) => new e(r), n);
  }
}
class ow {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (r) {
            if (Pr(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        Pr(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Pr(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Lz = /* @__PURE__ */ ze.define(), Jb = /* @__PURE__ */ ze.define(), af = /* @__PURE__ */ ze.define(), Mz = /* @__PURE__ */ ze.define(), nA = /* @__PURE__ */ ze.define(), Bz = /* @__PURE__ */ ze.define();
function BD(t, e) {
  let n = t.state.facet(Bz);
  if (!n.length)
    return n;
  let r = n.map((i) => i instanceof Function ? i(t) : i), s = [];
  return _t.spans(r, e.from, e.to, {
    point() {
    },
    span(i, o, a, l) {
      let c = i - e.from, u = o - e.from, h = s;
      for (let d = a.length - 1; d >= 0; d--, l--) {
        let f = a[d].spec.bidiIsolate, g;
        if (f == null && (f = RAe(e.text, c, u)), l > 0 && h.length && (g = h[h.length - 1]).to == c && g.direction == f)
          g.to = u, h = g.inner;
        else {
          let y = { from: c, to: u, direction: f, inner: [] };
          h.push(y), h = y.inner;
        }
      }
    }
  }), s;
}
const Fz = /* @__PURE__ */ ze.define();
function rA(t) {
  let e = 0, n = 0, r = 0, s = 0;
  for (let i of t.state.facet(Fz)) {
    let o = i(t);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (n = Math.max(n, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (s = Math.max(s, o.bottom)));
  }
  return { left: e, right: n, top: r, bottom: s };
}
const Rh = /* @__PURE__ */ ze.define();
class Qr {
  constructor(e, n, r, s) {
    this.fromA = e, this.toA = n, this.fromB = r, this.toB = s;
  }
  join(e) {
    return new Qr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length, r = this;
    for (; n > 0; n--) {
      let s = e[n - 1];
      if (!(s.fromA > r.toA)) {
        if (s.toA < r.fromA)
          break;
        r = r.join(s), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, r), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0)
      return e;
    let r = [];
    for (let s = 0, i = 0, o = 0, a = 0; ; s++) {
      let l = s == e.length ? null : e[s], c = o - a, u = l ? l.fromB : 1e9;
      for (; i < n.length && n[i] < u; ) {
        let h = n[i], d = n[i + 1], f = Math.max(a, h), g = Math.min(u, d);
        if (f <= g && new Qr(f + c, g + c, f, g).addToSet(r), d > u)
          break;
        i += 2;
      }
      if (!l)
        return r;
      new Qr(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), o = l.toA, a = l.toB;
    }
  }
}
class iy {
  constructor(e, n, r) {
    this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = un.empty(this.startState.doc.length);
    for (let i of r)
      this.changes = this.changes.compose(i.changes);
    let s = [];
    this.changes.iterChangedRanges((i, o, a, l) => s.push(new Qr(i, o, a, l))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new iy(e, n, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class FD extends It {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = yt.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new tn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Qr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var n;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? s = this.domChanged.newSel.head : !BAe(e.changes, this.hasComposition) && !e.selectionSet && (s = e.state.selection.main.head));
    let i = s > -1 ? OAe(this.view, e.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new Qr(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    this.hasComposition = i ? { from: i.range.fromB, to: i.range.toB } : null, (Fe.ie || Fe.chrome) && !i && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = LAe(o, a, e.changes);
    return r = Qr.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, i), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, n, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, r);
    let { observer: s } = this.view;
    s.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = Fe.chrome || Fe.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || s.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let i = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof io && o.widget instanceof ox && i.push(o.dom);
    s.updateGaps(i);
  }
  updateChildren(e, n, r) {
    let s = r ? r.range.addToSet(e.slice()) : e, i = this.childCursor(n);
    for (let o = s.length - 1; ; o--) {
      let a = o >= 0 ? s[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: u, toB: h } = a, d, f, g, y;
      if (r && r.range.fromB < h && r.range.toB > u) {
        let v = ad.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), w = ad.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        f = v.breakAtStart, g = v.openStart, y = w.openEnd;
        let E = this.compositionView(r);
        w.breakAtStart ? E.breakAfter = 1 : w.content.length && E.merge(E.length, E.length, w.content[0], !1, w.openStart, 0) && (E.breakAfter = w.content[0].breakAfter, w.content.shift()), v.content.length && E.merge(0, 0, v.content[v.content.length - 1], !0, 0, v.openEnd) && v.content.pop(), d = v.content.concat(E).concat(w.content);
      } else
        ({ content: d, breakAtStart: f, openStart: g, openEnd: y } = ad.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: p, off: m } = i.findPos(c, 1), { i: b, off: _ } = i.findPos(l, -1);
      dz(this, b, _, p, m, d, f, g, y);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let n of e.transactions)
      for (let r of n.effects)
        r.is(Nz) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let n = new As(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: s } of e.marks)
      n = new fo(s, [n], n.length);
    let r = new tn();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(e) {
    let n = (i, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = It.get(i);
      a && a != o && (a.dom = null), o.setDOM(i);
    }, r = this.childPos(e.range.fromB, 1), s = this.children[r.i];
    n(e.line, s);
    for (let i = e.marks.length - 1; i >= -1; i--)
      r = s.childPos(r.off, 1), s = s.children[r.i], n(i >= 0 ? e.marks[i].node : e.text, s);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, s = r == this.dom, i = !s && !(this.view.state.facet(eo) || this.dom.tabIndex > -1) && Cg(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(s || n || i))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (Fe.gecko && a.empty && !this.hasComposition && PAe(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = c = new $n(h, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!od(l.node, l.offset, u.anchorNode, u.anchorOffset) || !od(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
      Fe.android && Fe.chrome && this.dom.contains(u.focusNode) && MAe(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = sf(this.view.root);
      if (h) if (a.empty) {
        if (Fe.gecko) {
          let d = DAe(l.node, l.offset);
          if (d && d != 3) {
            let f = (d == 1 ? cz : uz)(l.node, l.offset);
            f && (l = new $n(f.node, f.offset));
          }
        }
        h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
      } else if (h.extend) {
        h.collapse(l.node, l.offset);
        try {
          h.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let d = document.createRange();
        a.anchor > a.head && ([l, c] = [c, l]), d.setEnd(c.node, c.offset), d.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(d);
      }
      i && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new $n(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new $n(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, n) {
    return this.hasComposition && n.empty && od(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, n = e.state.selection.main, r = sf(e.root), { anchorNode: s, anchorOffset: i } = e.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify)
      return;
    let o = tn.find(this, n.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (n.head == a || n.head == a + o.length)
      return;
    let l = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let u = this.domAtPos(n.head + n.assoc);
    r.collapse(u.node, u.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != n.from && r.collapse(s, i);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let n = this.dom, r;
    if (e.node != n)
      return e;
    for (let s = e.offset; !r && s < n.childNodes.length; s++) {
      let i = It.get(n.childNodes[s]);
      i instanceof tn && (r = i.domAtPos(0));
    }
    for (let s = e.offset - 1; !r && s >= 0; s--) {
      let i = It.get(n.childNodes[s]);
      i instanceof tn && (r = i.domAtPos(i.length));
    }
    return r ? new $n(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let r = It.get(n);
      if (r && r.rootView == this)
        return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, n) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: r } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let s = this.children[n];
      if (r < s.length || s instanceof tn)
        break;
      n++, r = 0;
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(e, n) {
    let r = null, s = 0;
    for (let i = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = i - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof tn && !(r instanceof tn && n >= 0)))
        r = a, s = c;
      else if (r && c == e && l == e && a instanceof io && Math.abs(n) < 2) {
        if (a.deco.startSide < 0)
          break;
        o && (r = null);
      }
      i = c;
    }
    return r ? r.coordsAt(e - s, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: r } = this.childPos(e, 1), s = this.children[n];
    if (!(s instanceof tn))
      return null;
    for (; s.children.length; ) {
      let { i: a, off: l } = s.childPos(r, 1);
      for (; ; a++) {
        if (a == s.children.length)
          return null;
        if ((s = s.children[a]).length)
          break;
      }
      r = l;
    }
    if (!(s instanceof As))
      return null;
    let i = An(s.text, r);
    if (i == r)
      return null;
    let o = Sl(s.dom, r, i).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [], { from: r, to: s } = e, i = this.view.contentDOM.clientWidth, o = i > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == jt.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u], d = c + h.length;
      if (d > s)
        break;
      if (c >= r) {
        let f = h.dom.getBoundingClientRect();
        if (n.push(f.height), o) {
          let g = h.dom.lastChild, y = g ? of(g) : [];
          if (y.length) {
            let p = y[y.length - 1], m = l ? p.right - f.left : f.right - p.left;
            m > a && (a = m, this.minWidth = i, this.minWidthFrom = c, this.minWidthTo = d);
          }
        }
      }
      c = d + h.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? jt.RTL : jt.LTR;
  }
  measureTextSize() {
    for (let i of this.children)
      if (i instanceof tn) {
        let o = i.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), n, r, s;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let i = of(e.firstChild)[0];
      n = e.getBoundingClientRect().height, r = i ? i.width / 27 : 7, s = i ? i.height : n, e.remove();
    }), { lineHeight: n, charWidth: r, textHeight: s };
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new hz(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [], n = this.view.viewState;
    for (let r = 0, s = 0; ; s++) {
      let i = s == n.viewports.length ? null : n.viewports[s], o = i ? i.from - 1 : this.length;
      if (o > r) {
        let a = (n.lineBlockAt(o).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        e.push(yt.replace({
          widget: new ox(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!i)
        break;
      r = i.to + 1;
    }
    return yt.set(e);
  }
  updateDeco() {
    let e = 1, n = this.view.state.facet(af).map((i) => (this.dynamicDecorationMap[e++] = typeof i == "function") ? i(this.view) : i), r = !1, s = this.view.state.facet(Mz).map((i, o) => {
      let a = typeof i == "function";
      return a && (r = !0), a ? i(this.view) : i;
    });
    for (s.length && (this.dynamicDecorationMap[e++] = r, n.push(_t.join(s))), this.decorations = [
      this.editContextFormatting,
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(Dz))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (u) {
        Pr(this.view.state, u, "scroll handler");
      }
    let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), s;
    if (!r)
      return;
    !n.empty && (s = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, s.left),
      top: Math.min(r.top, s.top),
      right: Math.max(r.right, s.right),
      bottom: Math.max(r.bottom, s.bottom)
    });
    let i = rA(this.view), o = {
      left: r.left - i.left,
      top: r.top - i.top,
      right: r.right + i.right,
      bottom: r.bottom + i.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    hAe(this.view.scrollDOM, o, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == jt.LTR);
  }
}
function PAe(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
function $z(t, e) {
  let n = t.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let r = cz(n.focusNode, n.focusOffset), s = uz(n.focusNode, n.focusOffset), i = r || s;
  if (s && r && s.node != r.node) {
    let a = It.get(s.node);
    if (!a || a instanceof As && a.text != s.node.nodeValue)
      i = s;
    else if (t.docView.lastCompositionAfterCursor) {
      let l = It.get(r.node);
      !l || l instanceof As && l.text != r.node.nodeValue || (i = s);
    }
  }
  if (t.docView.lastCompositionAfterCursor = i != r, !i)
    return null;
  let o = e - i.offset;
  return { from: o, to: o + i.node.nodeValue.length, node: i.node };
}
function OAe(t, e, n) {
  let r = $z(t, n);
  if (!r)
    return null;
  let { node: s, from: i, to: o } = r, a = s.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(r.from, r.to) != a)
    return null;
  let l = e.invertedDesc, c = new Qr(l.mapPos(i), l.mapPos(o), i, o), u = [];
  for (let h = s.parentNode; ; h = h.parentNode) {
    let d = It.get(h);
    if (d instanceof fo)
      u.push({ node: h, deco: d.mark });
    else {
      if (d instanceof tn || h.nodeName == "DIV" && h.parentNode == t.contentDOM)
        return { range: c, text: s, marks: u, line: h };
      if (h != t.contentDOM)
        u.push({ node: h, deco: new fp({
          inclusive: !0,
          attributes: _Ae(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function DAe(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let NAe = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    kg(e, n, this.changes);
  }
  comparePoint(e, n) {
    kg(e, n, this.changes);
  }
  boundChange(e) {
    kg(e, e, this.changes);
  }
};
function LAe(t, e, n) {
  let r = new NAe();
  return _t.compare(t, e, n, r), r.changes;
}
function MAe(t, e) {
  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function BAe(t, e) {
  let n = !1;
  return e && t.iterChangedRanges((r, s) => {
    r < e.to && s > e.from && (n = !0);
  }), n;
}
function FAe(t, e, n = 1) {
  let r = t.charCategorizer(e), s = t.doc.lineAt(e), i = e - s.from;
  if (s.length == 0)
    return Ae.cursor(e);
  i == 0 ? n = 1 : i == s.length && (n = -1);
  let o = i, a = i;
  n < 0 ? o = An(s.text, i, !1) : a = An(s.text, i);
  let l = r(s.text.slice(o, a));
  for (; o > 0; ) {
    let c = An(s.text, o, !1);
    if (r(s.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < s.length; ) {
    let c = An(s.text, a);
    if (r(s.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return Ae.range(o + s.from, a + s.from);
}
function $Ae(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function UAe(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function aw(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function $D(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function UD(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function hx(t, e, n) {
  let r, s, i, o, a = !1, l, c, u, h;
  for (let g = t.firstChild; g; g = g.nextSibling) {
    let y = of(g);
    for (let p = 0; p < y.length; p++) {
      let m = y[p];
      s && aw(s, m) && (m = $D(UD(m, s.bottom), s.top));
      let b = $Ae(e, m), _ = UAe(n, m);
      if (b == 0 && _ == 0)
        return g.nodeType == 3 ? jD(g, e, n) : hx(g, e, n);
      if (!r || o > _ || o == _ && i > b) {
        r = g, s = m, i = b, o = _;
        let v = _ ? n < m.top ? -1 : 1 : b ? e < m.left ? -1 : 1 : 0;
        a = !v || (v > 0 ? p < y.length - 1 : p > 0);
      }
      b == 0 ? n > m.bottom && (!u || u.bottom < m.bottom) ? (l = g, u = m) : n < m.top && (!h || h.top > m.top) && (c = g, h = m) : u && aw(u, m) ? u = UD(u, m.bottom) : h && aw(h, m) && (h = $D(h, m.top));
    }
  }
  if (u && u.bottom >= n ? (r = l, s = u) : h && h.top <= n && (r = c, s = h), !r)
    return { node: t, offset: 0 };
  let d = Math.max(s.left, Math.min(s.right, e));
  if (r.nodeType == 3)
    return jD(r, d, n);
  if (a && r.contentEditable != "false")
    return hx(r, d, n);
  let f = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: t, offset: f };
}
function jD(t, e, n) {
  let r = t.nodeValue.length, s = -1, i = 1e9, o = 0;
  for (let a = 0; a < r; a++) {
    let l = Sl(t, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let h = (u.top > n ? u.top - n : n - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < i) {
        let d = e >= (u.left + u.right) / 2, f = d;
        if ((Fe.chrome || Fe.gecko) && Sl(t, a).getBoundingClientRect().left == u.right && (f = !d), h <= 0)
          return { node: t, offset: a + (f ? 1 : 0) };
        s = a + (f ? 1 : 0), i = h;
      }
    }
  }
  return { node: t, offset: s > -1 ? s : o > 0 ? t.nodeValue.length : 0 };
}
function Uz(t, e, n, r = -1) {
  var s, i;
  let o = t.contentDOM.getBoundingClientRect(), a = o.top + t.viewState.paddingTop, l, { docHeight: c } = t.viewState, { x: u, y: h } = e, d = h - a;
  if (d < 0)
    return 0;
  if (d > c)
    return t.state.doc.length;
  for (let v = t.viewState.heightOracle.textHeight / 2, w = !1; l = t.elementAtHeight(d), l.type != Qn.Text; )
    for (; d = r > 0 ? l.bottom + v : l.top - v, !(d >= 0 && d <= c); ) {
      if (w)
        return n ? null : 0;
      w = !0, r = -r;
    }
  h = a + d;
  let f = l.from;
  if (f < t.viewport.from)
    return t.viewport.from == 0 ? 0 : n ? null : HD(t, o, l, u, h);
  if (f > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : HD(t, o, l, u, h);
  let g = t.dom.ownerDocument, y = t.root.elementFromPoint ? t.root : g, p = y.elementFromPoint(u, h);
  p && !t.contentDOM.contains(p) && (p = null), p || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), p = y.elementFromPoint(u, h), p && !t.contentDOM.contains(p) && (p = null));
  let m, b = -1;
  if (p && ((s = t.docView.nearest(p)) === null || s === void 0 ? void 0 : s.isEditable) != !1) {
    if (g.caretPositionFromPoint) {
      let v = g.caretPositionFromPoint(u, h);
      v && ({ offsetNode: m, offset: b } = v);
    } else if (g.caretRangeFromPoint) {
      let v = g.caretRangeFromPoint(u, h);
      v && ({ startContainer: m, startOffset: b } = v, (!t.contentDOM.contains(m) || Fe.safari && jAe(m, b, u) || Fe.chrome && HAe(m, b, u)) && (m = void 0));
    }
    m && (b = Math.min(ki(m), b));
  }
  if (!m || !t.docView.dom.contains(m)) {
    let v = tn.find(t.docView, f);
    if (!v)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: m, offset: b } = hx(v.dom, u, h));
  }
  let _ = t.docView.nearest(m);
  if (!_)
    return null;
  if (_.isWidget && ((i = _.dom) === null || i === void 0 ? void 0 : i.nodeType) == 1) {
    let v = _.dom.getBoundingClientRect();
    return e.y < v.top || e.y <= v.bottom && e.x <= (v.left + v.right) / 2 ? _.posAtStart : _.posAtEnd;
  } else
    return _.localPosFromDOM(m, b) + _.posAtStart;
}
function HD(t, e, n, r, s) {
  let i = Math.round((r - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, l = Math.floor((s - n.top - (t.defaultLineHeight - a) * 0.5) / a);
    i += l * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(n.from, n.to);
  return n.from + iAe(o, i, t.state.tabSize);
}
function jAe(t, e, n) {
  let r;
  if (t.nodeType != 3 || e != (r = t.nodeValue.length))
    return !1;
  for (let s = t.nextSibling; s; s = s.nextSibling)
    if (s.nodeType != 1 || s.nodeName != "BR")
      return !1;
  return Sl(t, r - 1, r).getBoundingClientRect().left > n;
}
function HAe(t, e, n) {
  if (e != 0)
    return !1;
  for (let s = t; ; ) {
    let i = s.parentNode;
    if (!i || i.nodeType != 1 || i.firstChild != s)
      return !1;
    if (i.classList.contains("cm-line"))
      break;
    s = i;
  }
  let r = t.nodeType == 1 ? t.getBoundingClientRect() : Sl(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function dx(t, e) {
  let n = t.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    for (let r of n.type)
      if (r.to > e || r.to == e && (r.to == n.to || r.type == Qn.Text))
        return r;
  }
  return n;
}
function zAe(t, e, n, r) {
  let s = dx(t, e.head), i = !r || s.type != Qn.Text || !(t.lineWrapping || s.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > s.from ? e.head - 1 : e.head);
  if (i) {
    let o = t.dom.getBoundingClientRect(), a = t.textDirectionAt(s.from), l = t.posAtCoords({
      x: n == (a == jt.LTR) ? o.right - 1 : o.left + 1,
      y: (i.top + i.bottom) / 2
    });
    if (l != null)
      return Ae.cursor(l, n ? -1 : 1);
  }
  return Ae.cursor(n ? s.to : s.from, n ? -1 : 1);
}
function zD(t, e, n, r) {
  let s = t.state.doc.lineAt(e.head), i = t.bidiSpans(s), o = t.textDirectionAt(s.from);
  for (let a = e, l = null; ; ) {
    let c = AAe(s, i, o, a, n), u = xz;
    if (!c) {
      if (s.number == (n ? t.state.doc.lines : 1))
        return a;
      u = `
`, s = t.state.doc.line(s.number + (n ? 1 : -1)), i = t.bidiSpans(s), c = t.visualLineSide(s, !n);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!r)
        return c;
      l = r(u);
    }
    a = c;
  }
}
function GAe(t, e, n) {
  let r = t.state.charCategorizer(e), s = r(n);
  return (i) => {
    let o = r(i);
    return s == on.Space && (s = o), s == o;
  };
}
function VAe(t, e, n, r) {
  let s = e.head, i = n ? 1 : -1;
  if (s == (n ? t.state.doc.length : 0))
    return Ae.cursor(s, e.assoc);
  let o = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(s, e.assoc || -1), u = t.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = i < 0 ? c.top : c.bottom;
  else {
    let f = t.viewState.lineBlockAt(s);
    o == null && (o = Math.min(l.right - l.left, t.defaultCharacterWidth * (s - f.from))), a = (i < 0 ? f.top : f.bottom) + u;
  }
  let h = l.left + o, d = r ?? t.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let g = a + (d + f) * i, y = Uz(t, { x: h, y: g }, !1, i);
    if (g < l.top || g > l.bottom || (i < 0 ? y < s : y > s)) {
      let p = t.docView.coordsForChar(y), m = !p || g < p.top ? -1 : 1;
      return Ae.cursor(y, m, void 0, o);
    }
  }
}
function Ag(t, e, n) {
  for (; ; ) {
    let r = 0;
    for (let s of t)
      s.between(e - 1, e + 1, (i, o, a) => {
        if (e > i && e < o) {
          let l = r || n || (e - i < o - e ? -1 : 1);
          e = l < 0 ? i : o, r = l;
        }
      });
    if (!r)
      return e;
  }
}
function lw(t, e, n) {
  let r = Ag(t.state.facet(nA).map((s) => s(t)), n.from, e.head > n.from ? -1 : 1);
  return r == n.from ? n : Ae.cursor(r, r < n.from ? 1 : -1);
}
const Ih = "";
class WAe {
  constructor(e, n) {
    this.points = e, this.text = "", this.lineSeparator = n.facet(pt.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Ih;
  }
  readRange(e, n) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let s = e; ; ) {
      this.findPointBefore(r, s);
      let i = this.text.length;
      this.readNode(s);
      let o = s.nextSibling;
      if (o == n)
        break;
      let a = It.get(s), l = It.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : ry(s)) || ry(o) && (s.nodeName != "BR" || s.cmIgnore) && this.text.length > i) && this.lineBreak(), s = o;
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let i = -1, o = 1, a;
      if (this.lineSeparator ? (i = n.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (a = s.exec(n)) && (i = a.index, o = a[0].length), this.append(n.slice(r, i < 0 ? n.length : i)), i < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      r = i + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let n = It.get(e), r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let s = r.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (qAe(e, r.node, r.offset) ? n : 0));
  }
}
function qAe(t, e, n) {
  for (; ; ) {
    if (!e || n < ki(e))
      return !1;
    if (e == t)
      return !0;
    n = El(e) + 1, e = e.parentNode;
  }
}
class GD {
  constructor(e, n) {
    this.node = e, this.offset = n, this.pos = -1;
  }
}
class KAe {
  constructor(e, n, r, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = n > -1;
    let { impreciseHead: i, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
      let a = i || o ? [] : JAe(e), l = new WAe(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = XAe(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = i && i.node == a.focusNode && i.offset == a.focusOffset || !ex(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !ex(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
      if ((Fe.ios || Fe.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(l, c), d = Math.max(l, c), f = u.from - h, g = u.to - d;
        (f == 0 || f == 1 || h == 0) && (g == 0 || g == -1 || d == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = Ae.single(c, l);
    }
  }
}
function jz(t, e) {
  let n, { newSel: r } = e, s = t.state.selection.main, i = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = s.from, c = null;
    (i === 8 || Fe.android && e.text.length < a - o) && (l = s.to, c = "end");
    let u = ZAe(t.state.doc.sliceString(o, a, Ih), e.text, l - o, c);
    u && (Fe.chrome && i == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Ih + Ih && u.toB--, n = {
      from: o + u.from,
      to: o + u.toA,
      insert: Et.of(e.text.slice(u.from, u.toB).split(Ih))
    });
  } else r && (!t.hasFocus && t.state.facet(eo) || r.main.eq(s)) && (r = null);
  if (!n && !r)
    return !1;
  if (!n && e.typeOver && !s.empty && r && r.main.empty ? n = { from: s.from, to: s.to, insert: t.state.doc.slice(s.from, s.to) } : (Fe.mac || Fe.android) && n && n.from == n.to && n.from == s.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = Ae.single(r.main.anchor - 1, r.main.head - 1)), n = { from: n.from, to: n.to, insert: Et.of([n.insert.toString().replace(".", " ")]) }) : n && n.from >= s.from && n.to <= s.to && (n.from != s.from || n.to != s.to) && s.to - s.from - (n.to - n.from) <= 4 ? n = {
    from: s.from,
    to: s.to,
    insert: t.state.doc.slice(s.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, s.to))
  } : Fe.chrome && n && n.from == n.to && n.from == s.head && n.insert.toString() == `
 ` && t.lineWrapping && (r && (r = Ae.single(r.main.anchor - 1, r.main.head - 1)), n = { from: s.from, to: s.to, insert: Et.of([" "]) }), n)
    return sA(t, n, r, i);
  if (r && !r.main.eq(s)) {
    let o = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (o = !0), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: r, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function sA(t, e, n, r = -1) {
  if (Fe.ios && t.inputState.flushIOSKey(e))
    return !0;
  let s = t.state.selection.main;
  if (Fe.android && (e.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == s.from || e.from == s.from - 1 && t.state.sliceDoc(e.from, s.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Mc(t.contentDOM, "Enter", 13) || (e.from == s.from - 1 && e.to == s.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > s.head) && Mc(t.contentDOM, "Backspace", 8) || e.from == s.from && e.to == s.to + 1 && e.insert.length == 0 && Mc(t.contentDOM, "Delete", 46)))
    return !0;
  let i = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let o, a = () => o || (o = YAe(t, e, n));
  return t.state.facet(Rz).some((l) => l(t, e.from, e.to, i, a)) || t.dispatch(a()), !0;
}
function YAe(t, e, n) {
  let r, s = t.state, i = s.selection.main;
  if (e.from >= i.from && e.to <= i.to && e.to - e.from >= (i.to - i.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let a = i.from < e.from ? s.sliceDoc(i.from, e.from) : "", l = i.to > e.to ? s.sliceDoc(e.to, i.to) : "";
    r = s.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l));
  } else {
    let a = s.changes(e), l = n && n.main.to <= a.newLength ? n.main : void 0;
    if (s.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= i.to && e.to >= i.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), u, h = n && $z(t, n.main.head);
      if (h) {
        let g = e.insert.length - (e.to - e.from);
        u = { from: h.from, to: h.to - g };
      } else
        u = t.state.doc.lineAt(i.head);
      let d = i.to - e.to, f = i.to - i.from;
      r = s.changeByRange((g) => {
        if (g.from == i.from && g.to == i.to)
          return { changes: a, range: l || g.map(a) };
        let y = g.to - d, p = y - c.length;
        if (g.to - g.from != f || t.state.sliceDoc(p, y) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        g.to >= u.from && g.from <= u.to)
          return { range: g };
        let m = s.changes({ from: p, to: y, insert: e.insert }), b = g.to - i.to;
        return {
          changes: m,
          range: l ? Ae.range(Math.max(0, l.anchor + b), Math.max(0, l.head + b)) : g.map(m)
        };
      });
    } else
      r = {
        changes: a,
        selection: l && s.selection.replaceRange(l)
      };
  }
  let o = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, o += ".compose", t.inputState.compositionFirstChange && (o += ".start", t.inputState.compositionFirstChange = !1)), s.update(r, { userEvent: o, scrollIntoView: !0 });
}
function ZAe(t, e, n, r) {
  let s = Math.min(t.length, e.length), i = 0;
  for (; i < s && t.charCodeAt(i) == e.charCodeAt(i); )
    i++;
  if (i == s && t.length == e.length)
    return null;
  let o = t.length, a = e.length;
  for (; o > 0 && a > 0 && t.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (r == "end") {
    let l = Math.max(0, i - Math.min(o, a));
    n -= o + l - i;
  }
  if (o < i && t.length < e.length) {
    let l = n <= i && n >= o ? i - n : 0;
    i -= l, a = i + (a - o), o = i;
  } else if (a < i) {
    let l = n <= i && n >= a ? i - n : 0;
    i -= l, o = i + (o - a), a = i;
  }
  return { from: i, toA: o, toB: a };
}
function JAe(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: n, anchorOffset: r, focusNode: s, focusOffset: i } = t.observer.selectionRange;
  return n && (e.push(new GD(n, r)), (s != n || i != r) && e.push(new GD(s, i))), e;
}
function XAe(t, e) {
  if (t.length == 0)
    return null;
  let n = t[0].pos, r = t.length == 2 ? t[1].pos : n;
  return n > -1 && r > -1 ? Ae.single(n + e, r + e) : null;
}
class QAe {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, Fe.safari && e.contentDOM.addEventListener("input", () => null), Fe.gecko && m2e(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !a2e(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, n) {
    let r = this.handlers[e];
    if (r) {
      for (let s of r.observers)
        s(this.view, n);
      for (let s of r.handlers) {
        if (n.defaultPrevented)
          break;
        if (s(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = e2e(e), r = this.handlers, s = this.view.contentDOM;
    for (let i in n)
      if (i != "scroll") {
        let o = !n[i].handlers.length, a = r[i];
        a && o != !a.handlers.length && (s.removeEventListener(i, this.handleEvent), a = null), a || s.addEventListener(i, this.handleEvent, { passive: o });
      }
    for (let i in r)
      i != "scroll" && !n[i] && s.removeEventListener(i, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && zz.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), Fe.android && Fe.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return Fe.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = Hz.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || t2e.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Mc(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : Fe.safari && !Fe.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function VD(t, e) {
  return (n, r) => {
    try {
      return e.call(t, r, n);
    } catch (s) {
      Pr(n.state, s);
    }
  };
}
function e2e(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of t) {
    let s = r.spec;
    if (s && s.domEventHandlers)
      for (let i in s.domEventHandlers) {
        let o = s.domEventHandlers[i];
        o && n(i).handlers.push(VD(r.value, o));
      }
    if (s && s.domEventObservers)
      for (let i in s.domEventObservers) {
        let o = s.domEventObservers[i];
        o && n(i).observers.push(VD(r.value, o));
      }
  }
  for (let r in Rs)
    n(r).handlers.push(Rs[r]);
  for (let r in os)
    n(r).observers.push(os[r]);
  return e;
}
const Hz = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], t2e = "dthko", zz = [16, 17, 18, 20, 91, 92, 224, 225], Am = 6;
function Rm(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function n2e(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class r2e {
  constructor(e, n, r, s) {
    this.view = e, this.startEvent = n, this.style = r, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = dAe(e.contentDOM), this.atoms = e.state.facet(nA).map((o) => o(e));
    let i = e.contentDOM.ownerDocument;
    i.addEventListener("mousemove", this.move = this.move.bind(this)), i.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(pt.allowMultipleSelections) && s2e(e, n), this.dragging = o2e(e, n) && Wz(n) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && n2e(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, r = 0, s = 0, i = 0, o = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: i, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = rA(this.view);
    e.clientX - l.left <= s + Am ? n = -Rm(s - e.clientX) : e.clientX + l.right >= o - Am && (n = Rm(e.clientX - o)), e.clientY - l.top <= i + Am ? r = -Rm(i - e.clientY) : e.clientY + l.bottom >= a - Am && (r = Rm(e.clientY - a)), this.setScrollSpeed(n, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, n) {
    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: n } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let s = e.ranges[r], i = null;
      if (s.empty) {
        let o = Ag(this.atoms, s.from, 0);
        o != s.from && (i = Ae.cursor(o, -1));
      } else {
        let o = Ag(this.atoms, s.from, -1), a = Ag(this.atoms, s.to, 1);
        (o != s.from || a != s.to) && (i = Ae.range(s.from == s.anchor ? o : a, s.from == s.head ? o : a));
      }
      i && (n || (n = e.ranges.slice()), n[r] = i);
    }
    return n ? Ae.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function s2e(t, e) {
  let n = t.state.facet(Tz);
  return n.length ? n[0](e) : Fe.mac ? e.metaKey : e.ctrlKey;
}
function i2e(t, e) {
  let n = t.state.facet(Cz);
  return n.length ? n[0](e) : Fe.mac ? !e.altKey : !e.ctrlKey;
}
function o2e(t, e) {
  let { main: n } = t.state.selection;
  if (n.empty)
    return !1;
  let r = sf(t.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let s = r.getRangeAt(0).getClientRects();
  for (let i = 0; i < s.length; i++) {
    let o = s[i];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function a2e(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (r = It.get(n)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const Rs = /* @__PURE__ */ Object.create(null), os = /* @__PURE__ */ Object.create(null), Gz = Fe.ie && Fe.ie_version < 15 || Fe.ios && Fe.webkit_version < 604;
function l2e(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let n = e.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    t.focus(), n.remove(), Vz(t, n.value);
  }, 50);
}
function Xb(t, e, n) {
  for (let r of t.facet(e))
    n = r(n, t);
  return n;
}
function Vz(t, e) {
  e = Xb(t.state, eA, e);
  let { state: n } = t, r, s = 1, i = n.toText(e), o = i.lines == n.selection.ranges.length;
  if (fx != null && n.selection.ranges.every((l) => l.empty) && fx == i.toString()) {
    let l = -1;
    r = n.changeByRange((c) => {
      let u = n.doc.lineAt(c.from);
      if (u.from == l)
        return { range: c };
      l = u.from;
      let h = n.toText((o ? i.line(s++).text : e) + n.lineBreak);
      return {
        changes: { from: u.from, insert: h },
        range: Ae.cursor(c.from + h.length)
      };
    });
  } else o ? r = n.changeByRange((l) => {
    let c = i.line(s++);
    return {
      changes: { from: l.from, to: l.to, insert: c.text },
      range: Ae.cursor(l.from + c.length)
    };
  }) : r = n.replaceSelection(i);
  t.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
os.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
Rs.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
os.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
os.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Rs.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let r of t.state.facet(kz))
    if (n = r(t, e), n)
      break;
  if (!n && e.button == 0 && (n = h2e(t, e)), n) {
    let r = !t.hasFocus;
    t.inputState.startMouseSelection(new r2e(t, e, n, r)), r && t.observer.ignore(() => {
      oz(t.contentDOM);
      let i = t.root.activeElement;
      i && !i.contains(t.contentDOM) && i.blur();
    });
    let s = t.inputState.mouseSelection;
    if (s)
      return s.start(e), s.dragging === !1;
  }
  return !1;
};
function WD(t, e, n, r) {
  if (r == 1)
    return Ae.cursor(e, n);
  if (r == 2)
    return FAe(t.state, e, n);
  {
    let s = tn.find(t.docView, e), i = t.state.doc.lineAt(s ? s.posAtEnd : e), o = s ? s.posAtStart : i.from, a = s ? s.posAtEnd : i.to;
    return a < t.state.doc.length && a == i.to && a++, Ae.range(o, a);
  }
}
let qD = (t, e, n) => e >= n.top && e <= n.bottom && t >= n.left && t <= n.right;
function c2e(t, e, n, r) {
  let s = tn.find(t.docView, e);
  if (!s)
    return 1;
  let i = e - s.posAtStart;
  if (i == 0)
    return 1;
  if (i == s.length)
    return -1;
  let o = s.coordsAt(i, -1);
  if (o && qD(n, r, o))
    return -1;
  let a = s.coordsAt(i, 1);
  return a && qD(n, r, a) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function KD(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: c2e(t, n, e.clientX, e.clientY) };
}
const u2e = Fe.ie && Fe.ie_version <= 11;
let YD = null, ZD = 0, JD = 0;
function Wz(t) {
  if (!u2e)
    return t.detail;
  let e = YD, n = JD;
  return YD = t, JD = Date.now(), ZD = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (ZD + 1) % 3 : 1;
}
function h2e(t, e) {
  let n = KD(t, e), r = Wz(e), s = t.state.selection;
  return {
    update(i) {
      i.docChanged && (n.pos = i.changes.mapPos(n.pos), s = s.map(i.changes));
    },
    get(i, o, a) {
      let l = KD(t, i), c, u = WD(t, l.pos, l.bias, r);
      if (n.pos != l.pos && !o) {
        let h = WD(t, n.pos, n.bias, r), d = Math.min(h.from, u.from), f = Math.max(h.to, u.to);
        u = d < u.from ? Ae.range(d, f) : Ae.range(f, d);
      }
      return o ? s.replaceRange(s.main.extend(u.from, u.to)) : a && r == 1 && s.ranges.length > 1 && (c = d2e(s, l.pos)) ? c : a ? s.addRange(u) : Ae.create([u]);
    }
  };
}
function d2e(t, e) {
  for (let n = 0; n < t.ranges.length; n++) {
    let { from: r, to: s } = t.ranges[n];
    if (r <= e && s >= e)
      return Ae.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
  }
  return null;
}
Rs.dragstart = (t, e) => {
  let { selection: { main: n } } = t.state;
  if (e.target.draggable) {
    let s = t.docView.nearest(e.target);
    if (s && s.isWidget) {
      let i = s.posAtStart, o = i + s.length;
      (i >= n.to || o <= n.from) && (n = Ae.range(i, o));
    }
  }
  let { inputState: r } = t;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", Xb(t.state, tA, t.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Rs.dragend = (t) => (t.inputState.draggedContent = null, !1);
function XD(t, e, n, r) {
  if (n = Xb(t.state, eA, n), !n)
    return;
  let s = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: i } = t.inputState, o = r && i && i2e(t, e) ? { from: i.from, to: i.to } : null, a = { from: s, insert: n }, l = t.state.changes(o ? [o, a] : a);
  t.focus(), t.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(s, -1), head: l.mapPos(s, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
Rs.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length), s = 0, i = () => {
      ++s == n.length && XD(t, e, r.filter((o) => o != null).join(t.state.lineBreak), !1);
    };
    for (let o = 0; o < n.length; o++) {
      let a = new FileReader();
      a.onerror = i, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[o] = a.result), i();
      }, a.readAsText(n[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return XD(t, e, r, !0), !0;
  }
  return !1;
};
Rs.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let n = Gz ? null : e.clipboardData;
  return n ? (Vz(t, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (l2e(t), !1);
};
function f2e(t, e) {
  let n = t.dom.parentNode;
  if (!n)
    return;
  let r = n.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), t.focus();
  }, 50);
}
function p2e(t) {
  let e = [], n = [], r = !1;
  for (let s of t.selection.ranges)
    s.empty || (e.push(t.sliceDoc(s.from, s.to)), n.push(s));
  if (!e.length) {
    let s = -1;
    for (let { from: i } of t.selection.ranges) {
      let o = t.doc.lineAt(i);
      o.number > s && (e.push(o.text), n.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), s = o.number;
    }
    r = !0;
  }
  return { text: Xb(t, tA, e.join(t.lineBreak)), ranges: n, linewise: r };
}
let fx = null;
Rs.copy = Rs.cut = (t, e) => {
  let { text: n, ranges: r, linewise: s } = p2e(t.state);
  if (!n && !s)
    return !1;
  fx = s ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let i = Gz ? null : e.clipboardData;
  return i ? (i.clearData(), i.setData("text/plain", n), !0) : (f2e(t, n), !1);
};
const qz = /* @__PURE__ */ bo.define();
function Kz(t, e) {
  let n = [];
  for (let r of t.facet(Iz)) {
    let s = r(t, e);
    s && n.push(s);
  }
  return n ? t.update({ effects: n, annotations: qz.of(!0) }) : null;
}
function Yz(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let n = Kz(t.state, e);
      n ? t.dispatch(n) : t.update([]);
    }
  }, 10);
}
os.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), Yz(t);
};
os.blur = (t) => {
  t.observer.clearSelectionRange(), Yz(t);
};
os.compositionstart = os.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
os.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, Fe.chrome && Fe.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
os.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
Rs.beforeinput = (t, e) => {
  var n, r;
  if (e.inputType == "insertReplacementText" && t.observer.editContext) {
    let i = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), o = e.getTargetRanges();
    if (i && o.length) {
      let a = o[0], l = t.posAtDOM(a.startContainer, a.startOffset), c = t.posAtDOM(a.endContainer, a.endOffset);
      return sA(t, { from: l, to: c, insert: t.state.toText(i) }, null), !0;
    }
  }
  let s;
  if (Fe.chrome && Fe.android && (s = Hz.find((i) => i.inputType == e.inputType)) && (t.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let i = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > i + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return Fe.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), Fe.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => os.compositionend(t, e), 20), !1;
};
const QD = /* @__PURE__ */ new Set();
function m2e(t) {
  QD.has(t) || (QD.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const eN = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let pu = !1;
function tN() {
  pu = !1;
}
class g2e {
  constructor(e) {
    this.lineWrapping = e, this.doc = Et.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return eN.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      s < 0 ? r++ : this.heightSamples[Math.floor(s * 10)] || (n = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return n;
  }
  refresh(e, n, r, s, i, o) {
    let a = eN.indexOf(e) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = s, this.lineLength = i, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}
class y2e {
  constructor(e, n) {
    this.from = e, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class li {
  /**
  @internal
  */
  constructor(e, n, r, s, i) {
    this.from = e, this.length = n, this.top = r, this.height = s, this._content = i;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Qn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof ha ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new li(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var Lt = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(Lt || (Lt = {}));
const Rg = 1e-3;
class er {
  constructor(e, n, r = 2) {
    this.length = e, this.height = n, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Rg && (pu = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, n, r) {
    return er.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, r, s) {
    let i = this, o = r.doc;
    for (let a = s.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: h } = s[a], d = i.lineAt(l, Lt.ByPosNoHeight, r.setDoc(n), 0, 0), f = d.to >= c ? d : i.lineAt(c, Lt.ByPosNoHeight, r, 0, 0);
      for (h += f.to - c, c = f.to; a > 0 && d.from <= s[a - 1].toA; )
        l = s[a - 1].fromA, u = s[a - 1].fromB, a--, l < d.from && (d = i.lineAt(l, Lt.ByPosNoHeight, r, 0, 0));
      u += d.from - l, l = d.from;
      let g = iA.build(r.setDoc(o), e, u, h);
      i = oy(i, i.replace(l, c, g));
    }
    return i.updateHeight(r, 0);
  }
  static empty() {
    return new Cr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let n = 0, r = e.length, s = 0, i = 0;
    for (; ; )
      if (n == r)
        if (s > i * 2) {
          let a = e[n - 1];
          a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), r += 1 + a.break, s -= a.size;
        } else if (i > s * 2) {
          let a = e[r];
          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, i -= a.size;
        } else
          break;
      else if (s < i) {
        let a = e[n++];
        a && (s += a.size);
      } else {
        let a = e[--r];
        a && (i += a.size);
      }
    let o = 0;
    return e[n - 1] == null ? (o = 1, n--) : e[n] == null && (o = 1, r++), new b2e(er.of(e.slice(0, n)), o, er.of(e.slice(r)));
  }
}
function oy(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (pu = !0), e);
}
er.prototype.size = 1;
class Zz extends er {
  constructor(e, n, r) {
    super(e, n), this.deco = r;
  }
  blockAt(e, n, r, s) {
    return new li(s, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, n, r, s, i) {
    return this.blockAt(0, r, s, i);
  }
  forEachLine(e, n, r, s, i, o) {
    e <= i + this.length && n >= i && o(this.blockAt(0, r, s, i));
  }
  updateHeight(e, n = 0, r = !1, s) {
    return s && s.from <= n && s.more && this.setHeight(s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Cr extends Zz {
  constructor(e, n) {
    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, n, r, s) {
    return new li(s, this.length, r, this.height, this.breaks);
  }
  replace(e, n, r) {
    let s = r[0];
    return r.length == 1 && (s instanceof Cr || s instanceof Cn && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof Cn ? s = new Cr(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : er.of(r);
  }
  updateHeight(e, n = 0, r = !1, s) {
    return s && s.from <= n && s.more ? this.setHeight(s.heights[s.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Cn extends er {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let r = e.doc.lineAt(n).number, s = e.doc.lineAt(n + this.length).number, i = s - r + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * i);
      o = l / i, this.length > i + 1 && (a = (this.height - l) / (this.length - i - 1));
    } else
      o = this.height / i;
    return { firstLine: r, lastLine: s, perLine: o, perChar: a };
  }
  blockAt(e, n, r, s) {
    let { firstLine: i, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(n, s);
    if (n.lineWrapping) {
      let c = s + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = n.doc.lineAt(c), h = a + u.length * l, d = Math.max(r, e - h / 2);
      return new li(u.from, u.length, d, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - i, Math.floor((e - r) / a))), { from: u, length: h } = n.doc.line(i + c);
      return new li(u, h, r + a * c, a, 0);
    }
  }
  lineAt(e, n, r, s, i) {
    if (n == Lt.ByHeight)
      return this.blockAt(e, r, s, i);
    if (n == Lt.ByPosNoHeight) {
      let { from: f, to: g } = r.doc.lineAt(e);
      return new li(f, g - f, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(r, i), c = r.doc.lineAt(e), u = a + c.length * l, h = c.number - o, d = s + a * h + l * (c.from - i - h);
    return new li(c.from, c.length, Math.max(s, Math.min(d, s + this.height - u)), u, 0);
  }
  forEachLine(e, n, r, s, i, o) {
    e = Math.max(e, i), n = Math.min(n, i + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, i);
    for (let u = e, h = s; u <= n; ) {
      let d = r.doc.lineAt(u);
      if (u == e) {
        let g = d.number - a;
        h += l * g + c * (e - i - g);
      }
      let f = l + c * d.length;
      o(new li(d.from, d.length, h, f, 0)), h += f, u = d.to + 1;
    }
  }
  replace(e, n, r) {
    let s = this.length - n;
    if (s > 0) {
      let i = r[r.length - 1];
      i instanceof Cn ? r[r.length - 1] = new Cn(i.length + s) : r.push(null, new Cn(s - 1));
    }
    if (e > 0) {
      let i = r[0];
      i instanceof Cn ? r[0] = new Cn(e + i.length) : r.unshift(new Cn(e - 1), null);
    }
    return er.of(r);
  }
  decomposeLeft(e, n) {
    n.push(new Cn(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new Cn(this.length - e - 1));
  }
  updateHeight(e, n = 0, r = !1, s) {
    let i = n + this.length;
    if (s && s.from <= n + this.length && s.more) {
      let o = [], a = Math.max(n, s.from), l = -1;
      for (s.from > n && o.push(new Cn(s.from - n - 1).updateHeight(e, n)); a <= i && s.more; ) {
        let u = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let h = s.heights[s.index++];
        l == -1 ? l = h : Math.abs(h - l) >= Rg && (l = -2);
        let d = new Cr(u, h);
        d.outdated = !1, o.push(d), a += u + 1;
      }
      a <= i && o.push(null, new Cn(i - a).updateHeight(e, a));
      let c = er.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= Rg || Math.abs(l - this.heightMetrics(e, n).perLine) >= Rg) && (pu = !0), oy(this, c);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class b2e extends er {
  constructor(e, n, r) {
    super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, r, s) {
    let i = r + this.left.height;
    return e < i ? this.left.blockAt(e, n, r, s) : this.right.blockAt(e, n, i, s + this.left.length + this.break);
  }
  lineAt(e, n, r, s, i) {
    let o = s + this.left.height, a = i + this.left.length + this.break, l = n == Lt.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, n, r, s, i) : this.right.lineAt(e, n, r, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let u = n == Lt.ByPosNoHeight ? Lt.ByPosNoHeight : Lt.ByPos;
    return l ? c.join(this.right.lineAt(a, u, r, o, a)) : this.left.lineAt(a, u, r, s, i).join(c);
  }
  forEachLine(e, n, r, s, i, o) {
    let a = s + this.left.height, l = i + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, n, r, s, i, o), n >= l && this.right.forEachLine(e, n, r, a, l, o);
    else {
      let c = this.lineAt(l, Lt.ByPos, r, s, i);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, s, i, o), c.to >= e && c.from <= n && o(c), n > c.to && this.right.forEachLine(c.to + 1, n, r, a, l, o);
    }
  }
  replace(e, n, r) {
    let s = this.left.length + this.break;
    if (n < s)
      return this.balanced(this.left.replace(e, n, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - s, n - s, r));
    let i = [];
    e > 0 && this.decomposeLeft(e, i);
    let o = i.length;
    for (let a of r)
      i.push(a);
    if (e > 0 && nN(i, o - 1), n < this.length) {
      let a = i.length;
      this.decomposeRight(n, i), nN(i, a);
    }
    return er.of(i);
  }
  decomposeLeft(e, n) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
  }
  decomposeRight(e, n) {
    let r = this.left.length, s = r + this.break;
    if (e >= s)
      return this.right.decomposeRight(e - s, n);
    e < r && this.left.decomposeRight(e, n), this.break && e < s && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size ? er.of(this.break ? [e, null, n] : [e, n]) : (this.left = oy(this.left, e), this.right = oy(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
  }
  updateHeight(e, n = 0, r = !1, s) {
    let { left: i, right: o } = this, a = n + i.length + this.break, l = null;
    return s && s.from <= n + i.length && s.more ? l = i = i.updateHeight(e, n, r, s) : i.updateHeight(e, n, r), s && s.from <= a + o.length && s.more ? l = o = o.updateHeight(e, a, r, s) : o.updateHeight(e, a, r), l ? this.balanced(i, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function nN(t, e) {
  let n, r;
  t[e] == null && (n = t[e - 1]) instanceof Cn && (r = t[e + 1]) instanceof Cn && t.splice(e - 1, 3, new Cn(n.length + 1 + r.length));
}
const _2e = 5;
class iA {
  constructor(e, n) {
    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof Cr ? s.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Cr(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(e, n, r) {
    if (e < n || r.heightRelevant) {
      let s = r.widget ? r.widget.estimatedHeight : 0, i = r.widget ? r.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let o = n - e;
      r.block ? this.addBlock(new Zz(o, s, r)) : (o || i || s >= _2e) && this.addLineDeco(s, i, o);
    } else n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Cr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, n) {
    let r = new Cn(n - e);
    return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Cr)
      return e;
    let n = new Cr(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, r) {
    let s = this.ensureLine();
    s.length += r, s.collapsed += r, s.widgetHeight = Math.max(s.widgetHeight, e), s.breaks += n, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Cr) && !this.isCovered ? this.nodes.push(new Cr(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let s of this.nodes)
      s instanceof Cr && s.updateHeight(this.oracle, r), r += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, n, r, s) {
    let i = new iA(r, e);
    return _t.spans(n, r, s, i, 0), i.finish(r);
  }
}
function v2e(t, e, n) {
  let r = new w2e();
  return _t.compare(t, e, n, r, 0), r.changes;
}
class w2e {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, n, r, s) {
    (e < n || r && r.heightRelevant || s && s.heightRelevant) && kg(e, n, this.changes, 5);
  }
}
function E2e(t, e) {
  let n = t.getBoundingClientRect(), r = t.ownerDocument, s = r.defaultView || window, i = Math.max(0, n.left), o = Math.min(s.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(s.innerHeight, n.bottom);
  for (let c = t.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c, h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let d = u.getBoundingClientRect();
        i = Math.max(i, d.left), o = Math.min(o, d.right), a = Math.max(a, d.top), l = Math.min(c == t.parentNode ? s.innerHeight : l, d.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: i - n.left,
    right: Math.max(i, o) - n.left,
    top: a - (n.top + e),
    bottom: Math.max(a, l) - (n.top + e)
  };
}
function S2e(t) {
  let e = t.getBoundingClientRect(), n = t.ownerDocument.defaultView || window;
  return e.left < n.innerWidth && e.right > 0 && e.top < n.innerHeight && e.bottom > 0;
}
function x2e(t, e) {
  let n = t.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: e,
    bottom: n.bottom - (n.top + e)
  };
}
class cw {
  constructor(e, n, r, s) {
    this.from = e, this.to = n, this.size = r, this.displaySize = s;
  }
  static same(e, n) {
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let s = e[r], i = n[r];
      if (s.from != i.from || s.to != i.to || s.size != i.size)
        return !1;
    }
    return !0;
  }
  draw(e, n) {
    return yt.replace({
      widget: new T2e(this.displaySize * (n ? e.scaleY : e.scaleX), n)
    }).range(this.from, this.to);
  }
}
class T2e extends $u {
  constructor(e, n) {
    super(), this.size = e, this.vertical = n;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class rN {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = sN, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = jt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = e.facet(Jb).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new g2e(n), this.stateDeco = e.facet(af).filter((r) => typeof r != "function"), this.heightMap = er.empty().applyChanges(this.stateDeco, Et.empty, this.heightOracle.setDoc(e.doc), [new Qr(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = yt.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let s = r ? n.head : n.anchor;
      if (!e.some(({ from: i, to: o }) => s >= i && s <= o)) {
        let { from: i, to: o } = this.lineBlockAt(s);
        e.push(new Im(i, o));
      }
    }
    return this.viewports = e.sort((r, s) => r.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? sN : new oA(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(Ph(e, this.scaler));
    });
  }
  update(e, n = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(af).filter((u) => typeof u != "function");
    let s = e.changedRanges, i = Qr.extendWithRanges(s, v2e(r, this.stateDeco, e ? e.changes : un.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    tN(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), i), (this.heightMap.height != o || pu) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = i.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Oz) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM, r = window.getComputedStyle(n), s = this.heightOracle, i = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? jt.RTL : jt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(i), a = n.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: v, scaleY: w } = iz(n, a);
      (v > 5e-3 && Math.abs(this.scaleX - v) > 5e-3 || w > 5e-3 && Math.abs(this.scaleY - w) > 5e-3) && (this.scaleX = v, this.scaleY = w, c |= 16, o = l = !0);
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY, d = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != d) && (this.paddingTop = h, this.paddingBottom = d, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (s.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let f = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f && (this.scrollAnchorHeight = -1, this.scrollTop = f), this.scrolledToBottom = lz(e.scrollDOM);
    let g = (this.printing ? x2e : E2e)(n, this.paddingTop), y = g.top - this.pixelViewport.top, p = g.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g;
    let m = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (m != this.inView && (this.inView = m, m && (l = !0)), !this.inView && !this.scrollTarget && !S2e(e.dom))
      return 0;
    let b = a.width;
    if ((this.contentDOMWidth != b || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
      let v = e.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(v) && (o = !0), o || s.lineWrapping && Math.abs(b - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: w, charWidth: E, textHeight: x } = e.docView.measureTextSize();
        o = w > 0 && s.refresh(i, w, E, x, b / E, v), o && (e.docView.minWidth = 0, c |= 16);
      }
      y > 0 && p > 0 ? u = Math.max(y, p) : y < 0 && p < 0 && (u = Math.min(y, p)), tN();
      for (let w of this.viewports) {
        let E = w.from == this.viewport.from ? v : e.docView.measureVisibleLineHeights(w);
        this.heightMap = (o ? er.empty().applyChanges(this.stateDeco, Et.empty, this.heightOracle, [new Qr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(s, 0, o, new y2e(w.from, E));
      }
      pu && (c |= 2);
    }
    let _ = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return _ && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || _) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), s = this.heightMap, i = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new Im(s.lineAt(o - r * 1e3, Lt.ByHeight, i, 0, 0).from, s.lineAt(a + (1 - r) * 1e3, Lt.ByHeight, i, 0, 0).to);
    if (n) {
      let { head: c } = n.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = s.lineAt(c, Lt.ByPos, i, 0, 0), d;
        n.y == "center" ? d = (h.top + h.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && c < l.from ? d = h.top : d = h.bottom - u, l = new Im(s.lineAt(d - 1e3 / 2, Lt.ByHeight, i, 0, 0).from, s.lineAt(d + u + 1e3 / 2, Lt.ByHeight, i, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, n) {
    let r = n.mapPos(e.from, -1), s = n.mapPos(e.to, 1);
    return new Im(this.heightMap.lineAt(r, Lt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, Lt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: n }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(e, Lt.ByPos, this.heightOracle, 0, 0), { bottom: i } = this.heightMap.lineAt(n, Lt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || s <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || i >= a + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && s > o - 2 * 1e3 && i < a + 2 * 1e3;
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty)
      return e;
    let r = [];
    for (let s of e)
      n.touchesRange(s.from, s.to) || r.push(new cw(n.mapPos(s.from), n.mapPos(s.to), s.size, s.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, n) {
    let r = this.heightOracle.lineWrapping, s = r ? 1e4 : 2e3, i = s >> 1, o = s << 1;
    if (this.defaultTextDirection != jt.LTR && !r)
      return [];
    let a = [], l = (u, h, d, f) => {
      if (h - u < i)
        return;
      let g = this.state.selection.main, y = [g.from];
      g.empty || y.push(g.to);
      for (let m of y)
        if (m > u && m < h) {
          l(u, m - 10, d, f), l(m + 10, h, d, f);
          return;
        }
      let p = k2e(e, (m) => m.from >= d.from && m.to <= d.to && Math.abs(m.from - u) < i && Math.abs(m.to - h) < i && !y.some((b) => m.from < b && m.to > b));
      if (!p) {
        if (h < d.to && n && r && n.visibleRanges.some((_) => _.from <= h && _.to >= h)) {
          let _ = n.moveToLineBoundary(Ae.cursor(h), !1, !0).head;
          _ > u && (h = _);
        }
        let m = this.gapSize(d, u, h, f), b = r || m < 2e6 ? m : 2e6;
        p = new cw(u, h, m, b);
      }
      a.push(p);
    }, c = (u) => {
      if (u.length < o || u.type != Qn.Text)
        return;
      let h = C2e(u.from, u.to, this.stateDeco);
      if (h.total < o)
        return;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, f, g;
      if (r) {
        let y = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, p, m;
        if (d != null) {
          let b = Om(h, d), _ = ((this.visibleBottom - this.visibleTop) / 2 + y) / u.height;
          p = b - _, m = b + _;
        } else
          p = (this.visibleTop - u.top - y) / u.height, m = (this.visibleBottom - u.top + y) / u.height;
        f = Pm(h, p), g = Pm(h, m);
      } else {
        let y = h.total * this.heightOracle.charWidth, p = s * this.heightOracle.charWidth, m = 0;
        if (y > 2e6)
          for (let E of e)
            E.from >= u.from && E.from < u.to && E.size != E.displaySize && E.from * this.heightOracle.charWidth + m < this.pixelViewport.left && (m = E.size - E.displaySize);
        let b = this.pixelViewport.left + m, _ = this.pixelViewport.right + m, v, w;
        if (d != null) {
          let E = Om(h, d), x = ((_ - b) / 2 + p) / y;
          v = E - x, w = E + x;
        } else
          v = (b - p) / y, w = (_ + p) / y;
        f = Pm(h, v), g = Pm(h, w);
      }
      f > u.from && l(u.from, f, u, h), g < u.to && l(g, u.to, u, h);
    };
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return a;
  }
  gapSize(e, n, r, s) {
    let i = Om(s, r) - Om(s, n);
    return this.heightOracle.lineWrapping ? e.height * i : s.total * this.heightOracle.charWidth * i;
  }
  updateLineGaps(e) {
    cw.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = yt.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let n = this.stateDeco;
    this.lineGaps.length && (n = n.concat(this.lineGapDeco));
    let r = [];
    _t.spans(n, this.viewport.from, this.viewport.to, {
      span(i, o) {
        r.push({ from: i, to: o });
      },
      point() {
      }
    }, 20);
    let s = 0;
    if (r.length != this.visibleRanges.length)
      s = 12;
    else
      for (let i = 0; i < r.length && !(s & 8); i++) {
        let o = this.visibleRanges[i], a = r[i];
        (o.from != a.from || o.to != a.to) && (s |= 4, e && e.mapPos(o.from, -1) == a.from && e.mapPos(o.to, 1) == a.to || (s |= 8));
      }
    return this.visibleRanges = r, s;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || Ph(this.heightMap.lineAt(e, Lt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || Ph(this.heightMap.lineAt(this.scaler.fromDOM(e), Lt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Ph(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Im {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
function C2e(t, e, n) {
  let r = [], s = t, i = 0;
  return _t.spans(n, t, e, {
    span() {
    },
    point(o, a) {
      o > s && (r.push({ from: s, to: o }), i += o - s), s = a;
    }
  }, 20), s < e && (r.push({ from: s, to: e }), i += e - s), { total: i, ranges: r };
}
function Pm({ total: t, ranges: e }, n) {
  if (n <= 0)
    return e[0].from;
  if (n >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(t * n);
  for (let s = 0; ; s++) {
    let { from: i, to: o } = e[s], a = o - i;
    if (r <= a)
      return i + r;
    r -= a;
  }
}
function Om(t, e) {
  let n = 0;
  for (let { from: r, to: s } of t.ranges) {
    if (e <= s) {
      n += e - r;
      break;
    }
    n += s - r;
  }
  return n / t.total;
}
function k2e(t, e) {
  for (let n of t)
    if (e(n))
      return n;
}
const sN = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class oA {
  constructor(e, n, r) {
    let s = 0, i = 0, o = 0;
    this.viewports = r.map(({ from: a, to: l }) => {
      let c = n.lineAt(a, Lt.ByPos, e, 0, 0).top, u = n.lineAt(l, Lt.ByPos, e, 0, 0).bottom;
      return s += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (n.height - s);
    for (let a of this.viewports)
      a.domTop = o + (a.top - i) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), i = a.bottom;
  }
  toDOM(e) {
    for (let n = 0, r = 0, s = 0; ; n++) {
      let i = n < this.viewports.length ? this.viewports[n] : null;
      if (!i || e < i.top)
        return s + (e - r) * this.scale;
      if (e <= i.bottom)
        return i.domTop + (e - i.top);
      r = i.bottom, s = i.domBottom;
    }
  }
  fromDOM(e) {
    for (let n = 0, r = 0, s = 0; ; n++) {
      let i = n < this.viewports.length ? this.viewports[n] : null;
      if (!i || e < i.domTop)
        return r + (e - s) / this.scale;
      if (e <= i.domBottom)
        return i.top + (e - i.domTop);
      r = i.bottom, s = i.domBottom;
    }
  }
  eq(e) {
    return e instanceof oA ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to) : !1;
  }
}
function Ph(t, e) {
  if (e.scale == 1)
    return t;
  let n = e.toDOM(t.top), r = e.toDOM(t.bottom);
  return new li(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((s) => Ph(s, e)) : t._content);
}
const Dm = /* @__PURE__ */ ze.define({ combine: (t) => t.join(" ") }), px = /* @__PURE__ */ ze.define({ combine: (t) => t.indexOf(!0) > -1 }), mx = /* @__PURE__ */ ca.newName(), Jz = /* @__PURE__ */ ca.newName(), Xz = /* @__PURE__ */ ca.newName(), Qz = { "&light": "." + Jz, "&dark": "." + Xz };
function gx(t, e, n) {
  return new ca(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (s) => {
        if (s == "&")
          return t;
        if (!n || !n[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return n[s];
      }) : t + " " + r;
    }
  });
}
const A2e = /* @__PURE__ */ gx("." + mx, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, Qz), R2e = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, uw = Fe.ie && Fe.ie_version <= 11;
class I2e {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new fAe(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
      for (let r of n)
        this.queue.push(r);
      (Fe.ie && Fe.ie_version <= 11 || Fe.ios && e.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(Fe.chrome && Fe.chrome_version < 126) && (this.editContext = new O2e(e), e.state.facet(eo) && (e.contentDOM.editContext = this.editContext.editContext)), uw && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
      this.gapIntersection.disconnect();
      for (let n of e)
        this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, s = this.selectionRange;
    if (r.state.facet(eo) ? r.root.activeElement != this.dom : !Cg(this.dom, s))
      return;
    let i = s.anchorNode && r.docView.nearest(s.anchorNode);
    if (i && i.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (Fe.ie && Fe.ie_version <= 11 || Fe.android && Fe.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && od(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, n = sf(e.root);
    if (!n)
      return !1;
    let r = Fe.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && P2e(this.view, n) || n;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let s = Cg(this.dom, r);
    return s && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && mAe(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = n)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, R2e), uw && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), uw && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let s = () => {
        let i = this.delayedAndroidKey;
        i && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = i.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && i.force && Mc(this.dom, i.key, i.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1, r = -1, s = !1;
    for (let i of e) {
      let o = this.readMutation(i);
      o && (o.typeOver && (s = !0), n == -1 ? { from: n, to: r } = o : (n = Math.min(o.from, n), r = Math.max(o.to, r)));
    }
    return { from: n, to: r, typeOver: s };
  }
  readChange() {
    let { from: e, to: n, typeOver: r } = this.processRecords(), s = this.selectionChanged && Cg(this.dom, this.selectionRange);
    if (e < 0 && !s)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let i = new KAe(this.view, e, n, r);
    return this.view.docView.domChanged = { newSel: i.newSel ? i.newSel.main : null }, i;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, s = jz(this.view, n);
    return this.view.state == r && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e))
      return null;
    if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
      let r = iN(n, e.previousSibling || e.target.previousSibling, -1), s = iN(n, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? n.posAfter(r) : n.posAtStart,
        to: s ? n.posBefore(s) : n.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(eo) != e.state.facet(eo) && (e.view.contentDOM.editContext = e.state.facet(eo) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, n, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function iN(t, e, n) {
  for (; e; ) {
    let r = It.get(e);
    if (r && r.parent == t)
      return r;
    let s = e.parentNode;
    e = s != t.dom ? s : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function oN(t, e) {
  let n = e.startContainer, r = e.startOffset, s = e.endContainer, i = e.endOffset, o = t.docView.domAtPos(t.state.selection.main.anchor);
  return od(o.node, o.offset, s, i) && ([n, r, s, i] = [s, i, n, r]), { anchorNode: n, anchorOffset: r, focusNode: s, focusOffset: i };
}
function P2e(t, e) {
  if (e.getComposedRanges) {
    let s = e.getComposedRanges(t.root)[0];
    if (s)
      return oN(t, s);
  }
  let n = null;
  function r(s) {
    s.preventDefault(), s.stopImmediatePropagation(), n = s.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), n ? oN(t, n) : null;
}
class O2e {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let n = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let s = e.state.selection.main, { anchor: i, head: o } = s, a = this.toEditorPos(r.updateRangeStart), l = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: a, drifted: !1 });
      let c = { from: a, to: l, insert: Et.of(r.text.split(`
`)) };
      if (c.from == this.from && i < this.from ? c.from = i : c.to == this.to && i > this.to && (c.to = i), c.from == c.to && !c.insert.length) {
        let u = Ae.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        u.main.eq(s) || e.dispatch({ selection: u, userEvent: "select" });
        return;
      }
      if ((Fe.mac || Fe.android) && c.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: a, to: l, insert: Et.of([r.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let u = this.to - this.from + (c.to - c.from + c.insert.length);
        sA(e, c, Ae.single(this.toEditorPos(r.selectionStart, u), this.toEditorPos(r.selectionEnd, u)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (r) => {
      let s = [], i = null;
      for (let o = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); o < a; o++) {
        let l = e.coordsForChar(o);
        i = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || i || new DOMRect(), s.push(i);
      }
      n.updateCharacterBounds(r.rangeStart, s);
    }, this.handlers.textformatupdate = (r) => {
      let s = [];
      for (let i of r.getTextFormats()) {
        let o = i.underlineStyle, a = i.underlineThickness;
        if (o != "None" && a != "None") {
          let l = this.toEditorPos(i.rangeStart), c = this.toEditorPos(i.rangeEnd);
          if (l < c) {
            let u = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
            s.push(yt.mark({ attributes: { style: u } }).range(l, c));
          }
        }
      }
      e.dispatch({ effects: Nz.of(yt.set(s)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      n.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let s = sf(r.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let n = 0, r = !1, s = this.pendingContextChange;
    return e.changes.iterChanges((i, o, a, l, c) => {
      if (r)
        return;
      let u = c.length - (o - i);
      if (s && o >= s.to)
        if (s.from == i && s.to == o && s.insert.eq(c)) {
          s = this.pendingContextChange = null, n += u, this.to += u;
          return;
        } else
          s = null, this.revertPending(e.state);
      if (i += n, o += n, o <= this.from)
        this.from += u, this.to += u;
      else if (i < this.to) {
        if (i < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(i), this.toContextPos(o), c.toString()), this.to += u;
      }
      n += u;
    }), s && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let n = this.pendingContextChange;
    this.composing && (this.composing.drifted || e.transactions.some((r) => !r.isUserEvent("input.type") && r.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: n } = e.selection.main;
    this.from = Math.max(
      0,
      n - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      n + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let n = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
  }
  setSelection(e) {
    let { main: n } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), s = this.toContextPos(n.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != s) && this.editContext.updateSelection(r, s);
  }
  rangeIsValid(e) {
    let { head: n } = e.selection.main;
    return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, n = this.to - this.from) {
    e = Math.min(e, n);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let n = this.composing;
    return n && n.drifted ? n.contextBase + (e - n.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class He {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var n;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((s) => s.forEach((i) => r(i, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = e.root || pAe(e.parent) || document, this.viewState = new rN(e.state || pt.create(e)), e.scrollTo && e.scrollTo.is(km) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Ah).map((s) => new ow(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new I2e(this), this.inputState = new QAe(this), this.inputState.ensureHandlers(this.plugins), this.docView = new FD(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof sn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, r = !1, s, i = this.state;
    for (let d of e) {
      if (d.startState != i)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      i = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = i;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((d) => d.annotation(qz)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = Kz(i, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(i.doc) || !this.state.selection.eq(i.selection)) && (u = null)) : this.observer.clear(), i.facet(pt.phrases) != this.state.facet(pt.phrases))
      return this.setState(i);
    s = iy.create(this, i, e), s.flags |= a;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (h && (h = h.map(d.changes)), d.scrollIntoView) {
          let { main: f } = d.state.selection;
          h = new Bc(f.empty ? f : Ae.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of d.effects)
          f.is(km) && (h = f.value.clip(this.state));
      }
      this.viewState.update(s, h), this.bidiCache = ay.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), n = this.docView.update(s), this.state.facet(Rh) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(Dm) != s.state.facet(Dm) && (this.viewState.mustMeasureContent = !0), (n || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !s.empty)
      for (let d of this.state.facet(ux))
        try {
          d(s);
        } catch (f) {
          Pr(this.state, f, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !jz(this, u) && c.force && Mc(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new rN(e), this.plugins = e.facet(Ah).map((r) => new ow(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new FD(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(Ah), r = e.state.facet(Ah);
    if (n != r) {
      let s = [];
      for (let i of r) {
        let o = n.indexOf(i);
        if (o < 0)
          s.push(new ow(i));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, s.push(a);
        }
      }
      for (let i of this.plugins)
        i.mustUpdate != e && i.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = e;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (r) {
          Pr(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let n = null, r = this.scrollDOM, s = r.scrollTop * this.scaleY, { scrollAnchorPos: i, scrollAnchorHeight: o } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (lz(r))
            i = -1, o = this.viewState.heightMap.height;
          else {
            let f = this.viewState.scrollAnchorAt(s);
            i = f.from, o = f.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((f) => {
          try {
            return f.read(this);
          } catch (g) {
            return Pr(this.state, g), aN;
          }
        }), h = iy.create(this, this.state, []), d = !1;
        h.flags |= l, n ? n.flags |= l : n = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), d = this.docView.update(h), d && this.docViewUpdate());
        for (let f = 0; f < c.length; f++)
          if (u[f] != aN)
            try {
              let g = c[f];
              g.write && g.write(u[f], this);
            } catch (g) {
              Pr(this.state, g);
            }
        if (d && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let g = (i < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(i).top) - o;
              if (g > 1 || g < -1) {
                s = s + g, r.scrollTop = s / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let a of this.state.facet(ux))
        a(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return mx + " " + (this.state.facet(px) ? Xz : Jz) + " " + this.state.facet(Dm);
  }
  updateAttrs() {
    let e = lN(this, Lz, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(eo) ? "true" : "false",
      class: "cm-content",
      style: `${Fe.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), lN(this, Jb, n);
    let r = this.observer.ignore(() => {
      let s = ix(this.contentDOM, this.contentAttrs, n), i = ix(this.dom, this.editorAttrs, e);
      return s || i;
    });
    return this.editorAttrs = e, this.contentAttrs = n, r;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let r of e)
      for (let s of r.effects)
        if (s.is(He.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let i = this.announceDOM.appendChild(document.createElement("div"));
          i.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Rh);
    let e = this.state.facet(He.cspNonce);
    ca.mount(this.root, this.styleModules.concat(A2e).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.spec == e) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, n, r) {
    return lw(this, e, zD(this, e, n, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, n) {
    return lw(this, e, zD(this, e, n, (r) => GAe(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, n) {
    let r = this.bidiSpans(e), s = this.textDirectionAt(e.from), i = r[n ? r.length - 1 : 0];
    return Ae.cursor(i.side(n, s) + e.from, i.forward(!n, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, n, r = !0) {
    return zAe(this, e, n, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, n, r) {
    return lw(this, e, VAe(this, e, n, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), Uz(this, e, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, n);
    if (!r || r.left == r.right)
      return r;
    let s = this.state.doc.lineAt(e), i = this.bidiSpans(s), o = i[zo.find(i, e - s.from, -1, n)];
    return Yb(r, o.dir == jt.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(Pz) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > D2e)
      return Sz(e.length);
    let n = this.textDirectionAt(e.from), r;
    for (let i of this.bidiCache)
      if (i.from == e.from && i.dir == n && (i.fresh || Ez(i.isolates, r = BD(this, e))))
        return i.order;
    r || (r = BD(this, e));
    let s = kAe(e.text, n, r);
    return this.bidiCache.push(new ay(e.from, e.to, n, r, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || Fe.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      oz(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, n = {}) {
    return km.of(new Bc(typeof e == "number" ? Ae.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return km.of(new Bc(Ae.cursor(r.from), "start", "start", r.top - e, n, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return In.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return In.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, n) {
    let r = ca.newName(), s = [Dm.of(r), Rh.of(gx(`.${r}`, e))];
    return n && n.dark && s.push(px.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return _a.lowest(Rh.of(gx("." + mx, e, Qz)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var n;
    let r = e.querySelector(".cm-content"), s = r && It.get(r) || It.get(e);
    return ((n = s?.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
He.styleModule = Rh;
He.inputHandler = Rz;
He.clipboardInputFilter = eA;
He.clipboardOutputFilter = tA;
He.scrollHandler = Dz;
He.focusChangeEffect = Iz;
He.perLineTextDirection = Pz;
He.exceptionSink = Az;
He.updateListener = ux;
He.editable = eo;
He.mouseSelectionStyle = kz;
He.dragMovesSelection = Cz;
He.clickAddsSelectionRange = Tz;
He.decorations = af;
He.outerDecorations = Mz;
He.atomicRanges = nA;
He.bidiIsolatedRanges = Bz;
He.scrollMargins = Fz;
He.darkTheme = px;
He.cspNonce = /* @__PURE__ */ ze.define({ combine: (t) => t.length ? t[0] : "" });
He.contentAttributes = Jb;
He.editorAttributes = Lz;
He.lineWrapping = /* @__PURE__ */ He.contentAttributes.of({ class: "cm-lineWrapping" });
He.announce = /* @__PURE__ */ at.define();
const D2e = 4096, aN = {};
class ay {
  constructor(e, n, r, s, i, o) {
    this.from = e, this.to = n, this.dir = r, this.isolates = s, this.fresh = i, this.order = o;
  }
  static update(e, n) {
    if (n.empty && !e.some((i) => i.fresh))
      return e;
    let r = [], s = e.length ? e[e.length - 1].dir : jt.LTR;
    for (let i = Math.max(0, e.length - 10); i < e.length; i++) {
      let o = e[i];
      o.dir == s && !n.touchesRange(o.from, o.to) && r.push(new ay(n.mapPos(o.from, 1), n.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function lN(t, e, n) {
  for (let r = t.state.facet(e), s = r.length - 1; s >= 0; s--) {
    let i = r[s], o = typeof i == "function" ? i(t) : i;
    o && sx(o, n);
  }
  return n;
}
const N2e = Fe.mac ? "mac" : Fe.windows ? "win" : Fe.linux ? "linux" : "key";
function L2e(t, e) {
  const n = t.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let s, i, o, a;
  for (let l = 0; l < n.length - 1; ++l) {
    const c = n[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      i = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return s && (r = "Alt-" + r), i && (r = "Ctrl-" + r), a && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function Nm(t, e, n) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const M2e = /* @__PURE__ */ _a.default(/* @__PURE__ */ He.domEventHandlers({
  keydown(t, e) {
    return tG(eG(e.state), t, e, "editor");
  }
})), Qb = /* @__PURE__ */ ze.define({ enables: M2e }), cN = /* @__PURE__ */ new WeakMap();
function eG(t) {
  let e = t.facet(Qb), n = cN.get(e);
  return n || cN.set(e, n = $2e(e.reduce((r, s) => r.concat(s), []))), n;
}
function B2e(t, e, n) {
  return tG(eG(t.state), e, t, n);
}
let Bo = null;
const F2e = 4e3;
function $2e(t, e = N2e) {
  let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), s = (o, a) => {
    let l = r[o];
    if (l == null)
      r[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, i = (o, a, l, c, u) => {
    var h, d;
    let f = n[o] || (n[o] = /* @__PURE__ */ Object.create(null)), g = a.split(/ (?!$)/).map((m) => L2e(m, e));
    for (let m = 1; m < g.length; m++) {
      let b = g.slice(0, m).join(" ");
      s(b, !0), f[b] || (f[b] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(_) => {
          let v = Bo = { view: _, prefix: b, scope: o };
          return setTimeout(() => {
            Bo == v && (Bo = null);
          }, F2e), !0;
        }]
      });
    }
    let y = g.join(" ");
    s(y, !1);
    let p = f[y] || (f[y] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (h = f._any) === null || h === void 0 ? void 0 : h.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    l && p.run.push(l), c && (p.preventDefault = !0), u && (p.stopPropagation = !0);
  };
  for (let o of t) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let u = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = o;
        for (let d in u)
          u[d].run.push((f) => h(f, yx));
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        i(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && i(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return n;
}
let yx = null;
function tG(t, e, n, r) {
  yx = e;
  let s = cAe(e), i = ms(s, 0), o = Qi(i) == s.length && s != " ", a = "", l = !1, c = !1, u = !1;
  Bo && Bo.view == n && Bo.scope == r && (a = Bo.prefix + " ", zz.indexOf(e.keyCode) < 0 && (c = !0, Bo = null));
  let h = /* @__PURE__ */ new Set(), d = (p) => {
    if (p) {
      for (let m of p.run)
        if (!h.has(m) && (h.add(m), m(n)))
          return p.stopPropagation && (u = !0), !0;
      p.preventDefault && (p.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, f = t[r], g, y;
  return f && (d(f[a + Nm(s, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Fe.windows && e.ctrlKey && e.altKey) && (g = ua[e.keyCode]) && g != s ? (d(f[a + Nm(g, e, !0)]) || e.shiftKey && (y = rf[e.keyCode]) != s && y != g && d(f[a + Nm(y, e, !1)])) && (l = !0) : o && e.shiftKey && d(f[a + Nm(s, e, !0)]) && (l = !0), !l && d(f._any) && (l = !0)), c && (l = !0), l && u && e.stopPropagation(), yx = null, l;
}
class mp {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, n, r, s, i) {
    this.className = e, this.left = n, this.top = r, this.width = s, this.height = i;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, n, r) {
    if (r.empty) {
      let s = e.coordsAtPos(r.head, r.assoc || 1);
      if (!s)
        return [];
      let i = nG(e);
      return [new mp(n, s.left - i.left, s.top - i.top, null, s.bottom - s.top)];
    } else
      return U2e(e, n, r);
  }
}
function nG(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == jt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function uN(t, e, n, r) {
  let s = t.coordsAtPos(e, n * 2);
  if (!s)
    return r;
  let i = t.dom.getBoundingClientRect(), o = (s.top + s.bottom) / 2, a = t.posAtCoords({ x: i.left + 1, y: o }), l = t.posAtCoords({ x: i.right - 1, y: o });
  return a == null || l == null ? r : { from: Math.max(r.from, Math.min(a, l)), to: Math.min(r.to, Math.max(a, l)) };
}
function U2e(t, e, n) {
  if (n.to <= t.viewport.from || n.from >= t.viewport.to)
    return [];
  let r = Math.max(n.from, t.viewport.from), s = Math.min(n.to, t.viewport.to), i = t.textDirection == jt.LTR, o = t.contentDOM, a = o.getBoundingClientRect(), l = nG(t), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), d = a.right - (u ? parseInt(u.paddingRight) : 0), f = dx(t, r), g = dx(t, s), y = f.type == Qn.Text ? f : null, p = g.type == Qn.Text ? g : null;
  if (y && (t.lineWrapping || f.widgetLineBreaks) && (y = uN(t, r, 1, y)), p && (t.lineWrapping || g.widgetLineBreaks) && (p = uN(t, s, -1, p)), y && p && y.from == p.from && y.to == p.to)
    return b(_(n.from, n.to, y));
  {
    let w = y ? _(n.from, null, y) : v(f, !1), E = p ? _(null, n.to, p) : v(g, !0), x = [];
    return (y || f).to < (p || g).from - (y && p ? 1 : 0) || f.widgetLineBreaks > 1 && w.bottom + t.defaultLineHeight / 2 < E.top ? x.push(m(h, w.bottom, d, E.top)) : w.bottom < E.top && t.elementAtHeight((w.bottom + E.top) / 2).type == Qn.Text && (w.bottom = E.top = (w.bottom + E.top) / 2), b(w).concat(x).concat(b(E));
  }
  function m(w, E, x, S) {
    return new mp(e, w - l.left, E - l.top, x - w, S - E);
  }
  function b({ top: w, bottom: E, horizontal: x }) {
    let S = [];
    for (let T = 0; T < x.length; T += 2)
      S.push(m(x[T], w, x[T + 1], E));
    return S;
  }
  function _(w, E, x) {
    let S = 1e9, T = -1e9, R = [];
    function F(A, V, ee, K, te) {
      let N = t.coordsAtPos(A, A == x.to ? -2 : 2), L = t.coordsAtPos(ee, ee == x.from ? 2 : -2);
      !N || !L || (S = Math.min(N.top, L.top, S), T = Math.max(N.bottom, L.bottom, T), te == jt.LTR ? R.push(i && V ? h : N.left, i && K ? d : L.right) : R.push(!i && K ? h : L.left, !i && V ? d : N.right));
    }
    let P = w ?? x.from, M = E ?? x.to;
    for (let A of t.visibleRanges)
      if (A.to > P && A.from < M)
        for (let V = Math.max(A.from, P), ee = Math.min(A.to, M); ; ) {
          let K = t.state.doc.lineAt(V);
          for (let te of t.bidiSpans(K)) {
            let N = te.from + K.from, L = te.to + K.from;
            if (N >= ee)
              break;
            L > V && F(Math.max(N, V), w == null && N <= P, Math.min(L, ee), E == null && L >= M, te.dir);
          }
          if (V = K.to + 1, V >= ee)
            break;
        }
    return R.length == 0 && F(P, w == null, M, E == null, t.textDirection), { top: S, bottom: T, horizontal: R };
  }
  function v(w, E) {
    let x = a.top + (E ? w.top : w.bottom);
    return { top: x, bottom: x, horizontal: [] };
  }
}
function j2e(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class H2e {
  constructor(e, n) {
    this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Ig) != e.state.facet(Ig) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0, r = e.facet(Ig);
    for (; n < r.length && r[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, r) => !j2e(n, this.drawn[r]))) {
      let n = this.dom.firstChild, r = 0;
      for (let s of e)
        s.update && n && s.constructor && this.drawn[r].constructor && s.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(s.draw(), n);
      for (; n; ) {
        let s = n.nextSibling;
        n.remove(), n = s;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Ig = /* @__PURE__ */ ze.define();
function rG(t) {
  return [
    In.define((e) => new H2e(e, t)),
    Ig.of(t)
  ];
}
const sG = !(Fe.ios && Fe.webkit && Fe.webkit_version < 534), lf = /* @__PURE__ */ ze.define({
  combine(t) {
    return $l(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, n) => Math.min(e, n),
      drawRangeCursor: (e, n) => e || n
    });
  }
});
function z2e(t = {}) {
  return [
    lf.of(t),
    G2e,
    V2e,
    W2e,
    Oz.of(!0)
  ];
}
function iG(t) {
  return t.startState.facet(lf) != t.state.facet(lf);
}
const G2e = /* @__PURE__ */ rG({
  above: !0,
  markers(t) {
    let { state: e } = t, n = e.facet(lf), r = [];
    for (let s of e.selection.ranges) {
      let i = s == e.selection.main;
      if (s.empty ? !i || sG : n.drawRangeCursor) {
        let o = i ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = s.empty ? s : Ae.cursor(s.head, s.head > s.anchor ? -1 : 1);
        for (let l of mp.forRange(t, o, a))
          r.push(l);
      }
    }
    return r;
  },
  update(t, e) {
    t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = iG(t);
    return n && hN(t.state, e), t.docChanged || t.selectionSet || n;
  },
  mount(t, e) {
    hN(e.state, t);
  },
  class: "cm-cursorLayer"
});
function hN(t, e) {
  e.style.animationDuration = t.facet(lf).cursorBlinkRate + "ms";
}
const V2e = /* @__PURE__ */ rG({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : mp.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || iG(t);
  },
  class: "cm-selectionLayer"
}), bx = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
sG && (bx[".cm-line"].caretColor = bx[".cm-content"].caretColor = "transparent !important");
const W2e = /* @__PURE__ */ _a.highest(/* @__PURE__ */ He.theme(bx)), oG = /* @__PURE__ */ at.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), Oh = /* @__PURE__ */ En.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => r.is(oG) ? r.value : n, t);
  }
}), q2e = /* @__PURE__ */ In.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let n = t.state.field(Oh);
    n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(Oh) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(Oh), n = e != null && t.coordsAtPos(e);
    if (!n)
      return null;
    let r = t.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: n } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(Oh) != t && this.view.dispatch({ effects: oG.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function K2e() {
  return [Oh, q2e];
}
const dN = /* @__PURE__ */ In.fromClass(class {
  constructor() {
    this.height = 1e3, this.attrs = { style: "padding-bottom: 1000px" };
  }
  update(t) {
    let { view: e } = t, n = e.viewState.editorHeight - e.defaultLineHeight - e.documentPadding.top - 0.5;
    n >= 0 && n != this.height && (this.height = n, this.attrs = { style: `padding-bottom: ${n}px` });
  }
});
function Y2e() {
  return [dN, Jb.of((t) => {
    var e;
    return ((e = t.plugin(dN)) === null || e === void 0 ? void 0 : e.attrs) || null;
  })];
}
function Z2e() {
  return X2e;
}
const J2e = /* @__PURE__ */ yt.line({ class: "cm-activeLine" }), X2e = /* @__PURE__ */ In.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, n = [];
    for (let r of t.state.selection.ranges) {
      let s = t.lineBlockAt(r.head);
      s.from > e && (n.push(J2e.range(s.from)), e = s.from);
    }
    return yt.set(n);
  }
}, {
  decorations: (t) => t.decorations
}), ch = "-10000px";
class Q2e {
  constructor(e, n, r, s) {
    this.facet = n, this.createTooltipView = r, this.removeTooltipView = s, this.input = e.state.facet(n), this.tooltips = this.input.filter((o) => o);
    let i = null;
    this.tooltipViews = this.tooltips.map((o) => i = r(o, i));
  }
  update(e, n) {
    var r;
    let s = e.state.facet(this.facet), i = s.filter((l) => l);
    if (s === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = n ? [] : null;
    for (let l = 0; l < i.length; l++) {
      let c = i[l], u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let d = this.tooltips[h];
          d && d.create == c.create && (u = h);
        }
        if (u < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let h = o[l] = this.tooltipViews[u];
          a && (a[l] = n[u]), h.update && h.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
    return n && (a.forEach((l, c) => n[c] = l), n.length = a.length), this.input = s, this.tooltips = i, this.tooltipViews = o, !0;
  }
}
function eRe(t = {}) {
  return Pg.of(t);
}
function tRe(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const Pg = /* @__PURE__ */ ze.define({
  combine: (t) => {
    var e, n, r;
    return {
      position: Fe.ios ? "absolute" : ((e = t.find((s) => s.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((n = t.find((s) => s.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((r = t.find((s) => s.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || tRe
    };
  }
}), fN = /* @__PURE__ */ new WeakMap(), aG = /* @__PURE__ */ In.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(Pg);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new Q2e(t, aA, (n, r) => this.createTooltip(n, r), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let n = e || t.geometryChanged, r = t.state.facet(Pg);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      n = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      n = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let n = t.create(this.view), r = e ? e.dom : null;
    if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", n.dom.appendChild(s);
    }
    return n.dom.style.position = this.position, n.dom.style.top = ch, n.dom.style.left = "0px", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var t, e, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = 1, e = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (Fe.gecko)
        n = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == ch && i.style.left == "0px") {
        let o = i.getBoundingClientRect();
        n = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (t = i.width / this.parent.offsetWidth, e = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), s = rA(this.view);
    return {
      visible: {
        left: r.left + s.left,
        top: r.top + s.top,
        right: r.right - s.right,
        bottom: r.bottom - s.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((i, o) => {
        let a = this.manager.tooltipViews[o];
        return a.getCoords ? a.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(Pg).tooltipSpace(this.view),
      scaleX: t,
      scaleY: e,
      makeAbsolute: n
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: n, space: r, scaleX: s, scaleY: i } = t, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, h = t.pos[a], d = t.size[a];
      if (!h || l.clip !== !1 && (h.bottom <= Math.max(n.top, r.top) || h.top >= Math.min(n.bottom, r.bottom) || h.right < Math.max(n.left, r.left) - 0.1 || h.left > Math.min(n.right, r.right) + 0.1)) {
        u.style.top = ch;
        continue;
      }
      let f = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, g = f ? 7 : 0, y = d.right - d.left, p = (e = fN.get(c)) !== null && e !== void 0 ? e : d.bottom - d.top, m = c.offset || rRe, b = this.view.textDirection == jt.LTR, _ = d.width > r.right - r.left ? b ? r.left : r.right - d.width : b ? Math.max(r.left, Math.min(h.left - (f ? 14 : 0) + m.x, r.right - y)) : Math.min(Math.max(r.left, h.left - y + (f ? 14 : 0) - m.x), r.right - y), v = this.above[a];
      !l.strictSide && (v ? h.top - p - g - m.y < r.top : h.bottom + p + g + m.y > r.bottom) && v == r.bottom - h.bottom > h.top - r.top && (v = this.above[a] = !v);
      let w = (v ? h.top - r.top : r.bottom - h.bottom) - g;
      if (w < p && c.resize !== !1) {
        if (w < this.view.defaultLineHeight) {
          u.style.top = ch;
          continue;
        }
        fN.set(c, p), u.style.height = (p = w) / i + "px";
      } else u.style.height && (u.style.height = "");
      let E = v ? h.top - p - g - m.y : h.bottom + g + m.y, x = _ + y;
      if (c.overlap !== !0)
        for (let S of o)
          S.left < x && S.right > _ && S.top < E + p && S.bottom > E && (E = v ? S.top - p - 2 - g : S.bottom + g + 2);
      if (this.position == "absolute" ? (u.style.top = (E - t.parent.top) / i + "px", pN(u, (_ - t.parent.left) / s)) : (u.style.top = E / i + "px", pN(u, _ / s)), f) {
        let S = h.left + (b ? m.x : -m.x) - (_ + 14 - 7);
        f.style.left = S / s + "px";
      }
      c.overlap !== !0 && o.push({ left: _, top: E, right: x, bottom: E + p }), u.classList.toggle("cm-tooltip-above", v), u.classList.toggle("cm-tooltip-below", !v), c.positioned && c.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = ch;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function pN(t, e) {
  let n = parseInt(t.style.left, 10);
  (isNaN(n) || Math.abs(e - n) > 1) && (t.style.left = e + "px");
}
const nRe = /* @__PURE__ */ He.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), rRe = { x: 0, y: 0 }, aA = /* @__PURE__ */ ze.define({
  enables: [aG, nRe]
});
function lG(t, e) {
  let n = t.plugin(aG);
  if (!n)
    return null;
  let r = n.manager.tooltips.indexOf(e);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
const mN = /* @__PURE__ */ ze.define({
  combine(t) {
    let e, n;
    for (let r of t)
      e = e || r.topContainer, n = n || r.bottomContainer;
    return { topContainer: e, bottomContainer: n };
  }
});
function ly(t, e) {
  let n = t.plugin(cG), r = n ? n.specs.indexOf(e) : -1;
  return r > -1 ? n.panels[r] : null;
}
const cG = /* @__PURE__ */ In.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(cy), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
    let e = t.state.facet(mN);
    this.top = new Lm(t, !0, e.topContainer), this.bottom = new Lm(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(t) {
    let e = t.state.facet(mN);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Lm(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Lm(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = t.state.facet(cy);
    if (n != this.input) {
      let r = n.filter((l) => l), s = [], i = [], o = [], a = [];
      for (let l of r) {
        let c = this.specs.indexOf(l), u;
        c < 0 ? (u = l(t.view), a.push(u)) : (u = this.panels[c], u.update && u.update(t)), s.push(u), (u.top ? i : o).push(u);
      }
      this.specs = r, this.panels = s, this.top.sync(i), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => He.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
let Lm = class {
  constructor(e, n, r) {
    this.view = e, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels)
      n.destroy && e.indexOf(n) < 0 && n.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; )
          e = gN(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(n.dom, e);
    for (; e; )
      e = gN(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
};
function gN(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const cy = /* @__PURE__ */ ze.define({
  enables: cG
});
class po extends vl {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
po.prototype.elementClass = "";
po.prototype.toDOM = void 0;
po.prototype.mapMode = Fn.TrackBefore;
po.prototype.startSide = po.prototype.endSide = -1;
po.prototype.point = !0;
const Og = /* @__PURE__ */ ze.define(), sRe = /* @__PURE__ */ ze.define(), iRe = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => _t.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, ld = /* @__PURE__ */ ze.define();
function oRe(t) {
  return [uG(), ld.of(Object.assign(Object.assign({}, iRe), t))];
}
const yN = /* @__PURE__ */ ze.define({
  combine: (t) => t.some((e) => e)
});
function uG(t) {
  return [
    aRe
  ];
}
const aRe = /* @__PURE__ */ In.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(ld).map((e) => new _N(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(yN), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, n = t.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
      this.syncGutters(r < (n.to - n.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(yN) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let n = _t.iter(this.view.state.facet(Og), this.view.viewport.from), r = [], s = this.gutters.map((i) => new lRe(i, this.view.viewport, -this.view.documentPadding.top));
    for (let i of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(i.type)) {
        let o = !0;
        for (let a of i.type)
          if (a.type == Qn.Text && o) {
            _x(n, r, a.from);
            for (let l of s)
              l.line(this.view, a, r);
            o = !1;
          } else if (a.widget)
            for (let l of s)
              l.widget(this.view, a);
      } else if (i.type == Qn.Text) {
        _x(n, r, i.from);
        for (let o of s)
          o.line(this.view, i, r);
      } else if (i.widget)
        for (let o of s)
          o.widget(this.view, i);
    for (let i of s)
      i.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(ld), n = t.state.facet(ld), r = t.docChanged || t.heightChanged || t.viewportChanged || !_t.eq(t.startState.facet(Og), t.state.facet(Og), t.view.viewport.from, t.view.viewport.to);
    if (e == n)
      for (let s of this.gutters)
        s.update(t) && (r = !0);
    else {
      r = !0;
      let s = [];
      for (let i of n) {
        let o = e.indexOf(i);
        o < 0 ? s.push(new _N(this.view, i)) : (this.gutters[o].update(t), s.push(this.gutters[o]));
      }
      for (let i of this.gutters)
        i.dom.remove(), s.indexOf(i) < 0 && i.destroy();
      for (let i of s)
        this.dom.appendChild(i.dom);
      this.gutters = s;
    }
    return r;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => He.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == jt.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX };
  })
});
function bN(t) {
  return Array.isArray(t) ? t : [t];
}
function _x(t, e, n) {
  for (; t.value && t.from <= n; )
    t.from == n && e.push(t.value), t.next();
}
class lRe {
  constructor(e, n, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = _t.iter(e.markers, n.from);
  }
  addElement(e, n, r) {
    let { gutter: s } = this, i = (n.top - this.height) / e.scaleY, o = n.height / e.scaleY;
    if (this.i == s.elements.length) {
      let a = new hG(e, o, i, r);
      s.elements.push(a), s.dom.appendChild(a.dom);
    } else
      s.elements[this.i].update(e, o, i, r);
    this.height = n.bottom, this.i++;
  }
  line(e, n, r) {
    let s = [];
    _x(this.cursor, s, n.from), r.length && (s = s.concat(r));
    let i = this.gutter.config.lineMarker(e, n, s);
    i && s.unshift(i);
    let o = this.gutter;
    s.length == 0 && !o.config.renderEmptyElements || this.addElement(e, n, s);
  }
  widget(e, n) {
    let r = this.gutter.config.widgetMarker(e, n.widget, n), s = r ? [r] : null;
    for (let i of e.state.facet(sRe)) {
      let o = i(e, n.widget, n);
      o && (s || (s = [])).push(o);
    }
    s && this.addElement(e, n, s);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class _N {
  constructor(e, n) {
    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in n.domEventHandlers)
      this.dom.addEventListener(r, (s) => {
        let i = s.target, o;
        if (i != this.dom && this.dom.contains(i)) {
          for (; i.parentNode != this.dom; )
            i = i.parentNode;
          let l = i.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = s.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        n.domEventHandlers[r](e, a, s) && s.preventDefault();
      });
    this.markers = bN(n.markers(e)), n.initialSpacer && (this.spacer = new hG(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let n = this.markers;
    if (this.markers = bN(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let s = this.config.updateSpacer(this.spacer.markers[0], e);
      s != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [s]);
    }
    let r = e.view.viewport;
    return !_t.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class hG {
  constructor(e, n, r, s) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, r, s);
  }
  update(e, n, r, s) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), cRe(this.markers, s) || this.setMarkers(e, s);
  }
  setMarkers(e, n) {
    let r = "cm-gutterElement", s = this.dom.firstChild;
    for (let i = 0, o = 0; ; ) {
      let a = o, l = i < n.length ? n[i++] : null, c = !1;
      if (l) {
        let u = l.elementClass;
        u && (r += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            a = h, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(s);
          let h = s.nextSibling;
          s.remove(), s = h;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? s = s.nextSibling : this.dom.insertBefore(l.toDOM(e), s)), c && o++;
    }
    this.dom.className = r, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function cRe(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].compare(e[n]))
      return !1;
  return !0;
}
const uRe = /* @__PURE__ */ ze.define(), hRe = /* @__PURE__ */ ze.define(), wc = /* @__PURE__ */ ze.define({
  combine(t) {
    return $l(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, n) {
        let r = Object.assign({}, e);
        for (let s in n) {
          let i = r[s], o = n[s];
          r[s] = i ? (a, l, c) => i(a, l, c) || o(a, l, c) : o;
        }
        return r;
      }
    });
  }
});
class hw extends po {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function dw(t, e) {
  return t.state.facet(wc).formatNumber(e, t.state);
}
const dRe = /* @__PURE__ */ ld.compute([wc], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(uRe);
  },
  lineMarker(e, n, r) {
    return r.some((s) => s.toDOM) ? null : new hw(dw(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: (e, n, r) => {
    for (let s of e.state.facet(hRe)) {
      let i = s(e, n, r);
      if (i)
        return i;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(wc) != e.state.facet(wc),
  initialSpacer(e) {
    return new hw(dw(e, vN(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let r = dw(n.view, vN(n.view.state.doc.lines));
    return r == e.number ? e : new hw(r);
  },
  domEventHandlers: t.facet(wc).domEventHandlers
}));
function fRe(t = {}) {
  return [
    wc.of(t),
    uG(),
    dRe
  ];
}
function vN(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const pRe = /* @__PURE__ */ new class extends po {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), mRe = /* @__PURE__ */ Og.compute(["selection"], (t) => {
  let e = [], n = -1;
  for (let r of t.selection.ranges) {
    let s = t.doc.lineAt(r.head).from;
    s > n && (n = s, e.push(pRe.range(s)));
  }
  return _t.of(e);
});
function gRe() {
  return mRe;
}
const yRe = 1024;
let bRe = 0;
class Yr {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
class ct {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = bRe++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Er.match(e)), (n) => {
      let r = e(n);
      return r === void 0 ? null : [this, r];
    };
  }
}
ct.closedBy = new ct({ deserialize: (t) => t.split(" ") });
ct.openedBy = new ct({ deserialize: (t) => t.split(" ") });
ct.group = new ct({ deserialize: (t) => t.split(" ") });
ct.isolate = new ct({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
ct.contextHash = new ct({ perNode: !0 });
ct.lookAhead = new ct({ perNode: !0 });
ct.mounted = new ct({ perNode: !0 });
class cf {
  constructor(e, n, r) {
    this.tree = e, this.overlay = n, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[ct.mounted.id];
  }
}
const _Re = /* @__PURE__ */ Object.create(null);
class Er {
  /**
  @internal
  */
  constructor(e, n, r, s = 0) {
    this.name = e, this.props = n, this.id = r, this.flags = s;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : _Re, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), s = new Er(e.name || "", n, e.id, r);
    if (e.props) {
      for (let i of e.props)
        if (Array.isArray(i) || (i = i(s)), i) {
          if (i[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[i[0].id] = i[1];
        }
    }
    return s;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let n = this.prop(ct.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let s of r.split(" "))
        n[s] = e[r];
    return (r) => {
      for (let s = r.prop(ct.group), i = -1; i < (s ? s.length : 0); i++) {
        let o = n[i < 0 ? r.name : s[i]];
        if (o)
          return o;
      }
    };
  }
}
Er.none = new Er(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class dG {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let n = [];
    for (let r of this.types) {
      let s = null;
      for (let i of e) {
        let o = i(r);
        o && (s || (s = Object.assign({}, r.props)), s[o[0].id] = o[1]);
      }
      n.push(s ? new Er(r.name, s, r.id, r.flags) : r);
    }
    return new dG(n);
  }
}
const Mm = /* @__PURE__ */ new WeakMap(), wN = /* @__PURE__ */ new WeakMap();
var Wt;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Wt || (Wt = {}));
class fn {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, n, r, s, i) {
    if (this.type = e, this.children = n, this.positions = r, this.length = s, this.props = null, i && i.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of i)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = cf.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let n = "";
    for (let r of this.children) {
      let s = r.toString();
      s && (n && (n += ","), n += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new uy(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, n = 0, r = 0) {
    let s = Mm.get(this) || this.topNode, i = new uy(s);
    return i.moveTo(e, n), Mm.set(this, i._tree), i;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Un(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, n = 0) {
    let r = uf(Mm.get(this) || this.topNode, e, n, !1);
    return Mm.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, n = 0) {
    let r = uf(wN.get(this) || this.topNode, e, n, !0);
    return wN.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, n = 0) {
    return ERe(this, e, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: n, leave: r, from: s = 0, to: i = this.length } = e, o = e.mode || 0, a = (o & Wt.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Wt.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= i && l.to >= s && (!a && l.type.isAnonymous || n(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let n in this.props)
        e.push([+n, this.props[n]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : uA(Er.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, s) => new fn(this.type, n, r, s, this.propValues), e.makeTree || ((n, r, s) => new fn(Er.none, n, r, s)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return SRe(e);
  }
}
fn.empty = new fn(Er.none, [], [], 0);
class lA {
  constructor(e, n) {
    this.buffer = e, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new lA(this.buffer, this.index);
  }
}
class da {
  /**
  Create a tree buffer.
  */
  constructor(e, n, r) {
    this.buffer = e, this.length = n, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Er.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; )
      e.push(this.childString(n)), n = this.buffer[n + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let n = this.buffer[e], r = this.buffer[e + 3], s = this.set.types[n], i = s.name;
    if (/\W/.test(i) && !s.isError && (i = JSON.stringify(i)), e += 4, r == e)
      return i;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return i + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, n, r, s, i) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != n && !(fG(i, s, o[l + 1], o[l + 2]) && (a = l, r > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, n, r) {
    let s = this.buffer, i = new Uint16Array(n - e), o = 0;
    for (let a = e, l = 0; a < n; ) {
      i[l++] = s[a++], i[l++] = s[a++] - r;
      let c = i[l++] = s[a++] - r;
      i[l++] = s[a++] - e, o = Math.max(o, c);
    }
    return new da(i, o, this.set);
  }
}
function fG(t, e, n, r) {
  switch (t) {
    case -2:
      return n < e;
    case -1:
      return r >= e && n < e;
    case 0:
      return n < e && r > e;
    case 1:
      return n <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function uf(t, e, n, r) {
  for (var s; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
    let o = !r && t instanceof Un && t.index < 0 ? null : t.parent;
    if (!o)
      return t;
    t = o;
  }
  let i = r ? 0 : Wt.IgnoreOverlays;
  if (r)
    for (let o = t, a = o.parent; a; o = a, a = o.parent)
      o instanceof Un && o.index < 0 && ((s = a.enter(e, n, i)) === null || s === void 0 ? void 0 : s.from) != o.from && (t = a);
  for (; ; ) {
    let o = t.enter(e, n, i);
    if (!o)
      return t;
    t = o;
  }
}
class pG {
  cursor(e = 0) {
    return new uy(this, e);
  }
  getChild(e, n = null, r = null) {
    let s = EN(this, e, n, r);
    return s.length ? s[0] : null;
  }
  getChildren(e, n = null, r = null) {
    return EN(this, e, n, r);
  }
  resolve(e, n = 0) {
    return uf(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return uf(this, e, n, !0);
  }
  matchContext(e) {
    return vx(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e), r = this;
    for (; n; ) {
      let s = n.lastChild;
      if (!s || s.to != n.to)
        break;
      s.type.isError && s.from == s.to ? (r = n, n = s.prevSibling) : n = s;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Un extends pG {
  constructor(e, n, r, s) {
    super(), this._tree = e, this.from = n, this.index = r, this._parent = s;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, r, s, i = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = n > 0 ? a.length : -1; e != c; e += n) {
        let u = a[e], h = l[e] + o.from;
        if (fG(s, r, h, h + u.length)) {
          if (u instanceof da) {
            if (i & Wt.ExcludeBuffers)
              continue;
            let d = u.findChild(0, u.buffer.length, n, r - h, s);
            if (d > -1)
              return new pi(new vRe(o, u, e, h), null, d);
          } else if (i & Wt.IncludeAnonymous || !u.type.isAnonymous || cA(u)) {
            let d;
            if (!(i & Wt.IgnoreMounts) && (d = cf.get(u)) && !d.overlay)
              return new Un(d.tree, h, e, o);
            let f = new Un(u, h, e, o);
            return i & Wt.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, s);
          }
        }
      }
      if (i & Wt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + n : e = n < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, r = 0) {
    let s;
    if (!(r & Wt.IgnoreOverlays) && (s = cf.get(this._tree)) && s.overlay) {
      let i = e - this.from;
      for (let { from: o, to: a } of s.overlay)
        if ((n > 0 ? o <= i : o < i) && (n < 0 ? a >= i : a > i))
          return new Un(s.tree, s.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function EN(t, e, n, r) {
  let s = t.cursor(), i = [];
  if (!s.firstChild())
    return i;
  if (n != null) {
    for (let o = !1; !o; )
      if (o = s.type.is(n), !s.nextSibling())
        return i;
  }
  for (; ; ) {
    if (r != null && s.type.is(r))
      return i;
    if (s.type.is(e) && i.push(s.node), !s.nextSibling())
      return r == null ? i : [];
  }
}
function vx(t, e, n = e.length - 1) {
  for (let r = t; n >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[n] && e[n] != r.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class vRe {
  constructor(e, n, r, s) {
    this.parent = e, this.buffer = n, this.index = r, this.start = s;
  }
}
class pi extends pG {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, r) {
    super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, n, r) {
    let { buffer: s } = this.context, i = s.findChild(this.index + 4, s.buffer[this.index + 3], e, n - this.context.start, r);
    return i < 0 ? null : new pi(this.context, this, i);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, r = 0) {
    if (r & Wt.ExcludeBuffers)
      return null;
    let { buffer: s } = this.context, i = s.findChild(this.index + 4, s.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return i < 0 ? null : new pi(this.context, this, i);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new pi(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new pi(this.context, this._parent, e.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], n = [], { buffer: r } = this.context, s = this.index + 4, i = r.buffer[this.index + 3];
    if (i > s) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(s, i, o)), n.push(0);
    }
    return new fn(this.type, e, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function mG(t) {
  if (!t.length)
    return null;
  let e = 0, n = t[0];
  for (let i = 1; i < t.length; i++) {
    let o = t[i];
    (o.from > n.from || o.to < n.to) && (n = o, e = i);
  }
  let r = n instanceof Un && n.index < 0 ? null : n.parent, s = t.slice();
  return r ? s[e] = r : s.splice(e, 1), new wRe(s, n);
}
class wRe {
  constructor(e, n) {
    this.heads = e, this.node = n;
  }
  get next() {
    return mG(this.heads);
  }
}
function ERe(t, e, n) {
  let r = t.resolveInner(e, n), s = null;
  for (let i = r instanceof Un ? r : r.context.parent; i; i = i.parent)
    if (i.index < 0) {
      let o = i.parent;
      (s || (s = [r])).push(o.resolve(e, n)), i = o;
    } else {
      let o = cf.get(i.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new Un(o.tree, o.overlay[0].from + i.from, -1, i);
        (s || (s = [r])).push(uf(a, e, n, !1));
      }
    }
  return s ? mG(s) : r;
}
class uy {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Un)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: r, buffer: s } = this.buffer;
    return this.type = n || s.set.types[s.buffer[e]], this.from = r + s.buffer[e + 1], this.to = r + s.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Un ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, n, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
    let { buffer: s } = this.buffer, i = s.findChild(this.index + 4, s.buffer[this.index + 3], e, n - this.buffer.start, r);
    return i < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(i));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, n, r = this.mode) {
    return this.buffer ? r & Wt.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Wt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Wt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let s = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != s)
        return this.yieldBuf(n.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let s = n.buffer[this.index + 3];
      if (s < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
        return this.yieldBuf(s);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n, r, { buffer: s } = this;
    if (s) {
      if (e > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let i = 0; i < this.index; i++)
          if (s.buffer.buffer[i + 3] < this.index)
            return !1;
      ({ index: n, parent: r } = s);
    } else
      ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let i = n + e, o = e < 0 ? -1 : r._tree.children.length; i != o; i += e) {
          let a = r._tree.children[i];
          if (this.mode & Wt.IncludeAnonymous || a instanceof da || !a.type.isAnonymous || cA(a))
            return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, n = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let s = this.index, i = this.stack.length; i >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == s) {
            if (s == this.index)
              return o;
            n = o, r = i + 1;
            break e;
          }
        s = this.stack[--i];
      }
    for (let s = r; s < this.stack.length; s++)
      n = new pi(this.buffer, n, this.stack[s]);
    return this.bufferNode = new pi(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, n) {
    for (let r = 0; ; ) {
      let s = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (s = !0);
      }
      for (; ; ) {
        if (s && n && n(this), s = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, s = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return vx(this.node.parent, e);
    let { buffer: n } = this.buffer, { types: r } = n.set;
    for (let s = e.length - 1, i = this.stack.length - 1; s >= 0; i--) {
      if (i < 0)
        return vx(this._tree, e, s);
      let o = r[n.buffer[this.stack[i]]];
      if (!o.isAnonymous) {
        if (e[s] && e[s] != o.name)
          return !1;
        s--;
      }
    }
    return !0;
  }
}
function cA(t) {
  return t.children.some((e) => e instanceof da || !e.type.isAnonymous || cA(e));
}
function SRe(t) {
  var e;
  let { buffer: n, nodeSet: r, maxBufferLength: s = yRe, reused: i = [], minRepeatType: o = r.types.length } = t, a = Array.isArray(n) ? new lA(n, n.length) : n, l = r.types, c = 0, u = 0;
  function h(w, E, x, S, T, R) {
    let { id: F, start: P, end: M, size: A } = a, V = u, ee = c;
    for (; A < 0; )
      if (a.next(), A == -1) {
        let j = i[F];
        x.push(j), S.push(P - w);
        return;
      } else if (A == -3) {
        c = F;
        return;
      } else if (A == -4) {
        u = F;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${A}`);
    let K = l[F], te, N, L = P - w;
    if (M - P <= s && (N = p(a.pos - E, T))) {
      let j = new Uint16Array(N.size - N.skip), H = a.pos - N.size, U = j.length;
      for (; a.pos > H; )
        U = m(N.start, j, U);
      te = new da(j, M - N.start, r), L = N.start - w;
    } else {
      let j = a.pos - A;
      a.next();
      let H = [], U = [], Y = F >= o ? F : -1, ne = 0, he = M;
      for (; a.pos > j; )
        Y >= 0 && a.id == Y && a.size >= 0 ? (a.end <= he - s && (g(H, U, P, ne, a.end, he, Y, V, ee), ne = H.length, he = a.end), a.next()) : R > 2500 ? d(P, j, H, U) : h(P, j, H, U, Y, R + 1);
      if (Y >= 0 && ne > 0 && ne < H.length && g(H, U, P, ne, P, he, Y, V, ee), H.reverse(), U.reverse(), Y > -1 && ne > 0) {
        let X = f(K, ee);
        te = uA(K, H, U, 0, H.length, 0, M - P, X, X);
      } else
        te = y(K, H, U, M - P, V - M, ee);
    }
    x.push(te), S.push(L);
  }
  function d(w, E, x, S) {
    let T = [], R = 0, F = -1;
    for (; a.pos > E; ) {
      let { id: P, start: M, end: A, size: V } = a;
      if (V > 4)
        a.next();
      else {
        if (F > -1 && M < F)
          break;
        F < 0 && (F = A - s), T.push(P, M, A), R++, a.next();
      }
    }
    if (R) {
      let P = new Uint16Array(R * 4), M = T[T.length - 2];
      for (let A = T.length - 3, V = 0; A >= 0; A -= 3)
        P[V++] = T[A], P[V++] = T[A + 1] - M, P[V++] = T[A + 2] - M, P[V++] = V;
      x.push(new da(P, T[2] - M, r)), S.push(M - w);
    }
  }
  function f(w, E) {
    return (x, S, T) => {
      let R = 0, F = x.length - 1, P, M;
      if (F >= 0 && (P = x[F]) instanceof fn) {
        if (!F && P.type == w && P.length == T)
          return P;
        (M = P.prop(ct.lookAhead)) && (R = S[F] + P.length + M);
      }
      return y(w, x, S, T, R, E);
    };
  }
  function g(w, E, x, S, T, R, F, P, M) {
    let A = [], V = [];
    for (; w.length > S; )
      A.push(w.pop()), V.push(E.pop() + x - T);
    w.push(y(r.types[F], A, V, R - T, P - R, M)), E.push(T - x);
  }
  function y(w, E, x, S, T, R, F) {
    if (R) {
      let P = [ct.contextHash, R];
      F = F ? [P].concat(F) : [P];
    }
    if (T > 25) {
      let P = [ct.lookAhead, T];
      F = F ? [P].concat(F) : [P];
    }
    return new fn(w, E, x, S, F);
  }
  function p(w, E) {
    let x = a.fork(), S = 0, T = 0, R = 0, F = x.end - s, P = { size: 0, start: 0, skip: 0 };
    e: for (let M = x.pos - w; x.pos > M; ) {
      let A = x.size;
      if (x.id == E && A >= 0) {
        P.size = S, P.start = T, P.skip = R, R += 4, S += 4, x.next();
        continue;
      }
      let V = x.pos - A;
      if (A < 0 || V < M || x.start < F)
        break;
      let ee = x.id >= o ? 4 : 0, K = x.start;
      for (x.next(); x.pos > V; ) {
        if (x.size < 0)
          if (x.size == -3)
            ee += 4;
          else
            break e;
        else x.id >= o && (ee += 4);
        x.next();
      }
      T = K, S += A, R += ee;
    }
    return (E < 0 || S == w) && (P.size = S, P.start = T, P.skip = R), P.size > 4 ? P : void 0;
  }
  function m(w, E, x) {
    let { id: S, start: T, end: R, size: F } = a;
    if (a.next(), F >= 0 && S < o) {
      let P = x;
      if (F > 4) {
        let M = a.pos - (F - 4);
        for (; a.pos > M; )
          x = m(w, E, x);
      }
      E[--x] = P, E[--x] = R - w, E[--x] = T - w, E[--x] = S;
    } else F == -3 ? c = S : F == -4 && (u = S);
    return x;
  }
  let b = [], _ = [];
  for (; a.pos > 0; )
    h(t.start || 0, t.bufferStart || 0, b, _, -1, 0);
  let v = (e = t.length) !== null && e !== void 0 ? e : b.length ? _[0] + b[0].length : 0;
  return new fn(l[t.topID], b.reverse(), _.reverse(), v);
}
const SN = /* @__PURE__ */ new WeakMap();
function Dg(t, e) {
  if (!t.isAnonymous || e instanceof da || e.type != t)
    return 1;
  let n = SN.get(e);
  if (n == null) {
    n = 1;
    for (let r of e.children) {
      if (r.type != t || !(r instanceof fn)) {
        n = 1;
        break;
      }
      n += Dg(t, r);
    }
    SN.set(e, n);
  }
  return n;
}
function uA(t, e, n, r, s, i, o, a, l) {
  let c = 0;
  for (let g = r; g < s; g++)
    c += Dg(t, e[g]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], d = [];
  function f(g, y, p, m, b) {
    for (let _ = p; _ < m; ) {
      let v = _, w = y[_], E = Dg(t, g[_]);
      for (_++; _ < m; _++) {
        let x = Dg(t, g[_]);
        if (E + x >= u)
          break;
        E += x;
      }
      if (_ == v + 1) {
        if (E > u) {
          let x = g[v];
          f(x.children, x.positions, 0, x.children.length, y[v] + b);
          continue;
        }
        h.push(g[v]);
      } else {
        let x = y[_ - 1] + g[_ - 1].length - w;
        h.push(uA(t, g, y, v, _, w, x, null, l));
      }
      d.push(w + b - i);
    }
  }
  return f(e, n, r, s, 0), (a || l)(h, d, o);
}
class VVe {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, n, r) {
    let s = this.map.get(e);
    s || this.map.set(e, s = /* @__PURE__ */ new Map()), s.set(n, r);
  }
  getBuffer(e, n) {
    let r = this.map.get(e);
    return r && r.get(n);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, n) {
    e instanceof pi ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof Un && this.map.set(e.tree, n);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof pi ? this.getBuffer(e.context.buffer, e.index) : e instanceof Un ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, n) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class oo {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, n, r, s, i = !1, o = !1) {
    this.from = e, this.to = n, this.tree = r, this.offset = s, this.open = (i ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, n = [], r = !1) {
    let s = [new oo(0, e.length, e, 0, !1, r)];
    for (let i of n)
      i.to > e.length && s.push(i);
    return s;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, n, r = 128) {
    if (!n.length)
      return e;
    let s = [], i = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < n.length ? n[a] : null, h = u ? u.fromA : 1e9;
      if (h - l >= r)
        for (; o && o.from < h; ) {
          let d = o;
          if (l >= d.from || h <= d.to || c) {
            let f = Math.max(d.from, l) - c, g = Math.min(d.to, h) - c;
            d = f >= g ? null : new oo(f, g, d.tree, d.offset + c, a > 0, !!u);
          }
          if (d && s.push(d), o.to > h)
            break;
          o = i < e.length ? e[i++] : null;
        }
      if (!u)
        break;
      l = u.toA, c = u.toA - u.toB;
    }
    return s;
  }
}
class xRe {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, n, r) {
    return typeof e == "string" && (e = new TRe(e)), r = r ? r.length ? r.map((s) => new Yr(s.from, s.to)) : [new Yr(0, 0)] : [new Yr(0, e.length)], this.createParse(e, n || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, n, r) {
    let s = this.startParse(e, n, r);
    for (; ; ) {
      let i = s.advance();
      if (i)
        return i;
    }
  }
}
class TRe {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
function WVe(t) {
  return (e, n, r, s) => new kRe(e, t, n, r, s);
}
class xN {
  constructor(e, n, r, s, i) {
    this.parser = e, this.parse = n, this.overlay = r, this.target = s, this.from = i;
  }
}
function TN(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class CRe {
  constructor(e, n, r, s, i, o, a) {
    this.parser = e, this.predicate = n, this.mounts = r, this.index = s, this.start = i, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const wx = new ct({ perNode: !0 });
class kRe {
  constructor(e, n, r, s, i) {
    this.nest = n, this.input = r, this.fragments = s, this.ranges = i, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let s of this.inner)
          s.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new fn(r.type, r.children, r.positions, r.length, r.propValues.concat([[wx, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], n = e.parse.advance();
    if (n) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[ct.mounted.id] = new cf(n, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++)
      this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let n = this.innerDone; n < this.inner.length; n++)
        this.inner[n].parse.stopAt(e);
  }
  startInner() {
    let e = new IRe(this.fragments), n = null, r = null, s = new uy(new Un(this.baseTree, this.ranges[0].from, 0, null), Wt.IncludeAnonymous | Wt.IgnoreMounts);
    e: for (let i, o; ; ) {
      let a = !0, l;
      if (this.stoppedAt != null && s.from >= this.stoppedAt)
        a = !1;
      else if (e.hasNode(s)) {
        if (n) {
          let c = n.mounts.find((u) => u.frag.from <= s.from && u.frag.to >= s.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let h = u.from + c.pos, d = u.to + c.pos;
              h >= s.from && d <= s.to && !n.ranges.some((f) => f.from < d && f.to > h) && n.ranges.push({ from: h, to: d });
            }
        }
        a = !1;
      } else if (r && (o = ARe(r.ranges, s.from, s.to)))
        a = o != 2;
      else if (!s.type.isAnonymous && (i = this.nest(s, this.input)) && (s.from < s.to || !i.overlay)) {
        s.tree || RRe(s);
        let c = e.findMounts(s.from, i.parser);
        if (typeof i.overlay == "function")
          n = new CRe(i.parser, i.overlay, c, this.inner.length, s.from, s.tree, n);
        else {
          let u = AN(this.ranges, i.overlay || (s.from < s.to ? [new Yr(s.from, s.to)] : []));
          u.length && TN(u), (u.length || !i.overlay) && this.inner.push(new xN(i.parser, u.length ? i.parser.startParse(this.input, RN(c, u), u) : i.parser.startParse(""), i.overlay ? i.overlay.map((h) => new Yr(h.from - s.from, h.to - s.from)) : null, s.tree, u.length ? u[0].from : s.from)), i.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : a = !1;
        }
      } else if (n && (l = n.predicate(s)) && (l === !0 && (l = new Yr(s.from, s.to)), l.from < l.to)) {
        let c = n.ranges.length - 1;
        c >= 0 && n.ranges[c].to == l.from ? n.ranges[c] = { from: n.ranges[c].from, to: l.to } : n.ranges.push(l);
      }
      if (a && s.firstChild())
        n && n.depth++, r && r.depth++;
      else
        for (; !s.nextSibling(); ) {
          if (!s.parent())
            break e;
          if (n && !--n.depth) {
            let c = AN(this.ranges, n.ranges);
            c.length && (TN(c), this.inner.splice(n.index, 0, new xN(n.parser, n.parser.startParse(this.input, RN(n.mounts, c), c), n.ranges.map((u) => new Yr(u.from - n.start, u.to - n.start)), n.target, c[0].from))), n = n.prev;
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function ARe(t, e, n) {
  for (let r of t) {
    if (r.from >= n)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= n ? 2 : 1;
  }
  return 0;
}
function CN(t, e, n, r, s, i) {
  if (e < n) {
    let o = t.buffer[e + 1];
    r.push(t.slice(e, n, o)), s.push(o - i);
  }
}
function RRe(t) {
  let { node: e } = t, n = [], r = e.context.buffer;
  do
    n.push(t.index), t.parent();
  while (!t.tree);
  let s = t.tree, i = s.children.indexOf(r), o = s.children[i], a = o.buffer, l = [i];
  function c(u, h, d, f, g, y) {
    let p = n[y], m = [], b = [];
    CN(o, u, p, m, b, f);
    let _ = a[p + 1], v = a[p + 2];
    l.push(m.length);
    let w = y ? c(p + 4, a[p + 3], o.set.types[a[p]], _, v - _, y - 1) : e.toTree();
    return m.push(w), b.push(_ - f), CN(o, a[p + 3], h, m, b, f), new fn(d, m, b, g);
  }
  s.children[i] = c(0, a.length, Er.none, 0, o.length, n.length - 1);
  for (let u of l) {
    let h = t.tree.children[u], d = t.tree.positions[u];
    t.yield(new Un(h, d + t.from, u, t._tree));
  }
}
class kN {
  constructor(e, n) {
    this.offset = n, this.done = !1, this.cursor = e.cursor(Wt.IncludeAnonymous | Wt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: n } = this, r = e - this.offset;
    for (; !this.done && n.from < r; )
      n.to >= e && n.enter(r, 1, Wt.IgnoreOverlays | Wt.ExcludeBuffers) || n.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let n = this.cursor.tree; ; ) {
        if (n == e.tree)
          return !0;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof fn)
          n = n.children[0];
        else
          break;
      }
    return !1;
  }
}
class IRe {
  constructor(e) {
    var n;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (n = r.tree.prop(wx)) !== null && n !== void 0 ? n : r.to, this.inner = new kN(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let n = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = n.tree.prop(wx)) !== null && e !== void 0 ? e : n.to, this.inner = new kN(n.tree, -n.offset);
    }
  }
  findMounts(e, n) {
    var r;
    let s = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let i = this.inner.cursor.node; i; i = i.parent) {
        let o = (r = i.tree) === null || r === void 0 ? void 0 : r.prop(ct.mounted);
        if (o && o.parser == n)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= i.to)
              break;
            l.tree == this.curFrag.tree && s.push({
              frag: l,
              pos: i.from - l.offset,
              mount: o
            });
          }
      }
    }
    return s;
  }
}
function AN(t, e) {
  let n = null, r = e;
  for (let s = 1, i = 0; s < t.length; s++) {
    let o = t[s - 1].to, a = t[s].from;
    for (; i < r.length; i++) {
      let l = r[i];
      if (l.from >= a)
        break;
      l.to <= o || (n || (r = n = e.slice()), l.from < o ? (n[i] = new Yr(l.from, o), l.to > a && n.splice(i + 1, 0, new Yr(a, l.to))) : l.to > a ? n[i--] = new Yr(a, l.to) : n.splice(i--, 1));
    }
  }
  return r;
}
function PRe(t, e, n, r) {
  let s = 0, i = 0, o = !1, a = !1, l = -1e9, c = [];
  for (; ; ) {
    let u = s == t.length ? 1e9 : o ? t[s].to : t[s].from, h = i == e.length ? 1e9 : a ? e[i].to : e[i].from;
    if (o != a) {
      let d = Math.max(l, n), f = Math.min(u, h, r);
      d < f && c.push(new Yr(d, f));
    }
    if (l = Math.min(u, h), l == 1e9)
      break;
    u == l && (o ? (o = !1, s++) : o = !0), h == l && (a ? (a = !1, i++) : a = !0);
  }
  return c;
}
function RN(t, e) {
  let n = [];
  for (let { pos: r, mount: s, frag: i } of t) {
    let o = r + (s.overlay ? s.overlay[0].from : 0), a = o + s.tree.length, l = Math.max(i.from, o), c = Math.min(i.to, a);
    if (s.overlay) {
      let u = s.overlay.map((d) => new Yr(d.from + r, d.to + r)), h = PRe(e, u, l, c);
      for (let d = 0, f = l; ; d++) {
        let g = d == h.length, y = g ? c : h[d].from;
        if (y > f && n.push(new oo(f, y, s.tree, -o, i.from >= f || i.openStart, i.to <= y || i.openEnd)), g)
          break;
        f = h[d].to;
      }
    } else
      n.push(new oo(l, c, s.tree, -o, i.from >= o || i.openStart, i.to <= a || i.openEnd));
  }
  return n;
}
let ORe = 0;
class qr {
  /**
  @internal
  */
  constructor(e, n, r, s) {
    this.name = e, this.set = n, this.base = r, this.modified = s, this.id = ORe++;
  }
  toString() {
    let { name: e } = this;
    for (let n of this.modified)
      n.name && (e = `${n.name}(${e})`);
    return e;
  }
  static define(e, n) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof qr && (n = e), n?.base)
      throw new Error("Can not derive from a modified tag");
    let s = new qr(r, [], null, []);
    if (s.set.push(s), n)
      for (let i of n.set)
        s.set.push(i);
    return s;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let n = new hy(e);
    return (r) => r.modified.indexOf(n) > -1 ? r : hy.get(r.base || r, r.modified.concat(n).sort((s, i) => s.id - i.id));
  }
}
let DRe = 0;
class hy {
  constructor(e) {
    this.name = e, this.instances = [], this.id = DRe++;
  }
  static get(e, n) {
    if (!n.length)
      return e;
    let r = n[0].instances.find((a) => a.base == e && NRe(n, a.modified));
    if (r)
      return r;
    let s = [], i = new qr(e.name, s, e, n);
    for (let a of n)
      a.instances.push(i);
    let o = LRe(n);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          s.push(hy.get(a, l));
    return i;
  }
}
function NRe(t, e) {
  return t.length == e.length && t.every((n, r) => n == e[r]);
}
function LRe(t) {
  let e = [[]];
  for (let n = 0; n < t.length; n++)
    for (let r = 0, s = e.length; r < s; r++)
      e.push(e[r].concat(t[n]));
  return e.sort((n, r) => r.length - n.length);
}
function MRe(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    Array.isArray(r) || (r = [r]);
    for (let s of n.split(" "))
      if (s) {
        let i = [], o = 2, a = s;
        for (let h = 0; ; ) {
          if (a == "..." && h > 0 && h + 3 == s.length) {
            o = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + s);
          if (i.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), h += d[0].length, h == s.length)
            break;
          let f = s[h++];
          if (h == s.length && f == "!") {
            o = 0;
            break;
          }
          if (f != "/")
            throw new RangeError("Invalid path: " + s);
          a = s.slice(h);
        }
        let l = i.length - 1, c = i[l];
        if (!c)
          throw new RangeError("Invalid path: " + s);
        let u = new dy(r, o, l > 0 ? i.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return gG.add(e);
}
const gG = new ct();
let dy = class {
  constructor(e, n, r, s) {
    this.tags = e, this.mode = n, this.context = r, this.next = s;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
dy.empty = new dy([], 2, null);
function yG(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let i of t)
    if (!Array.isArray(i.tag))
      n[i.tag.id] = i.class;
    else
      for (let o of i.tag)
        n[o.id] = i.class;
  let { scope: r, all: s = null } = e || {};
  return {
    style: (i) => {
      let o = s;
      for (let a of i)
        for (let l of a.set) {
          let c = n[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function BRe(t, e) {
  let n = null;
  for (let r of t) {
    let s = r.style(e);
    s && (n = n ? n + " " + s : s);
  }
  return n;
}
function FRe(t, e, n, r = 0, s = t.length) {
  let i = new $Re(r, Array.isArray(e) ? e : [e], n);
  i.highlightRange(t.cursor(), r, s, "", i.highlighters), i.flush(s);
}
class $Re {
  constructor(e, n, r) {
    this.at = e, this.highlighters = n, this.span = r, this.class = "";
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, r, s, i) {
    let { type: o, from: a, to: l } = e;
    if (a >= r || l <= n)
      return;
    o.isTop && (i = this.highlighters.filter((f) => !f.scope || f.scope(o)));
    let c = s, u = URe(e) || dy.empty, h = BRe(i, u.tags);
    if (h && (c && (c += " "), c += h, u.mode == 1 && (s += (s ? " " : "") + h)), this.startSpan(Math.max(n, a), c), u.opaque)
      return;
    let d = e.tree && e.tree.prop(ct.mounted);
    if (d && d.overlay) {
      let f = e.node.enter(d.overlay[0].from + a, 1), g = this.highlighters.filter((p) => !p.scope || p.scope(d.tree.type)), y = e.firstChild();
      for (let p = 0, m = a; ; p++) {
        let b = p < d.overlay.length ? d.overlay[p] : null, _ = b ? b.from + a : l, v = Math.max(n, m), w = Math.min(r, _);
        if (v < w && y)
          for (; e.from < w && (this.highlightRange(e, v, w, s, i), this.startSpan(Math.min(w, e.to), c), !(e.to >= _ || !e.nextSibling())); )
            ;
        if (!b || _ > r)
          break;
        m = b.to + a, m > n && (this.highlightRange(f.cursor(), Math.max(n, b.from + a), Math.min(r, m), "", g), this.startSpan(Math.min(r, m), c));
      }
      y && e.parent();
    } else if (e.firstChild()) {
      d && (s = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, n, r, s, i), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function URe(t) {
  let e = t.type.prop(gG);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const Le = qr.define, Bm = Le(), No = Le(), IN = Le(No), PN = Le(No), Lo = Le(), Fm = Le(Lo), fw = Le(Lo), Ks = Le(), ka = Le(Ks), js = Le(), Hs = Le(), Ex = Le(), uh = Le(Ex), $m = Le(), me = {
  /**
  A comment.
  */
  comment: Bm,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Le(Bm),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Le(Bm),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Le(Bm),
  /**
  Any kind of identifier.
  */
  name: No,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Le(No),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: IN,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Le(IN),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: PN,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Le(PN),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Le(No),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Le(No),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Le(No),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Le(No),
  /**
  A literal value.
  */
  literal: Lo,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Fm,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Le(Fm),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Le(Fm),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Le(Fm),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: fw,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Le(fw),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Le(fw),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Le(Lo),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Le(Lo),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Le(Lo),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Le(Lo),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Le(Lo),
  /**
  A language keyword.
  */
  keyword: js,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Le(js),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Le(js),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Le(js),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Le(js),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Le(js),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Le(js),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Le(js),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Le(js),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Le(js),
  /**
  An operator.
  */
  operator: Hs,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Le(Hs),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Le(Hs),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Le(Hs),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Le(Hs),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Le(Hs),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Le(Hs),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Le(Hs),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Le(Hs),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Le(Hs),
  /**
  Program or markup punctuation.
  */
  punctuation: Ex,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Le(Ex),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: uh,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Le(uh),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Le(uh),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Le(uh),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Le(uh),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Ks,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: ka,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Le(ka),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Le(ka),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Le(ka),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Le(ka),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Le(ka),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Le(ka),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: Le(Ks),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Le(Ks),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Le(Ks),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Le(Ks),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Le(Ks),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Le(Ks),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Le(Ks),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Le(Ks),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Le(),
  /**
  Deleted text.
  */
  deleted: Le(),
  /**
  Changed text.
  */
  changed: Le(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Le(),
  /**
  Metadata or meta-instruction.
  */
  meta: $m,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Le($m),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Le($m),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Le($m),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: qr.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: qr.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: qr.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: qr.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: qr.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: qr.defineModifier("special")
};
for (let t in me) {
  let e = me[t];
  e instanceof qr && (e.name = t);
}
yG([
  { tag: me.link, class: "tok-link" },
  { tag: me.heading, class: "tok-heading" },
  { tag: me.emphasis, class: "tok-emphasis" },
  { tag: me.strong, class: "tok-strong" },
  { tag: me.keyword, class: "tok-keyword" },
  { tag: me.atom, class: "tok-atom" },
  { tag: me.bool, class: "tok-bool" },
  { tag: me.url, class: "tok-url" },
  { tag: me.labelName, class: "tok-labelName" },
  { tag: me.inserted, class: "tok-inserted" },
  { tag: me.deleted, class: "tok-deleted" },
  { tag: me.literal, class: "tok-literal" },
  { tag: me.string, class: "tok-string" },
  { tag: me.number, class: "tok-number" },
  { tag: [me.regexp, me.escape, me.special(me.string)], class: "tok-string2" },
  { tag: me.variableName, class: "tok-variableName" },
  { tag: me.local(me.variableName), class: "tok-variableName tok-local" },
  { tag: me.definition(me.variableName), class: "tok-variableName tok-definition" },
  { tag: me.special(me.variableName), class: "tok-variableName2" },
  { tag: me.definition(me.propertyName), class: "tok-propertyName tok-definition" },
  { tag: me.typeName, class: "tok-typeName" },
  { tag: me.namespace, class: "tok-namespace" },
  { tag: me.className, class: "tok-className" },
  { tag: me.macroName, class: "tok-macroName" },
  { tag: me.propertyName, class: "tok-propertyName" },
  { tag: me.operator, class: "tok-operator" },
  { tag: me.comment, class: "tok-comment" },
  { tag: me.meta, class: "tok-meta" },
  { tag: me.invalid, class: "tok-invalid" },
  { tag: me.punctuation, class: "tok-punctuation" }
]);
var pw;
const Ec = /* @__PURE__ */ new ct();
function jRe(t) {
  return ze.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const HRe = /* @__PURE__ */ new ct();
class ys {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, n, r = [], s = "") {
    this.data = e, this.name = s, pt.prototype.hasOwnProperty("tree") || Object.defineProperty(pt.prototype, "tree", { get() {
      return Pn(this);
    } }), this.parser = n, this.extension = [
      fa.of(this),
      pt.languageData.of((i, o, a) => {
        let l = ON(i, o, a), c = l.type.prop(Ec);
        if (!c)
          return [];
        let u = i.facet(c), h = l.type.prop(HRe);
        if (h) {
          let d = l.resolve(o - l.from, a);
          for (let f of h)
            if (f.test(d, i)) {
              let g = i.facet(f.facet);
              return f.type == "replace" ? g : g.concat(u);
            }
        }
        return u;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, n, r = -1) {
    return ON(e, n, r).type.prop(Ec) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let n = e.facet(fa);
    if (n?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let r = [], s = (i, o) => {
      if (i.prop(Ec) == this.data) {
        r.push({ from: o, to: o + i.length });
        return;
      }
      let a = i.prop(ct.mounted);
      if (a) {
        if (a.tree.prop(Ec) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + o, to: l.to + o });
          else
            r.push({ from: o, to: o + i.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (s(a.tree, a.overlay[0].from + o), r.length > l)
            return;
        }
      }
      for (let l = 0; l < i.children.length; l++) {
        let c = i.children[l];
        c instanceof fn && s(c, i.positions[l] + o);
      }
    };
    return s(Pn(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
ys.setState = /* @__PURE__ */ at.define();
function ON(t, e, n) {
  let r = t.facet(fa), s = Pn(t).topNode;
  if (!r || r.allowsNesting)
    for (let i = s; i; i = i.enter(e, n, Wt.ExcludeBuffers))
      i.type.isTop && (s = i);
  return s;
}
class Sx extends ys {
  constructor(e, n, r) {
    super(e, n, [], r), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let n = jRe(e.languageData);
    return new Sx(n, e.parser.configure({
      props: [Ec.add((r) => r.isTop ? n : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, n) {
    return new Sx(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Pn(t) {
  let e = t.field(ys.state, !1);
  return e ? e.tree : fn.empty;
}
class zRe {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let r = this.cursorPos - this.string.length;
    return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
  }
}
let hh = null;
class fy {
  constructor(e, n, r = [], s, i, o, a, l) {
    this.parser = e, this.state = n, this.fragments = r, this.tree = s, this.treeLen = i, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new fy(e, n, [], fn.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new zRe(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != fn.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let s = Date.now() + e;
        e = () => Date.now() > s;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(oo.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, n;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(oo.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let n = hh;
    hh = this;
    try {
      return e();
    } finally {
      hh = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; n = this.tempSkipped.pop(); )
      e = DN(e, n.from, n.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, n) {
    let { fragments: r, tree: s, treeLen: i, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, u, h, d) => l.push({ fromA: c, toA: u, fromB: h, toB: d })), r = oo.applyChanges(r, l), s = fn.empty, i = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          u < h && a.push({ from: u, to: h });
        }
      }
    }
    return new fy(this.parser, n, r, s, i, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: s, to: i } = this.skipped[r];
      s < e.to && i > e.from && (this.fragments = DN(this.fragments, s, i), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends xRe {
      createParse(n, r, s) {
        let i = s[0].from, o = s[s.length - 1].to;
        return {
          parsedPos: i,
          advance() {
            let l = hh;
            if (l) {
              for (let c of s)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new fn(Er.none, [], [], o - i);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return hh;
  }
}
function DN(t, e, n) {
  return oo.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class mu {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new mu(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length), r = fy.create(e.facet(fa).parser, e, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new mu(r);
  }
}
ys.state = /* @__PURE__ */ En.define({
  create: mu.init,
  update(t, e) {
    for (let n of e.effects)
      if (n.is(ys.setState))
        return n.value;
    return e.startState.facet(fa) != e.state.facet(fa) ? mu.init(e.state) : t.apply(e);
  }
});
let bG = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (bG = (t) => {
  let e = -1, n = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
});
const mw = typeof navigator < "u" && (!((pw = navigator.scheduling) === null || pw === void 0) && pw.isInputPending) ? () => navigator.scheduling.isInputPending() : null, GRe = /* @__PURE__ */ In.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let n = this.view.state.field(ys.state).context;
    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, n = e.field(ys.state);
    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = bG(this.work));
  }
  work(e) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: s } } = this.view, i = r.field(ys.state);
    if (i.tree == i.context.tree && i.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !mw ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = i.context.treeLen < s && r.doc.length > s + 1e3, l = i.context.work(() => mw && mw() || Date.now() > o, s + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (i.context.takeTree(), this.view.dispatch({ effects: ys.setState.of(new mu(i.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(i.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => Pr(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), fa = /* @__PURE__ */ ze.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    ys.state,
    GRe,
    He.contentAttributes.compute([t], (e) => {
      let n = e.facet(t);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class YVe {
  /**
  Create a language support object.
  */
  constructor(e, n = []) {
    this.language = e, this.support = n, this.extension = [e, n];
  }
}
class xn {
  constructor(e, n, r, s, i, o = void 0) {
    this.name = e, this.alias = n, this.extensions = r, this.filename = s, this.loadFunc = i, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: n, support: r } = e;
    if (!n) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      n = () => Promise.resolve(r);
    }
    return new xn(e.name, (e.alias || []).concat(e.name).map((s) => s.toLowerCase()), e.extensions || [], e.filename, n, r);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, n) {
    for (let s of e)
      if (s.filename && s.filename.test(n))
        return s;
    let r = /\.([^.]+)$/.exec(n);
    if (r) {
      for (let s of e)
        if (s.extensions.indexOf(r[1]) > -1)
          return s;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, n, r = !0) {
    n = n.toLowerCase();
    for (let s of e)
      if (s.alias.some((i) => i == n))
        return s;
    if (r)
      for (let s of e)
        for (let i of s.alias) {
          let o = n.indexOf(i);
          if (o > -1 && (i.length > 2 || !/\w/.test(n[o - 1]) && !/\w/.test(n[o + i.length])))
            return s;
        }
    return null;
  }
}
const VRe = /* @__PURE__ */ ze.define(), Uu = /* @__PURE__ */ ze.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function py(t) {
  let e = t.facet(Uu);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function hf(t, e) {
  let n = "", r = t.tabSize, s = t.facet(Uu)[0];
  if (s == "	") {
    for (; e >= r; )
      n += "	", e -= r;
    s = " ";
  }
  for (let i = 0; i < e; i++)
    n += s;
  return n;
}
function hA(t, e) {
  t instanceof pt && (t = new e_(t));
  for (let r of t.state.facet(VRe)) {
    let s = r(t, e);
    if (s !== void 0)
      return s;
  }
  let n = Pn(t.state);
  return n.length >= e ? qRe(t, n, e) : null;
}
class e_ {
  /**
  Create an indent context.
  */
  constructor(e, n = {}) {
    this.state = e, this.options = n, this.unit = py(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, n = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: s, simulateDoubleBreak: i } = this.options;
    return s != null && s >= r.from && s <= r.to ? i && s == e ? { text: "", from: e } : (n < 0 ? s < e : s <= e) ? { text: r.text.slice(s - r.from), from: s } : { text: r.text.slice(0, s - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: s } = this.lineAt(e, n);
    return r.slice(e - s, Math.min(r.length, e + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(e, n = 1) {
    let { text: r, from: s } = this.lineAt(e, n), i = this.countColumn(r, e - s), o = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return o > -1 && (i += o - this.countColumn(r, r.search(/\S|$/))), i;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, n = e.length) {
    return Kb(e, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, n = 1) {
    let { text: r, from: s } = this.lineAt(e, n), i = this.options.overrideIndentation;
    if (i) {
      let o = i(s);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const WRe = /* @__PURE__ */ new ct();
function qRe(t, e, n) {
  let r = e.resolveStack(n), s = e.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
  if (s != r.node) {
    let i = [];
    for (let o = s; o && !(o.from == r.node.from && o.type == r.node.type); o = o.parent)
      i.push(o);
    for (let o = i.length - 1; o >= 0; o--)
      r = { node: i[o], next: r };
  }
  return _G(r, t, n);
}
function _G(t, e, n) {
  for (let r = t; r; r = r.next) {
    let s = YRe(r.node);
    if (s)
      return s(dA.create(e, n, r));
  }
  return 0;
}
function KRe(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function YRe(t) {
  let e = t.type.prop(WRe);
  if (e)
    return e;
  let n = t.firstChild, r;
  if (n && (r = n.type.prop(ct.closedBy))) {
    let s = t.lastChild, i = s && r.indexOf(s.name) > -1;
    return (o) => vG(o, !0, 1, void 0, i && !KRe(o) ? s.from : void 0);
  }
  return t.parent == null ? ZRe : null;
}
function ZRe() {
  return 0;
}
class dA extends e_ {
  constructor(e, n, r) {
    super(e.state, e.options), this.base = e, this.pos = n, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new dA(e, n, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(n.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (JRe(r, e))
        break;
      n = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return _G(this.context.next, this.base, this.pos);
  }
}
function JRe(t, e) {
  for (let n = e; n; n = n.parent)
    if (t == n)
      return !0;
  return !1;
}
function XRe(t) {
  let e = t.node, n = e.childAfter(e.from), r = e.lastChild;
  if (!n)
    return null;
  let s = t.options.simulateBreak, i = t.state.doc.lineAt(n.from), o = s == null || s <= i.from ? i.to : Math.min(i.to, s);
  for (let a = n.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= o)
        return null;
      let c = /^ */.exec(i.text.slice(n.to - i.from))[0].length;
      return { from: n.from, to: n.to + c };
    }
    a = l.to;
  }
}
function ZVe({ closing: t, align: e = !0, units: n = 1 }) {
  return (r) => vG(r, e, n, t);
}
function vG(t, e, n, r, s) {
  let i = t.textAfter, o = i.match(/^\s*/)[0].length, a = r && i.slice(o, o + r.length) == r || s == t.pos + o, l = e ? XRe(t) : null;
  return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * n);
}
const JVe = (t) => t.baseIndent;
function XVe({ except: t, units: e = 1 } = {}) {
  return (n) => {
    let r = t && t.test(n.textAfter);
    return n.baseIndent + (r ? 0 : e * n.unit);
  };
}
const QRe = 200;
function eIe() {
  return pt.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let n = t.newDoc, { head: r } = t.newSelection.main, s = n.lineAt(r);
    if (r > s.from + QRe)
      return t;
    let i = n.sliceString(s.from, r);
    if (!e.some((c) => c.test(i)))
      return t;
    let { state: o } = t, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == a)
        continue;
      a = u.from;
      let h = hA(o, u.from);
      if (h == null)
        continue;
      let d = /^\s*/.exec(u.text)[0], f = hf(o, h);
      d != f && l.push({ from: u.from, to: u.from + d.length, insert: f });
    }
    return l.length ? [t, { changes: l, sequential: !0 }] : t;
  });
}
const tIe = /* @__PURE__ */ ze.define(), nIe = /* @__PURE__ */ new ct();
function QVe(t) {
  let e = t.firstChild, n = t.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;
}
function rIe(t, e, n) {
  let r = Pn(t);
  if (r.length < n)
    return null;
  let s = r.resolveStack(n, 1), i = null;
  for (let o = s; o; o = o.next) {
    let a = o.node;
    if (a.to <= n || a.from > n)
      continue;
    if (i && a.from < e)
      break;
    let l = a.type.prop(nIe);
    if (l && (a.to < r.length - 50 || r.length == t.doc.length || !sIe(a))) {
      let c = l(a, t);
      c && c.from <= n && c.from >= e && c.to > n && (i = c);
    }
  }
  return i;
}
function sIe(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function NN(t, e, n) {
  for (let r of t.facet(tIe)) {
    let s = r(t, e, n);
    if (s)
      return s;
  }
  return rIe(t, e, n);
}
function wG(t, e) {
  let n = e.mapPos(t.from, 1), r = e.mapPos(t.to, -1);
  return n >= r ? void 0 : { from: n, to: r };
}
const EG = /* @__PURE__ */ at.define({ map: wG }), fA = /* @__PURE__ */ at.define({ map: wG }), my = /* @__PURE__ */ En.define({
  create() {
    return yt.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects)
      if (n.is(EG) && !iIe(t, n.value.from, n.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(SG), s = r ? yt.replace({ widget: new lIe(r(e.state, n.value)) }) : LN;
        t = t.update({ add: [s.range(n.value.from, n.value.to)] });
      } else n.is(fA) && (t = t.update({
        filter: (r, s) => n.value.from != r || n.value.to != s,
        filterFrom: n.value.from,
        filterTo: n.value.to
      }));
    if (e.selection) {
      let n = !1, { head: r } = e.selection.main;
      t.between(r, r, (s, i) => {
        s < r && i > r && (n = !0);
      }), n && (t = t.update({
        filterFrom: r,
        filterTo: r,
        filter: (s, i) => i <= r || s >= r
      }));
    }
    return t;
  },
  provide: (t) => He.decorations.from(t),
  toJSON(t, e) {
    let n = [];
    return t.between(0, e.doc.length, (r, s) => {
      n.push(r, s);
    }), n;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < t.length; ) {
      let r = t[n++], s = t[n++];
      if (typeof r != "number" || typeof s != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(LN.range(r, s));
    }
    return yt.set(e, !0);
  }
});
function xx(t, e, n) {
  var r;
  let s = null;
  return (r = t.field(my, !1)) === null || r === void 0 || r.between(e, n, (i, o) => {
    (!s || s.from > i) && (s = { from: i, to: o });
  }), s;
}
function iIe(t, e, n) {
  let r = !1;
  return t.between(e, e, (s, i) => {
    s == e && i == n && (r = !0);
  }), r;
}
const oIe = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, SG = /* @__PURE__ */ ze.define({
  combine(t) {
    return $l(t, oIe);
  }
});
function aIe(t) {
  return [my, hIe];
}
function xG(t, e) {
  let { state: n } = t, r = n.facet(SG), s = (o) => {
    let a = t.lineBlockAt(t.posAtDOM(o.target)), l = xx(t.state, a.from, a.to);
    l && t.dispatch({ effects: fA.of(l) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(t, s, e);
  let i = document.createElement("span");
  return i.textContent = r.placeholderText, i.setAttribute("aria-label", n.phrase("folded code")), i.title = n.phrase("unfold"), i.className = "cm-foldPlaceholder", i.onclick = s, i;
}
const LN = /* @__PURE__ */ yt.replace({ widget: /* @__PURE__ */ new class extends $u {
  toDOM(t) {
    return xG(t, null);
  }
}() });
class lIe extends $u {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return xG(e, this.value);
  }
}
const cIe = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class gw extends po {
  constructor(e, n) {
    super(), this.config = e, this.open = n;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function uIe(t = {}) {
  let e = Object.assign(Object.assign({}, cIe), t), n = new gw(e, !0), r = new gw(e, !1), s = In.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(fa) != o.state.facet(fa) || o.startState.field(my, !1) != o.state.field(my, !1) || Pn(o.startState) != Pn(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new wl();
      for (let l of o.viewportLineBlocks) {
        let c = xx(o.state, l.from, l.to) ? r : NN(o.state, l.from, l.to) ? n : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: i } = e;
  return [
    s,
    oRe({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(s)) === null || a === void 0 ? void 0 : a.markers) || _t.empty;
      },
      initialSpacer() {
        return new gw(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, i), { click: (o, a, l) => {
        if (i.click && i.click(o, a, l))
          return !0;
        let c = xx(o.state, a.from, a.to);
        if (c)
          return o.dispatch({ effects: fA.of(c) }), !0;
        let u = NN(o.state, a.from, a.to);
        return u ? (o.dispatch({ effects: EG.of(u) }), !0) : !1;
      } })
    }),
    aIe()
  ];
}
const hIe = /* @__PURE__ */ He.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class t_ {
  constructor(e, n) {
    this.specs = e;
    let r;
    function s(a) {
      let l = ca.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const i = typeof n.all == "string" ? n.all : n.all ? s(n.all) : void 0, o = n.scope;
    this.scope = o instanceof ys ? (a) => a.prop(Ec) == o.data : o ? (a) => a == o : void 0, this.style = yG(e.map((a) => ({
      tag: a.tag,
      class: a.class || s(Object.assign({}, a, { tag: null }))
    })), {
      all: i
    }).style, this.module = r ? new ca(r) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, n) {
    return new t_(e, n || {});
  }
}
const Tx = /* @__PURE__ */ ze.define(), dIe = /* @__PURE__ */ ze.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function yw(t) {
  let e = t.facet(Tx);
  return e.length ? e : t.facet(dIe);
}
function fIe(t, e) {
  let n = [mIe], r;
  return t instanceof t_ && (t.module && n.push(He.styleModule.of(t.module)), r = t.themeType), r ? n.push(Tx.computeN([He.darkTheme], (s) => s.facet(He.darkTheme) == (r == "dark") ? [t] : [])) : n.push(Tx.of(t)), n;
}
class pIe {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Pn(e.state), this.decorations = this.buildDeco(e, yw(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let n = Pn(e.state), r = yw(e.state), s = r != yw(e.startState), { viewport: i } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    n.length < i.to && !s && n.type == this.tree.type && o >= i.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (n != this.tree || e.viewportChanged || s) && (this.tree = n, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = i.to);
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length)
      return yt.none;
    let r = new wl();
    for (let { from: s, to: i } of e.visibleRanges)
      FRe(this.tree, n, (o, a, l) => {
        r.add(o, a, this.markCache[l] || (this.markCache[l] = yt.mark({ class: l })));
      }, s, i);
    return r.finish();
  }
}
const mIe = /* @__PURE__ */ _a.high(/* @__PURE__ */ In.fromClass(pIe, {
  decorations: (t) => t.decorations
})), gIe = /* @__PURE__ */ He.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), TG = 1e4, CG = "()[]{}", kG = /* @__PURE__ */ ze.define({
  combine(t) {
    return $l(t, {
      afterCursor: !0,
      brackets: CG,
      maxScanDistance: TG,
      renderMatch: _Ie
    });
  }
}), yIe = /* @__PURE__ */ yt.mark({ class: "cm-matchingBracket" }), bIe = /* @__PURE__ */ yt.mark({ class: "cm-nonmatchingBracket" });
function _Ie(t) {
  let e = [], n = t.matched ? yIe : bIe;
  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
}
const vIe = /* @__PURE__ */ En.define({
  create() {
    return yt.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let n = [], r = e.state.facet(kG);
    for (let s of e.state.selection.ranges) {
      if (!s.empty)
        continue;
      let i = mi(e.state, s.head, -1, r) || s.head > 0 && mi(e.state, s.head - 1, 1, r) || r.afterCursor && (mi(e.state, s.head, 1, r) || s.head < e.state.doc.length && mi(e.state, s.head + 1, -1, r));
      i && (n = n.concat(r.renderMatch(i, e.state)));
    }
    return yt.set(n, !0);
  },
  provide: (t) => He.decorations.from(t)
}), wIe = [
  vIe,
  gIe
];
function EIe(t = {}) {
  return [kG.of(t), wIe];
}
const SIe = /* @__PURE__ */ new ct();
function Cx(t, e, n) {
  let r = t.prop(e < 0 ? ct.openedBy : ct.closedBy);
  if (r)
    return r;
  if (t.name.length == 1) {
    let s = n.indexOf(t.name);
    if (s > -1 && s % 2 == (e < 0 ? 1 : 0))
      return [n[s + e]];
  }
  return null;
}
function kx(t) {
  let e = t.type.prop(SIe);
  return e ? e(t.node) : t;
}
function mi(t, e, n, r = {}) {
  let s = r.maxScanDistance || TG, i = r.brackets || CG, o = Pn(t), a = o.resolveInner(e, n);
  for (let l = a; l; l = l.parent) {
    let c = Cx(l.type, n, i);
    if (c && l.from < l.to) {
      let u = kx(l);
      if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return xIe(t, e, n, l, u, c, i);
    }
  }
  return TIe(t, e, n, o, a.type, s, i);
}
function xIe(t, e, n, r, s, i, o) {
  let a = r.parent, l = { from: s.from, to: s.to }, c = 0, u = a?.cursor();
  if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (n < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && i.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = kx(u);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (Cx(u.type, n, o))
          c++;
        else if (Cx(u.type, -n, o)) {
          if (c == 0) {
            let h = kx(u);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (n < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function TIe(t, e, n, r, s, i, o) {
  let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != n > 0)
    return null;
  let c = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), h = 0;
  for (let d = 0; !u.next().done && d <= i; ) {
    let f = u.value;
    n < 0 && (d += f.length);
    let g = e + d * n;
    for (let y = n > 0 ? 0 : f.length - 1, p = n > 0 ? f.length : -1; y != p; y += n) {
      let m = o.indexOf(f[y]);
      if (!(m < 0 || r.resolveInner(g + y, 1).type != s))
        if (m % 2 == 0 == n > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: g + y, to: g + y + 1 }, matched: m >> 1 == l >> 1 };
          h--;
        }
    }
    n > 0 && (d += f.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
const CIe = /* @__PURE__ */ Object.create(null), MN = [Er.none], BN = [], FN = /* @__PURE__ */ Object.create(null), kIe = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  kIe[t] = /* @__PURE__ */ AIe(CIe, e);
function bw(t, e) {
  BN.indexOf(t) > -1 || (BN.push(t), console.warn(e));
}
function AIe(t, e) {
  let n = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = t[c] || me[c];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : bw(c, `Modifier ${c} used at start of tag`) : l.length ? bw(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : bw(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      n.push(c);
  }
  if (!n.length)
    return 0;
  let r = e.replace(/ /g, "_"), s = r + " " + n.map((a) => a.id), i = FN[s];
  if (i)
    return i.id;
  let o = FN[s] = Er.define({
    id: MN.length,
    name: r,
    props: [MRe({ [r]: n })]
  });
  return MN.push(o), o.id;
}
jt.RTL, jt.LTR;
class AG {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, n, r, s) {
    this.state = e, this.pos = n, this.explicit = r, this.view = s, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let n = Pn(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), s = n.text.slice(r - n.from, this.pos - n.from), i = s.search(RG(e, !1));
    return i < 0 ? null : { from: r + i, to: this.pos, text: s.slice(i) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, n, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(n), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function $N(t) {
  let e = Object.keys(t).join(""), n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function RIe(t) {
  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of t) {
    e[s[0]] = !0;
    for (let i = 1; i < s.length; i++)
      n[s[i]] = !0;
  }
  let r = $N(e) + $N(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function IIe(t) {
  let e = t.map((s) => typeof s == "string" ? { label: s } : s), [n, r] = e.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : RIe(e);
  return (s) => {
    let i = s.matchBefore(r);
    return i || s.explicit ? { from: i ? i.from : s.pos, options: e, validFor: n } : null;
  };
}
function eWe(t, e) {
  return (n) => {
    for (let r = Pn(n.state).resolveInner(n.pos, -1); r; r = r.parent) {
      if (t.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(n);
  };
}
class UN {
  constructor(e, n, r, s) {
    this.completion = e, this.source = n, this.match = r, this.score = s;
  }
}
function ol(t) {
  return t.selection.main.from;
}
function RG(t, e) {
  var n;
  let { source: r } = t, s = e && r[0] != "^", i = r[r.length - 1] != "$";
  return !s && !i ? t : new RegExp(`${s ? "^" : ""}(?:${r})${i ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
}
const pA = /* @__PURE__ */ bo.define();
function PIe(t, e, n, r) {
  let { main: s } = t.selection, i = n - s.from, o = r - s.from;
  return Object.assign(Object.assign({}, t.changeByRange((a) => {
    if (a != s && n != r && t.sliceDoc(a.from + i, a.from + o) != t.sliceDoc(n, r))
      return { range: a };
    let l = t.toText(e);
    return {
      changes: { from: a.from + i, to: r == s.from ? a.to : a.from + o, insert: l },
      range: Ae.cursor(a.from + i + l.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const jN = /* @__PURE__ */ new WeakMap();
function OIe(t) {
  if (!Array.isArray(t))
    return t;
  let e = jN.get(t);
  return e || jN.set(t, e = IIe(t)), e;
}
const gy = /* @__PURE__ */ at.define(), df = /* @__PURE__ */ at.define();
class DIe {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < e.length; ) {
      let r = ms(e, n), s = Qi(r);
      this.chars.push(r);
      let i = e.slice(n, n + s), o = i.toUpperCase();
      this.folded.push(ms(o == i ? i.toLowerCase() : o, 0)), n += s;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return this.score = e, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: n, folded: r, any: s, precise: i, byWord: o } = this;
    if (n.length == 1) {
      let b = ms(e, 0), _ = Qi(b), v = _ == e.length ? 0 : -100;
      if (b != n[0]) if (b == r[0])
        v += -200;
      else
        return null;
      return this.ret(v, [0, _]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = n.length, c = 0;
    if (a < 0) {
      for (let b = 0, _ = Math.min(e.length, 200); b < _ && c < l; ) {
        let v = ms(e, b);
        (v == n[c] || v == r[c]) && (s[c++] = b), b += Qi(v);
      }
      if (c < l)
        return null;
    }
    let u = 0, h = 0, d = !1, f = 0, g = -1, y = -1, p = /[a-z]/.test(e), m = !0;
    for (let b = 0, _ = Math.min(e.length, 200), v = 0; b < _ && h < l; ) {
      let w = ms(e, b);
      a < 0 && (u < l && w == n[u] && (i[u++] = b), f < l && (w == n[f] || w == r[f] ? (f == 0 && (g = b), y = b + 1, f++) : f = 0));
      let E, x = w < 255 ? w >= 48 && w <= 57 || w >= 97 && w <= 122 ? 2 : w >= 65 && w <= 90 ? 1 : 0 : (E = Kk(w)) != E.toLowerCase() ? 1 : E != E.toUpperCase() ? 2 : 0;
      (!b || x == 1 && p || v == 0 && x != 0) && (n[h] == w || r[h] == w && (d = !0) ? o[h++] = b : o.length && (m = !1)), v = x, b += Qi(w);
    }
    return h == l && o[0] == 0 && m ? this.result(-100 + (d ? -200 : 0), o, e) : f == l && g == 0 ? this.ret(-200 - e.length + (y == e.length ? 0 : -100), [0, y]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : f == l ? this.ret(-900 - e.length, [g, y]) : h == l ? this.result(-100 + (d ? -200 : 0) + -700 + (m ? 0 : -1100), o, e) : n.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, e);
  }
  result(e, n, r) {
    let s = [], i = 0;
    for (let o of n) {
      let a = o + (this.astral ? Qi(ms(r, o)) : 1);
      i && s[i - 1] == o ? s[i - 1] = a : (s[i++] = o, s[i++] = a);
    }
    return this.ret(e - r.length, s);
  }
}
class NIe {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let n = e.slice(0, this.pattern.length), r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, n.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const vn = /* @__PURE__ */ ze.define({
  combine(t) {
    return $l(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: LIe,
      filterStrict: !1,
      compareCompletions: (e, n) => e.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, n) => e && n,
      closeOnBlur: (e, n) => e && n,
      icons: (e, n) => e && n,
      tooltipClass: (e, n) => (r) => HN(e(r), n(r)),
      optionClass: (e, n) => (r) => HN(e(r), n(r)),
      addToOptions: (e, n) => e.concat(n),
      filterStrict: (e, n) => e || n
    });
  }
});
function HN(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function LIe(t, e, n, r, s, i) {
  let o = t.textDirection == jt.RTL, a = o, l = !1, c = "top", u, h, d = e.left - s.left, f = s.right - e.right, g = r.right - r.left, y = r.bottom - r.top;
  if (a && d < Math.min(g, f) ? a = !1 : !a && f < Math.min(g, d) && (a = !0), g <= (a ? d : f))
    u = Math.max(s.top, Math.min(n.top, s.bottom - y)) - e.top, h = Math.min(400, a ? d : f);
  else {
    l = !0, h = Math.min(
      400,
      (o ? e.right : s.right - e.left) - 30
      /* Info.Margin */
    );
    let b = s.bottom - e.bottom;
    b >= y || b > e.top ? u = n.bottom - e.top : (c = "bottom", u = e.bottom - n.top);
  }
  let p = (e.bottom - e.top) / i.offsetHeight, m = (e.right - e.left) / i.offsetWidth;
  return {
    style: `${c}: ${u / p}px; max-width: ${h / m}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function MIe(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(n) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(n, r, s, i) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = n.displayLabel || n.label, l = 0;
      for (let c = 0; c < i.length; ) {
        let u = i[c++], h = i[c++];
        u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
        let d = o.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(a.slice(u, h))), d.className = "cm-completionMatchedText", l = h;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = n.detail, r;
    },
    position: 80
  }), e.sort((n, r) => n.position - r.position).map((n) => n.render);
}
function _w(t, e, n) {
  if (t <= n)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let s = Math.floor(e / n);
    return { from: s * n, to: (s + 1) * n };
  }
  let r = Math.floor((t - e) / n);
  return { from: t - (r + 1) * n, to: t - r * n };
}
class BIe {
  constructor(e, n, r) {
    this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let s = e.state.field(n), { options: i, selected: o } = s.open, a = e.state.facet(vn);
    this.optionContent = MIe(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = _w(i.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(n).open;
      for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
          this.applyCompletion(e, c[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(vn).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: df.of(null) });
    }), this.showOptions(i, s.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var n;
    let r = e.state.field(this.stateField), s = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != s) {
      let { options: i, selected: o, disabled: a } = r.open;
      (!s.open || s.open.options != i) && (this.range = _w(i.length, o, e.state.facet(vn).maxRenderedOptions), this.showOptions(i, r.id)), this.updateSel(), a != ((n = s.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of n.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), n = e.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = _w(n.options.length, n.selected, this.view.state.facet(vn).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: r } = n.options[n.selected], { info: s } = r;
      if (!s)
        return;
      let i = typeof s == "string" ? document.createTextNode(s) : s(r);
      if (!i)
        return;
      "then" in i ? i.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => Pr(this.view.state, o, "completion info")) : this.addInfoPane(i, r);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: s, destroy: i } = e;
      r.appendChild(s), this.infoDestroy = i || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let r = this.list.firstChild, s = this.range.from; r; r = r.nextSibling, s++)
      r.nodeName != "LI" || !r.id ? s-- : s == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return n && $Ie(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), s = e.getBoundingClientRect(), i = this.space;
    if (!i) {
      let o = this.dom.ownerDocument.defaultView || window;
      i = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return s.top > Math.min(i.bottom, n.bottom) - 10 || s.bottom < Math.max(i.top, n.top) + 10 ? null : this.view.state.facet(vn).positionInfo(this.view, n, s, r, i, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, n, r) {
    const s = document.createElement("ul");
    s.id = n, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let i = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let d = typeof c == "string" ? c : c.name;
        if (d != i && (o > r.from || r.from == 0))
          if (i = d, typeof c != "string" && c.header)
            s.appendChild(c.header(c));
          else {
            let f = s.appendChild(document.createElement("completion-section"));
            f.textContent = d;
          }
      }
      const u = s.appendChild(document.createElement("li"));
      u.id = n + "-" + o, u.setAttribute("role", "option");
      let h = this.optionClass(a);
      h && (u.className = h);
      for (let d of this.optionContent) {
        let f = d(a, this.view.state, this.view, l);
        f && u.appendChild(f);
      }
    }
    return r.from && s.classList.add("cm-completionListIncompleteTop"), r.to < e.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function FIe(t, e) {
  return (n) => new BIe(n, t, e);
}
function $Ie(t, e) {
  let n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), s = n.height / t.offsetHeight;
  r.top < n.top ? t.scrollTop -= (n.top - r.top) / s : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / s);
}
function zN(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function UIe(t, e) {
  let n = [], r = null, s = (c) => {
    n.push(c);
    let { section: u } = c.completion;
    if (u) {
      r || (r = []);
      let h = typeof u == "string" ? u : u.name;
      r.some((d) => d.name == h) || r.push(typeof u == "string" ? { name: h } : u);
    }
  }, i = e.facet(vn);
  for (let c of t)
    if (c.hasResult()) {
      let u = c.result.getMatch;
      if (c.result.filter === !1)
        for (let h of c.result.options)
          s(new UN(h, c.source, u ? u(h) : [], 1e9 - n.length));
      else {
        let h = e.sliceDoc(c.from, c.to), d, f = i.filterStrict ? new NIe(h) : new DIe(h);
        for (let g of c.result.options)
          if (d = f.match(g.label)) {
            let y = g.displayLabel ? u ? u(g, d.matched) : [] : d.matched;
            s(new UN(g, c.source, y, d.score + (g.boost || 0)));
          }
      }
    }
  if (r) {
    let c = /* @__PURE__ */ Object.create(null), u = 0, h = (d, f) => {
      var g, y;
      return ((g = d.rank) !== null && g !== void 0 ? g : 1e9) - ((y = f.rank) !== null && y !== void 0 ? y : 1e9) || (d.name < f.name ? -1 : 1);
    };
    for (let d of r.sort(h))
      u -= 1e5, c[d.name] = u;
    for (let d of n) {
      let { section: f } = d.completion;
      f && (d.score += c[typeof f == "string" ? f : f.name]);
    }
  }
  let o = [], a = null, l = i.compareCompletions;
  for (let c of n.sort((u, h) => h.score - u.score || l(u.completion, h.completion))) {
    let u = c.completion;
    !a || a.label != u.label || a.detail != u.detail || a.type != null && u.type != null && a.type != u.type || a.apply != u.apply || a.boost != u.boost ? o.push(c) : zN(c.completion) > zN(a) && (o[o.length - 1] = c), a = c.completion;
  }
  return o;
}
class Sc {
  constructor(e, n, r, s, i, o) {
    this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = s, this.selected = i, this.disabled = o;
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length ? this : new Sc(this.options, GN(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, r, s, i, o) {
    if (s && !o && e.some((c) => c.isPending))
      return s.setDisabled();
    let a = UIe(e, n);
    if (!a.length)
      return s && e.some((c) => c.isPending) ? s.setDisabled() : null;
    let l = n.facet(vn).selectOnOpen ? 0 : -1;
    if (s && s.selected != l && s.selected != -1) {
      let c = s.options[s.selected].completion;
      for (let u = 0; u < a.length; u++)
        if (a[u].completion == c) {
          l = u;
          break;
        }
    }
    return new Sc(a, GN(r, l), {
      pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
      create: WIe,
      above: i.aboveCursor
    }, s ? s.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new Sc(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Sc(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class yy {
  constructor(e, n, r) {
    this.active = e, this.id = n, this.open = r;
  }
  static start() {
    return new yy(GIe, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e, r = n.facet(vn), i = (r.override || n.languageDataAt("autocomplete", ol(n)).map(OIe)).map((l) => (this.active.find((u) => u.source == l) || new Zr(
      l,
      this.active.some(
        (u) => u.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    i.length == this.active.length && i.every((l, c) => l == this.active[c]) && (i = this.active);
    let o = this.open, a = e.effects.some((l) => l.is(mA));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || i.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !jIe(i, this.active) || a ? o = Sc.build(i, n, this.id, o, r, a) : o && o.disabled && !i.some((l) => l.isPending) && (o = null), !o && i.every((l) => !l.isPending) && i.some((l) => l.hasResult()) && (i = i.map((l) => l.hasResult() ? new Zr(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(PG) && (o = o && o.setSelected(l.value, this.id));
    return i == this.active && o == this.open ? this : new yy(i, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? HIe : zIe;
  }
}
function jIe(t, e) {
  if (t == e)
    return !0;
  for (let n = 0, r = 0; ; ) {
    for (; n < t.length && !t[n].hasResult(); )
      n++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let s = n == t.length, i = r == e.length;
    if (s || i)
      return s == i;
    if (t[n++].result != e[r++].result)
      return !1;
  }
}
const HIe = {
  "aria-autocomplete": "list"
}, zIe = {};
function GN(t, e) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
}
const GIe = [];
function IG(t, e) {
  if (t.isUserEvent("input.complete")) {
    let r = t.annotation(pA);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let n = t.isUserEvent("input.type");
  return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class Zr {
  constructor(e, n, r = !1) {
    this.source = e, this.state = n, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, n) {
    let r = IG(e, n), s = this;
    (r & 8 || r & 16 && this.touches(e)) && (s = new Zr(
      s.source,
      0
      /* State.Inactive */
    )), r & 4 && s.state == 0 && (s = new Zr(
      this.source,
      1
      /* State.Pending */
    )), s = s.updateFor(e, r);
    for (let i of e.effects)
      if (i.is(gy))
        s = new Zr(s.source, 1, i.value);
      else if (i.is(df))
        s = new Zr(
          s.source,
          0
          /* State.Inactive */
        );
      else if (i.is(mA))
        for (let o of i.value)
          o.source == s.source && (s = o);
    return s;
  }
  updateFor(e, n) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(ol(e.state));
  }
}
class Fc extends Zr {
  constructor(e, n, r, s, i, o) {
    super(e, 3, n), this.limit = r, this.result = s, this.from = i, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, n) {
    var r;
    if (!(n & 3))
      return this.map(e.changes);
    let s = this.result;
    s.map && !e.changes.empty && (s = s.map(s, e.changes));
    let i = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = ol(e.state);
    if (a > o || !s || n & 2 && (ol(e.startState) == this.from || a < this.limit))
      return new Zr(
        this.source,
        n & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return VIe(s.validFor, e.state, i, o) ? new Fc(this.source, this.explicit, l, s, i, o) : s.update && (s = s.update(s, i, o, new AG(e.state, a, !1))) ? new Fc(this.source, this.explicit, l, s, s.from, (r = s.to) !== null && r !== void 0 ? r : ol(e.state)) : new Zr(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Fc(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new Zr(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function VIe(t, e, n, r) {
  if (!t)
    return !1;
  let s = e.sliceDoc(n, r);
  return typeof t == "function" ? t(s, n, r, e) : RG(t, !0).test(s);
}
const mA = /* @__PURE__ */ at.define({
  map(t, e) {
    return t.map((n) => n.map(e));
  }
}), PG = /* @__PURE__ */ at.define(), fr = /* @__PURE__ */ En.define({
  create() {
    return yy.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    aA.from(t, (e) => e.tooltip),
    He.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function gA(t, e) {
  const n = e.completion.apply || e.completion.label;
  let r = t.state.field(fr).active.find((s) => s.source == e.source);
  return r instanceof Fc ? (typeof n == "string" ? t.dispatch(Object.assign(Object.assign({}, PIe(t.state, n, r.from, r.to)), { annotations: pA.of(e.completion) })) : n(t, e.completion, r.from, r.to), !0) : !1;
}
const WIe = /* @__PURE__ */ FIe(fr, gA);
function Um(t, e = "option") {
  return (n) => {
    let r = n.state.field(fr, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(vn).interactionDelay)
      return !1;
    let s = 1, i;
    e == "page" && (i = lG(n, r.open.tooltip)) && (s = Math.max(2, Math.floor(i.dom.offsetHeight / i.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, a = r.open.selected > -1 ? r.open.selected + s * (t ? 1 : -1) : t ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), n.dispatch({ effects: PG.of(a) }), !0;
  };
}
const OG = (t) => {
  let e = t.state.field(fr, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(vn).interactionDelay ? !1 : gA(t, e.open.options[e.open.selected]);
}, VN = (t) => t.state.field(fr, !1) ? (t.dispatch({ effects: gy.of(!0) }), !0) : !1, qIe = (t) => {
  let e = t.state.field(fr, !1);
  return !e || !e.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: df.of(null) }), !0);
};
class KIe {
  constructor(e, n) {
    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const YIe = 50, ZIe = 1e3, JIe = /* @__PURE__ */ In.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(fr).active)
      e.isPending && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(fr), n = t.state.facet(vn);
    if (!t.selectionSet && !t.docChanged && t.startState.field(fr) == e)
      return;
    let r = t.transactions.some((i) => {
      let o = IG(i, n);
      return o & 8 || (i.selection || i.docChanged) && !(o & 3);
    });
    for (let i = 0; i < this.running.length; i++) {
      let o = this.running[i];
      if (r || o.context.abortOnDocChange && t.docChanged || o.updates.length + t.transactions.length > YIe && Date.now() - o.time > ZIe) {
        for (let a of o.context.abortListeners)
          try {
            a();
          } catch (l) {
            Pr(this.view.state, l);
          }
        o.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        o.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((i) => i.effects.some((o) => o.is(gy))) && (this.pendingStart = !0);
    let s = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((i) => i.isPending && !this.running.some((o) => o.active.source == i.source)) ? setTimeout(() => this.startUpdate(), s) : -1, this.composing != 0)
      for (let i of t.transactions)
        i.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(fr);
    for (let n of e.active)
      n.isPending && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(vn).updateSyncTime));
  }
  startQuery(t) {
    let { state: e } = this.view, n = ol(e), r = new AG(e, n, t.explicit, this.view), s = new KIe(t, r);
    this.running.push(s), Promise.resolve(t.source(r)).then((i) => {
      s.context.aborted || (s.done = i || null, this.scheduleAccept());
    }, (i) => {
      this.view.dispatch({ effects: df.of(null) }), Pr(this.view.state, i);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(vn).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], n = this.view.state.facet(vn), r = this.view.state.field(fr);
    for (let s = 0; s < this.running.length; s++) {
      let i = this.running[s];
      if (i.done === void 0)
        continue;
      if (this.running.splice(s--, 1), i.done) {
        let a = ol(i.updates.length ? i.updates[0].startState : this.view.state), l = Math.min(a, i.done.from + (i.active.explicit ? 0 : 1)), c = new Fc(i.active.source, i.active.explicit, l, i.done, i.done.from, (t = i.done.to) !== null && t !== void 0 ? t : a);
        for (let u of i.updates)
          c = c.update(u, n);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = r.active.find((a) => a.source == i.active.source);
      if (o && o.isPending)
        if (i.done == null) {
          let a = new Zr(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let l of i.updates)
            a = a.update(l, n);
          a.isPending || e.push(a);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: mA.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(fr, !1);
      if (e && e.tooltip && this.view.state.facet(vn).closeOnBlur) {
        let n = e.open && lG(this.view, e.open.tooltip);
        (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: df.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: gy.of(!1) }), 20), this.composing = 0;
    }
  }
}), XIe = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), QIe = /* @__PURE__ */ _a.highest(/* @__PURE__ */ He.domEventHandlers({
  keydown(t, e) {
    let n = e.state.field(fr, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(XIe && t.altKey) || t.metaKey)
      return !1;
    let r = n.open.options[n.open.selected], s = n.active.find((o) => o.source == r.source), i = r.completion.commitCharacters || s.result.commitCharacters;
    return i && i.indexOf(t.key) > -1 && gA(e, r), !1;
  }
})), DG = /* @__PURE__ */ He.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class ePe {
  constructor(e, n, r, s) {
    this.field = e, this.line = n, this.from = r, this.to = s;
  }
}
class yA {
  constructor(e, n, r) {
    this.field = e, this.from = n, this.to = r;
  }
  map(e) {
    let n = e.mapPos(this.from, -1, Fn.TrackDel), r = e.mapPos(this.to, 1, Fn.TrackDel);
    return n == null || r == null ? null : new yA(this.field, n, r);
  }
}
class bA {
  constructor(e, n) {
    this.lines = e, this.fieldPositions = n;
  }
  instantiate(e, n) {
    let r = [], s = [n], i = e.doc.lineAt(n), o = /^\s*/.exec(i.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let c = o, u = /^\t*/.exec(l)[0].length;
        for (let h = 0; h < u; h++)
          c += e.facet(Uu);
        s.push(n + c.length - u), l = c + l.slice(u);
      }
      r.push(l), n += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new yA(l.field, s[l.line] + l.from, s[l.line] + l.to));
    return { text: r, ranges: a };
  }
  static parse(e) {
    let n = [], r = [], s = [], i;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; i = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o); ) {
        let a = i[1] ? +i[1] : null, l = i[2] || i[3] || "", c = -1, u = l.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < n.length; h++)
          (a != null ? n[h].seq == a : u && n[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < n.length && (a == null || n[h].seq != null && n[h].seq < a); )
            h++;
          n.splice(h, 0, { seq: a, name: u }), c = h;
          for (let d of s)
            d.field >= c && d.field++;
        }
        s.push(new ePe(c, r.length, i.index, i.index + u.length)), o = o.slice(0, i.index) + l + o.slice(i.index + i[0].length);
      }
      o = o.replace(/\\([{}])/g, (a, l, c) => {
        for (let u of s)
          u.line == r.length && u.from > c && (u.from--, u.to--);
        return l;
      }), r.push(o);
    }
    return new bA(r, s);
  }
}
let tPe = /* @__PURE__ */ yt.widget({ widget: /* @__PURE__ */ new class extends $u {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), nPe = /* @__PURE__ */ yt.mark({ class: "cm-snippetField" });
class ju {
  constructor(e, n) {
    this.ranges = e, this.active = n, this.deco = yt.set(e.map((r) => (r.from == r.to ? tPe : nPe).range(r.from, r.to)));
  }
  map(e) {
    let n = [];
    for (let r of this.ranges) {
      let s = r.map(e);
      if (!s)
        return null;
      n.push(s);
    }
    return new ju(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((r) => r.field == this.active && r.from <= n.from && r.to >= n.to));
  }
}
const gp = /* @__PURE__ */ at.define({
  map(t, e) {
    return t && t.map(e);
  }
}), rPe = /* @__PURE__ */ at.define(), ff = /* @__PURE__ */ En.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let n of e.effects) {
      if (n.is(gp))
        return n.value;
      if (n.is(rPe) && t)
        return new ju(t.ranges, n.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => He.decorations.from(t, (e) => e ? e.deco : yt.none)
});
function _A(t, e) {
  return Ae.create(t.filter((n) => n.field == e).map((n) => Ae.range(n.from, n.to)));
}
function sPe(t) {
  let e = bA.parse(t);
  return (n, r, s, i) => {
    let { text: o, ranges: a } = e.instantiate(n.state, s), { main: l } = n.state.selection, c = {
      changes: { from: s, to: i == l.from ? l.to : i, insert: Et.of(o) },
      scrollIntoView: !0,
      annotations: r ? [pA.of(r), sn.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (c.selection = _A(a, 0)), a.some((u) => u.field > 0)) {
      let u = new ju(a, 0), h = c.effects = [gp.of(u)];
      n.state.field(ff, !1) === void 0 && h.push(at.appendConfig.of([ff, cPe, uPe, DG]));
    }
    n.dispatch(n.state.update(c));
  };
}
function NG(t) {
  return ({ state: e, dispatch: n }) => {
    let r = e.field(ff, !1);
    if (!r || t < 0 && r.active == 0)
      return !1;
    let s = r.active + t, i = t > 0 && !r.ranges.some((o) => o.field == s + t);
    return n(e.update({
      selection: _A(r.ranges, s),
      effects: gp.of(i ? null : new ju(r.ranges, s)),
      scrollIntoView: !0
    })), !0;
  };
}
const iPe = ({ state: t, dispatch: e }) => t.field(ff, !1) ? (e(t.update({ effects: gp.of(null) })), !0) : !1, oPe = /* @__PURE__ */ NG(1), aPe = /* @__PURE__ */ NG(-1), lPe = [
  { key: "Tab", run: oPe, shift: aPe },
  { key: "Escape", run: iPe }
], WN = /* @__PURE__ */ ze.define({
  combine(t) {
    return t.length ? t[0] : lPe;
  }
}), cPe = /* @__PURE__ */ _a.highest(/* @__PURE__ */ Qb.compute([WN], (t) => t.facet(WN)));
function tWe(t, e) {
  return Object.assign(Object.assign({}, e), { apply: sPe(t) });
}
const uPe = /* @__PURE__ */ He.domEventHandlers({
  mousedown(t, e) {
    let n = e.state.field(ff, !1), r;
    if (!n || (r = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let s = n.ranges.find((i) => i.from <= r && i.to >= r);
    return !s || s.field == n.active ? !1 : (e.dispatch({
      selection: _A(n.ranges, s.field),
      effects: gp.of(n.ranges.some((i) => i.field > s.field) ? new ju(n.ranges, s.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), by = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Wa = /* @__PURE__ */ at.define({
  map(t, e) {
    let n = e.mapPos(t, -1, Fn.TrackAfter);
    return n ?? void 0;
  }
}), vA = /* @__PURE__ */ new class extends vl {
}();
vA.startSide = 1;
vA.endSide = -1;
const LG = /* @__PURE__ */ En.define({
  create() {
    return _t.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of e.effects)
      n.is(Wa) && (t = t.update({ add: [vA.range(n.value, n.value + 1)] }));
    return t;
  }
});
function hPe() {
  return [mPe, LG];
}
const vw = "()[]{}<>";
function dPe(t) {
  for (let e = 0; e < vw.length; e += 2)
    if (vw.charCodeAt(e) == t)
      return vw.charAt(e + 1);
  return Kk(t < 128 ? t : t + 1);
}
function fPe(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || by;
}
const pPe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), mPe = /* @__PURE__ */ He.inputHandler.of((t, e, n, r) => {
  if ((pPe ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let s = t.state.selection.main;
  if (r.length > 2 || r.length == 2 && Qi(ms(r, 0)) == 1 || e != s.from || n != s.to)
    return !1;
  let i = gPe(t.state, r);
  return i ? (t.dispatch(i), !0) : !1;
});
function gPe(t, e) {
  let n = fPe(t, t.selection.main.head), r = n.brackets || by.brackets;
  for (let s of r) {
    let i = dPe(ms(s, 0));
    if (e == s)
      return i == s ? _Pe(t, s, r.indexOf(s + s + s) > -1, n) : yPe(t, s, i, n.before || by.before);
    if (e == i && MG(t, t.selection.main.from))
      return bPe(t, s, i);
  }
  return null;
}
function MG(t, e) {
  let n = !1;
  return t.field(LG).between(0, t.doc.length, (r) => {
    r == e && (n = !0);
  }), n;
}
function wA(t, e) {
  let n = t.sliceString(e, e + 2);
  return n.slice(0, Qi(ms(n, 0)));
}
function yPe(t, e, n, r) {
  let s = null, i = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: n, from: o.to }],
        effects: Wa.of(o.to + e.length),
        range: Ae.range(o.anchor + e.length, o.head + e.length)
      };
    let a = wA(t.doc, o.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: e + n, from: o.head },
      effects: Wa.of(o.head + e.length),
      range: Ae.cursor(o.head + e.length)
    } : { range: s = o };
  });
  return s ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function bPe(t, e, n) {
  let r = null, s = t.changeByRange((i) => i.empty && wA(t.doc, i.head) == n ? {
    changes: { from: i.head, to: i.head + n.length, insert: n },
    range: Ae.cursor(i.head + n.length)
  } : r = { range: i });
  return r ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function _Pe(t, e, n, r) {
  let s = r.stringPrefixes || by.stringPrefixes, i = null, o = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: Wa.of(a.to + e.length),
        range: Ae.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = wA(t.doc, l), u;
    if (c == e) {
      if (qN(t, l))
        return {
          changes: { insert: e + e, from: l },
          effects: Wa.of(l + e.length),
          range: Ae.cursor(l + e.length)
        };
      if (MG(t, l)) {
        let d = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + d.length, insert: d },
          range: Ae.cursor(l + d.length)
        };
      }
    } else {
      if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = KN(t, l - 2 * e.length, s)) > -1 && qN(t, u))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: Wa.of(l + e.length),
          range: Ae.cursor(l + e.length)
        };
      if (t.charCategorizer(l)(c) != on.Word && KN(t, l, s) > -1 && !vPe(t, l, e, s))
        return {
          changes: { insert: e + e, from: l },
          effects: Wa.of(l + e.length),
          range: Ae.cursor(l + e.length)
        };
    }
    return { range: i = a };
  });
  return i ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function qN(t, e) {
  let n = Pn(t).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function vPe(t, e, n, r) {
  let s = Pn(t).resolveInner(e, -1), i = r.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = t.sliceDoc(s.from, Math.min(s.to, s.from + n.length + i)), l = a.indexOf(n);
    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
      let u = s.firstChild;
      for (; u && u.from == s.from && u.to - u.from > n.length + l; ) {
        if (t.sliceDoc(u.to - n.length, u.to) == n)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = s.to == e && s.parent;
    if (!c)
      break;
    s = c;
  }
  return !1;
}
function KN(t, e, n) {
  let r = t.charCategorizer(e);
  if (r(t.sliceDoc(e - 1, e)) != on.Word)
    return e;
  for (let s of n) {
    let i = e - s.length;
    if (t.sliceDoc(i, e) == s && r(t.sliceDoc(i - 1, i)) != on.Word)
      return i;
  }
  return -1;
}
function wPe(t = {}) {
  return [
    QIe,
    fr,
    vn.of(t),
    JIe,
    SPe,
    DG
  ];
}
const EPe = [
  { key: "Ctrl-Space", run: VN },
  { mac: "Alt-`", run: VN },
  { key: "Escape", run: qIe },
  { key: "ArrowDown", run: /* @__PURE__ */ Um(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Um(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Um(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Um(!1, "page") },
  { key: "Enter", run: OG }
], SPe = /* @__PURE__ */ _a.highest(/* @__PURE__ */ Qb.computeN([vn], (t) => t.facet(vn).defaultKeymap ? [EPe] : [])), xPe = (t) => {
  let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), r = SA(t.state, n.from);
  return r.line ? TPe(t) : r.block ? kPe(t) : !1;
};
function EA(t, e) {
  return ({ state: n, dispatch: r }) => {
    if (n.readOnly)
      return !1;
    let s = t(e, n);
    return s ? (r(n.update(s)), !0) : !1;
  };
}
const TPe = /* @__PURE__ */ EA(
  IPe,
  0
  /* CommentOption.Toggle */
), CPe = /* @__PURE__ */ EA(
  BG,
  0
  /* CommentOption.Toggle */
), kPe = /* @__PURE__ */ EA(
  (t, e) => BG(t, e, RPe(e)),
  0
  /* CommentOption.Toggle */
);
function SA(t, e) {
  let n = t.languageDataAt("commentTokens", e);
  return n.length ? n[0] : {};
}
const dh = 50;
function APe(t, { open: e, close: n }, r, s) {
  let i = t.sliceDoc(r - dh, r), o = t.sliceDoc(s, s + dh), a = /\s*$/.exec(i)[0].length, l = /^\s*/.exec(o)[0].length, c = i.length - a;
  if (i.slice(c - e.length, c) == e && o.slice(l, l + n.length) == n)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: s + l, margin: l && 1 }
    };
  let u, h;
  s - r <= 2 * dh ? u = h = t.sliceDoc(r, s) : (u = t.sliceDoc(r, r + dh), h = t.sliceDoc(s - dh, s));
  let d = /^\s*/.exec(u)[0].length, f = /\s*$/.exec(h)[0].length, g = h.length - f - n.length;
  return u.slice(d, d + e.length) == e && h.slice(g, g + n.length) == n ? {
    open: {
      pos: r + d + e.length,
      margin: /\s/.test(u.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: s - f - n.length,
      margin: /\s/.test(h.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
function RPe(t) {
  let e = [];
  for (let n of t.selection.ranges) {
    let r = t.doc.lineAt(n.from), s = n.to <= r.to ? r : t.doc.lineAt(n.to);
    s.from > r.from && s.from == n.to && (s = n.to == r.to + 1 ? r : t.doc.lineAt(n.to - 1));
    let i = e.length - 1;
    i >= 0 && e[i].to > r.from ? e[i].to = s.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: s.to });
  }
  return e;
}
function BG(t, e, n = e.selection.ranges) {
  let r = n.map((i) => SA(e, i.from).block);
  if (!r.every((i) => i))
    return null;
  let s = n.map((i, o) => APe(e, r[o], i.from, i.to));
  if (t != 2 && !s.every((i) => i))
    return { changes: e.changes(n.map((i, o) => s[o] ? [] : [{ from: i.from, insert: r[o].open + " " }, { from: i.to, insert: " " + r[o].close }])) };
  if (t != 1 && s.some((i) => i)) {
    let i = [];
    for (let o = 0, a; o < s.length; o++)
      if (a = s[o]) {
        let l = r[o], { open: c, close: u } = a;
        i.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: i };
  }
  return null;
}
function IPe(t, e, n = e.selection.ranges) {
  let r = [], s = -1;
  for (let { from: i, to: o } of n) {
    let a = r.length, l = 1e9, c = SA(e, i).line;
    if (c) {
      for (let u = i; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > s && (i == o || o > h.from)) {
          s = h.from;
          let d = /^\s*/.exec(h.text)[0].length, f = d == h.length, g = h.text.slice(d, d + c.length) == c ? d : -1;
          d < h.text.length && d < l && (l = d), r.push({ line: h, comment: g, token: c, indent: d, empty: f, single: !1 });
        }
        u = h.to + 1;
      }
      if (l < 1e9)
        for (let u = a; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = l);
      r.length == a + 1 && (r[a].single = !0);
    }
  }
  if (t != 2 && r.some((i) => i.comment < 0 && (!i.empty || i.single))) {
    let i = [];
    for (let { line: a, token: l, indent: c, empty: u, single: h } of r)
      (h || !u) && i.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(i);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (t != 1 && r.some((i) => i.comment >= 0)) {
    let i = [];
    for (let { line: o, comment: a, token: l } of r)
      if (a >= 0) {
        let c = o.from + a, u = c + l.length;
        o.text[u - o.from] == " " && u++, i.push({ from: c, to: u });
      }
    return { changes: i };
  }
  return null;
}
const Ax = /* @__PURE__ */ bo.define(), PPe = /* @__PURE__ */ bo.define(), OPe = /* @__PURE__ */ ze.define(), FG = /* @__PURE__ */ ze.define({
  combine(t) {
    return $l(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, n) => (r, s) => e(r, s) || n(r, s)
    });
  }
}), $G = /* @__PURE__ */ En.define({
  create() {
    return gi.empty;
  },
  update(t, e) {
    let n = e.state.facet(FG), r = e.annotation(Ax);
    if (r) {
      let l = mr.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? t.undone : t.done;
      return l ? u = _y(u, u.length, n.minDepth, l) : u = HG(u, e.startState.selection), new gi(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
    }
    let s = e.annotation(PPe);
    if ((s == "full" || s == "before") && (t = t.isolate()), e.annotation(sn.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let i = mr.fromTransaction(e), o = e.annotation(sn.time), a = e.annotation(sn.userEvent);
    return i ? t = t.addChanges(i, o, a, n, e) : e.selection && (t = t.addSelection(e.startState.selection, o, a, n.newGroupDelay)), (s == "full" || s == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new gi(t.done.map(mr.fromJSON), t.undone.map(mr.fromJSON));
  }
});
function DPe(t = {}) {
  return [
    $G,
    FG.of(t),
    He.domEventHandlers({
      beforeinput(e, n) {
        let r = e.inputType == "historyUndo" ? UG : e.inputType == "historyRedo" ? Rx : null;
        return r ? (e.preventDefault(), r(n)) : !1;
      }
    })
  ];
}
function n_(t, e) {
  return function({ state: n, dispatch: r }) {
    if (!e && n.readOnly)
      return !1;
    let s = n.field($G, !1);
    if (!s)
      return !1;
    let i = s.pop(t, n, e);
    return i ? (r(i), !0) : !1;
  };
}
const UG = /* @__PURE__ */ n_(0, !1), Rx = /* @__PURE__ */ n_(1, !1), NPe = /* @__PURE__ */ n_(0, !0), LPe = /* @__PURE__ */ n_(1, !0);
class mr {
  constructor(e, n, r, s, i) {
    this.changes = e, this.effects = n, this.mapped = r, this.startSelection = s, this.selectionsAfter = i;
  }
  setSelAfter(e) {
    return new mr(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(e) {
    return new mr(e.changes && un.fromJSON(e.changes), [], e.mapped && Ei.fromJSON(e.mapped), e.startSelection && Ae.fromJSON(e.startSelection), e.selectionsAfter.map(Ae.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, n) {
    let r = Jr;
    for (let s of e.startState.facet(OPe)) {
      let i = s(e);
      i.length && (r = r.concat(i));
    }
    return !r.length && e.changes.empty ? null : new mr(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, Jr);
  }
  static selection(e) {
    return new mr(void 0, Jr, void 0, void 0, e);
  }
}
function _y(t, e, n, r) {
  let s = e + 1 > n + 20 ? e - n - 1 : 0, i = t.slice(s, e);
  return i.push(r), i;
}
function MPe(t, e) {
  let n = [], r = !1;
  return t.iterChangedRanges((s, i) => n.push(s, i)), e.iterChangedRanges((s, i, o, a) => {
    for (let l = 0; l < n.length; ) {
      let c = n[l++], u = n[l++];
      a >= c && o <= u && (r = !0);
    }
  }), r;
}
function BPe(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
}
function jG(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Jr = [], FPe = 200;
function HG(t, e) {
  if (t.length) {
    let n = t[t.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - FPe));
    return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), _y(t, t.length - 1, 1e9, n.setSelAfter(r)));
  } else
    return [mr.selection([e])];
}
function $Pe(t) {
  let e = t[t.length - 1], n = t.slice();
  return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
}
function ww(t, e) {
  if (!t.length)
    return t;
  let n = t.length, r = Jr;
  for (; n; ) {
    let s = UPe(t[n - 1], e, r);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let i = t.slice(0, n);
      return i[n - 1] = s, i;
    } else
      e = s.mapped, n--, r = s.selectionsAfter;
  }
  return r.length ? [mr.selection(r)] : Jr;
}
function UPe(t, e, n) {
  let r = jG(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : Jr, n);
  if (!t.changes)
    return mr.selection(r);
  let s = t.changes.map(e), i = e.mapDesc(t.changes, !0), o = t.mapped ? t.mapped.composeDesc(i) : i;
  return new mr(s, at.mapEffects(t.effects, e), o, t.startSelection.map(i), r);
}
const jPe = /^(input\.type|delete)($|\.)/;
class gi {
  constructor(e, n, r = 0, s = void 0) {
    this.done = e, this.undone = n, this.prevTime = r, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new gi(this.done, this.undone) : this;
  }
  addChanges(e, n, r, s, i) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!r || jPe.test(r)) && (!a.selectionsAfter.length && n - this.prevTime < s.newGroupDelay && s.joinToEvent(i, MPe(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = _y(o, o.length - 1, s.minDepth, new mr(e.changes.compose(a.changes), jG(at.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, Jr)) : o = _y(o, o.length, s.minDepth, e), new gi(o, Jr, n, r);
  }
  addSelection(e, n, r, s) {
    let i = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Jr;
    return i.length > 0 && n - this.prevTime < s && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && BPe(i[i.length - 1], e) ? this : new gi(HG(this.done, e), this.undone, n, r);
  }
  addMapping(e) {
    return new gi(ww(this.done, e), ww(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, r) {
    let s = e == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let i = s[s.length - 1], o = i.selectionsAfter[0] || n.selection;
    if (r && i.selectionsAfter.length)
      return n.update({
        selection: i.selectionsAfter[i.selectionsAfter.length - 1],
        annotations: Ax.of({ side: e, rest: $Pe(s), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (i.changes) {
      let a = s.length == 1 ? Jr : s.slice(0, s.length - 1);
      return i.mapped && (a = ww(a, i.mapped)), n.update({
        changes: i.changes,
        selection: i.startSelection,
        effects: i.effects,
        annotations: Ax.of({ side: e, rest: a, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
gi.empty = /* @__PURE__ */ new gi(Jr, Jr);
const HPe = [
  { key: "Mod-z", run: UG, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Rx, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Rx, preventDefault: !0 },
  { key: "Mod-u", run: NPe, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: LPe, preventDefault: !0 }
];
function Hu(t, e) {
  return Ae.create(t.ranges.map(e), t.mainIndex);
}
function Li(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Ds({ state: t, dispatch: e }, n) {
  let r = Hu(t.selection, n);
  return r.eq(t.selection, !0) ? !1 : (e(Li(t, r)), !0);
}
function r_(t, e) {
  return Ae.cursor(e ? t.to : t.from);
}
function zG(t, e) {
  return Ds(t, (n) => n.empty ? t.moveByChar(n, e) : r_(n, e));
}
function Gn(t) {
  return t.textDirectionAt(t.state.selection.main.head) == jt.LTR;
}
const GG = (t) => zG(t, !Gn(t)), VG = (t) => zG(t, Gn(t));
function WG(t, e) {
  return Ds(t, (n) => n.empty ? t.moveByGroup(n, e) : r_(n, e));
}
const zPe = (t) => WG(t, !Gn(t)), GPe = (t) => WG(t, Gn(t));
function VPe(t, e, n) {
  if (e.type.prop(n))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function s_(t, e, n) {
  let r = Pn(t).resolveInner(e.head), s = n ? ct.closedBy : ct.openedBy;
  for (let l = e.head; ; ) {
    let c = n ? r.childAfter(l) : r.childBefore(l);
    if (!c)
      break;
    VPe(t, c, s) ? r = c : l = n ? c.to : c.from;
  }
  let i = r.type.prop(s), o, a;
  return i && (o = n ? mi(t, r.from, 1) : mi(t, r.to, -1)) && o.matched ? a = n ? o.end.to : o.end.from : a = n ? r.to : r.from, Ae.cursor(a, n ? -1 : 1);
}
const WPe = (t) => Ds(t, (e) => s_(t.state, e, !Gn(t))), qPe = (t) => Ds(t, (e) => s_(t.state, e, Gn(t)));
function qG(t, e) {
  return Ds(t, (n) => {
    if (!n.empty)
      return r_(n, e);
    let r = t.moveVertically(n, e);
    return r.head != n.head ? r : t.moveToLineBoundary(n, e);
  });
}
const KG = (t) => qG(t, !1), YG = (t) => qG(t, !0);
function ZG(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, r = 0, s;
  if (e) {
    for (let i of t.state.facet(He.scrollMargins)) {
      let o = i(t);
      o?.top && (n = Math.max(o?.top, n)), o?.bottom && (r = Math.max(o?.bottom, r));
    }
    s = t.scrollDOM.clientHeight - n - r;
  } else
    s = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, s - 5)
  };
}
function JG(t, e) {
  let n = ZG(t), { state: r } = t, s = Hu(r.selection, (o) => o.empty ? t.moveVertically(o, e, n.height) : r_(o, e));
  if (s.eq(r.selection))
    return !1;
  let i;
  if (n.selfScroll) {
    let o = t.coordsAtPos(r.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + n.marginTop, c = a.bottom - n.marginBottom;
    o && o.top > l && o.bottom < c && (i = He.scrollIntoView(s.main.head, { y: "start", yMargin: o.top - l }));
  }
  return t.dispatch(Li(r, s), { effects: i }), !0;
}
const YN = (t) => JG(t, !1), Ix = (t) => JG(t, !0);
function va(t, e, n) {
  let r = t.lineBlockAt(e.head), s = t.moveToLineBoundary(e, n);
  if (s.head == e.head && s.head != (n ? r.to : r.from) && (s = t.moveToLineBoundary(e, n, !1)), !n && s.head == r.from && r.length) {
    let i = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    i && e.head != r.from + i && (s = Ae.cursor(r.from + i));
  }
  return s;
}
const KPe = (t) => Ds(t, (e) => va(t, e, !0)), YPe = (t) => Ds(t, (e) => va(t, e, !1)), ZPe = (t) => Ds(t, (e) => va(t, e, !Gn(t))), JPe = (t) => Ds(t, (e) => va(t, e, Gn(t))), XPe = (t) => Ds(t, (e) => Ae.cursor(t.lineBlockAt(e.head).from, 1)), QPe = (t) => Ds(t, (e) => Ae.cursor(t.lineBlockAt(e.head).to, -1));
function eOe(t, e, n) {
  let r = !1, s = Hu(t.selection, (i) => {
    let o = mi(t, i.head, -1) || mi(t, i.head, 1) || i.head > 0 && mi(t, i.head - 1, 1) || i.head < t.doc.length && mi(t, i.head + 1, -1);
    if (!o || !o.end)
      return i;
    r = !0;
    let a = o.start.from == i.head ? o.end.to : o.end.from;
    return Ae.cursor(a);
  });
  return r ? (e(Li(t, s)), !0) : !1;
}
const tOe = ({ state: t, dispatch: e }) => eOe(t, e);
function us(t, e) {
  let n = Hu(t.state.selection, (r) => {
    let s = e(r);
    return Ae.range(r.anchor, s.head, s.goalColumn, s.bidiLevel || void 0);
  });
  return n.eq(t.state.selection) ? !1 : (t.dispatch(Li(t.state, n)), !0);
}
function XG(t, e) {
  return us(t, (n) => t.moveByChar(n, e));
}
const QG = (t) => XG(t, !Gn(t)), eV = (t) => XG(t, Gn(t));
function tV(t, e) {
  return us(t, (n) => t.moveByGroup(n, e));
}
const nOe = (t) => tV(t, !Gn(t)), rOe = (t) => tV(t, Gn(t)), sOe = (t) => us(t, (e) => s_(t.state, e, !Gn(t))), iOe = (t) => us(t, (e) => s_(t.state, e, Gn(t)));
function nV(t, e) {
  return us(t, (n) => t.moveVertically(n, e));
}
const rV = (t) => nV(t, !1), sV = (t) => nV(t, !0);
function iV(t, e) {
  return us(t, (n) => t.moveVertically(n, e, ZG(t).height));
}
const ZN = (t) => iV(t, !1), JN = (t) => iV(t, !0), oOe = (t) => us(t, (e) => va(t, e, !0)), aOe = (t) => us(t, (e) => va(t, e, !1)), lOe = (t) => us(t, (e) => va(t, e, !Gn(t))), cOe = (t) => us(t, (e) => va(t, e, Gn(t))), uOe = (t) => us(t, (e) => Ae.cursor(t.lineBlockAt(e.head).from)), hOe = (t) => us(t, (e) => Ae.cursor(t.lineBlockAt(e.head).to)), XN = ({ state: t, dispatch: e }) => (e(Li(t, { anchor: 0 })), !0), QN = ({ state: t, dispatch: e }) => (e(Li(t, { anchor: t.doc.length })), !0), eL = ({ state: t, dispatch: e }) => (e(Li(t, { anchor: t.selection.main.anchor, head: 0 })), !0), tL = ({ state: t, dispatch: e }) => (e(Li(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), dOe = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), fOe = ({ state: t, dispatch: e }) => {
  let n = i_(t).map(({ from: r, to: s }) => Ae.range(r, Math.min(s + 1, t.doc.length)));
  return e(t.update({ selection: Ae.create(n), userEvent: "select" })), !0;
}, pOe = ({ state: t, dispatch: e }) => {
  let n = Hu(t.selection, (r) => {
    let s = Pn(t), i = s.resolveStack(r.from, 1);
    if (r.empty) {
      let o = s.resolveStack(r.from, -1);
      o.node.from >= i.node.from && o.node.to <= i.node.to && (i = o);
    }
    for (let o = i; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && o.next)
        return Ae.range(a.to, a.from);
    }
    return r;
  });
  return n.eq(t.selection) ? !1 : (e(Li(t, n)), !0);
}, mOe = ({ state: t, dispatch: e }) => {
  let n = t.selection, r = null;
  return n.ranges.length > 1 ? r = Ae.create([n.main]) : n.main.empty || (r = Ae.create([Ae.cursor(n.main.head)])), r ? (e(Li(t, r)), !0) : !1;
};
function yp(t, e) {
  if (t.state.readOnly)
    return !1;
  let n = "delete.selection", { state: r } = t, s = r.changeByRange((i) => {
    let { from: o, to: a } = i;
    if (o == a) {
      let l = e(i);
      l < o ? (n = "delete.backward", l = jm(t, l, !1)) : l > o && (n = "delete.forward", l = jm(t, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = jm(t, o, !1), a = jm(t, a, !0);
    return o == a ? { range: i } : { changes: { from: o, to: a }, range: Ae.cursor(o, o < i.head ? -1 : 1) };
  });
  return s.changes.empty ? !1 : (t.dispatch(r.update(s, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? He.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function jm(t, e, n) {
  if (t instanceof He)
    for (let r of t.state.facet(He.atomicRanges).map((s) => s(t)))
      r.between(e, e, (s, i) => {
        s < e && i > e && (e = n ? i : s);
      });
  return e;
}
const oV = (t, e, n) => yp(t, (r) => {
  let s = r.from, { state: i } = t, o = i.doc.lineAt(s), a, l;
  if (n && !e && s > o.from && s < o.from + 200 && !/[^ \t]/.test(a = o.text.slice(0, s - o.from))) {
    if (a[a.length - 1] == "	")
      return s - 1;
    let c = Kb(a, i.tabSize), u = c % py(i) || py(i);
    for (let h = 0; h < u && a[a.length - 1 - h] == " "; h++)
      s--;
    l = s;
  } else
    l = An(o.text, s - o.from, e, e) + o.from, l == s && o.number != (e ? i.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(l - o.from, s - o.from)) && (l = An(o.text, l - o.from, !1, !1) + o.from);
  return l;
}), Px = (t) => oV(t, !1, !0), aV = (t) => oV(t, !0, !1), lV = (t, e) => yp(t, (n) => {
  let r = n.head, { state: s } = t, i = s.doc.lineAt(r), o = s.charCategorizer(r);
  for (let a = null; ; ) {
    if (r == (e ? i.to : i.from)) {
      r == n.head && i.number != (e ? s.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let l = An(i.text, r - i.from, e) + i.from, c = i.text.slice(Math.min(r, l) - i.from, Math.max(r, l) - i.from), u = o(c);
    if (a != null && u != a)
      break;
    (c != " " || r != n.head) && (a = u), r = l;
  }
  return r;
}), cV = (t) => lV(t, !1), gOe = (t) => lV(t, !0), yOe = (t) => yp(t, (e) => {
  let n = t.lineBlockAt(e.head).to;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), bOe = (t) => yp(t, (e) => {
  let n = t.moveToLineBoundary(e, !1).head;
  return e.head > n ? n : Math.max(0, e.head - 1);
}), _Oe = (t) => yp(t, (e) => {
  let n = t.moveToLineBoundary(e, !0).head;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), vOe = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: Et.of(["", ""]) },
    range: Ae.cursor(r.from)
  }));
  return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, wOe = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == t.doc.length)
      return { range: r };
    let s = r.from, i = t.doc.lineAt(s), o = s == i.from ? s - 1 : An(i.text, s - i.from, !1) + i.from, a = s == i.to ? s + 1 : An(i.text, s - i.from, !0) + i.from;
    return {
      changes: { from: o, to: a, insert: t.doc.slice(s, a).append(t.doc.slice(o, s)) },
      range: Ae.cursor(a)
    };
  });
  return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function i_(t) {
  let e = [], n = -1;
  for (let r of t.selection.ranges) {
    let s = t.doc.lineAt(r.from), i = t.doc.lineAt(r.to);
    if (!r.empty && r.to == i.from && (i = t.doc.lineAt(r.to - 1)), n >= s.number) {
      let o = e[e.length - 1];
      o.to = i.to, o.ranges.push(r);
    } else
      e.push({ from: s.from, to: i.to, ranges: [r] });
    n = i.number + 1;
  }
  return e;
}
function uV(t, e, n) {
  if (t.readOnly)
    return !1;
  let r = [], s = [];
  for (let i of i_(t)) {
    if (n ? i.to == t.doc.length : i.from == 0)
      continue;
    let o = t.doc.lineAt(n ? i.to + 1 : i.from - 1), a = o.length + 1;
    if (n) {
      r.push({ from: i.to, to: o.to }, { from: i.from, insert: o.text + t.lineBreak });
      for (let l of i.ranges)
        s.push(Ae.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
    } else {
      r.push({ from: o.from, to: i.from }, { from: i.to, insert: t.lineBreak + o.text });
      for (let l of i.ranges)
        s.push(Ae.range(l.anchor - a, l.head - a));
    }
  }
  return r.length ? (e(t.update({
    changes: r,
    scrollIntoView: !0,
    selection: Ae.create(s, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const EOe = ({ state: t, dispatch: e }) => uV(t, e, !1), SOe = ({ state: t, dispatch: e }) => uV(t, e, !0);
function hV(t, e, n) {
  if (t.readOnly)
    return !1;
  let r = [];
  for (let s of i_(t))
    n ? r.push({ from: s.from, insert: t.doc.slice(s.from, s.to) + t.lineBreak }) : r.push({ from: s.to, insert: t.lineBreak + t.doc.slice(s.from, s.to) });
  return e(t.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const xOe = ({ state: t, dispatch: e }) => hV(t, e, !1), TOe = ({ state: t, dispatch: e }) => hV(t, e, !0), COe = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, n = e.changes(i_(e).map(({ from: s, to: i }) => (s > 0 ? s-- : i < e.doc.length && i++, { from: s, to: i }))), r = Hu(e.selection, (s) => {
    let i;
    if (t.lineWrapping) {
      let o = t.lineBlockAt(s.head), a = t.coordsAtPos(s.head, s.assoc || 1);
      a && (i = o.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(s, !0, i);
  }).map(n);
  return t.dispatch({ changes: n, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function kOe(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let n = Pn(t).resolveInner(e), r = n.childBefore(e), s = n.childAfter(e), i;
  return r && s && r.to <= e && s.from >= e && (i = r.type.prop(ct.closedBy)) && i.indexOf(s.name) > -1 && t.doc.lineAt(r.to).from == t.doc.lineAt(s.from).from && !/\S/.test(t.sliceDoc(r.to, s.from)) ? { from: r.to, to: s.from } : null;
}
const nL = /* @__PURE__ */ dV(!1), AOe = /* @__PURE__ */ dV(!0);
function dV(t) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((s) => {
      let { from: i, to: o } = s, a = e.doc.lineAt(i), l = !t && i == o && kOe(e, i);
      t && (i = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new e_(e, { simulateBreak: i, simulateDoubleBreak: !!l }), u = hA(c, i);
      for (u == null && (u = Kb(/^\s*/.exec(e.doc.lineAt(i).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: i, to: o } = l : i > a.from && i < a.from + 100 && !/\S/.test(a.text.slice(0, i)) && (i = a.from);
      let h = ["", hf(e, u)];
      return l && h.push(hf(e, c.lineIndent(a.from, -1))), {
        changes: { from: i, to: o, insert: Et.of(h) },
        range: Ae.cursor(i + 1 + h[1].length)
      };
    });
    return n(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function xA(t, e) {
  let n = -1;
  return t.changeByRange((r) => {
    let s = [];
    for (let o = r.from; o <= r.to; ) {
      let a = t.doc.lineAt(o);
      a.number > n && (r.empty || r.to > a.from) && (e(a, s, r), n = a.number), o = a.to + 1;
    }
    let i = t.changes(s);
    return {
      changes: s,
      range: Ae.range(i.mapPos(r.anchor, 1), i.mapPos(r.head, 1))
    };
  });
}
const ROe = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), r = new e_(t, { overrideIndentation: (i) => {
    let o = n[i];
    return o ?? -1;
  } }), s = xA(t, (i, o, a) => {
    let l = hA(r, i.from);
    if (l == null)
      return;
    /\S/.test(i.text) || (l = 0);
    let c = /^\s*/.exec(i.text)[0], u = hf(t, l);
    (c != u || a.from < i.from + c.length) && (n[i.from] = l, o.push({ from: i.from, to: i.from + c.length, insert: u }));
  });
  return s.changes.empty || e(t.update(s, { userEvent: "indent" })), !0;
}, IOe = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(xA(t, (n, r) => {
  r.push({ from: n.from, insert: t.facet(Uu) });
}), { userEvent: "input.indent" })), !0), fV = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(xA(t, (n, r) => {
  let s = /^\s*/.exec(n.text)[0];
  if (!s)
    return;
  let i = Kb(s, t.tabSize), o = 0, a = hf(t, Math.max(0, i - py(t)));
  for (; o < s.length && o < a.length && s.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  r.push({ from: n.from + o, to: n.from + s.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), POe = (t) => (t.setTabFocusMode(), !0), OOe = [
  { key: "Ctrl-b", run: GG, shift: QG, preventDefault: !0 },
  { key: "Ctrl-f", run: VG, shift: eV },
  { key: "Ctrl-p", run: KG, shift: rV },
  { key: "Ctrl-n", run: YG, shift: sV },
  { key: "Ctrl-a", run: XPe, shift: uOe },
  { key: "Ctrl-e", run: QPe, shift: hOe },
  { key: "Ctrl-d", run: aV },
  { key: "Ctrl-h", run: Px },
  { key: "Ctrl-k", run: yOe },
  { key: "Ctrl-Alt-h", run: cV },
  { key: "Ctrl-o", run: vOe },
  { key: "Ctrl-t", run: wOe },
  { key: "Ctrl-v", run: Ix }
], DOe = /* @__PURE__ */ [
  { key: "ArrowLeft", run: GG, shift: QG, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: zPe, shift: nOe, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: ZPe, shift: lOe, preventDefault: !0 },
  { key: "ArrowRight", run: VG, shift: eV, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: GPe, shift: rOe, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: JPe, shift: cOe, preventDefault: !0 },
  { key: "ArrowUp", run: KG, shift: rV, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: XN, shift: eL },
  { mac: "Ctrl-ArrowUp", run: YN, shift: ZN },
  { key: "ArrowDown", run: YG, shift: sV, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: QN, shift: tL },
  { mac: "Ctrl-ArrowDown", run: Ix, shift: JN },
  { key: "PageUp", run: YN, shift: ZN },
  { key: "PageDown", run: Ix, shift: JN },
  { key: "Home", run: YPe, shift: aOe, preventDefault: !0 },
  { key: "Mod-Home", run: XN, shift: eL },
  { key: "End", run: KPe, shift: oOe, preventDefault: !0 },
  { key: "Mod-End", run: QN, shift: tL },
  { key: "Enter", run: nL, shift: nL },
  { key: "Mod-a", run: dOe },
  { key: "Backspace", run: Px, shift: Px },
  { key: "Delete", run: aV },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: cV },
  { key: "Mod-Delete", mac: "Alt-Delete", run: gOe },
  { mac: "Mod-Backspace", run: bOe },
  { mac: "Mod-Delete", run: _Oe }
].concat(/* @__PURE__ */ OOe.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), NOe = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: WPe, shift: sOe },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: qPe, shift: iOe },
  { key: "Alt-ArrowUp", run: EOe },
  { key: "Shift-Alt-ArrowUp", run: xOe },
  { key: "Alt-ArrowDown", run: SOe },
  { key: "Shift-Alt-ArrowDown", run: TOe },
  { key: "Escape", run: mOe },
  { key: "Mod-Enter", run: AOe },
  { key: "Alt-l", mac: "Ctrl-l", run: fOe },
  { key: "Mod-i", run: pOe, preventDefault: !0 },
  { key: "Mod-[", run: fV },
  { key: "Mod-]", run: IOe },
  { key: "Mod-Alt-\\", run: ROe },
  { key: "Shift-Mod-k", run: COe },
  { key: "Shift-Mod-\\", run: tOe },
  { key: "Mod-/", run: xPe },
  { key: "Alt-A", run: CPe },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: POe }
].concat(DOe);
function Ln() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n) if (Object.prototype.hasOwnProperty.call(n, r)) {
      var s = n[r];
      typeof s == "string" ? t.setAttribute(r, s) : s != null && (t[r] = s);
    }
    e++;
  }
  for (; e < arguments.length; e++) pV(t, arguments[e]);
  return t;
}
function pV(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    t.appendChild(e);
  else if (Array.isArray(e))
    for (var n = 0; n < e.length; n++) pV(t, e[n]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
const rL = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class pf {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, n, r = 0, s = e.length, i, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, s), this.bufferStart = r, this.normalize = i ? (a) => i(rL(a)) : rL, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return ms(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let n = Kk(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += Qi(e);
      let s = this.normalize(n);
      if (s.length)
        for (let i = 0, o = r; ; i++) {
          let a = s.charCodeAt(i), l = this.match(a, o, this.bufferPos + this.bufferStart);
          if (i == s.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          o == r && i < n.length && n.charCodeAt(i) == a && o++;
        }
    }
  }
  match(e, n, r) {
    let s = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let o = this.matches[i], a = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? s = { from: this.matches[i + 1], to: r } : (this.matches[i]++, a = !0)), a || (this.matches.splice(i, 2), i -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? s = { from: n, to: r } : this.matches.push(1, n)), s && this.test && !this.test(s.from, s.to, this.buffer, this.bufferStart) && (s = null), s;
  }
}
typeof Symbol < "u" && (pf.prototype[Symbol.iterator] = function() {
  return this;
});
const mV = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, TA = "gm" + (/x/.unicode == null ? "" : "u");
class gV {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, n, r, s = 0, i = e.length) {
    if (this.text = e, this.to = i, this.curLine = "", this.done = !1, this.value = mV, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new yV(e, n, r, s, i);
    this.re = new RegExp(n, TA + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.iter = e.iter();
    let o = e.lineAt(s);
    this.curLineStart = o.from, this.matchPos = vy(e, s), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let r = this.curLineStart + n.index, s = r + n[0].length;
        if (this.matchPos = vy(this.text, s + (r == s ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < s || r > this.value.to) && (!this.test || this.test(r, s, n)))
          return this.value = { from: r, to: s, match: n }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Ew = /* @__PURE__ */ new WeakMap();
class $c {
  constructor(e, n) {
    this.from = e, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, r) {
    let s = Ew.get(e);
    if (!s || s.from >= r || s.to <= n) {
      let a = new $c(n, e.sliceString(n, r));
      return Ew.set(e, a), a;
    }
    if (s.from == n && s.to == r)
      return s;
    let { text: i, from: o } = s;
    return o > n && (i = e.sliceString(n, o) + i, o = n), s.to < r && (i += e.sliceString(s.to, r)), Ew.set(e, new $c(o, i)), new $c(n, i.slice(n - o, r - o));
  }
}
class yV {
  constructor(e, n, r, s, i) {
    this.text = e, this.to = i, this.done = !1, this.value = mV, this.matchPos = vy(e, s), this.re = new RegExp(n, TA + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.flat = $c.get(e, s, this.chunkEnd(
      s + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
        let r = this.flat.from + n.index, s = r + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, s, n)))
          return this.value = { from: r, to: s, match: n }, this.matchPos = vy(this.text, s + (r == s ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = $c.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (gV.prototype[Symbol.iterator] = yV.prototype[Symbol.iterator] = function() {
  return this;
});
function LOe(t) {
  try {
    return new RegExp(t, TA), !0;
  } catch {
    return !1;
  }
}
function vy(t, e) {
  if (e >= t.length)
    return e;
  let n = t.lineAt(e), r;
  for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function Ox(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = Ln("input", { class: "cm-textfield", name: "line", value: e }), r = Ln("form", {
    class: "cm-gotoLine",
    onkeydown: (i) => {
      i.keyCode == 27 ? (i.preventDefault(), t.dispatch({ effects: wy.of(!1) }), t.focus()) : i.keyCode == 13 && (i.preventDefault(), s());
    },
    onsubmit: (i) => {
      i.preventDefault(), s();
    }
  }, Ln("label", t.state.phrase("Go to line"), ": ", n), " ", Ln("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function s() {
    let i = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!i)
      return;
    let { state: o } = t, a = o.doc.lineAt(o.selection.main.head), [, l, c, u, h] = i, d = u ? +u.slice(1) : 0, f = c ? +c : a.number;
    if (c && h) {
      let p = f / 100;
      l && (p = p * (l == "-" ? -1 : 1) + a.number / o.doc.lines), f = Math.round(o.doc.lines * p);
    } else c && l && (f = f * (l == "-" ? -1 : 1) + a.number);
    let g = o.doc.line(Math.max(1, Math.min(o.doc.lines, f))), y = Ae.cursor(g.from + Math.max(0, Math.min(d, g.length)));
    t.dispatch({
      effects: [wy.of(!1), He.scrollIntoView(y.from, { y: "center" })],
      selection: y
    }), t.focus();
  }
  return { dom: r };
}
const wy = /* @__PURE__ */ at.define(), sL = /* @__PURE__ */ En.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(wy) && (t = n.value);
    return t;
  },
  provide: (t) => cy.from(t, (e) => e ? Ox : null)
}), MOe = (t) => {
  let e = ly(t, Ox);
  if (!e) {
    let n = [wy.of(!0)];
    t.state.field(sL, !1) == null && n.push(at.appendConfig.of([sL, BOe])), t.dispatch({ effects: n }), e = ly(t, Ox);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, BOe = /* @__PURE__ */ He.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), FOe = ({ state: t, dispatch: e }) => {
  let { selection: n } = t, r = Ae.create(n.ranges.map((s) => t.wordAt(s.head) || Ae.cursor(s.head)), n.mainIndex);
  return r.eq(n) ? !1 : (e(t.update({ selection: r })), !0);
};
function $Oe(t, e) {
  let { main: n, ranges: r } = t.selection, s = t.wordAt(n.head), i = s && s.from == n.from && s.to == n.to;
  for (let o = !1, a = new pf(t.doc, e, r[r.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new pf(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((l) => l.from == a.value.from))
        continue;
      if (i) {
        let l = t.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const UOe = ({ state: t, dispatch: e }) => {
  let { ranges: n } = t.selection;
  if (n.some((i) => i.from === i.to))
    return FOe({ state: t, dispatch: e });
  let r = t.sliceDoc(n[0].from, n[0].to);
  if (t.selection.ranges.some((i) => t.sliceDoc(i.from, i.to) != r))
    return !1;
  let s = $Oe(t, r);
  return s ? (e(t.update({
    selection: t.selection.addRange(Ae.range(s.from, s.to), !1),
    effects: He.scrollIntoView(s.to)
  })), !0) : !1;
}, zu = /* @__PURE__ */ ze.define({
  combine(t) {
    return $l(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new XOe(e),
      scrollToMatch: (e) => He.scrollIntoView(e)
    });
  }
});
class bV {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || LOe(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new GOe(this) : new HOe(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, n = 0, r) {
    let s = e.doc ? e : pt.create({ doc: e });
    return r == null && (r = s.doc.length), this.regexp ? lc(this, s, n, r) : ac(this, s, n, r);
  }
}
class _V {
  constructor(e) {
    this.spec = e;
  }
}
function ac(t, e, n, r) {
  return new pf(e.doc, t.unquoted, n, r, t.caseSensitive ? void 0 : (s) => s.toLowerCase(), t.wholeWord ? jOe(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function jOe(t, e) {
  return (n, r, s, i) => ((i > n || i + s.length < r) && (i = Math.max(0, n - 2), s = t.sliceString(i, Math.min(t.length, r + 2))), (e(Ey(s, n - i)) != on.Word || e(Sy(s, n - i)) != on.Word) && (e(Sy(s, r - i)) != on.Word || e(Ey(s, r - i)) != on.Word));
}
class HOe extends _V {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, r) {
    let s = ac(this.spec, e, r, e.doc.length).nextOverlapping();
    if (s.done) {
      let i = Math.min(e.doc.length, n + this.spec.unquoted.length);
      s = ac(this.spec, e, 0, i).nextOverlapping();
    }
    return s.done || s.value.from == n && s.value.to == r ? null : s.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, n, r) {
    for (let s = r; ; ) {
      let i = Math.max(n, s - 1e4 - this.spec.unquoted.length), o = ac(this.spec, e, i, s), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (i == n)
        return null;
      s -= 1e4;
    }
  }
  prevMatch(e, n, r) {
    let s = this.prevMatchInRange(e, 0, n);
    return s || (s = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), s && (s.from != n || s.to != r) ? s : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let r = ac(this.spec, e, 0, e.doc.length), s = [];
    for (; !r.next().done; ) {
      if (s.length >= n)
        return null;
      s.push(r.value);
    }
    return s;
  }
  highlight(e, n, r, s) {
    let i = ac(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !i.next().done; )
      s(i.value.from, i.value.to);
  }
}
function lc(t, e, n, r) {
  return new gV(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? zOe(e.charCategorizer(e.selection.main.head)) : void 0
  }, n, r);
}
function Ey(t, e) {
  return t.slice(An(t, e, !1), e);
}
function Sy(t, e) {
  return t.slice(e, An(t, e));
}
function zOe(t) {
  return (e, n, r) => !r[0].length || (t(Ey(r.input, r.index)) != on.Word || t(Sy(r.input, r.index)) != on.Word) && (t(Sy(r.input, r.index + r[0].length)) != on.Word || t(Ey(r.input, r.index + r[0].length)) != on.Word);
}
class GOe extends _V {
  nextMatch(e, n, r) {
    let s = lc(this.spec, e, r, e.doc.length).next();
    return s.done && (s = lc(this.spec, e, 0, n).next()), s.done ? null : s.value;
  }
  prevMatchInRange(e, n, r) {
    for (let s = 1; ; s++) {
      let i = Math.max(
        n,
        r - s * 1e4
        /* FindPrev.ChunkSize */
      ), o = lc(this.spec, e, i, r), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (i == n || a.from > i + 10))
        return a;
      if (i == n)
        return null;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, r) => r == "$" ? "$" : r == "&" ? e.match[0] : r != "0" && +r < e.match.length ? e.match[r] : n);
  }
  matchAll(e, n) {
    let r = lc(this.spec, e, 0, e.doc.length), s = [];
    for (; !r.next().done; ) {
      if (s.length >= n)
        return null;
      s.push(r.value);
    }
    return s;
  }
  highlight(e, n, r, s) {
    let i = lc(this.spec, e, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !i.next().done; )
      s(i.value.from, i.value.to);
  }
}
const mf = /* @__PURE__ */ at.define(), CA = /* @__PURE__ */ at.define(), Ko = /* @__PURE__ */ En.define({
  create(t) {
    return new Sw(Dx(t).create(), null);
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(mf) ? t = new Sw(n.value.create(), t.panel) : n.is(CA) && (t = new Sw(t.query, n.value ? kA : null));
    return t;
  },
  provide: (t) => cy.from(t, (e) => e.panel)
});
class Sw {
  constructor(e, n) {
    this.query = e, this.panel = n;
  }
}
const VOe = /* @__PURE__ */ yt.mark({ class: "cm-searchMatch" }), WOe = /* @__PURE__ */ yt.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), qOe = /* @__PURE__ */ In.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Ko));
  }
  update(t) {
    let e = t.state.field(Ko);
    (e != t.startState.field(Ko) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return yt.none;
    let { view: n } = this, r = new wl();
    for (let s = 0, i = n.visibleRanges, o = i.length; s < o; s++) {
      let { from: a, to: l } = i[s];
      for (; s < o - 1 && l > i[s + 1].from - 2 * 250; )
        l = i[++s].to;
      t.highlight(n.state, a, l, (c, u) => {
        let h = n.state.selection.ranges.some((d) => d.from == c && d.to == u);
        r.add(c, u, h ? WOe : VOe);
      });
    }
    return r.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function bp(t) {
  return (e) => {
    let n = e.state.field(Ko, !1);
    return n && n.query.spec.valid ? t(e, n) : EV(e);
  };
}
const xy = /* @__PURE__ */ bp((t, { query: e }) => {
  let { to: n } = t.state.selection.main, r = e.nextMatch(t.state, n, n);
  if (!r)
    return !1;
  let s = Ae.single(r.from, r.to), i = t.state.facet(zu);
  return t.dispatch({
    selection: s,
    effects: [AA(t, r), i.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), wV(t), !0;
}), Ty = /* @__PURE__ */ bp((t, { query: e }) => {
  let { state: n } = t, { from: r } = n.selection.main, s = e.prevMatch(n, r, r);
  if (!s)
    return !1;
  let i = Ae.single(s.from, s.to), o = t.state.facet(zu);
  return t.dispatch({
    selection: i,
    effects: [AA(t, s), o.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), wV(t), !0;
}), KOe = /* @__PURE__ */ bp((t, { query: e }) => {
  let n = e.matchAll(t.state, 1e3);
  return !n || !n.length ? !1 : (t.dispatch({
    selection: Ae.create(n.map((r) => Ae.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), YOe = ({ state: t, dispatch: e }) => {
  let n = t.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: r, to: s } = n.main, i = [], o = 0;
  for (let a = new pf(t.doc, t.sliceDoc(r, s)); !a.next().done; ) {
    if (i.length > 1e3)
      return !1;
    a.value.from == r && (o = i.length), i.push(Ae.range(a.value.from, a.value.to));
  }
  return e(t.update({
    selection: Ae.create(i, o),
    userEvent: "select.search.matches"
  })), !0;
}, iL = /* @__PURE__ */ bp((t, { query: e }) => {
  let { state: n } = t, { from: r, to: s } = n.selection.main;
  if (n.readOnly)
    return !1;
  let i = e.nextMatch(n, r, r);
  if (!i)
    return !1;
  let o = i, a = [], l, c, u = [];
  if (o.from == r && o.to == s && (c = n.toText(e.getReplacement(o)), a.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(n, o.from, o.to), u.push(He.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + "."))), o) {
    let h = a.length == 0 || a[0].from >= i.to ? 0 : i.to - i.from - c.length;
    l = Ae.single(o.from - h, o.to - h), u.push(AA(t, o)), u.push(n.facet(zu).scrollToMatch(l.main, t));
  }
  return t.dispatch({
    changes: a,
    selection: l,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), ZOe = /* @__PURE__ */ bp((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let n = e.matchAll(t.state, 1e9).map((s) => {
    let { from: i, to: o } = s;
    return { from: i, to: o, insert: e.getReplacement(s) };
  });
  if (!n.length)
    return !1;
  let r = t.state.phrase("replaced $ matches", n.length) + ".";
  return t.dispatch({
    changes: n,
    effects: He.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function kA(t) {
  return t.state.facet(zu).createPanel(t);
}
function Dx(t, e) {
  var n, r, s, i, o;
  let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = t.facet(zu);
  return new bV({
    search: ((n = e?.literal) !== null && n !== void 0 ? n : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (s = e?.literal) !== null && s !== void 0 ? s : c.literal,
    regexp: (i = e?.regexp) !== null && i !== void 0 ? i : c.regexp,
    wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function vV(t) {
  let e = ly(t, kA);
  return e && e.dom.querySelector("[main-field]");
}
function wV(t) {
  let e = vV(t);
  e && e == t.root.activeElement && e.select();
}
const EV = (t) => {
  let e = t.state.field(Ko, !1);
  if (e && e.panel) {
    let n = vV(t);
    if (n && n != t.root.activeElement) {
      let r = Dx(t.state, e.query.spec);
      r.valid && t.dispatch({ effects: mf.of(r) }), n.focus(), n.select();
    }
  } else
    t.dispatch({ effects: [
      CA.of(!0),
      e ? mf.of(Dx(t.state, e.query.spec)) : at.appendConfig.of(eDe)
    ] });
  return !0;
}, SV = (t) => {
  let e = t.state.field(Ko, !1);
  if (!e || !e.panel)
    return !1;
  let n = ly(t, kA);
  return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: CA.of(!1) }), !0;
}, JOe = [
  { key: "Mod-f", run: EV, scope: "editor search-panel" },
  { key: "F3", run: xy, shift: Ty, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: xy, shift: Ty, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: SV, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: YOe },
  { key: "Mod-Alt-g", run: MOe },
  { key: "Mod-d", run: UOe, preventDefault: !0 }
];
class XOe {
  constructor(e) {
    this.view = e;
    let n = this.query = e.state.field(Ko).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Ln("input", {
      value: n.search,
      placeholder: xr(e, "Find"),
      "aria-label": xr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Ln("input", {
      value: n.replace,
      placeholder: xr(e, "Replace"),
      "aria-label": xr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Ln("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = Ln("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = Ln("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function r(s, i, o) {
      return Ln("button", { class: "cm-button", name: s, onclick: i, type: "button" }, o);
    }
    this.dom = Ln("div", { onkeydown: (s) => this.keydown(s), class: "cm-search" }, [
      this.searchField,
      r("next", () => xy(e), [xr(e, "next")]),
      r("prev", () => Ty(e), [xr(e, "previous")]),
      r("select", () => KOe(e), [xr(e, "all")]),
      Ln("label", null, [this.caseField, xr(e, "match case")]),
      Ln("label", null, [this.reField, xr(e, "regexp")]),
      Ln("label", null, [this.wordField, xr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Ln("br"),
        this.replaceField,
        r("replace", () => iL(e), [xr(e, "replace")]),
        r("replaceAll", () => ZOe(e), [xr(e, "replace all")])
      ],
      Ln("button", {
        name: "close",
        onclick: () => SV(e),
        "aria-label": xr(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new bV({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: mf.of(e) }));
  }
  keydown(e) {
    B2e(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Ty : xy)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), iL(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let r of n.effects)
        r.is(mf) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(zu).top;
  }
}
function xr(t, e) {
  return t.state.phrase(e);
}
const Hm = 30, zm = /[\s\.,:;?!]/;
function AA(t, { from: e, to: n }) {
  let r = t.state.doc.lineAt(e), s = t.state.doc.lineAt(n).to, i = Math.max(r.from, e - Hm), o = Math.min(s, n + Hm), a = t.state.sliceDoc(i, o);
  if (i != r.from) {
    for (let l = 0; l < Hm; l++)
      if (!zm.test(a[l + 1]) && zm.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != s) {
    for (let l = a.length - 1; l > a.length - Hm; l--)
      if (!zm.test(a[l - 1]) && zm.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return He.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${r.number}.`);
}
const QOe = /* @__PURE__ */ He.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), eDe = [
  Ko,
  /* @__PURE__ */ _a.low(qOe),
  QOe
];
function tDe() {
  return /* @__PURE__ */ k.jsx("div", { className: "flex items-center justify-center absolute inset-0 z-10 text-sm bg-tk-elements-app-backgroundColor text-tk-elements-app-textColor", children: "File format cannot be displayed." });
}
function Cy() {
  return Cy = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Cy.apply(null, arguments);
}
var xV = (t) => {
  var {
    theme: e,
    settings: n = {},
    styles: r = []
  } = t, s = {
    ".cm-gutters": {}
  }, i = {};
  n.background && (i.backgroundColor = n.background), n.backgroundImage && (i.backgroundImage = n.backgroundImage), n.foreground && (i.color = n.foreground), n.fontSize && (i.fontSize = n.fontSize), (n.background || n.foreground) && (s["&"] = i), n.fontFamily && (s["&.cm-editor .cm-scroller"] = {
    fontFamily: n.fontFamily
  }), n.gutterBackground && (s[".cm-gutters"].backgroundColor = n.gutterBackground), n.gutterForeground && (s[".cm-gutters"].color = n.gutterForeground), n.gutterBorder && (s[".cm-gutters"].borderRightColor = n.gutterBorder), n.caret && (s[".cm-content"] = {
    caretColor: n.caret
  }, s[".cm-cursor, .cm-dropCursor"] = {
    borderLeftColor: n.caret
  });
  var o = {};
  n.gutterActiveForeground && (o.color = n.gutterActiveForeground), n.lineHighlight && (s[".cm-activeLine"] = {
    backgroundColor: n.lineHighlight
  }, o.backgroundColor = n.lineHighlight), s[".cm-activeLineGutter"] = o, n.selection && (s["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
    background: n.selection + " !important"
  }), n.selectionMatch && (s["& .cm-selectionMatch"] = {
    backgroundColor: n.selectionMatch
  });
  var a = He.theme(s, {
    dark: e === "dark"
  }), l = t_.define(r), c = [a, fIe(l)];
  return c;
}, nDe = {
  background: "#ffffff",
  foreground: "#383a42",
  caret: "#000",
  selection: "#add6ff",
  selectionMatch: "#a8ac94",
  lineHighlight: "#99999926",
  gutterBackground: "#fff",
  gutterForeground: "#237893",
  gutterActiveForeground: "#0b216f",
  fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace'
}, rDe = [{
  tag: [me.keyword, me.operatorKeyword, me.modifier, me.color, me.constant(me.name), me.standard(me.name), me.standard(me.tagName), me.special(me.brace), me.atom, me.bool, me.special(me.variableName)],
  color: "#0000ff"
}, {
  tag: [me.moduleKeyword, me.controlKeyword],
  color: "#af00db"
}, {
  tag: [me.name, me.deleted, me.character, me.macroName, me.propertyName, me.variableName, me.labelName, me.definition(me.name)],
  color: "#0070c1"
}, {
  tag: me.heading,
  fontWeight: "bold",
  color: "#0070c1"
}, {
  tag: [me.typeName, me.className, me.tagName, me.number, me.changed, me.annotation, me.self, me.namespace],
  color: "#267f99"
}, {
  tag: [me.function(me.variableName), me.function(me.propertyName)],
  color: "#795e26"
}, {
  tag: [me.number],
  color: "#098658"
}, {
  tag: [me.operator, me.punctuation, me.separator, me.url, me.escape, me.regexp],
  color: "#383a42"
}, {
  tag: [me.regexp],
  color: "#af00db"
}, {
  tag: [me.special(me.string), me.processingInstruction, me.string, me.inserted],
  color: "#a31515"
}, {
  tag: [me.angleBracket],
  color: "#383a42"
}, {
  tag: me.strong,
  fontWeight: "bold"
}, {
  tag: me.emphasis,
  fontStyle: "italic"
}, {
  tag: me.strikethrough,
  textDecoration: "line-through"
}, {
  tag: [me.meta, me.comment],
  color: "#008000"
}, {
  tag: me.link,
  color: "#4078f2",
  textDecoration: "underline"
}, {
  tag: me.invalid,
  color: "#e45649"
}];
function sDe(t) {
  var {
    theme: e = "light",
    settings: n = {},
    styles: r = []
  } = {};
  return xV({
    theme: e,
    settings: Cy({}, nDe, n),
    styles: [...rDe, ...r]
  });
}
var iDe = sDe(), oDe = {
  background: "#1e1e1e",
  foreground: "#9cdcfe",
  caret: "#c6c6c6",
  selection: "#6199ff2f",
  selectionMatch: "#72a1ff59",
  lineHighlight: "#ffffff0f",
  gutterBackground: "#1e1e1e",
  gutterForeground: "#838383",
  gutterActiveForeground: "#fff",
  fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace'
}, aDe = [{
  tag: [me.keyword, me.operatorKeyword, me.modifier, me.color, me.constant(me.name), me.standard(me.name), me.standard(me.tagName), me.special(me.brace), me.atom, me.bool, me.special(me.variableName)],
  color: "#569cd6"
}, {
  tag: [me.controlKeyword, me.moduleKeyword],
  color: "#c586c0"
}, {
  tag: [me.name, me.deleted, me.character, me.macroName, me.propertyName, me.variableName, me.labelName, me.definition(me.name)],
  color: "#9cdcfe"
}, {
  tag: me.heading,
  fontWeight: "bold",
  color: "#9cdcfe"
}, {
  tag: [me.typeName, me.className, me.tagName, me.number, me.changed, me.annotation, me.self, me.namespace],
  color: "#4ec9b0"
}, {
  tag: [me.function(me.variableName), me.function(me.propertyName)],
  color: "#dcdcaa"
}, {
  tag: [me.number],
  color: "#b5cea8"
}, {
  tag: [me.operator, me.punctuation, me.separator, me.url, me.escape, me.regexp],
  color: "#d4d4d4"
}, {
  tag: [me.regexp],
  color: "#d16969"
}, {
  tag: [me.special(me.string), me.processingInstruction, me.string, me.inserted],
  color: "#ce9178"
}, {
  tag: [me.angleBracket],
  color: "#808080"
}, {
  tag: me.strong,
  fontWeight: "bold"
}, {
  tag: me.emphasis,
  fontStyle: "italic"
}, {
  tag: me.strikethrough,
  textDecoration: "line-through"
}, {
  tag: [me.meta, me.comment],
  color: "#6a9955"
}, {
  tag: me.link,
  color: "#6a9955",
  textDecoration: "underline"
}, {
  tag: me.invalid,
  color: "#ff0000"
}];
function lDe(t) {
  var {
    theme: e = "dark",
    settings: n = {},
    styles: r = []
  } = {};
  return xV({
    theme: e,
    settings: Cy({}, oDe, n),
    styles: [...aDe, ...r]
  });
}
var cDe = lDe();
He.theme({}, { dark: !0 });
const Nx = new Fu();
function uDe(t, e = {}) {
  return [
    hDe(e),
    t === "dark" ? Nx.of([kV()]) : Nx.of([CV()])
  ];
}
function TV(t) {
  return Nx.reconfigure(t === "dark" ? kV() : CV());
}
function hDe(t) {
  return He.theme({
    "&": {
      fontSize: t.fontSize ?? "12px"
    },
    "&.cm-editor": {
      height: "100%",
      background: "var(--cm-backgroundColor)",
      color: "var(--cm-textColor)"
    },
    ".cm-cursor": {
      borderLeft: "var(--cm-cursor-width) solid var(--cm-cursor-backgroundColor)"
    },
    ".cm-scroller": {
      lineHeight: "1.5",
      "&:focus-visible": {
        outline: "none"
      }
    },
    ".cm-line": {
      padding: "0 0 0 4px"
    },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      backgroundColor: "var(--cm-selection-backgroundColorFocused) !important",
      opacity: "var(--cm-selection-backgroundOpacityFocused, 0.3)"
    },
    "&:not(.cm-focused) > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      backgroundColor: "var(--cm-selection-backgroundColorBlured)",
      opacity: "var(--cm-selection-backgroundOpacityBlured, 0.3)"
    },
    "&.cm-focused > .cm-scroller .cm-matchingBracket": {
      backgroundColor: "var(--cm-matching-bracket)"
    },
    ".cm-activeLine": {
      background: "var(--cm-activeLineBackgroundColor)"
    },
    ".cm-gutters": {
      background: "var(--cm-gutter-backgroundColor)",
      borderRight: 0,
      color: "var(--cm-gutter-textColor)"
    },
    ".cm-gutter": {
      "&.cm-lineNumbers": {
        fontFamily: "Roboto Mono, monospace",
        fontSize: t.gutterFontSize ?? t.fontSize ?? "12px",
        minWidth: "40px"
      },
      "& .cm-activeLineGutter": {
        background: "transparent",
        color: "var(--cm-gutter-activeLineTextColor)"
      },
      "&.cm-foldGutter .cm-gutterElement > .fold-icon": {
        cursor: "pointer",
        color: "var(--cm-foldGutter-textColor)",
        transform: "translateY(2px)",
        "&:hover": {
          color: "var(--cm-foldGutter-textColorHover)"
        }
      }
    },
    ".cm-foldGutter .cm-gutterElement": {
      padding: "0 4px"
    },
    ".cm-tooltip-autocomplete > ul > li": {
      minHeight: "18px"
    },
    ".cm-panel.cm-search label": {
      marginLeft: "2px",
      fontSize: "12px"
    },
    ".cm-panel.cm-search .cm-button": {
      fontSize: "12px"
    },
    ".cm-panel.cm-search .cm-textfield": {
      fontSize: "12px"
    },
    ".cm-panel.cm-search input[type=checkbox]": {
      position: "relative",
      transform: "translateY(2px)",
      marginRight: "4px"
    },
    ".cm-panels": {
      borderColor: "var(--cm-panels-borderColor)"
    },
    ".cm-panels-bottom": {
      borderTop: "1px solid var(--cm-panels-borderColor)",
      backgroundColor: "transparent"
    },
    ".cm-panel.cm-search": {
      background: "var(--cm-search-backgroundColor)",
      color: "var(--cm-search-textColor)",
      padding: "8px"
    },
    ".cm-search .cm-button": {
      background: "var(--cm-search-button-backgroundColor)",
      borderColor: "var(--cm-search-button-borderColor)",
      color: "var(--cm-search-button-textColor)",
      borderRadius: "4px",
      "&:hover": {
        color: "var(--cm-search-button-textColorHover)"
      },
      "&:focus-visible": {
        outline: "none",
        borderColor: "var(--cm-search-button-borderColorFocused)"
      },
      "&:hover:not(:focus-visible)": {
        background: "var(--cm-search-button-backgroundColorHover)",
        borderColor: "var(--cm-search-button-borderColorHover)"
      },
      "&:hover:focus-visible": {
        background: "var(--cm-search-button-backgroundColorHover)",
        borderColor: "var(--cm-search-button-borderColorFocused)"
      }
    },
    ".cm-panel.cm-search [name=close]": {
      top: "6px",
      right: "6px",
      padding: "0 6px",
      fontSize: "1rem",
      backgroundColor: "var(--cm-search-closeButton-backgroundColor)",
      color: "var(--cm-search-closeButton-textColor)",
      "&:hover": {
        "border-radius": "6px",
        color: "var(--cm-search-closeButton-textColorHover)",
        backgroundColor: "var(--cm-search-closeButton-backgroundColorHover)"
      }
    },
    ".cm-search input": {
      background: "var(--cm-search-input-backgroundColor)",
      borderColor: "var(--cm-search-input-borderColor)",
      color: "var(--cm-search-input-textColor)",
      outline: "none",
      borderRadius: "4px",
      "&:focus-visible": {
        borderColor: "var(--cm-search-input-borderColorFocused)"
      }
    },
    ".cm-tooltip": {
      background: "var(--cm-tooltip-backgroundColor)",
      border: "1px solid transparent",
      borderColor: "var(--cm-tooltip-borderColor)",
      color: "var(--cm-tooltip-textColor)"
    },
    ".cm-tooltip.cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "var(--cm-tooltip-backgroundColorSelected)",
      color: "var(--cm-tooltip-textColorSelected)"
    },
    ".cm-searchMatch": {
      backgroundColor: "var(--cm-searchMatch-backgroundColor)"
    },
    ".cm-tooltip.cm-readonly-tooltip": {
      padding: "4px",
      whiteSpace: "nowrap",
      backgroundColor: "var(--bolt-elements-bg-depth-2)",
      borderColor: "var(--bolt-elements-borderColorActive)",
      "& .cm-tooltip-arrow:before": {
        borderTopColor: "var(--bolt-elements-borderColorActive)"
      },
      "& .cm-tooltip-arrow:after": {
        borderTopColor: "transparent"
      }
    }
  });
}
function CV() {
  return iDe;
}
function kV() {
  return cDe;
}
const dDe = {
  key: "Tab",
  run: fDe,
  shift: fV
};
function fDe({ state: t, dispatch: e }) {
  return t.readOnly ? !1 : (e(
    t.update(
      pDe(t, (n, r, s) => {
        s.push({ from: n, to: r, insert: t.facet(Uu) });
      }),
      { userEvent: "input.indent" }
    )
  ), !0);
}
function pDe(t, e) {
  return t.changeByRange((n) => {
    const r = [], s = t.doc.lineAt(n.from);
    if (n.from === n.to)
      e(n.from, void 0, r, s);
    else if (n.from < n.to && n.to <= s.to)
      e(n.from, n.to, r, s);
    else {
      let o = -1;
      for (let a = n.from; a <= n.to; ) {
        const l = t.doc.lineAt(a);
        l.number > o && (n.empty || n.to > l.from) && (e(l.from, void 0, r, l), o = l.number), a = l.to + 1;
      }
    }
    const i = t.changes(r);
    return {
      changes: r,
      range: Ae.range(i.mapPos(n.anchor, 1), i.mapPos(n.head, 1))
    };
  });
}
const mDe = [
  xn.of({
    name: "VUE",
    extensions: ["vue"],
    async load() {
      return import("./index-BK76OM5y.js").then((t) => t.vue());
    }
  }),
  xn.of({
    name: "TS",
    extensions: ["ts"],
    async load() {
      return import("./index-8qjcNtaV.js").then((t) => t.javascript({ typescript: !0 }));
    }
  }),
  xn.of({
    name: "JS",
    extensions: ["js", "mjs", "cjs"],
    async load() {
      return import("./index-8qjcNtaV.js").then((t) => t.javascript());
    }
  }),
  xn.of({
    name: "TSX",
    extensions: ["tsx"],
    async load() {
      return import("./index-8qjcNtaV.js").then((t) => t.javascript({ jsx: !0, typescript: !0 }));
    }
  }),
  xn.of({
    name: "JSX",
    extensions: ["jsx"],
    async load() {
      return import("./index-8qjcNtaV.js").then((t) => t.javascript({ jsx: !0 }));
    }
  }),
  xn.of({
    name: "HTML",
    extensions: ["html"],
    async load() {
      return import("./index-B2tqdPhD.js").then((t) => t.html());
    }
  }),
  xn.of({
    name: "CSS",
    extensions: ["css"],
    async load() {
      return import("./index-CMVEj-k-.js").then((t) => t.css());
    }
  }),
  xn.of({
    name: "SASS",
    extensions: ["sass"],
    async load() {
      return import("./index-LLfffX6N.js").then((t) => t.sass({ indented: !0 }));
    }
  }),
  xn.of({
    name: "SCSS",
    extensions: ["scss"],
    async load() {
      return import("./index-LLfffX6N.js").then((t) => t.sass({ indented: !1 }));
    }
  }),
  xn.of({
    name: "JSON",
    extensions: ["json"],
    async load() {
      return import("./index-Br_GH5QF.js").then((t) => t.json());
    }
  }),
  xn.of({
    name: "Markdown",
    extensions: ["md"],
    async load() {
      return import("./index-GSm-KomM.js").then((t) => t.markdown());
    }
  }),
  xn.of({
    name: "Wasm",
    extensions: ["wat"],
    async load() {
      return import("./index-CKsZ980l.js").then((t) => t.wast());
    }
  }),
  xn.of({
    name: "Python",
    extensions: ["py"],
    async load() {
      return import("./index-Cgm4qXRc.js").then((t) => t.python());
    }
  }),
  xn.of({
    name: "C++",
    extensions: ["cpp"],
    async load() {
      return import("./index-BP4MWDKO.js").then((t) => t.cpp());
    }
  })
];
async function gDe(t) {
  const e = xn.matchFilename(mDe, t);
  if (e)
    return await e.load();
}
const yDe = Sr("CodeMirrorEditor"), AV = at.define(), bDe = En.define({
  create: () => [],
  update(t, e) {
    if (!e.state.readOnly)
      return [];
    for (const n of e.effects)
      if (n.is(AV) && n.value)
        return wDe(e.state);
    return [];
  },
  provide: (t) => aA.computeN([t], (e) => e.field(t))
}), RV = at.define(), oL = En.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (const n of e.effects)
      if (n.is(RV))
        return n.value;
    return t;
  }
}), IV = I.memo(
  ({
    id: t,
    doc: e,
    debounceScroll: n = 100,
    debounceChange: r = 150,
    autoFocusOnDocumentChange: s = !1,
    editable: i = !0,
    onScroll: o,
    onChange: a,
    onSave: l,
    theme: c,
    settings: u,
    className: h = ""
  }) => {
    Eu.trace("CodeMirrorEditor");
    const [d] = I.useState(new Fu()), f = I.useRef(null), g = I.useRef(), y = I.useRef(), p = I.useRef(), m = I.useRef(), b = I.useRef(o), _ = I.useRef(a), v = I.useRef(l);
    return I.useEffect(() => {
      b.current = o, _.current = a, v.current = l, p.current = e, y.current = c;
    }), I.useEffect(() => {
      const w = qk((x) => {
        _.current?.(x);
      }, r), E = new He({
        parent: f.current,
        dispatchTransactions(x) {
          const S = E.state.selection;
          E.update(x);
          const T = E.state.selection, R = T !== S && (T === void 0 || S === void 0 || !T.eq(S));
          p.current && (x.some((F) => F.docChanged) || R) && (w({
            selection: E.state.selection,
            content: E.state.doc.toString()
          }), m.current.set(p.current.filePath, E.state));
        }
      });
      return g.current = E, () => {
        g.current?.destroy(), g.current = void 0;
      };
    }, []), I.useEffect(() => {
      g.current && g.current.dispatch({
        effects: [TV(c)]
      });
    }, [c]), I.useEffect(() => {
      m.current = /* @__PURE__ */ new Map();
    }, [t]), I.useEffect(() => {
      const w = m.current, E = g.current, x = y.current;
      if (!e) {
        const T = aL("", x, u, b, n, v, [
          d.of([])
        ]);
        E.setState(T), _De(E);
        return;
      }
      if (e.isBinary)
        return;
      e.filePath === "" && yDe.warn("File path should not be empty");
      let S = w.get(e.filePath);
      S || (S = aL(e.value, x, u, b, n, v, [
        d.of([])
      ]), w.set(e.filePath, S)), E.setState(S), vDe(
        E,
        x,
        i,
        d,
        s,
        e
      );
    }, [e?.value, i, e?.filePath, s]), /* @__PURE__ */ k.jsxs("div", { className: qe("relative h-full", h), children: [
      e?.isBinary && /* @__PURE__ */ k.jsx(tDe, {}),
      /* @__PURE__ */ k.jsx("div", { className: "h-full overflow-hidden", ref: f })
    ] });
  }
);
IV.displayName = "CodeMirrorEditor";
function aL(t, e, n, r, s, i, o) {
  return pt.create({
    doc: t,
    extensions: [
      He.domEventHandlers({
        scroll: qk((a, l) => {
          a.target === l.scrollDOM && r.current?.({ left: l.scrollDOM.scrollLeft, top: l.scrollDOM.scrollTop });
        }, s),
        keydown: (a, l) => l.state.readOnly ? (l.dispatch({
          effects: [AV.of(a.key !== "Escape")]
        }), !0) : !1
      }),
      uDe(e, n),
      DPe(),
      Qb.of([
        ...NOe,
        ...HPe,
        ...JOe,
        { key: "Tab", run: OG },
        {
          key: "Mod-s",
          preventDefault: !0,
          run: () => (i.current?.(), !0)
        },
        dDe
      ]),
      Uu.of("	"),
      wPe({
        closeOnBlur: !1
      }),
      eRe({
        position: "absolute",
        parent: document.body,
        tooltipSpace: (a) => {
          const l = a.dom.getBoundingClientRect();
          return {
            top: l.top - 50,
            left: l.left,
            bottom: l.bottom,
            right: l.right + 10
          };
        }
      }),
      hPe(),
      fRe(),
      Y2e(),
      K2e(),
      z2e(),
      EIe(),
      pt.tabSize.of(n?.tabSize ?? 2),
      eIe(),
      bDe,
      oL,
      pt.readOnly.from(oL, (a) => !a),
      gRe(),
      Z2e(),
      uIe({
        markerDOM: (a) => {
          const l = document.createElement("div");
          return l.className = `fold-icon ${a ? "i-ph-caret-down-bold" : "i-ph-caret-right-bold"}`, l;
        }
      }),
      ...o
    ]
  });
}
function _De(t) {
  t.dispatch({
    selection: { anchor: 0 },
    changes: {
      from: 0,
      to: t.state.doc.length,
      insert: ""
    }
  }), t.scrollDOM.scrollTo(0, 0);
}
function vDe(t, e, n, r, s, i) {
  i.value !== t.state.doc.toString() && t.dispatch({
    selection: { anchor: 0 },
    changes: {
      from: 0,
      to: t.state.doc.length,
      insert: i.value
    }
  }), t.dispatch({
    effects: [RV.of(n && !i.isBinary)]
  }), gDe(i.filePath).then((o) => {
    o && (t.dispatch({
      effects: [r.reconfigure([o]), TV(e)]
    }), requestAnimationFrame(() => {
      const a = t.scrollDOM.scrollLeft, l = t.scrollDOM.scrollTop, c = i.scroll?.left ?? 0, u = i.scroll?.top ?? 0;
      s && n && (a !== c || l !== u ? t.scrollDOM.addEventListener(
        "scroll",
        () => {
          t.focus();
        },
        { once: !0 }
      ) : t.focus()), t.scrollDOM.scrollTo(c, u);
    }));
  });
}
function wDe(t) {
  return t.readOnly ? t.selection.ranges.filter((e) => e.empty).map((e) => ({
    pos: e.head,
    above: !0,
    strictSide: !0,
    arrow: !0,
    create: () => {
      const n = document.createElement("div");
      return n.className = "cm-readonly-tooltip", n.textContent = "Cannot edit file while AI response is being generated", { dom: n };
    }
  })) : [];
}
const xc = I.memo(
  ({ className: t, disabledClassName: e, disabled: n = !1, children: r, onClick: s }) => /* @__PURE__ */ k.jsx(
    "button",
    {
      className: qe(
        "flex items-center shrink-0 gap-1.5 px-1.5 rounded-md py-0.5 text-bolt-elements-item-contentDefault bg-transparent enabled:hover:text-bolt-elements-item-contentActive enabled:hover:bg-bolt-elements-item-backgroundActive disabled:cursor-not-allowed",
        {
          [qe("opacity-30", e)]: n
        },
        t
      ),
      disabled: n,
      onClick: (i) => {
        n || s?.(i);
      },
      children: r
    }
  )
), EDe = I.memo, SDe = EDe(({ selected: t, options: e, setSelected: n }) => {
  const r = t === e.left.value;
  return /* @__PURE__ */ k.jsxs("div", { className: "flex items-center flex-wrap shrink-0 gap-1 bg-bolt-elements-background-depth-1 overflow-hidden rounded-full p-1", children: [
    /* @__PURE__ */ k.jsx(lL, { selected: r, setSelected: () => n?.(e.left.value), children: e.left.text }),
    /* @__PURE__ */ k.jsx(lL, { selected: !r, setSelected: () => n?.(e.right.value), children: e.right.text })
  ] });
}), lL = I.memo(({ selected: t, children: e, setSelected: n }) => /* @__PURE__ */ k.jsxs(
  "button",
  {
    onClick: n,
    className: qe(
      "bg-transparent text-sm px-2.5 py-0.5 rounded-full relative",
      t ? "text-bolt-elements-item-contentAccent" : "text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive"
    ),
    children: [
      /* @__PURE__ */ k.jsx("span", { className: "relative z-10", children: e }),
      t && /* @__PURE__ */ k.jsx(
        hn.span,
        {
          layoutId: "pill-tab",
          transition: { duration: 0.2, ease: xs },
          className: "absolute inset-0 z-0 bg-bolt-elements-item-backgroundAccent rounded-full"
        }
      )
    ]
  }
)), {
  createElement: gu,
  createContext: xDe,
  forwardRef: PV,
  useCallback: ar,
  useContext: OV,
  useEffect: al,
  useImperativeHandle: DV,
  useLayoutEffect: TDe,
  useMemo: CDe,
  useRef: ur,
  useState: Uc
} = LT, cL = LT[`useId${Math.random()}`.slice(0, 5)], kDe = TDe, o_ = xDe(null);
o_.displayName = "PanelGroupContext";
const ll = kDe, ADe = typeof cL == "function" ? cL : () => null;
let RDe = 0;
function RA(t = null) {
  const e = ADe(), n = ur(t || e || null);
  return n.current === null && (n.current = "" + RDe++), t ?? n.current;
}
function NV({
  children: t,
  className: e = "",
  collapsedSize: n,
  collapsible: r,
  defaultSize: s,
  forwardedRef: i,
  id: o,
  maxSize: a,
  minSize: l,
  onCollapse: c,
  onExpand: u,
  onResize: h,
  order: d,
  style: f,
  tagName: g = "div",
  ...y
}) {
  const p = OV(o_);
  if (p === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: m,
    expandPanel: b,
    getPanelSize: _,
    getPanelStyle: v,
    groupId: w,
    isPanelCollapsed: E,
    reevaluatePanelConstraints: x,
    registerPanel: S,
    resizePanel: T,
    unregisterPanel: R
  } = p, F = RA(o), P = ur({
    callbacks: {
      onCollapse: c,
      onExpand: u,
      onResize: h
    },
    constraints: {
      collapsedSize: n,
      collapsible: r,
      defaultSize: s,
      maxSize: a,
      minSize: l
    },
    id: F,
    idIsFromProps: o !== void 0,
    order: d
  });
  ur({
    didLogMissingDefaultSizeWarning: !1
  }), ll(() => {
    const {
      callbacks: A,
      constraints: V
    } = P.current, ee = {
      ...V
    };
    P.current.id = F, P.current.idIsFromProps = o !== void 0, P.current.order = d, A.onCollapse = c, A.onExpand = u, A.onResize = h, V.collapsedSize = n, V.collapsible = r, V.defaultSize = s, V.maxSize = a, V.minSize = l, (ee.collapsedSize !== V.collapsedSize || ee.collapsible !== V.collapsible || ee.maxSize !== V.maxSize || ee.minSize !== V.minSize) && x(P.current, ee);
  }), ll(() => {
    const A = P.current;
    return S(A), () => {
      R(A);
    };
  }, [d, F, S, R]), DV(i, () => ({
    collapse: () => {
      m(P.current);
    },
    expand: (A) => {
      b(P.current, A);
    },
    getId() {
      return F;
    },
    getSize() {
      return _(P.current);
    },
    isCollapsed() {
      return E(P.current);
    },
    isExpanded() {
      return !E(P.current);
    },
    resize: (A) => {
      T(P.current, A);
    }
  }), [m, b, _, E, F, T]);
  const M = v(P.current, s);
  return gu(g, {
    ...y,
    children: t,
    className: e,
    id: o,
    style: {
      ...M,
      ...f
    },
    // CSS selectors
    "data-panel": "",
    "data-panel-collapsible": r || void 0,
    "data-panel-group-id": w,
    "data-panel-id": F,
    "data-panel-size": parseFloat("" + M.flexGrow).toFixed(1)
  });
}
const cd = PV((t, e) => gu(NV, {
  ...t,
  forwardedRef: e
}));
NV.displayName = "Panel";
cd.displayName = "forwardRef(Panel)";
let Lx = null, qa = null;
function IDe(t, e) {
  if (e) {
    const n = (e & $V) !== 0, r = (e & UV) !== 0, s = (e & jV) !== 0, i = (e & HV) !== 0;
    if (n)
      return s ? "se-resize" : i ? "ne-resize" : "e-resize";
    if (r)
      return s ? "sw-resize" : i ? "nw-resize" : "w-resize";
    if (s)
      return "s-resize";
    if (i)
      return "n-resize";
  }
  switch (t) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function PDe() {
  qa !== null && (document.head.removeChild(qa), Lx = null, qa = null);
}
function xw(t, e) {
  const n = IDe(t, e);
  Lx !== n && (Lx = n, qa === null && (qa = document.createElement("style"), document.head.appendChild(qa)), qa.innerHTML = `*{cursor: ${n}!important;}`);
}
function LV(t) {
  return t.type === "keydown";
}
function MV(t) {
  return t.type.startsWith("pointer");
}
function BV(t) {
  return t.type.startsWith("mouse");
}
function a_(t) {
  if (MV(t)) {
    if (t.isPrimary)
      return {
        x: t.clientX,
        y: t.clientY
      };
  } else if (BV(t))
    return {
      x: t.clientX,
      y: t.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function ODe() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function DDe(t, e, n) {
  return t.x < e.x + e.width && t.x + t.width > e.x && t.y < e.y + e.height && t.y + t.height > e.y;
}
function NDe(t, e) {
  if (t === e) throw new Error("Cannot compare node with itself");
  const n = {
    a: dL(t),
    b: dL(e)
  };
  let r;
  for (; n.a.at(-1) === n.b.at(-1); )
    t = n.a.pop(), e = n.b.pop(), r = t;
  rt(r, "Stacking order can only be calculated for elements with a common ancestor");
  const s = {
    a: hL(uL(n.a)),
    b: hL(uL(n.b))
  };
  if (s.a === s.b) {
    const i = r.childNodes, o = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let a = i.length;
    for (; a--; ) {
      const l = i[a];
      if (l === o.a) return 1;
      if (l === o.b) return -1;
    }
  }
  return Math.sign(s.a - s.b);
}
const LDe = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function MDe(t) {
  var e;
  const n = getComputedStyle((e = FV(t)) !== null && e !== void 0 ? e : t).display;
  return n === "flex" || n === "inline-flex";
}
function BDe(t) {
  const e = getComputedStyle(t);
  return !!(e.position === "fixed" || e.zIndex !== "auto" && (e.position !== "static" || MDe(t)) || +e.opacity < 1 || "transform" in e && e.transform !== "none" || "webkitTransform" in e && e.webkitTransform !== "none" || "mixBlendMode" in e && e.mixBlendMode !== "normal" || "filter" in e && e.filter !== "none" || "webkitFilter" in e && e.webkitFilter !== "none" || "isolation" in e && e.isolation === "isolate" || LDe.test(e.willChange) || e.webkitOverflowScrolling === "touch");
}
function uL(t) {
  let e = t.length;
  for (; e--; ) {
    const n = t[e];
    if (rt(n, "Missing node"), BDe(n)) return n;
  }
  return null;
}
function hL(t) {
  return t && Number(getComputedStyle(t).zIndex) || 0;
}
function dL(t) {
  const e = [];
  for (; t; )
    e.push(t), t = FV(t);
  return e;
}
function FV(t) {
  const {
    parentNode: e
  } = t;
  return e && e instanceof ShadowRoot ? e.host : e;
}
const $V = 1, UV = 2, jV = 4, HV = 8, FDe = ODe() === "coarse";
let Es = [], jc = !1, Fo = /* @__PURE__ */ new Map(), l_ = /* @__PURE__ */ new Map();
const gf = /* @__PURE__ */ new Set();
function $De(t, e, n, r, s) {
  var i;
  const {
    ownerDocument: o
  } = e, a = {
    direction: n,
    element: e,
    hitAreaMargins: r,
    setResizeHandlerState: s
  }, l = (i = Fo.get(o)) !== null && i !== void 0 ? i : 0;
  return Fo.set(o, l + 1), gf.add(a), ky(), function() {
    var u;
    l_.delete(t), gf.delete(a);
    const h = (u = Fo.get(o)) !== null && u !== void 0 ? u : 1;
    if (Fo.set(o, h - 1), ky(), h === 1 && Fo.delete(o), Es.includes(a)) {
      const d = Es.indexOf(a);
      d >= 0 && Es.splice(d, 1), PA(), s("up", !0, null);
    }
  };
}
function fL(t) {
  const {
    target: e
  } = t, {
    x: n,
    y: r
  } = a_(t);
  jc = !0, IA({
    target: e,
    x: n,
    y: r
  }), ky(), Es.length > 0 && (Ay("down", t), t.preventDefault(), t.stopPropagation());
}
function fh(t) {
  const {
    x: e,
    y: n
  } = a_(t);
  if (jc && t.buttons === 0 && (jc = !1, Ay("up", t)), !jc) {
    const {
      target: r
    } = t;
    IA({
      target: r,
      x: e,
      y: n
    });
  }
  Ay("move", t), PA(), Es.length > 0 && t.preventDefault();
}
function ec(t) {
  const {
    target: e
  } = t, {
    x: n,
    y: r
  } = a_(t);
  l_.clear(), jc = !1, Es.length > 0 && t.preventDefault(), Ay("up", t), IA({
    target: e,
    x: n,
    y: r
  }), PA(), ky();
}
function IA({
  target: t,
  x: e,
  y: n
}) {
  Es.splice(0);
  let r = null;
  (t instanceof HTMLElement || t instanceof SVGElement) && (r = t), gf.forEach((s) => {
    const {
      element: i,
      hitAreaMargins: o
    } = s, a = i.getBoundingClientRect(), {
      bottom: l,
      left: c,
      right: u,
      top: h
    } = a, d = FDe ? o.coarse : o.fine;
    if (e >= c - d && e <= u + d && n >= h - d && n <= l + d) {
      if (r !== null && document.contains(r) && i !== r && !i.contains(r) && !r.contains(i) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      NDe(r, i) > 0) {
        let g = r, y = !1;
        for (; g && !g.contains(i); ) {
          if (DDe(g.getBoundingClientRect(), a)) {
            y = !0;
            break;
          }
          g = g.parentElement;
        }
        if (y)
          return;
      }
      Es.push(s);
    }
  });
}
function Tw(t, e) {
  l_.set(t, e);
}
function PA() {
  let t = !1, e = !1;
  Es.forEach((r) => {
    const {
      direction: s
    } = r;
    s === "horizontal" ? t = !0 : e = !0;
  });
  let n = 0;
  l_.forEach((r) => {
    n |= r;
  }), t && e ? xw("intersection", n) : t ? xw("horizontal", n) : e ? xw("vertical", n) : PDe();
}
function ky() {
  Fo.forEach((t, e) => {
    const {
      body: n
    } = e;
    n.removeEventListener("contextmenu", ec), n.removeEventListener("pointerdown", fL), n.removeEventListener("pointerleave", fh), n.removeEventListener("pointermove", fh);
  }), window.removeEventListener("pointerup", ec), window.removeEventListener("pointercancel", ec), gf.size > 0 && (jc ? (Es.length > 0 && Fo.forEach((t, e) => {
    const {
      body: n
    } = e;
    t > 0 && (n.addEventListener("contextmenu", ec), n.addEventListener("pointerleave", fh), n.addEventListener("pointermove", fh));
  }), window.addEventListener("pointerup", ec), window.addEventListener("pointercancel", ec)) : Fo.forEach((t, e) => {
    const {
      body: n
    } = e;
    t > 0 && (n.addEventListener("pointerdown", fL, {
      capture: !0
    }), n.addEventListener("pointermove", fh));
  }));
}
function Ay(t, e) {
  gf.forEach((n) => {
    const {
      setResizeHandlerState: r
    } = n, s = Es.includes(n);
    r(t, s, e);
  });
}
function UDe() {
  const [t, e] = Uc(0);
  return ar(() => e((n) => n + 1), []);
}
function rt(t, e) {
  if (!t)
    throw console.error(e), Error(e);
}
const OA = 10;
function Tl(t, e, n = OA) {
  return t.toFixed(n) === e.toFixed(n) ? 0 : t > e ? 1 : -1;
}
function to(t, e, n = OA) {
  return Tl(t, e, n) === 0;
}
function kr(t, e, n) {
  return Tl(t, e, n) === 0;
}
function jDe(t, e, n) {
  if (t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    const s = t[r], i = e[r];
    if (!kr(s, i, n))
      return !1;
  }
  return !0;
}
function Tc({
  panelConstraints: t,
  panelIndex: e,
  size: n
}) {
  const r = t[e];
  rt(r != null, `Panel constraints not found for index ${e}`);
  let {
    collapsedSize: s = 0,
    collapsible: i,
    maxSize: o = 100,
    minSize: a = 0
  } = r;
  if (Tl(n, a) < 0)
    if (i) {
      const l = (s + a) / 2;
      Tl(n, l) < 0 ? n = s : n = a;
    } else
      n = a;
  return n = Math.min(o, n), n = parseFloat(n.toFixed(OA)), n;
}
function Dh({
  delta: t,
  initialLayout: e,
  panelConstraints: n,
  pivotIndices: r,
  prevLayout: s,
  trigger: i
}) {
  if (kr(t, 0))
    return e;
  const o = [...e], [a, l] = r;
  rt(a != null, "Invalid first pivot index"), rt(l != null, "Invalid second pivot index");
  let c = 0;
  if (i === "keyboard") {
    {
      const h = t < 0 ? l : a, d = n[h];
      rt(d, `Panel constraints not found for index ${h}`);
      const {
        collapsedSize: f = 0,
        collapsible: g,
        minSize: y = 0
      } = d;
      if (g) {
        const p = e[h];
        if (rt(p != null, `Previous layout not found for panel index ${h}`), kr(p, f)) {
          const m = y - p;
          Tl(m, Math.abs(t)) > 0 && (t = t < 0 ? 0 - m : m);
        }
      }
    }
    {
      const h = t < 0 ? a : l, d = n[h];
      rt(d, `No panel constraints found for index ${h}`);
      const {
        collapsedSize: f = 0,
        collapsible: g,
        minSize: y = 0
      } = d;
      if (g) {
        const p = e[h];
        if (rt(p != null, `Previous layout not found for panel index ${h}`), kr(p, y)) {
          const m = p - f;
          Tl(m, Math.abs(t)) > 0 && (t = t < 0 ? 0 - m : m);
        }
      }
    }
  }
  {
    const h = t < 0 ? 1 : -1;
    let d = t < 0 ? l : a, f = 0;
    for (; ; ) {
      const y = e[d];
      rt(y != null, `Previous layout not found for panel index ${d}`);
      const m = Tc({
        panelConstraints: n,
        panelIndex: d,
        size: 100
      }) - y;
      if (f += m, d += h, d < 0 || d >= n.length)
        break;
    }
    const g = Math.min(Math.abs(t), Math.abs(f));
    t = t < 0 ? 0 - g : g;
  }
  {
    let d = t < 0 ? a : l;
    for (; d >= 0 && d < n.length; ) {
      const f = Math.abs(t) - Math.abs(c), g = e[d];
      rt(g != null, `Previous layout not found for panel index ${d}`);
      const y = g - f, p = Tc({
        panelConstraints: n,
        panelIndex: d,
        size: y
      });
      if (!kr(g, p) && (c += g - p, o[d] = p, c.toPrecision(3).localeCompare(Math.abs(t).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      t < 0 ? d-- : d++;
    }
  }
  if (jDe(s, o))
    return s;
  {
    const h = t < 0 ? l : a, d = e[h];
    rt(d != null, `Previous layout not found for panel index ${h}`);
    const f = d + c, g = Tc({
      panelConstraints: n,
      panelIndex: h,
      size: f
    });
    if (o[h] = g, !kr(g, f)) {
      let y = f - g, m = t < 0 ? l : a;
      for (; m >= 0 && m < n.length; ) {
        const b = o[m];
        rt(b != null, `Previous layout not found for panel index ${m}`);
        const _ = b + y, v = Tc({
          panelConstraints: n,
          panelIndex: m,
          size: _
        });
        if (kr(b, v) || (y -= v - b, o[m] = v), kr(y, 0))
          break;
        t > 0 ? m-- : m++;
      }
    }
  }
  const u = o.reduce((h, d) => d + h, 0);
  return kr(u, 100) ? o : s;
}
function HDe({
  layout: t,
  panelsArray: e,
  pivotIndices: n
}) {
  let r = 0, s = 100, i = 0, o = 0;
  const a = n[0];
  rt(a != null, "No pivot index found"), e.forEach((h, d) => {
    const {
      constraints: f
    } = h, {
      maxSize: g = 100,
      minSize: y = 0
    } = f;
    d === a ? (r = y, s = g) : (i += y, o += g);
  });
  const l = Math.min(s, 100 - i), c = Math.max(r, 100 - o), u = t[a];
  return {
    valueMax: l,
    valueMin: c,
    valueNow: u
  };
}
function yf(t, e = document) {
  return Array.from(e.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${t}"]`));
}
function zV(t, e, n = document) {
  const s = yf(t, n).findIndex((i) => i.getAttribute("data-panel-resize-handle-id") === e);
  return s ?? null;
}
function GV(t, e, n) {
  const r = zV(t, e, n);
  return r != null ? [r, r + 1] : [-1, -1];
}
function VV(t, e = document) {
  var n;
  if (e instanceof HTMLElement && (e == null || (n = e.dataset) === null || n === void 0 ? void 0 : n.panelGroupId) == t)
    return e;
  const r = e.querySelector(`[data-panel-group][data-panel-group-id="${t}"]`);
  return r || null;
}
function c_(t, e = document) {
  const n = e.querySelector(`[data-panel-resize-handle-id="${t}"]`);
  return n || null;
}
function zDe(t, e, n, r = document) {
  var s, i, o, a;
  const l = c_(e, r), c = yf(t, r), u = l ? c.indexOf(l) : -1, h = (s = (i = n[u]) === null || i === void 0 ? void 0 : i.id) !== null && s !== void 0 ? s : null, d = (o = (a = n[u + 1]) === null || a === void 0 ? void 0 : a.id) !== null && o !== void 0 ? o : null;
  return [h, d];
}
function GDe({
  committedValuesRef: t,
  eagerValuesRef: e,
  groupId: n,
  layout: r,
  panelDataArray: s,
  panelGroupElement: i,
  setLayout: o
}) {
  ur({
    didWarnAboutMissingResizeHandle: !1
  }), ll(() => {
    if (!i)
      return;
    const a = yf(n, i);
    for (let l = 0; l < s.length - 1; l++) {
      const {
        valueMax: c,
        valueMin: u,
        valueNow: h
      } = HDe({
        layout: r,
        panelsArray: s,
        pivotIndices: [l, l + 1]
      }), d = a[l];
      if (d != null) {
        const f = s[l];
        rt(f, `No panel data found for index "${l}"`), d.setAttribute("aria-controls", f.id), d.setAttribute("aria-valuemax", "" + Math.round(c)), d.setAttribute("aria-valuemin", "" + Math.round(u)), d.setAttribute("aria-valuenow", h != null ? "" + Math.round(h) : "");
      }
    }
    return () => {
      a.forEach((l, c) => {
        l.removeAttribute("aria-controls"), l.removeAttribute("aria-valuemax"), l.removeAttribute("aria-valuemin"), l.removeAttribute("aria-valuenow");
      });
    };
  }, [n, r, s, i]), al(() => {
    if (!i)
      return;
    const a = e.current;
    rt(a, "Eager values not found");
    const {
      panelDataArray: l
    } = a, c = VV(n, i);
    rt(c != null, `No group found for id "${n}"`);
    const u = yf(n, i);
    rt(u, `No resize handles found for group id "${n}"`);
    const h = u.map((d) => {
      const f = d.getAttribute("data-panel-resize-handle-id");
      rt(f, "Resize handle element has no handle id attribute");
      const [g, y] = zDe(n, f, l, i);
      if (g == null || y == null)
        return () => {
        };
      const p = (m) => {
        if (!m.defaultPrevented)
          switch (m.key) {
            case "Enter": {
              m.preventDefault();
              const b = l.findIndex((_) => _.id === g);
              if (b >= 0) {
                const _ = l[b];
                rt(_, `No panel data found for index ${b}`);
                const v = r[b], {
                  collapsedSize: w = 0,
                  collapsible: E,
                  minSize: x = 0
                } = _.constraints;
                if (v != null && E) {
                  const S = Dh({
                    delta: kr(v, w) ? x - w : w - v,
                    initialLayout: r,
                    panelConstraints: l.map((T) => T.constraints),
                    pivotIndices: GV(n, f, i),
                    prevLayout: r,
                    trigger: "keyboard"
                  });
                  r !== S && o(S);
                }
              }
              break;
            }
          }
      };
      return d.addEventListener("keydown", p), () => {
        d.removeEventListener("keydown", p);
      };
    });
    return () => {
      h.forEach((d) => d());
    };
  }, [i, t, e, n, r, s, o]);
}
function pL(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function WV(t, e) {
  const n = t === "horizontal", {
    x: r,
    y: s
  } = a_(e);
  return n ? r : s;
}
function VDe(t, e, n, r, s) {
  const i = n === "horizontal", o = c_(e, s);
  rt(o, `No resize handle element found for id "${e}"`);
  const a = o.getAttribute("data-panel-group-id");
  rt(a, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: l
  } = r;
  const c = WV(n, t), u = VV(a, s);
  rt(u, `No group element found for id "${a}"`);
  const h = u.getBoundingClientRect(), d = i ? h.width : h.height;
  return (c - l) / d * 100;
}
function WDe(t, e, n, r, s, i) {
  if (LV(t)) {
    const o = n === "horizontal";
    let a = 0;
    t.shiftKey ? a = 100 : s != null ? a = s : a = 10;
    let l = 0;
    switch (t.key) {
      case "ArrowDown":
        l = o ? 0 : a;
        break;
      case "ArrowLeft":
        l = o ? -a : 0;
        break;
      case "ArrowRight":
        l = o ? a : 0;
        break;
      case "ArrowUp":
        l = o ? 0 : -a;
        break;
      case "End":
        l = 100;
        break;
      case "Home":
        l = -100;
        break;
    }
    return l;
  } else
    return r == null ? 0 : VDe(t, e, n, r, i);
}
function qDe({
  panelDataArray: t
}) {
  const e = Array(t.length), n = t.map((i) => i.constraints);
  let r = 0, s = 100;
  for (let i = 0; i < t.length; i++) {
    const o = n[i];
    rt(o, `Panel constraints not found for index ${i}`);
    const {
      defaultSize: a
    } = o;
    a != null && (r++, e[i] = a, s -= a);
  }
  for (let i = 0; i < t.length; i++) {
    const o = n[i];
    rt(o, `Panel constraints not found for index ${i}`);
    const {
      defaultSize: a
    } = o;
    if (a != null)
      continue;
    const l = t.length - r, c = s / l;
    r++, e[i] = c, s -= c;
  }
  return e;
}
function tc(t, e, n) {
  e.forEach((r, s) => {
    const i = t[s];
    rt(i, `Panel data not found for index ${s}`);
    const {
      callbacks: o,
      constraints: a,
      id: l
    } = i, {
      collapsedSize: c = 0,
      collapsible: u
    } = a, h = n[l];
    if (h == null || r !== h) {
      n[l] = r;
      const {
        onCollapse: d,
        onExpand: f,
        onResize: g
      } = o;
      g && g(r, h), u && (d || f) && (f && (h == null || to(h, c)) && !to(r, c) && f(), d && (h == null || !to(h, c)) && to(r, c) && d());
    }
  });
}
function Gm(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] != e[n])
      return !1;
  return !0;
}
function KDe({
  defaultSize: t,
  dragState: e,
  layout: n,
  panelData: r,
  panelIndex: s,
  precision: i = 3
}) {
  const o = n[s];
  let a;
  return o == null ? a = t != null ? t.toPrecision(i) : "1" : r.length === 1 ? a = "1" : a = o.toPrecision(i), {
    flexBasis: 0,
    flexGrow: a,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: e !== null ? "none" : void 0
  };
}
function YDe(t, e = 10) {
  let n = null;
  return (...s) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      t(...s);
    }, e);
  };
}
function mL(t) {
  try {
    if (typeof localStorage < "u")
      t.getItem = (e) => localStorage.getItem(e), t.setItem = (e, n) => {
        localStorage.setItem(e, n);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (e) {
    console.error(e), t.getItem = () => null, t.setItem = () => {
    };
  }
}
function qV(t) {
  return `react-resizable-panels:${t}`;
}
function KV(t) {
  return t.map((e) => {
    const {
      constraints: n,
      id: r,
      idIsFromProps: s,
      order: i
    } = e;
    return s ? r : i ? `${i}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((e, n) => e.localeCompare(n)).join(",");
}
function YV(t, e) {
  try {
    const n = qV(t), r = e.getItem(n);
    if (r) {
      const s = JSON.parse(r);
      if (typeof s == "object" && s != null)
        return s;
    }
  } catch {
  }
  return null;
}
function ZDe(t, e, n) {
  var r, s;
  const i = (r = YV(t, n)) !== null && r !== void 0 ? r : {}, o = KV(e);
  return (s = i[o]) !== null && s !== void 0 ? s : null;
}
function JDe(t, e, n, r, s) {
  var i;
  const o = qV(t), a = KV(e), l = (i = YV(t, s)) !== null && i !== void 0 ? i : {};
  l[a] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: r
  };
  try {
    s.setItem(o, JSON.stringify(l));
  } catch (c) {
    console.error(c);
  }
}
function gL({
  layout: t,
  panelConstraints: e
}) {
  const n = [...t], r = n.reduce((i, o) => i + o, 0);
  if (n.length !== e.length)
    throw Error(`Invalid ${e.length} panel layout: ${n.map((i) => `${i}%`).join(", ")}`);
  if (!kr(r, 100) && n.length > 0)
    for (let i = 0; i < e.length; i++) {
      const o = n[i];
      rt(o != null, `No layout data found for index ${i}`);
      const a = 100 / r * o;
      n[i] = a;
    }
  let s = 0;
  for (let i = 0; i < e.length; i++) {
    const o = n[i];
    rt(o != null, `No layout data found for index ${i}`);
    const a = Tc({
      panelConstraints: e,
      panelIndex: i,
      size: o
    });
    o != a && (s += o - a, n[i] = a);
  }
  if (!kr(s, 0))
    for (let i = 0; i < e.length; i++) {
      const o = n[i];
      rt(o != null, `No layout data found for index ${i}`);
      const a = o + s, l = Tc({
        panelConstraints: e,
        panelIndex: i,
        size: a
      });
      if (o !== l && (s -= l - o, n[i] = l, kr(s, 0)))
        break;
    }
  return n;
}
const XDe = 100, Nh = {
  getItem: (t) => (mL(Nh), Nh.getItem(t)),
  setItem: (t, e) => {
    mL(Nh), Nh.setItem(t, e);
  }
}, yL = {};
function ZV({
  autoSaveId: t = null,
  children: e,
  className: n = "",
  direction: r,
  forwardedRef: s,
  id: i = null,
  onLayout: o = null,
  keyboardResizeBy: a = null,
  storage: l = Nh,
  style: c,
  tagName: u = "div",
  ...h
}) {
  const d = RA(i), f = ur(null), [g, y] = Uc(null), [p, m] = Uc([]), b = UDe(), _ = ur({}), v = ur(/* @__PURE__ */ new Map()), w = ur(0), E = ur({
    autoSaveId: t,
    direction: r,
    dragState: g,
    id: d,
    keyboardResizeBy: a,
    onLayout: o,
    storage: l
  }), x = ur({
    layout: p,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  ur({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), DV(s, () => ({
    getId: () => E.current.id,
    getLayout: () => {
      const {
        layout: U
      } = x.current;
      return U;
    },
    setLayout: (U) => {
      const {
        onLayout: Y
      } = E.current, {
        layout: ne,
        panelDataArray: he
      } = x.current, X = gL({
        layout: U,
        panelConstraints: he.map((z) => z.constraints)
      });
      pL(ne, X) || (m(X), x.current.layout = X, Y && Y(X), tc(he, X, _.current));
    }
  }), []), ll(() => {
    E.current.autoSaveId = t, E.current.direction = r, E.current.dragState = g, E.current.id = d, E.current.onLayout = o, E.current.storage = l;
  }), GDe({
    committedValuesRef: E,
    eagerValuesRef: x,
    groupId: d,
    layout: p,
    panelDataArray: x.current.panelDataArray,
    setLayout: m,
    panelGroupElement: f.current
  }), al(() => {
    const {
      panelDataArray: U
    } = x.current;
    if (t) {
      if (p.length === 0 || p.length !== U.length)
        return;
      let Y = yL[t];
      Y == null && (Y = YDe(JDe, XDe), yL[t] = Y);
      const ne = [...U], he = new Map(v.current);
      Y(t, ne, he, p, l);
    }
  }, [t, p, l]), al(() => {
  });
  const S = ar((U) => {
    const {
      onLayout: Y
    } = E.current, {
      layout: ne,
      panelDataArray: he
    } = x.current;
    if (U.constraints.collapsible) {
      const X = he.map((be) => be.constraints), {
        collapsedSize: z = 0,
        panelSize: ue,
        pivotIndices: ae
      } = Aa(he, U, ne);
      if (rt(ue != null, `Panel size not found for panel "${U.id}"`), !to(ue, z)) {
        v.current.set(U.id, ue);
        const de = cc(he, U) === he.length - 1 ? ue - z : z - ue, _e = Dh({
          delta: de,
          initialLayout: ne,
          panelConstraints: X,
          pivotIndices: ae,
          prevLayout: ne,
          trigger: "imperative-api"
        });
        Gm(ne, _e) || (m(_e), x.current.layout = _e, Y && Y(_e), tc(he, _e, _.current));
      }
    }
  }, []), T = ar((U, Y) => {
    const {
      onLayout: ne
    } = E.current, {
      layout: he,
      panelDataArray: X
    } = x.current;
    if (U.constraints.collapsible) {
      const z = X.map(($) => $.constraints), {
        collapsedSize: ue = 0,
        panelSize: ae = 0,
        minSize: be = 0,
        pivotIndices: de
      } = Aa(X, U, he), _e = Y ?? be;
      if (to(ae, ue)) {
        const $ = v.current.get(U.id), ce = $ != null && $ >= _e ? $ : _e, W = cc(X, U) === X.length - 1 ? ae - ce : ce - ae, q = Dh({
          delta: W,
          initialLayout: he,
          panelConstraints: z,
          pivotIndices: de,
          prevLayout: he,
          trigger: "imperative-api"
        });
        Gm(he, q) || (m(q), x.current.layout = q, ne && ne(q), tc(X, q, _.current));
      }
    }
  }, []), R = ar((U) => {
    const {
      layout: Y,
      panelDataArray: ne
    } = x.current, {
      panelSize: he
    } = Aa(ne, U, Y);
    return rt(he != null, `Panel size not found for panel "${U.id}"`), he;
  }, []), F = ar((U, Y) => {
    const {
      panelDataArray: ne
    } = x.current, he = cc(ne, U);
    return KDe({
      defaultSize: Y,
      dragState: g,
      layout: p,
      panelData: ne,
      panelIndex: he
    });
  }, [g, p]), P = ar((U) => {
    const {
      layout: Y,
      panelDataArray: ne
    } = x.current, {
      collapsedSize: he = 0,
      collapsible: X,
      panelSize: z
    } = Aa(ne, U, Y);
    return rt(z != null, `Panel size not found for panel "${U.id}"`), X === !0 && to(z, he);
  }, []), M = ar((U) => {
    const {
      layout: Y,
      panelDataArray: ne
    } = x.current, {
      collapsedSize: he = 0,
      collapsible: X,
      panelSize: z
    } = Aa(ne, U, Y);
    return rt(z != null, `Panel size not found for panel "${U.id}"`), !X || Tl(z, he) > 0;
  }, []), A = ar((U) => {
    const {
      panelDataArray: Y
    } = x.current;
    Y.push(U), Y.sort((ne, he) => {
      const X = ne.order, z = he.order;
      return X == null && z == null ? 0 : X == null ? -1 : z == null ? 1 : X - z;
    }), x.current.panelDataArrayChanged = !0, b();
  }, [b]);
  ll(() => {
    if (x.current.panelDataArrayChanged) {
      x.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: U,
        onLayout: Y,
        storage: ne
      } = E.current, {
        layout: he,
        panelDataArray: X
      } = x.current;
      let z = null;
      if (U) {
        const ae = ZDe(U, X, ne);
        ae && (v.current = new Map(Object.entries(ae.expandToSizes)), z = ae.layout);
      }
      z == null && (z = qDe({
        panelDataArray: X
      }));
      const ue = gL({
        layout: z,
        panelConstraints: X.map((ae) => ae.constraints)
      });
      pL(he, ue) || (m(ue), x.current.layout = ue, Y && Y(ue), tc(X, ue, _.current));
    }
  }), ll(() => {
    const U = x.current;
    return () => {
      U.layout = [];
    };
  }, []);
  const V = ar((U) => {
    let Y = !1;
    const ne = f.current;
    return ne && window.getComputedStyle(ne, null).getPropertyValue("direction") === "rtl" && (Y = !0), function(X) {
      X.preventDefault();
      const z = f.current;
      if (!z)
        return () => null;
      const {
        direction: ue,
        dragState: ae,
        id: be,
        keyboardResizeBy: de,
        onLayout: _e
      } = E.current, {
        layout: $,
        panelDataArray: ce
      } = x.current, {
        initialLayout: re
      } = ae ?? {}, W = GV(be, U, z);
      let q = WDe(X, U, ue, ae, de, z);
      const ie = ue === "horizontal";
      ie && Y && (q = -q);
      const ye = ce.map((Ce) => Ce.constraints), xe = Dh({
        delta: q,
        initialLayout: re ?? $,
        panelConstraints: ye,
        pivotIndices: W,
        prevLayout: $,
        trigger: LV(X) ? "keyboard" : "mouse-or-touch"
      }), fe = !Gm($, xe);
      (MV(X) || BV(X)) && w.current != q && (w.current = q, !fe && q !== 0 ? ie ? Tw(U, q < 0 ? $V : UV) : Tw(U, q < 0 ? jV : HV) : Tw(U, 0)), fe && (m(xe), x.current.layout = xe, _e && _e(xe), tc(ce, xe, _.current));
    };
  }, []), ee = ar((U, Y) => {
    const {
      onLayout: ne
    } = E.current, {
      layout: he,
      panelDataArray: X
    } = x.current, z = X.map(($) => $.constraints), {
      panelSize: ue,
      pivotIndices: ae
    } = Aa(X, U, he);
    rt(ue != null, `Panel size not found for panel "${U.id}"`);
    const de = cc(X, U) === X.length - 1 ? ue - Y : Y - ue, _e = Dh({
      delta: de,
      initialLayout: he,
      panelConstraints: z,
      pivotIndices: ae,
      prevLayout: he,
      trigger: "imperative-api"
    });
    Gm(he, _e) || (m(_e), x.current.layout = _e, ne && ne(_e), tc(X, _e, _.current));
  }, []), K = ar((U, Y) => {
    const {
      layout: ne,
      panelDataArray: he
    } = x.current, {
      collapsedSize: X = 0,
      collapsible: z
    } = Y, {
      collapsedSize: ue = 0,
      collapsible: ae,
      maxSize: be = 100,
      minSize: de = 0
    } = U.constraints, {
      panelSize: _e
    } = Aa(he, U, ne);
    _e != null && (z && ae && to(_e, X) ? to(X, ue) || ee(U, ue) : _e < de ? ee(U, de) : _e > be && ee(U, be));
  }, [ee]), te = ar((U, Y) => {
    const {
      direction: ne
    } = E.current, {
      layout: he
    } = x.current;
    if (!f.current)
      return;
    const X = c_(U, f.current);
    rt(X, `Drag handle element not found for id "${U}"`);
    const z = WV(ne, Y);
    y({
      dragHandleId: U,
      dragHandleRect: X.getBoundingClientRect(),
      initialCursorPosition: z,
      initialLayout: he
    });
  }, []), N = ar(() => {
    y(null);
  }, []), L = ar((U) => {
    const {
      panelDataArray: Y
    } = x.current, ne = cc(Y, U);
    ne >= 0 && (Y.splice(ne, 1), delete _.current[U.id], x.current.panelDataArrayChanged = !0, b());
  }, [b]), j = CDe(() => ({
    collapsePanel: S,
    direction: r,
    dragState: g,
    expandPanel: T,
    getPanelSize: R,
    getPanelStyle: F,
    groupId: d,
    isPanelCollapsed: P,
    isPanelExpanded: M,
    reevaluatePanelConstraints: K,
    registerPanel: A,
    registerResizeHandle: V,
    resizePanel: ee,
    startDragging: te,
    stopDragging: N,
    unregisterPanel: L,
    panelGroupElement: f.current
  }), [S, g, r, T, R, F, d, P, M, K, A, V, ee, te, N, L]), H = {
    display: "flex",
    flexDirection: r === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return gu(o_.Provider, {
    value: j
  }, gu(u, {
    ...h,
    children: e,
    className: n,
    id: i,
    ref: f,
    style: {
      ...H,
      ...c
    },
    // CSS selectors
    "data-panel-group": "",
    "data-panel-group-direction": r,
    "data-panel-group-id": d
  }));
}
const Mx = PV((t, e) => gu(ZV, {
  ...t,
  forwardedRef: e
}));
ZV.displayName = "PanelGroup";
Mx.displayName = "forwardRef(PanelGroup)";
function cc(t, e) {
  return t.findIndex((n) => n === e || n.id === e.id);
}
function Aa(t, e, n) {
  const r = cc(t, e), i = r === t.length - 1 ? [r - 1, r] : [r, r + 1], o = n[r];
  return {
    ...e.constraints,
    panelSize: o,
    pivotIndices: i
  };
}
function QDe({
  disabled: t,
  handleId: e,
  resizeHandler: n,
  panelGroupElement: r
}) {
  al(() => {
    if (t || n == null || r == null)
      return;
    const s = c_(e, r);
    if (s == null)
      return;
    const i = (o) => {
      if (!o.defaultPrevented)
        switch (o.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            o.preventDefault(), n(o);
            break;
          }
          case "F6": {
            o.preventDefault();
            const a = s.getAttribute("data-panel-group-id");
            rt(a, `No group element found for id "${a}"`);
            const l = yf(a, r), c = zV(a, e, r);
            rt(c !== null, `No resize element found for id "${e}"`);
            const u = o.shiftKey ? c > 0 ? c - 1 : l.length - 1 : c + 1 < l.length ? c + 1 : 0;
            l[u].focus();
            break;
          }
        }
    };
    return s.addEventListener("keydown", i), () => {
      s.removeEventListener("keydown", i);
    };
  }, [r, t, e, n]);
}
function Bx({
  children: t = null,
  className: e = "",
  disabled: n = !1,
  hitAreaMargins: r,
  id: s,
  onBlur: i,
  onDragging: o,
  onFocus: a,
  style: l = {},
  tabIndex: c = 0,
  tagName: u = "div",
  ...h
}) {
  var d, f;
  const g = ur(null), y = ur({
    onDragging: o
  });
  al(() => {
    y.current.onDragging = o;
  });
  const p = OV(o_);
  if (p === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: m,
    groupId: b,
    registerResizeHandle: _,
    startDragging: v,
    stopDragging: w,
    panelGroupElement: E
  } = p, x = RA(s), [S, T] = Uc("inactive"), [R, F] = Uc(!1), [P, M] = Uc(null), A = ur({
    state: S
  });
  ll(() => {
    A.current.state = S;
  }), al(() => {
    if (n)
      M(null);
    else {
      const te = _(x);
      M(() => te);
    }
  }, [n, x, _]);
  const V = (d = r?.coarse) !== null && d !== void 0 ? d : 15, ee = (f = r?.fine) !== null && f !== void 0 ? f : 5;
  return al(() => {
    if (n || P == null)
      return;
    const te = g.current;
    return rt(te, "Element ref not attached"), $De(x, te, m, {
      coarse: V,
      fine: ee
    }, (L, j, H) => {
      if (j)
        switch (L) {
          case "down": {
            T("drag"), rt(H, 'Expected event to be defined for "down" action'), v(x, H);
            const {
              onDragging: U
            } = y.current;
            U && U(!0);
            break;
          }
          case "move": {
            const {
              state: U
            } = A.current;
            U !== "drag" && T("hover"), rt(H, 'Expected event to be defined for "move" action'), P(H);
            break;
          }
          case "up": {
            T("hover"), w();
            const {
              onDragging: U
            } = y.current;
            U && U(!1);
            break;
          }
        }
      else
        T("inactive");
    });
  }, [V, m, n, ee, _, x, P, v, w]), QDe({
    disabled: n,
    handleId: x,
    resizeHandler: P,
    panelGroupElement: E
  }), gu(u, {
    ...h,
    children: t,
    className: e,
    id: s,
    onBlur: () => {
      F(!1), i?.();
    },
    onFocus: () => {
      F(!0), a?.();
    },
    ref: g,
    role: "separator",
    style: {
      ...{
        touchAction: "none",
        userSelect: "none"
      },
      ...l
    },
    tabIndex: c,
    // CSS selectors
    "data-panel-group-direction": m,
    "data-panel-group-id": b,
    "data-resize-handle": "",
    "data-resize-handle-active": S === "drag" ? "pointer" : R ? "keyboard" : void 0,
    "data-resize-handle-state": S,
    "data-panel-resize-handle-enabled": !n,
    "data-panel-resize-handle-id": x
  });
}
Bx.displayName = "PanelResizeHandle";
const bL = I.memo(({ className: t, children: e }) => /* @__PURE__ */ k.jsx(
  "div",
  {
    className: qe(
      "flex items-center gap-2 bg-bolt-elements-background-depth-2 text-bolt-elements-textSecondary border-b border-bolt-elements-borderColor px-4 py-1 min-h-[34px] text-sm",
      t
    ),
    children: e
  }
));
function eNe() {
  return globalThis.innerWidth < 640;
}
function JV(t) {
  const e = t + "CollectionProvider", [n, r] = Ii(e), [s, i] = n(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), o = (f) => {
    const { scope: g, children: y } = f, p = Qe.useRef(null), m = Qe.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ k.jsx(s, { scope: g, itemMap: m, collectionRef: p, children: y });
  };
  o.displayName = e;
  const a = t + "CollectionSlot", l = Qe.forwardRef(
    (f, g) => {
      const { scope: y, children: p } = f, m = i(a, y), b = Yt(g, m.collectionRef);
      return /* @__PURE__ */ k.jsx(dl, { ref: b, children: p });
    }
  );
  l.displayName = a;
  const c = t + "CollectionItemSlot", u = "data-radix-collection-item", h = Qe.forwardRef(
    (f, g) => {
      const { scope: y, children: p, ...m } = f, b = Qe.useRef(null), _ = Yt(g, b), v = i(c, y);
      return Qe.useEffect(() => (v.itemMap.set(b, { ref: b, ...m }), () => void v.itemMap.delete(b))), /* @__PURE__ */ k.jsx(dl, { [u]: "", ref: _, children: p });
    }
  );
  h.displayName = c;
  function d(f) {
    const g = i(t + "CollectionConsumer", f);
    return Qe.useCallback(() => {
      const p = g.collectionRef.current;
      if (!p) return [];
      const m = Array.from(p.querySelectorAll(`[${u}]`));
      return Array.from(g.itemMap.values()).sort(
        (v, w) => m.indexOf(v.ref.current) - m.indexOf(w.ref.current)
      );
    }, [g.collectionRef, g.itemMap]);
  }
  return [
    { Provider: o, Slot: l, ItemSlot: h },
    d,
    r
  ];
}
var tNe = I.createContext(void 0);
function XV(t) {
  const e = I.useContext(tNe);
  return t || e || "ltr";
}
var Cw = "rovingFocusGroup.onEntryFocus", nNe = { bubbles: !1, cancelable: !0 }, u_ = "RovingFocusGroup", [Fx, QV, rNe] = JV(u_), [sNe, eW] = Ii(
  u_,
  [rNe]
), [iNe, oNe] = sNe(u_), tW = I.forwardRef(
  (t, e) => /* @__PURE__ */ k.jsx(Fx.Provider, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ k.jsx(Fx.Slot, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ k.jsx(aNe, { ...t, ref: e }) }) })
);
tW.displayName = u_;
var aNe = I.forwardRef((t, e) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: s = !1,
    dir: i,
    currentTabStopId: o,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: l,
    onEntryFocus: c,
    preventScrollOnEntryFocus: u = !1,
    ...h
  } = t, d = I.useRef(null), f = Yt(e, d), g = XV(i), [y = null, p] = tp({
    prop: o,
    defaultProp: a,
    onChange: l
  }), [m, b] = I.useState(!1), _ = rs(c), v = QV(n), w = I.useRef(!1), [E, x] = I.useState(0);
  return I.useEffect(() => {
    const S = d.current;
    if (S)
      return S.addEventListener(Cw, _), () => S.removeEventListener(Cw, _);
  }, [_]), /* @__PURE__ */ k.jsx(
    iNe,
    {
      scope: n,
      orientation: r,
      dir: g,
      loop: s,
      currentTabStopId: y,
      onItemFocus: I.useCallback(
        (S) => p(S),
        [p]
      ),
      onItemShiftTab: I.useCallback(() => b(!0), []),
      onFocusableItemAdd: I.useCallback(
        () => x((S) => S + 1),
        []
      ),
      onFocusableItemRemove: I.useCallback(
        () => x((S) => S - 1),
        []
      ),
      children: /* @__PURE__ */ k.jsx(
        Pt.div,
        {
          tabIndex: m || E === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: f,
          style: { outline: "none", ...t.style },
          onMouseDown: Ke(t.onMouseDown, () => {
            w.current = !0;
          }),
          onFocus: Ke(t.onFocus, (S) => {
            const T = !w.current;
            if (S.target === S.currentTarget && T && !m) {
              const R = new CustomEvent(Cw, nNe);
              if (S.currentTarget.dispatchEvent(R), !R.defaultPrevented) {
                const F = v().filter((ee) => ee.focusable), P = F.find((ee) => ee.active), M = F.find((ee) => ee.id === y), V = [P, M, ...F].filter(
                  Boolean
                ).map((ee) => ee.ref.current);
                sW(V, u);
              }
            }
            w.current = !1;
          }),
          onBlur: Ke(t.onBlur, () => b(!1))
        }
      )
    }
  );
}), nW = "RovingFocusGroupItem", rW = I.forwardRef(
  (t, e) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: s = !1,
      tabStopId: i,
      ...o
    } = t, a = Ad(), l = i || a, c = oNe(nW, n), u = c.currentTabStopId === l, h = QV(n), { onFocusableItemAdd: d, onFocusableItemRemove: f } = c;
    return I.useEffect(() => {
      if (r)
        return d(), () => f();
    }, [r, d, f]), /* @__PURE__ */ k.jsx(
      Fx.ItemSlot,
      {
        scope: n,
        id: l,
        focusable: r,
        active: s,
        children: /* @__PURE__ */ k.jsx(
          Pt.span,
          {
            tabIndex: u ? 0 : -1,
            "data-orientation": c.orientation,
            ...o,
            ref: e,
            onMouseDown: Ke(t.onMouseDown, (g) => {
              r ? c.onItemFocus(l) : g.preventDefault();
            }),
            onFocus: Ke(t.onFocus, () => c.onItemFocus(l)),
            onKeyDown: Ke(t.onKeyDown, (g) => {
              if (g.key === "Tab" && g.shiftKey) {
                c.onItemShiftTab();
                return;
              }
              if (g.target !== g.currentTarget) return;
              const y = uNe(g, c.orientation, c.dir);
              if (y !== void 0) {
                if (g.metaKey || g.ctrlKey || g.altKey || g.shiftKey) return;
                g.preventDefault();
                let m = h().filter((b) => b.focusable).map((b) => b.ref.current);
                if (y === "last") m.reverse();
                else if (y === "prev" || y === "next") {
                  y === "prev" && m.reverse();
                  const b = m.indexOf(g.currentTarget);
                  m = c.loop ? hNe(m, b + 1) : m.slice(b + 1);
                }
                setTimeout(() => sW(m));
              }
            })
          }
        )
      }
    );
  }
);
rW.displayName = nW;
var lNe = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function cNe(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function uNe(t, e, n) {
  const r = cNe(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return lNe[r];
}
function sW(t, e = !1) {
  const n = document.activeElement;
  for (const r of t)
    if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return;
}
function hNe(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var dNe = tW, fNe = rW, $x = ["Enter", " "], pNe = ["ArrowDown", "PageUp", "Home"], iW = ["ArrowUp", "PageDown", "End"], mNe = [...pNe, ...iW], gNe = {
  ltr: [...$x, "ArrowRight"],
  rtl: [...$x, "ArrowLeft"]
}, yNe = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, _p = "Menu", [bf, bNe, _Ne] = JV(_p), [Ul, h_] = Ii(_p, [
  _Ne,
  Bu,
  eW
]), d_ = Bu(), oW = eW(), [vNe, jl] = Ul(_p), [wNe, vp] = Ul(_p), aW = (t) => {
  const { __scopeMenu: e, open: n = !1, children: r, dir: s, onOpenChange: i, modal: o = !0 } = t, a = d_(e), [l, c] = I.useState(null), u = I.useRef(!1), h = rs(i), d = XV(s);
  return I.useEffect(() => {
    const f = () => {
      u.current = !0, document.addEventListener("pointerdown", g, { capture: !0, once: !0 }), document.addEventListener("pointermove", g, { capture: !0, once: !0 });
    }, g = () => u.current = !1;
    return document.addEventListener("keydown", f, { capture: !0 }), () => {
      document.removeEventListener("keydown", f, { capture: !0 }), document.removeEventListener("pointerdown", g, { capture: !0 }), document.removeEventListener("pointermove", g, { capture: !0 });
    };
  }, []), /* @__PURE__ */ k.jsx(Hk, { ...a, children: /* @__PURE__ */ k.jsx(
    vNe,
    {
      scope: e,
      open: n,
      onOpenChange: h,
      content: l,
      onContentChange: c,
      children: /* @__PURE__ */ k.jsx(
        wNe,
        {
          scope: e,
          onClose: I.useCallback(() => h(!1), [h]),
          isUsingKeyboardRef: u,
          dir: d,
          modal: o,
          children: r
        }
      )
    }
  ) });
};
aW.displayName = _p;
var ENe = "MenuAnchor", DA = I.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, s = d_(n);
    return /* @__PURE__ */ k.jsx(Gb, { ...s, ...r, ref: e });
  }
);
DA.displayName = ENe;
var NA = "MenuPortal", [SNe, lW] = Ul(NA, {
  forceMount: void 0
}), cW = (t) => {
  const { __scopeMenu: e, forceMount: n, children: r, container: s } = t, i = jl(NA, e);
  return /* @__PURE__ */ k.jsx(SNe, { scope: e, forceMount: n, children: /* @__PURE__ */ k.jsx(ls, { present: n || i.open, children: /* @__PURE__ */ k.jsx(rp, { asChild: !0, container: s, children: r }) }) });
};
cW.displayName = NA;
var es = "MenuContent", [xNe, LA] = Ul(es), uW = I.forwardRef(
  (t, e) => {
    const n = lW(es, t.__scopeMenu), { forceMount: r = n.forceMount, ...s } = t, i = jl(es, t.__scopeMenu), o = vp(es, t.__scopeMenu);
    return /* @__PURE__ */ k.jsx(bf.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ k.jsx(ls, { present: r || i.open, children: /* @__PURE__ */ k.jsx(bf.Slot, { scope: t.__scopeMenu, children: o.modal ? /* @__PURE__ */ k.jsx(TNe, { ...s, ref: e }) : /* @__PURE__ */ k.jsx(CNe, { ...s, ref: e }) }) }) });
  }
), TNe = I.forwardRef(
  (t, e) => {
    const n = jl(es, t.__scopeMenu), r = I.useRef(null), s = Yt(e, r);
    return I.useEffect(() => {
      const i = r.current;
      if (i) return _C(i);
    }, []), /* @__PURE__ */ k.jsx(
      MA,
      {
        ...t,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ke(
          t.onFocusOutside,
          (i) => i.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), CNe = I.forwardRef((t, e) => {
  const n = jl(es, t.__scopeMenu);
  return /* @__PURE__ */ k.jsx(
    MA,
    {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), MA = I.forwardRef(
  (t, e) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: s,
      onOpenAutoFocus: i,
      onCloseAutoFocus: o,
      disableOutsidePointerEvents: a,
      onEntryFocus: l,
      onEscapeKeyDown: c,
      onPointerDownOutside: u,
      onFocusOutside: h,
      onInteractOutside: d,
      onDismiss: f,
      disableOutsideScroll: g,
      ...y
    } = t, p = jl(es, n), m = vp(es, n), b = d_(n), _ = oW(n), v = bNe(n), [w, E] = I.useState(null), x = I.useRef(null), S = Yt(e, x, p.onContentChange), T = I.useRef(0), R = I.useRef(""), F = I.useRef(0), P = I.useRef(null), M = I.useRef("right"), A = I.useRef(0), V = g ? db : I.Fragment, ee = g ? { as: dl, allowPinchZoom: !0 } : void 0, K = (N) => {
      const L = R.current + N, j = v().filter((X) => !X.disabled), H = document.activeElement, U = j.find((X) => X.ref.current === H)?.textValue, Y = j.map((X) => X.textValue), ne = FNe(Y, L, U), he = j.find((X) => X.textValue === ne)?.ref.current;
      (function X(z) {
        R.current = z, window.clearTimeout(T.current), z !== "" && (T.current = window.setTimeout(() => X(""), 1e3));
      })(L), he && setTimeout(() => he.focus());
    };
    I.useEffect(() => () => window.clearTimeout(T.current), []), bC();
    const te = I.useCallback((N) => M.current === P.current?.side && UNe(N, P.current?.area), []);
    return /* @__PURE__ */ k.jsx(
      xNe,
      {
        scope: n,
        searchRef: R,
        onItemEnter: I.useCallback(
          (N) => {
            te(N) && N.preventDefault();
          },
          [te]
        ),
        onItemLeave: I.useCallback(
          (N) => {
            te(N) || (x.current?.focus(), E(null));
          },
          [te]
        ),
        onTriggerLeave: I.useCallback(
          (N) => {
            te(N) && N.preventDefault();
          },
          [te]
        ),
        pointerGraceTimerRef: F,
        onPointerGraceIntentChange: I.useCallback((N) => {
          P.current = N;
        }, []),
        children: /* @__PURE__ */ k.jsx(V, { ...ee, children: /* @__PURE__ */ k.jsx(
          ub,
          {
            asChild: !0,
            trapped: s,
            onMountAutoFocus: Ke(i, (N) => {
              N.preventDefault(), x.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: o,
            children: /* @__PURE__ */ k.jsx(
              np,
              {
                asChild: !0,
                disableOutsidePointerEvents: a,
                onEscapeKeyDown: c,
                onPointerDownOutside: u,
                onFocusOutside: h,
                onInteractOutside: d,
                onDismiss: f,
                children: /* @__PURE__ */ k.jsx(
                  dNe,
                  {
                    asChild: !0,
                    ..._,
                    dir: m.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: w,
                    onCurrentTabStopIdChange: E,
                    onEntryFocus: Ke(l, (N) => {
                      m.isUsingKeyboardRef.current || N.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ k.jsx(
                      zk,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": CW(p.open),
                        "data-radix-menu-content": "",
                        dir: m.dir,
                        ...b,
                        ...y,
                        ref: S,
                        style: { outline: "none", ...y.style },
                        onKeyDown: Ke(y.onKeyDown, (N) => {
                          const j = N.target.closest("[data-radix-menu-content]") === N.currentTarget, H = N.ctrlKey || N.altKey || N.metaKey, U = N.key.length === 1;
                          j && (N.key === "Tab" && N.preventDefault(), !H && U && K(N.key));
                          const Y = x.current;
                          if (N.target !== Y || !mNe.includes(N.key)) return;
                          N.preventDefault();
                          const he = v().filter((X) => !X.disabled).map((X) => X.ref.current);
                          iW.includes(N.key) && he.reverse(), MNe(he);
                        }),
                        onBlur: Ke(t.onBlur, (N) => {
                          N.currentTarget.contains(N.target) || (window.clearTimeout(T.current), R.current = "");
                        }),
                        onPointerMove: Ke(
                          t.onPointerMove,
                          _f((N) => {
                            const L = N.target, j = A.current !== N.clientX;
                            if (N.currentTarget.contains(L) && j) {
                              const H = N.clientX > A.current ? "right" : "left";
                              M.current = H, A.current = N.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
uW.displayName = es;
var kNe = "MenuGroup", BA = I.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ k.jsx(Pt.div, { role: "group", ...r, ref: e });
  }
);
BA.displayName = kNe;
var ANe = "MenuLabel", hW = I.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ k.jsx(Pt.div, { ...r, ref: e });
  }
);
hW.displayName = ANe;
var Ry = "MenuItem", _L = "menu.itemSelect", f_ = I.forwardRef(
  (t, e) => {
    const { disabled: n = !1, onSelect: r, ...s } = t, i = I.useRef(null), o = vp(Ry, t.__scopeMenu), a = LA(Ry, t.__scopeMenu), l = Yt(e, i), c = I.useRef(!1), u = () => {
      const h = i.current;
      if (!n && h) {
        const d = new CustomEvent(_L, { bubbles: !0, cancelable: !0 });
        h.addEventListener(_L, (f) => r?.(f), { once: !0 }), d4(h, d), d.defaultPrevented ? c.current = !1 : o.onClose();
      }
    };
    return /* @__PURE__ */ k.jsx(
      dW,
      {
        ...s,
        ref: l,
        disabled: n,
        onClick: Ke(t.onClick, u),
        onPointerDown: (h) => {
          t.onPointerDown?.(h), c.current = !0;
        },
        onPointerUp: Ke(t.onPointerUp, (h) => {
          c.current || h.currentTarget?.click();
        }),
        onKeyDown: Ke(t.onKeyDown, (h) => {
          const d = a.searchRef.current !== "";
          n || d && h.key === " " || $x.includes(h.key) && (h.currentTarget.click(), h.preventDefault());
        })
      }
    );
  }
);
f_.displayName = Ry;
var dW = I.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: s, ...i } = t, o = LA(Ry, n), a = oW(n), l = I.useRef(null), c = Yt(e, l), [u, h] = I.useState(!1), [d, f] = I.useState("");
    return I.useEffect(() => {
      const g = l.current;
      g && f((g.textContent ?? "").trim());
    }, [i.children]), /* @__PURE__ */ k.jsx(
      bf.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: s ?? d,
        children: /* @__PURE__ */ k.jsx(fNe, { asChild: !0, ...a, focusable: !r, children: /* @__PURE__ */ k.jsx(
          Pt.div,
          {
            role: "menuitem",
            "data-highlighted": u ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...i,
            ref: c,
            onPointerMove: Ke(
              t.onPointerMove,
              _f((g) => {
                r ? o.onItemLeave(g) : (o.onItemEnter(g), g.defaultPrevented || g.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Ke(
              t.onPointerLeave,
              _f((g) => o.onItemLeave(g))
            ),
            onFocus: Ke(t.onFocus, () => h(!0)),
            onBlur: Ke(t.onBlur, () => h(!1))
          }
        ) })
      }
    );
  }
), RNe = "MenuCheckboxItem", fW = I.forwardRef(
  (t, e) => {
    const { checked: n = !1, onCheckedChange: r, ...s } = t;
    return /* @__PURE__ */ k.jsx(bW, { scope: t.__scopeMenu, checked: n, children: /* @__PURE__ */ k.jsx(
      f_,
      {
        role: "menuitemcheckbox",
        "aria-checked": Iy(n) ? "mixed" : n,
        ...s,
        ref: e,
        "data-state": $A(n),
        onSelect: Ke(
          s.onSelect,
          () => r?.(Iy(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
fW.displayName = RNe;
var pW = "MenuRadioGroup", [INe, PNe] = Ul(
  pW,
  { value: void 0, onValueChange: () => {
  } }
), mW = I.forwardRef(
  (t, e) => {
    const { value: n, onValueChange: r, ...s } = t, i = rs(r);
    return /* @__PURE__ */ k.jsx(INe, { scope: t.__scopeMenu, value: n, onValueChange: i, children: /* @__PURE__ */ k.jsx(BA, { ...s, ref: e }) });
  }
);
mW.displayName = pW;
var gW = "MenuRadioItem", yW = I.forwardRef(
  (t, e) => {
    const { value: n, ...r } = t, s = PNe(gW, t.__scopeMenu), i = n === s.value;
    return /* @__PURE__ */ k.jsx(bW, { scope: t.__scopeMenu, checked: i, children: /* @__PURE__ */ k.jsx(
      f_,
      {
        role: "menuitemradio",
        "aria-checked": i,
        ...r,
        ref: e,
        "data-state": $A(i),
        onSelect: Ke(
          r.onSelect,
          () => s.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
yW.displayName = gW;
var FA = "MenuItemIndicator", [bW, ONe] = Ul(
  FA,
  { checked: !1 }
), _W = I.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, forceMount: r, ...s } = t, i = ONe(FA, n);
    return /* @__PURE__ */ k.jsx(
      ls,
      {
        present: r || Iy(i.checked) || i.checked === !0,
        children: /* @__PURE__ */ k.jsx(
          Pt.span,
          {
            ...s,
            ref: e,
            "data-state": $A(i.checked)
          }
        )
      }
    );
  }
);
_W.displayName = FA;
var DNe = "MenuSeparator", vW = I.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ k.jsx(
      Pt.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: e
      }
    );
  }
);
vW.displayName = DNe;
var NNe = "MenuArrow", wW = I.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, s = d_(n);
    return /* @__PURE__ */ k.jsx(Gk, { ...s, ...r, ref: e });
  }
);
wW.displayName = NNe;
var LNe = "MenuSub", [nWe, EW] = Ul(LNe), Lh = "MenuSubTrigger", SW = I.forwardRef(
  (t, e) => {
    const n = jl(Lh, t.__scopeMenu), r = vp(Lh, t.__scopeMenu), s = EW(Lh, t.__scopeMenu), i = LA(Lh, t.__scopeMenu), o = I.useRef(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: l } = i, c = { __scopeMenu: t.__scopeMenu }, u = I.useCallback(() => {
      o.current && window.clearTimeout(o.current), o.current = null;
    }, []);
    return I.useEffect(() => u, [u]), I.useEffect(() => {
      const h = a.current;
      return () => {
        window.clearTimeout(h), l(null);
      };
    }, [a, l]), /* @__PURE__ */ k.jsx(DA, { asChild: !0, ...c, children: /* @__PURE__ */ k.jsx(
      dW,
      {
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": s.contentId,
        "data-state": CW(n.open),
        ...t,
        ref: cb(e, s.onTriggerChange),
        onClick: (h) => {
          t.onClick?.(h), !(t.disabled || h.defaultPrevented) && (h.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Ke(
          t.onPointerMove,
          _f((h) => {
            i.onItemEnter(h), !h.defaultPrevented && !t.disabled && !n.open && !o.current && (i.onPointerGraceIntentChange(null), o.current = window.setTimeout(() => {
              n.onOpenChange(!0), u();
            }, 100));
          })
        ),
        onPointerLeave: Ke(
          t.onPointerLeave,
          _f((h) => {
            u();
            const d = n.content?.getBoundingClientRect();
            if (d) {
              const f = n.content?.dataset.side, g = f === "right", y = g ? -5 : 5, p = d[g ? "left" : "right"], m = d[g ? "right" : "left"];
              i.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: h.clientX + y, y: h.clientY },
                  { x: p, y: d.top },
                  { x: m, y: d.top },
                  { x: m, y: d.bottom },
                  { x: p, y: d.bottom }
                ],
                side: f
              }), window.clearTimeout(a.current), a.current = window.setTimeout(
                () => i.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (i.onTriggerLeave(h), h.defaultPrevented) return;
              i.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ke(t.onKeyDown, (h) => {
          const d = i.searchRef.current !== "";
          t.disabled || d && h.key === " " || gNe[r.dir].includes(h.key) && (n.onOpenChange(!0), n.content?.focus(), h.preventDefault());
        })
      }
    ) });
  }
);
SW.displayName = Lh;
var xW = "MenuSubContent", TW = I.forwardRef(
  (t, e) => {
    const n = lW(es, t.__scopeMenu), { forceMount: r = n.forceMount, ...s } = t, i = jl(es, t.__scopeMenu), o = vp(es, t.__scopeMenu), a = EW(xW, t.__scopeMenu), l = I.useRef(null), c = Yt(e, l);
    return /* @__PURE__ */ k.jsx(bf.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ k.jsx(ls, { present: r || i.open, children: /* @__PURE__ */ k.jsx(bf.Slot, { scope: t.__scopeMenu, children: /* @__PURE__ */ k.jsx(
      MA,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...s,
        ref: c,
        align: "start",
        side: o.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (u) => {
          o.isUsingKeyboardRef.current && l.current?.focus(), u.preventDefault();
        },
        onCloseAutoFocus: (u) => u.preventDefault(),
        onFocusOutside: Ke(t.onFocusOutside, (u) => {
          u.target !== a.trigger && i.onOpenChange(!1);
        }),
        onEscapeKeyDown: Ke(t.onEscapeKeyDown, (u) => {
          o.onClose(), u.preventDefault();
        }),
        onKeyDown: Ke(t.onKeyDown, (u) => {
          const h = u.currentTarget.contains(u.target), d = yNe[o.dir].includes(u.key);
          h && d && (i.onOpenChange(!1), a.trigger?.focus(), u.preventDefault());
        })
      }
    ) }) }) });
  }
);
TW.displayName = xW;
function CW(t) {
  return t ? "open" : "closed";
}
function Iy(t) {
  return t === "indeterminate";
}
function $A(t) {
  return Iy(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function MNe(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return;
}
function BNe(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
function FNe(t, e, n) {
  const s = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e, i = n ? t.indexOf(n) : -1;
  let o = BNe(t, Math.max(i, 0));
  s.length === 1 && (o = o.filter((c) => c !== n));
  const l = o.find(
    (c) => c.toLowerCase().startsWith(s.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function $Ne(t, e) {
  const { x: n, y: r } = t;
  let s = !1;
  for (let i = 0, o = e.length - 1; i < e.length; o = i++) {
    const a = e[i].x, l = e[i].y, c = e[o].x, u = e[o].y;
    l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (s = !s);
  }
  return s;
}
function UNe(t, e) {
  if (!e) return !1;
  const n = { x: t.clientX, y: t.clientY };
  return $Ne(n, e);
}
function _f(t) {
  return (e) => e.pointerType === "mouse" ? t(e) : void 0;
}
var kW = aW, AW = DA, RW = cW, IW = uW, PW = BA, OW = hW, DW = f_, NW = fW, LW = mW, MW = yW, BW = _W, FW = vW, $W = wW, UW = SW, jW = TW, UA = "DropdownMenu", [jNe, rWe] = Ii(
  UA,
  [h_]
), sr = h_(), [HNe, HW] = jNe(UA), zW = (t) => {
  const {
    __scopeDropdownMenu: e,
    children: n,
    dir: r,
    open: s,
    defaultOpen: i,
    onOpenChange: o,
    modal: a = !0
  } = t, l = sr(e), c = I.useRef(null), [u = !1, h] = tp({
    prop: s,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ k.jsx(
    HNe,
    {
      scope: e,
      triggerId: Ad(),
      triggerRef: c,
      contentId: Ad(),
      open: u,
      onOpenChange: h,
      onOpenToggle: I.useCallback(() => h((d) => !d), [h]),
      modal: a,
      children: /* @__PURE__ */ k.jsx(kW, { ...l, open: u, onOpenChange: h, dir: r, modal: a, children: n })
    }
  );
};
zW.displayName = UA;
var GW = "DropdownMenuTrigger", VW = I.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...s } = t, i = HW(GW, n), o = sr(n);
    return /* @__PURE__ */ k.jsx(AW, { asChild: !0, ...o, children: /* @__PURE__ */ k.jsx(
      Pt.button,
      {
        type: "button",
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": i.open,
        "aria-controls": i.open ? i.contentId : void 0,
        "data-state": i.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...s,
        ref: cb(e, i.triggerRef),
        onPointerDown: Ke(t.onPointerDown, (a) => {
          !r && a.button === 0 && a.ctrlKey === !1 && (i.onOpenToggle(), i.open || a.preventDefault());
        }),
        onKeyDown: Ke(t.onKeyDown, (a) => {
          r || (["Enter", " "].includes(a.key) && i.onOpenToggle(), a.key === "ArrowDown" && i.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
        })
      }
    ) });
  }
);
VW.displayName = GW;
var zNe = "DropdownMenuPortal", WW = (t) => {
  const { __scopeDropdownMenu: e, ...n } = t, r = sr(e);
  return /* @__PURE__ */ k.jsx(RW, { ...r, ...n });
};
WW.displayName = zNe;
var qW = "DropdownMenuContent", KW = I.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = HW(qW, n), i = sr(n), o = I.useRef(!1);
    return /* @__PURE__ */ k.jsx(
      IW,
      {
        id: s.contentId,
        "aria-labelledby": s.triggerId,
        ...i,
        ...r,
        ref: e,
        onCloseAutoFocus: Ke(t.onCloseAutoFocus, (a) => {
          o.current || s.triggerRef.current?.focus(), o.current = !1, a.preventDefault();
        }),
        onInteractOutside: Ke(t.onInteractOutside, (a) => {
          const l = a.detail.originalEvent, c = l.button === 0 && l.ctrlKey === !0, u = l.button === 2 || c;
          (!s.modal || u) && (o.current = !0);
        }),
        style: {
          ...t.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
KW.displayName = qW;
var GNe = "DropdownMenuGroup", VNe = I.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
    return /* @__PURE__ */ k.jsx(PW, { ...s, ...r, ref: e });
  }
);
VNe.displayName = GNe;
var WNe = "DropdownMenuLabel", qNe = I.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
    return /* @__PURE__ */ k.jsx(OW, { ...s, ...r, ref: e });
  }
);
qNe.displayName = WNe;
var KNe = "DropdownMenuItem", YNe = I.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
    return /* @__PURE__ */ k.jsx(DW, { ...s, ...r, ref: e });
  }
);
YNe.displayName = KNe;
var ZNe = "DropdownMenuCheckboxItem", JNe = I.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
  return /* @__PURE__ */ k.jsx(NW, { ...s, ...r, ref: e });
});
JNe.displayName = ZNe;
var XNe = "DropdownMenuRadioGroup", QNe = I.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
  return /* @__PURE__ */ k.jsx(LW, { ...s, ...r, ref: e });
});
QNe.displayName = XNe;
var eLe = "DropdownMenuRadioItem", tLe = I.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
  return /* @__PURE__ */ k.jsx(MW, { ...s, ...r, ref: e });
});
tLe.displayName = eLe;
var nLe = "DropdownMenuItemIndicator", rLe = I.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
  return /* @__PURE__ */ k.jsx(BW, { ...s, ...r, ref: e });
});
rLe.displayName = nLe;
var sLe = "DropdownMenuSeparator", iLe = I.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
  return /* @__PURE__ */ k.jsx(FW, { ...s, ...r, ref: e });
});
iLe.displayName = sLe;
var oLe = "DropdownMenuArrow", YW = I.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
    return /* @__PURE__ */ k.jsx($W, { ...s, ...r, ref: e });
  }
);
YW.displayName = oLe;
var aLe = "DropdownMenuSubTrigger", lLe = I.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
  return /* @__PURE__ */ k.jsx(UW, { ...s, ...r, ref: e });
});
lLe.displayName = aLe;
var cLe = "DropdownMenuSubContent", uLe = I.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = sr(n);
  return /* @__PURE__ */ k.jsx(
    jW,
    {
      ...s,
      ...r,
      ref: e,
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
uLe.displayName = cLe;
var hLe = zW, dLe = VW, fLe = WW, pLe = KW, mLe = YW, jA = "ContextMenu", [gLe, sWe] = Ii(jA, [
  h_
]), ir = h_(), [yLe, ZW] = gLe(jA), JW = (t) => {
  const { __scopeContextMenu: e, children: n, onOpenChange: r, dir: s, modal: i = !0 } = t, [o, a] = I.useState(!1), l = ir(e), c = rs(r), u = I.useCallback(
    (h) => {
      a(h), c(h);
    },
    [c]
  );
  return /* @__PURE__ */ k.jsx(
    yLe,
    {
      scope: e,
      open: o,
      onOpenChange: u,
      modal: i,
      children: /* @__PURE__ */ k.jsx(
        kW,
        {
          ...l,
          dir: s,
          open: o,
          onOpenChange: u,
          modal: i,
          children: n
        }
      )
    }
  );
};
JW.displayName = jA;
var XW = "ContextMenuTrigger", QW = I.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, disabled: r = !1, ...s } = t, i = ZW(XW, n), o = ir(n), a = I.useRef({ x: 0, y: 0 }), l = I.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...a.current })
    }), c = I.useRef(0), u = I.useCallback(
      () => window.clearTimeout(c.current),
      []
    ), h = (d) => {
      a.current = { x: d.clientX, y: d.clientY }, i.onOpenChange(!0);
    };
    return I.useEffect(() => u, [u]), I.useEffect(() => void (r && u()), [r, u]), /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
      /* @__PURE__ */ k.jsx(AW, { ...o, virtualRef: l }),
      /* @__PURE__ */ k.jsx(
        Pt.span,
        {
          "data-state": i.open ? "open" : "closed",
          "data-disabled": r ? "" : void 0,
          ...s,
          ref: e,
          style: { WebkitTouchCallout: "none", ...t.style },
          onContextMenu: r ? t.onContextMenu : Ke(t.onContextMenu, (d) => {
            u(), h(d), d.preventDefault();
          }),
          onPointerDown: r ? t.onPointerDown : Ke(
            t.onPointerDown,
            Vm((d) => {
              u(), c.current = window.setTimeout(() => h(d), 700);
            })
          ),
          onPointerMove: r ? t.onPointerMove : Ke(t.onPointerMove, Vm(u)),
          onPointerCancel: r ? t.onPointerCancel : Ke(t.onPointerCancel, Vm(u)),
          onPointerUp: r ? t.onPointerUp : Ke(t.onPointerUp, Vm(u))
        }
      )
    ] });
  }
);
QW.displayName = XW;
var bLe = "ContextMenuPortal", eq = (t) => {
  const { __scopeContextMenu: e, ...n } = t, r = ir(e);
  return /* @__PURE__ */ k.jsx(RW, { ...r, ...n });
};
eq.displayName = bLe;
var tq = "ContextMenuContent", nq = I.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = ZW(tq, n), i = ir(n), o = I.useRef(!1);
    return /* @__PURE__ */ k.jsx(
      IW,
      {
        ...i,
        ...r,
        ref: e,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (a) => {
          t.onCloseAutoFocus?.(a), !a.defaultPrevented && o.current && a.preventDefault(), o.current = !1;
        },
        onInteractOutside: (a) => {
          t.onInteractOutside?.(a), !a.defaultPrevented && !s.modal && (o.current = !0);
        },
        style: {
          ...t.style,
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
nq.displayName = tq;
var _Le = "ContextMenuGroup", rq = I.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = ir(n);
    return /* @__PURE__ */ k.jsx(PW, { ...s, ...r, ref: e });
  }
);
rq.displayName = _Le;
var vLe = "ContextMenuLabel", wLe = I.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = ir(n);
    return /* @__PURE__ */ k.jsx(OW, { ...s, ...r, ref: e });
  }
);
wLe.displayName = vLe;
var ELe = "ContextMenuItem", sq = I.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = ir(n);
    return /* @__PURE__ */ k.jsx(DW, { ...s, ...r, ref: e });
  }
);
sq.displayName = ELe;
var SLe = "ContextMenuCheckboxItem", xLe = I.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = ir(n);
  return /* @__PURE__ */ k.jsx(NW, { ...s, ...r, ref: e });
});
xLe.displayName = SLe;
var TLe = "ContextMenuRadioGroup", CLe = I.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = ir(n);
  return /* @__PURE__ */ k.jsx(LW, { ...s, ...r, ref: e });
});
CLe.displayName = TLe;
var kLe = "ContextMenuRadioItem", ALe = I.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = ir(n);
  return /* @__PURE__ */ k.jsx(MW, { ...s, ...r, ref: e });
});
ALe.displayName = kLe;
var RLe = "ContextMenuItemIndicator", ILe = I.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = ir(n);
  return /* @__PURE__ */ k.jsx(BW, { ...s, ...r, ref: e });
});
ILe.displayName = RLe;
var PLe = "ContextMenuSeparator", OLe = I.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = ir(n);
  return /* @__PURE__ */ k.jsx(FW, { ...s, ...r, ref: e });
});
OLe.displayName = PLe;
var DLe = "ContextMenuArrow", NLe = I.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = ir(n);
    return /* @__PURE__ */ k.jsx($W, { ...s, ...r, ref: e });
  }
);
NLe.displayName = DLe;
var LLe = "ContextMenuSubTrigger", MLe = I.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = ir(n);
  return /* @__PURE__ */ k.jsx(UW, { ...s, ...r, ref: e });
});
MLe.displayName = LLe;
var BLe = "ContextMenuSubContent", FLe = I.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = ir(n);
  return /* @__PURE__ */ k.jsx(
    jW,
    {
      ...s,
      ...r,
      ref: e,
      style: {
        ...t.style,
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
FLe.displayName = BLe;
function Vm(t) {
  return (e) => e.pointerType !== "mouse" ? t(e) : void 0;
}
var $Le = JW, ULe = QW, jLe = eq, HLe = nq, zLe = rq, GLe = sq;
const Ux = Sr("FileTree"), VLe = 8, WLe = [/\/node_modules\//, /\/\.next/, /\/\.astro/], iq = I.memo(
  ({
    files: t = {},
    onFileSelect: e,
    selectedFile: n,
    rootFolder: r,
    hideRoot: s = !1,
    collapsed: i = !1,
    allowFolderSelection: o = !1,
    hiddenFiles: a,
    className: l,
    unsavedFiles: c
  }) => {
    Eu.trace("FileTree");
    const u = I.useMemo(() => [...WLe, ...a ?? []], [a]), h = I.useMemo(() => YLe(t, r, s, u), [t, r, s, u]), [d, f] = I.useState(() => i ? new Set(h.filter((b) => b.kind === "folder").map((b) => b.fullPath)) : /* @__PURE__ */ new Set());
    I.useEffect(() => {
      if (i) {
        f(new Set(h.filter((b) => b.kind === "folder").map((b) => b.fullPath)));
        return;
      }
      f((b) => {
        const _ = /* @__PURE__ */ new Set();
        for (const v of h)
          v.kind === "folder" && b.has(v.fullPath) && _.add(v.fullPath);
        return _;
      });
    }, [h, i]);
    const g = I.useMemo(() => {
      const b = [];
      let _ = Number.MAX_SAFE_INTEGER;
      for (const v of h) {
        const w = v.depth;
        _ === w && (_ = Number.MAX_SAFE_INTEGER), d.has(v.fullPath) && (_ = Math.min(_, w)), !(_ < w) && b.push(v);
      }
      return b;
    }, [h, d]), y = (b) => {
      f((_) => {
        const v = new Set(_);
        return v.has(b) ? v.delete(b) : v.add(b), v;
      });
    }, p = (b) => {
      try {
        navigator.clipboard.writeText(b.fullPath);
      } catch (_) {
        Ux.error(_);
      }
    }, m = (b) => {
      try {
        navigator.clipboard.writeText(b.fullPath.substring((r || "").length));
      } catch (_) {
        Ux.error(_);
      }
    };
    return /* @__PURE__ */ k.jsx("div", { className: qe("text-sm", l, "overflow-y-auto"), children: g.map((b) => {
      switch (b.kind) {
        case "file":
          return /* @__PURE__ */ k.jsx(
            KLe,
            {
              selected: n === b.fullPath,
              file: b,
              unsavedChanges: c?.has(b.fullPath),
              onCopyPath: () => {
                p(b);
              },
              onCopyRelativePath: () => {
                m(b);
              },
              onClick: () => {
                e?.(b.fullPath);
              }
            },
            b.id
          );
        case "folder":
          return /* @__PURE__ */ k.jsx(
            qLe,
            {
              folder: b,
              selected: o && n === b.fullPath,
              collapsed: d.has(b.fullPath),
              onCopyPath: () => {
                p(b);
              },
              onCopyRelativePath: () => {
                m(b);
              },
              onClick: () => {
                y(b.fullPath);
              }
            },
            b.id
          );
        default:
          return;
      }
    }) });
  }
);
function vL({ onSelect: t, children: e }) {
  return /* @__PURE__ */ k.jsxs(
    GLe,
    {
      onSelect: t,
      className: "flex items-center gap-2 px-2 py-1.5 outline-0 text-sm text-bolt-elements-textPrimary cursor-pointer ws-nowrap text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive hover:bg-bolt-elements-item-backgroundActive rounded-md",
      children: [
        /* @__PURE__ */ k.jsx("span", { className: "size-4 shrink-0" }),
        /* @__PURE__ */ k.jsx("span", { children: e })
      ]
    }
  );
}
function oq({ onCopyPath: t, onCopyRelativePath: e, children: n }) {
  return /* @__PURE__ */ k.jsxs($Le, { children: [
    /* @__PURE__ */ k.jsx(ULe, { children: n }),
    /* @__PURE__ */ k.jsx(jLe, { children: /* @__PURE__ */ k.jsx(
      HLe,
      {
        style: { zIndex: 998 },
        className: "border border-bolt-elements-borderColor rounded-md z-context-menu bg-bolt-elements-background-depth-1 dark:bg-bolt-elements-background-depth-2 data-[state=open]:animate-in animate-duration-100 data-[state=open]:fade-in-0 data-[state=open]:zoom-in-98 w-56",
        children: /* @__PURE__ */ k.jsxs(zLe, { className: "p-1 border-b-px border-solid border-bolt-elements-borderColor", children: [
          /* @__PURE__ */ k.jsx(vL, { onSelect: t, children: "Copy path" }),
          /* @__PURE__ */ k.jsx(vL, { onSelect: e, children: "Copy relative path" })
        ] })
      }
    ) })
  ] });
}
function qLe({ folder: t, collapsed: e, selected: n = !1, onCopyPath: r, onCopyRelativePath: s, onClick: i }) {
  return /* @__PURE__ */ k.jsx(oq, { onCopyPath: r, onCopyRelativePath: s, children: /* @__PURE__ */ k.jsx(
    aq,
    {
      className: qe("group", {
        "bg-transparent text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive hover:bg-bolt-elements-item-backgroundActive": !n,
        "bg-bolt-elements-item-backgroundAccent text-bolt-elements-item-contentAccent": n
      }),
      depth: t.depth,
      iconClasses: qe({
        "i-ph:caret-right scale-98": e,
        "i-ph:caret-down scale-98": !e
      }),
      onClick: i,
      children: t.name
    }
  ) });
}
function KLe({
  file: { depth: t, name: e },
  onClick: n,
  onCopyPath: r,
  onCopyRelativePath: s,
  selected: i,
  unsavedChanges: o = !1
}) {
  return /* @__PURE__ */ k.jsx(oq, { onCopyPath: r, onCopyRelativePath: s, children: /* @__PURE__ */ k.jsx(
    aq,
    {
      className: qe("group", {
        "bg-transparent hover:bg-bolt-elements-item-backgroundActive text-bolt-elements-item-contentDefault": !i,
        "bg-bolt-elements-item-backgroundAccent text-bolt-elements-item-contentAccent": i
      }),
      depth: t,
      iconClasses: qe("i-ph:file-duotone scale-98", {
        "group-hover:text-bolt-elements-item-contentActive": !i
      }),
      onClick: n,
      children: /* @__PURE__ */ k.jsxs(
        "div",
        {
          className: qe("flex items-center", {
            "group-hover:text-bolt-elements-item-contentActive": !i
          }),
          children: [
            /* @__PURE__ */ k.jsx("div", { className: "flex-1 truncate pr-2", children: e }),
            o && /* @__PURE__ */ k.jsx("span", { className: "i-ph:circle-fill scale-68 shrink-0 text-orange-500" })
          ]
        }
      )
    }
  ) });
}
function aq({ depth: t, iconClasses: e, onClick: n, className: r, children: s }) {
  return /* @__PURE__ */ k.jsxs(
    "button",
    {
      className: qe(
        "flex items-center gap-1.5 w-full pr-2 border-2 border-transparent text-faded py-0.5",
        r
      ),
      style: { paddingLeft: `${6 + t * VLe}px` },
      onClick: () => n?.(),
      children: [
        /* @__PURE__ */ k.jsx("div", { className: qe("scale-120 shrink-0", e) }),
        /* @__PURE__ */ k.jsx("div", { className: "truncate w-full text-left", children: s })
      ]
    }
  );
}
function YLe(t, e = "/", n, r) {
  const s = /* @__PURE__ */ new Set(), i = [];
  let o = 0;
  e === "/" && !n && (o = 1, i.push({ kind: "folder", name: "/", depth: 0, id: 0, fullPath: "/" }));
  for (const [a, l] of Object.entries(t)) {
    const c = a.split("/").filter((g) => g), u = c.at(-1);
    if (!u || ZLe(a, u, r))
      continue;
    let h = "", d = 0, f = 0;
    for (; d < c.length; ) {
      const g = c[d], y = h += `/${g}`;
      if (!y.startsWith(e) || n && y === e) {
        d++;
        continue;
      }
      d === c.length - 1 && l?.type === "file" ? i.push({
        kind: "file",
        id: i.length,
        name: g,
        fullPath: y,
        depth: f + o
      }) : s.has(y) || (s.add(y), i.push({
        kind: "folder",
        id: i.length,
        name: g,
        fullPath: y,
        depth: f + o
      })), d++, f++;
    }
  }
  return JLe(e, i, n);
}
function ZLe(t, e, n) {
  return n.some((r) => typeof r == "string" ? e === r : r.test(t));
}
function JLe(t, e, n) {
  Ux.trace("sortFileList");
  const r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  e.sort((a, l) => XLe(a, l));
  for (const a of e) {
    r.set(a.fullPath, a);
    const l = a.fullPath.slice(0, a.fullPath.lastIndexOf("/"));
    l !== t.slice(0, t.lastIndexOf("/")) && (s.has(l) || s.set(l, []), s.get(l)?.push(a));
  }
  const i = [], o = (a) => {
    const l = r.get(a);
    l && i.push(l);
    const c = s.get(a);
    if (c)
      for (const u of c)
        u.kind === "folder" ? o(u.fullPath) : i.push(u);
  };
  if (n) {
    const a = s.get(t) || [];
    for (const l of a)
      o(l.fullPath);
  } else
    o(t);
  return i;
}
function XLe(t, e) {
  return t.kind !== e.kind ? t.kind === "folder" ? -1 : 1 : t.name.localeCompare(e.name, void 0, { numeric: !0, sensitivity: "base" });
}
const QLe = new RegExp(`^${ia.split("/").slice(0, -1).join("/").replaceAll("/", "\\/")}/`), eMe = {
  open: {
    y: 0,
    opacity: 1,
    transition: {
      duration: 0.15,
      ease: xs
    }
  },
  close: {
    y: 6,
    opacity: 0,
    transition: {
      duration: 0.15,
      ease: xs
    }
  }
}, tMe = I.memo(({ files: t, pathSegments: e = [], onFileSelect: n }) => {
  Eu.trace("FileBreadcrumb");
  const [r, s] = I.useState(null), i = I.useRef(null), o = I.useRef([]), a = (l) => {
    s((c) => c === l ? null : l);
  };
  return I.useEffect(() => {
    const l = (c) => {
      r !== null && !i.current?.contains(c.target) && !o.current.some((u) => u?.contains(c.target)) && s(null);
    };
    return document.addEventListener("mousedown", l), () => {
      document.removeEventListener("mousedown", l);
    };
  }, [r]), t === void 0 || e.length === 0 ? null : /* @__PURE__ */ k.jsx("div", { className: "flex", children: e.map((l, c) => {
    const u = c === e.length - 1, h = e.slice(0, c).join("/");
    if (!QLe.test(h))
      return null;
    const d = r === c;
    return /* @__PURE__ */ k.jsx("div", { className: "relative flex items-center", children: /* @__PURE__ */ k.jsxs(hLe, { open: d, modal: !1, children: [
      /* @__PURE__ */ k.jsx(dLe, { asChild: !0, children: /* @__PURE__ */ k.jsxs(
        "span",
        {
          ref: (f) => o.current[c] = f,
          className: qe("flex items-center gap-1.5 cursor-pointer shrink-0", {
            "text-bolt-elements-textTertiary hover:text-bolt-elements-textPrimary": !d,
            "text-bolt-elements-textPrimary underline": d,
            "pr-4": u
          }),
          onClick: () => a(c),
          children: [
            u && /* @__PURE__ */ k.jsx("div", { className: "i-ph:file-duotone" }),
            l
          ]
        }
      ) }),
      c > 0 && !u && /* @__PURE__ */ k.jsx("span", { className: "i-ph:caret-right inline-block mx-1" }),
      /* @__PURE__ */ k.jsx(cl, { children: d && /* @__PURE__ */ k.jsx(fLe, { children: /* @__PURE__ */ k.jsx(
        pLe,
        {
          className: "z-file-tree-breadcrumb",
          asChild: !0,
          align: "start",
          side: "bottom",
          avoidCollisions: !1,
          children: /* @__PURE__ */ k.jsxs(
            hn.div,
            {
              ref: i,
              initial: "close",
              animate: "open",
              exit: "close",
              variants: eMe,
              children: [
                /* @__PURE__ */ k.jsx("div", { className: "rounded-lg overflow-hidden", children: /* @__PURE__ */ k.jsx("div", { className: "max-h-[50vh] min-w-[300px] overflow-scroll bg-bolt-elements-background-depth-1 border border-bolt-elements-borderColor shadow-sm rounded-lg", children: /* @__PURE__ */ k.jsx(
                  iq,
                  {
                    files: t,
                    hideRoot: !0,
                    rootFolder: h,
                    collapsed: !0,
                    allowFolderSelection: !0,
                    selectedFile: `${h}/${l}`,
                    onFileSelect: (f) => {
                      s(null), n?.(f);
                    }
                  }
                ) }) }),
                /* @__PURE__ */ k.jsx(mLe, { className: "fill-bolt-elements-borderColor" })
              ]
            }
          )
        }
      ) }) })
    ] }) }, c);
  }) });
});
var lq = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(self, () => (() => {
    var n = {};
    return (() => {
      var r = n;
      Object.defineProperty(r, "__esModule", { value: !0 }), r.FitAddon = void 0, r.FitAddon = class {
        activate(s) {
          this._terminal = s;
        }
        dispose() {
        }
        fit() {
          const s = this.proposeDimensions();
          if (!s || !this._terminal || isNaN(s.cols) || isNaN(s.rows)) return;
          const i = this._terminal._core;
          this._terminal.rows === s.rows && this._terminal.cols === s.cols || (i._renderService.clear(), this._terminal.resize(s.cols, s.rows));
        }
        proposeDimensions() {
          if (!this._terminal || !this._terminal.element || !this._terminal.element.parentElement) return;
          const s = this._terminal._core, i = s._renderService.dimensions;
          if (i.css.cell.width === 0 || i.css.cell.height === 0) return;
          const o = this._terminal.options.scrollback === 0 ? 0 : s.viewport.scrollBarWidth, a = window.getComputedStyle(this._terminal.element.parentElement), l = parseInt(a.getPropertyValue("height")), c = Math.max(0, parseInt(a.getPropertyValue("width"))), u = window.getComputedStyle(this._terminal.element), h = l - (parseInt(u.getPropertyValue("padding-top")) + parseInt(u.getPropertyValue("padding-bottom"))), d = c - (parseInt(u.getPropertyValue("padding-right")) + parseInt(u.getPropertyValue("padding-left"))) - o;
          return { cols: Math.max(2, Math.floor(d / i.css.cell.width)), rows: Math.max(1, Math.floor(h / i.css.cell.height)) };
        }
      };
    })(), n;
  })());
})(lq);
var nMe = lq.exports, cq = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(self, () => (() => {
    var n = { 6: (o, a) => {
      function l(u) {
        try {
          const h = new URL(u), d = h.password && h.username ? `${h.protocol}//${h.username}:${h.password}@${h.host}` : h.username ? `${h.protocol}//${h.username}@${h.host}` : `${h.protocol}//${h.host}`;
          return u.toLocaleLowerCase().startsWith(d.toLocaleLowerCase());
        } catch {
          return !1;
        }
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.LinkComputer = a.WebLinkProvider = void 0, a.WebLinkProvider = class {
        constructor(u, h, d, f = {}) {
          this._terminal = u, this._regex = h, this._handler = d, this._options = f;
        }
        provideLinks(u, h) {
          const d = c.computeLink(u, this._regex, this._terminal, this._handler);
          h(this._addCallbacks(d));
        }
        _addCallbacks(u) {
          return u.map((h) => (h.leave = this._options.leave, h.hover = (d, f) => {
            if (this._options.hover) {
              const { range: g } = h;
              this._options.hover(d, f, g);
            }
          }, h));
        }
      };
      class c {
        static computeLink(h, d, f, g) {
          const y = new RegExp(d.source, (d.flags || "") + "g"), [p, m] = c._getWindowedLineStrings(h - 1, f), b = p.join("");
          let _;
          const v = [];
          for (; _ = y.exec(b); ) {
            const w = _[0];
            if (!l(w)) continue;
            const [E, x] = c._mapStrIdx(f, m, 0, _.index), [S, T] = c._mapStrIdx(f, E, x, w.length);
            if (E === -1 || x === -1 || S === -1 || T === -1) continue;
            const R = { start: { x: x + 1, y: E + 1 }, end: { x: T, y: S + 1 } };
            v.push({ range: R, text: w, activate: g });
          }
          return v;
        }
        static _getWindowedLineStrings(h, d) {
          let f, g = h, y = h, p = 0, m = "";
          const b = [];
          if (f = d.buffer.active.getLine(h)) {
            const _ = f.translateToString(!0);
            if (f.isWrapped && _[0] !== " ") {
              for (p = 0; (f = d.buffer.active.getLine(--g)) && p < 2048 && (m = f.translateToString(!0), p += m.length, b.push(m), f.isWrapped && m.indexOf(" ") === -1); ) ;
              b.reverse();
            }
            for (b.push(_), p = 0; (f = d.buffer.active.getLine(++y)) && f.isWrapped && p < 2048 && (m = f.translateToString(!0), p += m.length, b.push(m), m.indexOf(" ") === -1); ) ;
          }
          return [b, g];
        }
        static _mapStrIdx(h, d, f, g) {
          const y = h.buffer.active, p = y.getNullCell();
          let m = f;
          for (; g; ) {
            const b = y.getLine(d);
            if (!b) return [-1, -1];
            for (let _ = m; _ < b.length; ++_) {
              b.getCell(_, p);
              const v = p.getChars();
              if (p.getWidth() && (g -= v.length || 1, _ === b.length - 1 && v === "")) {
                const w = y.getLine(d + 1);
                w && w.isWrapped && (w.getCell(0, p), p.getWidth() === 2 && (g += 1));
              }
              if (g < 0) return [d, _];
            }
            d++, m = 0;
          }
          return [d, m];
        }
      }
      a.LinkComputer = c;
    } }, r = {};
    function s(o) {
      var a = r[o];
      if (a !== void 0) return a.exports;
      var l = r[o] = { exports: {} };
      return n[o](l, l.exports, s), l.exports;
    }
    var i = {};
    return (() => {
      var o = i;
      Object.defineProperty(o, "__esModule", { value: !0 }), o.WebLinksAddon = void 0;
      const a = s(6), l = /(https?|HTTPS?):[/]{2}[^\s"'!*(){}|\\\^<>`]*[^\s"':,.!?{}|\\\^~\[\]`()<>]/;
      function c(u, h) {
        const d = window.open();
        if (d) {
          try {
            d.opener = null;
          } catch {
          }
          d.location.href = h;
        } else console.warn("Opening link blocked as opener could not be cleared");
      }
      o.WebLinksAddon = class {
        constructor(u = c, h = {}) {
          this._handler = u, this._options = h;
        }
        activate(u) {
          this._terminal = u;
          const h = this._options, d = h.urlRegex || l;
          this._linkProvider = this._terminal.registerLinkProvider(new a.WebLinkProvider(this._terminal, d, this._handler, h));
        }
        dispose() {
          this._linkProvider?.dispose();
        }
      };
    })(), i;
  })());
})(cq);
var rMe = cq.exports, uq = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(globalThis, () => (() => {
    var n = { 4567: function(o, a, l) {
      var c = this && this.__decorate || function(b, _, v, w) {
        var E, x = arguments.length, S = x < 3 ? _ : w === null ? w = Object.getOwnPropertyDescriptor(_, v) : w;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") S = Reflect.decorate(b, _, v, w);
        else for (var T = b.length - 1; T >= 0; T--) (E = b[T]) && (S = (x < 3 ? E(S) : x > 3 ? E(_, v, S) : E(_, v)) || S);
        return x > 3 && S && Object.defineProperty(_, v, S), S;
      }, u = this && this.__param || function(b, _) {
        return function(v, w) {
          _(v, w, b);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.AccessibilityManager = void 0;
      const h = l(9042), d = l(9924), f = l(844), g = l(4725), y = l(2585), p = l(3656);
      let m = a.AccessibilityManager = class extends f.Disposable {
        constructor(b, _, v, w) {
          super(), this._terminal = b, this._coreBrowserService = v, this._renderService = w, this._rowColumns = /* @__PURE__ */ new WeakMap(), this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = this._coreBrowserService.mainDocument.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = this._coreBrowserService.mainDocument.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
          for (let E = 0; E < this._terminal.rows; E++) this._rowElements[E] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[E]);
          if (this._topBoundaryFocusListener = (E) => this._handleBoundaryFocus(E, 0), this._bottomBoundaryFocusListener = (E) => this._handleBoundaryFocus(E, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = this._coreBrowserService.mainDocument.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new d.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
          this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((E) => this._handleResize(E.rows))), this.register(this._terminal.onRender((E) => this._refreshRows(E.start, E.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((E) => this._handleChar(E))), this.register(this._terminal.onLineFeed(() => this._handleChar(`
`))), this.register(this._terminal.onA11yTab((E) => this._handleTab(E))), this.register(this._terminal.onKey((E) => this._handleKey(E.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this.register((0, p.addDisposableDomListener)(document, "selectionchange", () => this._handleSelectionChange())), this.register(this._coreBrowserService.onDprChange(() => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, f.toDisposable)(() => {
            this._accessibilityContainer.remove(), this._rowElements.length = 0;
          }));
        }
        _handleTab(b) {
          for (let _ = 0; _ < b; _++) this._handleChar(" ");
        }
        _handleChar(b) {
          this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== b && (this._charsToAnnounce += b) : this._charsToAnnounce += b, b === `
` && (this._liveRegionLineCount++, this._liveRegionLineCount === 21 && (this._liveRegion.textContent += h.tooMuchOutput)));
        }
        _clearLiveRegion() {
          this._liveRegion.textContent = "", this._liveRegionLineCount = 0;
        }
        _handleKey(b) {
          this._clearLiveRegion(), /\p{Control}/u.test(b) || this._charsToConsume.push(b);
        }
        _refreshRows(b, _) {
          this._liveRegionDebouncer.refresh(b, _, this._terminal.rows);
        }
        _renderRows(b, _) {
          const v = this._terminal.buffer, w = v.lines.length.toString();
          for (let E = b; E <= _; E++) {
            const x = v.lines.get(v.ydisp + E), S = [], T = x?.translateToString(!0, void 0, void 0, S) || "", R = (v.ydisp + E + 1).toString(), F = this._rowElements[E];
            F && (T.length === 0 ? (F.innerText = "", this._rowColumns.set(F, [0, 1])) : (F.textContent = T, this._rowColumns.set(F, S)), F.setAttribute("aria-posinset", R), F.setAttribute("aria-setsize", w));
          }
          this._announceCharacters();
        }
        _announceCharacters() {
          this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
        }
        _handleBoundaryFocus(b, _) {
          const v = b.target, w = this._rowElements[_ === 0 ? 1 : this._rowElements.length - 2];
          if (v.getAttribute("aria-posinset") === (_ === 0 ? "1" : `${this._terminal.buffer.lines.length}`) || b.relatedTarget !== w) return;
          let E, x;
          if (_ === 0 ? (E = v, x = this._rowElements.pop(), this._rowContainer.removeChild(x)) : (E = this._rowElements.shift(), x = v, this._rowContainer.removeChild(E)), E.removeEventListener("focus", this._topBoundaryFocusListener), x.removeEventListener("focus", this._bottomBoundaryFocusListener), _ === 0) {
            const S = this._createAccessibilityTreeNode();
            this._rowElements.unshift(S), this._rowContainer.insertAdjacentElement("afterbegin", S);
          } else {
            const S = this._createAccessibilityTreeNode();
            this._rowElements.push(S), this._rowContainer.appendChild(S);
          }
          this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(_ === 0 ? -1 : 1), this._rowElements[_ === 0 ? 1 : this._rowElements.length - 2].focus(), b.preventDefault(), b.stopImmediatePropagation();
        }
        _handleSelectionChange() {
          if (this._rowElements.length === 0) return;
          const b = document.getSelection();
          if (!b) return;
          if (b.isCollapsed) return void (this._rowContainer.contains(b.anchorNode) && this._terminal.clearSelection());
          if (!b.anchorNode || !b.focusNode) return void console.error("anchorNode and/or focusNode are null");
          let _ = { node: b.anchorNode, offset: b.anchorOffset }, v = { node: b.focusNode, offset: b.focusOffset };
          if ((_.node.compareDocumentPosition(v.node) & Node.DOCUMENT_POSITION_PRECEDING || _.node === v.node && _.offset > v.offset) && ([_, v] = [v, _]), _.node.compareDocumentPosition(this._rowElements[0]) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING) && (_ = { node: this._rowElements[0].childNodes[0], offset: 0 }), !this._rowContainer.contains(_.node)) return;
          const w = this._rowElements.slice(-1)[0];
          if (v.node.compareDocumentPosition(w) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_PRECEDING) && (v = { node: w, offset: w.textContent?.length ?? 0 }), !this._rowContainer.contains(v.node)) return;
          const E = ({ node: T, offset: R }) => {
            const F = T instanceof Text ? T.parentNode : T;
            let P = parseInt(F?.getAttribute("aria-posinset"), 10) - 1;
            if (isNaN(P)) return console.warn("row is invalid. Race condition?"), null;
            const M = this._rowColumns.get(F);
            if (!M) return console.warn("columns is null. Race condition?"), null;
            let A = R < M.length ? M[R] : M.slice(-1)[0] + 1;
            return A >= this._terminal.cols && (++P, A = 0), { row: P, column: A };
          }, x = E(_), S = E(v);
          if (x && S) {
            if (x.row > S.row || x.row === S.row && x.column >= S.column) throw new Error("invalid range");
            this._terminal.select(x.column, x.row, (S.row - x.row) * this._terminal.cols - x.column + S.column);
          }
        }
        _handleResize(b) {
          this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
          for (let _ = this._rowContainer.children.length; _ < this._terminal.rows; _++) this._rowElements[_] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[_]);
          for (; this._rowElements.length > b; ) this._rowContainer.removeChild(this._rowElements.pop());
          this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
        }
        _createAccessibilityTreeNode() {
          const b = this._coreBrowserService.mainDocument.createElement("div");
          return b.setAttribute("role", "listitem"), b.tabIndex = -1, this._refreshRowDimensions(b), b;
        }
        _refreshRowsDimensions() {
          if (this._renderService.dimensions.css.cell.height) {
            this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
            for (let b = 0; b < this._terminal.rows; b++) this._refreshRowDimensions(this._rowElements[b]);
          }
        }
        _refreshRowDimensions(b) {
          b.style.height = `${this._renderService.dimensions.css.cell.height}px`;
        }
      };
      a.AccessibilityManager = m = c([u(1, y.IInstantiationService), u(2, g.ICoreBrowserService), u(3, g.IRenderService)], m);
    }, 3614: (o, a) => {
      function l(d) {
        return d.replace(/\r?\n/g, "\r");
      }
      function c(d, f) {
        return f ? "\x1B[200~" + d + "\x1B[201~" : d;
      }
      function u(d, f, g, y) {
        d = c(d = l(d), g.decPrivateModes.bracketedPasteMode && y.rawOptions.ignoreBracketedPasteMode !== !0), g.triggerDataEvent(d, !0), f.value = "";
      }
      function h(d, f, g) {
        const y = g.getBoundingClientRect(), p = d.clientX - y.left - 10, m = d.clientY - y.top - 10;
        f.style.width = "20px", f.style.height = "20px", f.style.left = `${p}px`, f.style.top = `${m}px`, f.style.zIndex = "1000", f.focus();
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.rightClickHandler = a.moveTextAreaUnderMouseCursor = a.paste = a.handlePasteEvent = a.copyHandler = a.bracketTextForPaste = a.prepareTextForTerminal = void 0, a.prepareTextForTerminal = l, a.bracketTextForPaste = c, a.copyHandler = function(d, f) {
        d.clipboardData && d.clipboardData.setData("text/plain", f.selectionText), d.preventDefault();
      }, a.handlePasteEvent = function(d, f, g, y) {
        d.stopPropagation(), d.clipboardData && u(d.clipboardData.getData("text/plain"), f, g, y);
      }, a.paste = u, a.moveTextAreaUnderMouseCursor = h, a.rightClickHandler = function(d, f, g, y, p) {
        h(d, f, g), p && y.rightClickSelect(d), f.value = y.selectionText, f.select();
      };
    }, 7239: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ColorContrastCache = void 0;
      const c = l(1505);
      a.ColorContrastCache = class {
        constructor() {
          this._color = new c.TwoKeyMap(), this._css = new c.TwoKeyMap();
        }
        setCss(u, h, d) {
          this._css.set(u, h, d);
        }
        getCss(u, h) {
          return this._css.get(u, h);
        }
        setColor(u, h, d) {
          this._color.set(u, h, d);
        }
        getColor(u, h) {
          return this._color.get(u, h);
        }
        clear() {
          this._color.clear(), this._css.clear();
        }
      };
    }, 3656: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.addDisposableDomListener = void 0, a.addDisposableDomListener = function(l, c, u, h) {
        l.addEventListener(c, u, h);
        let d = !1;
        return { dispose: () => {
          d || (d = !0, l.removeEventListener(c, u, h));
        } };
      };
    }, 3551: function(o, a, l) {
      var c = this && this.__decorate || function(m, b, _, v) {
        var w, E = arguments.length, x = E < 3 ? b : v === null ? v = Object.getOwnPropertyDescriptor(b, _) : v;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") x = Reflect.decorate(m, b, _, v);
        else for (var S = m.length - 1; S >= 0; S--) (w = m[S]) && (x = (E < 3 ? w(x) : E > 3 ? w(b, _, x) : w(b, _)) || x);
        return E > 3 && x && Object.defineProperty(b, _, x), x;
      }, u = this && this.__param || function(m, b) {
        return function(_, v) {
          b(_, v, m);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Linkifier = void 0;
      const h = l(3656), d = l(8460), f = l(844), g = l(2585), y = l(4725);
      let p = a.Linkifier = class extends f.Disposable {
        get currentLink() {
          return this._currentLink;
        }
        constructor(m, b, _, v, w) {
          super(), this._element = m, this._mouseService = b, this._renderService = _, this._bufferService = v, this._linkProviderService = w, this._linkCacheDisposables = [], this._isMouseOut = !0, this._wasResized = !1, this._activeLine = -1, this._onShowLinkUnderline = this.register(new d.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new d.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, f.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, f.toDisposable)(() => {
            this._lastMouseEvent = void 0, this._activeProviderReplies?.clear();
          })), this.register(this._bufferService.onResize(() => {
            this._clearCurrentLink(), this._wasResized = !0;
          })), this.register((0, h.addDisposableDomListener)(this._element, "mouseleave", () => {
            this._isMouseOut = !0, this._clearCurrentLink();
          })), this.register((0, h.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
        }
        _handleMouseMove(m) {
          this._lastMouseEvent = m;
          const b = this._positionFromMouseEvent(m, this._element, this._mouseService);
          if (!b) return;
          this._isMouseOut = !1;
          const _ = m.composedPath();
          for (let v = 0; v < _.length; v++) {
            const w = _[v];
            if (w.classList.contains("xterm")) break;
            if (w.classList.contains("xterm-hover")) return;
          }
          this._lastBufferCell && b.x === this._lastBufferCell.x && b.y === this._lastBufferCell.y || (this._handleHover(b), this._lastBufferCell = b);
        }
        _handleHover(m) {
          if (this._activeLine !== m.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(m, !1), void (this._wasResized = !1);
          this._currentLink && this._linkAtPosition(this._currentLink.link, m) || (this._clearCurrentLink(), this._askForLink(m, !0));
        }
        _askForLink(m, b) {
          this._activeProviderReplies && b || (this._activeProviderReplies?.forEach((v) => {
            v?.forEach((w) => {
              w.link.dispose && w.link.dispose();
            });
          }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = m.y);
          let _ = !1;
          for (const [v, w] of this._linkProviderService.linkProviders.entries()) b ? this._activeProviderReplies?.get(v) && (_ = this._checkLinkProviderResult(v, m, _)) : w.provideLinks(m.y, (E) => {
            if (this._isMouseOut) return;
            const x = E?.map((S) => ({ link: S }));
            this._activeProviderReplies?.set(v, x), _ = this._checkLinkProviderResult(v, m, _), this._activeProviderReplies?.size === this._linkProviderService.linkProviders.length && this._removeIntersectingLinks(m.y, this._activeProviderReplies);
          });
        }
        _removeIntersectingLinks(m, b) {
          const _ = /* @__PURE__ */ new Set();
          for (let v = 0; v < b.size; v++) {
            const w = b.get(v);
            if (w) for (let E = 0; E < w.length; E++) {
              const x = w[E], S = x.link.range.start.y < m ? 0 : x.link.range.start.x, T = x.link.range.end.y > m ? this._bufferService.cols : x.link.range.end.x;
              for (let R = S; R <= T; R++) {
                if (_.has(R)) {
                  w.splice(E--, 1);
                  break;
                }
                _.add(R);
              }
            }
          }
        }
        _checkLinkProviderResult(m, b, _) {
          if (!this._activeProviderReplies) return _;
          const v = this._activeProviderReplies.get(m);
          let w = !1;
          for (let E = 0; E < m; E++) this._activeProviderReplies.has(E) && !this._activeProviderReplies.get(E) || (w = !0);
          if (!w && v) {
            const E = v.find((x) => this._linkAtPosition(x.link, b));
            E && (_ = !0, this._handleNewLink(E));
          }
          if (this._activeProviderReplies.size === this._linkProviderService.linkProviders.length && !_) for (let E = 0; E < this._activeProviderReplies.size; E++) {
            const x = this._activeProviderReplies.get(E)?.find((S) => this._linkAtPosition(S.link, b));
            if (x) {
              _ = !0, this._handleNewLink(x);
              break;
            }
          }
          return _;
        }
        _handleMouseDown() {
          this._mouseDownLink = this._currentLink;
        }
        _handleMouseUp(m) {
          if (!this._currentLink) return;
          const b = this._positionFromMouseEvent(m, this._element, this._mouseService);
          b && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, b) && this._currentLink.link.activate(m, this._currentLink.link.text);
        }
        _clearCurrentLink(m, b) {
          this._currentLink && this._lastMouseEvent && (!m || !b || this._currentLink.link.range.start.y >= m && this._currentLink.link.range.end.y <= b) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, f.disposeArray)(this._linkCacheDisposables));
        }
        _handleNewLink(m) {
          if (!this._lastMouseEvent) return;
          const b = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
          b && this._linkAtPosition(m.link, b) && (this._currentLink = m, this._currentLink.state = { decorations: { underline: m.link.decorations === void 0 || m.link.decorations.underline, pointerCursor: m.link.decorations === void 0 || m.link.decorations.pointerCursor }, isHovered: !0 }, this._linkHover(this._element, m.link, this._lastMouseEvent), m.link.decorations = {}, Object.defineProperties(m.link.decorations, { pointerCursor: { get: () => this._currentLink?.state?.decorations.pointerCursor, set: (_) => {
            this._currentLink?.state && this._currentLink.state.decorations.pointerCursor !== _ && (this._currentLink.state.decorations.pointerCursor = _, this._currentLink.state.isHovered && this._element.classList.toggle("xterm-cursor-pointer", _));
          } }, underline: { get: () => this._currentLink?.state?.decorations.underline, set: (_) => {
            this._currentLink?.state && this._currentLink?.state?.decorations.underline !== _ && (this._currentLink.state.decorations.underline = _, this._currentLink.state.isHovered && this._fireUnderlineEvent(m.link, _));
          } } }), this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((_) => {
            if (!this._currentLink) return;
            const v = _.start === 0 ? 0 : _.start + 1 + this._bufferService.buffer.ydisp, w = this._bufferService.buffer.ydisp + 1 + _.end;
            if (this._currentLink.link.range.start.y >= v && this._currentLink.link.range.end.y <= w && (this._clearCurrentLink(v, w), this._lastMouseEvent)) {
              const E = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
              E && this._askForLink(E, !1);
            }
          })));
        }
        _linkHover(m, b, _) {
          this._currentLink?.state && (this._currentLink.state.isHovered = !0, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(b, !0), this._currentLink.state.decorations.pointerCursor && m.classList.add("xterm-cursor-pointer")), b.hover && b.hover(_, b.text);
        }
        _fireUnderlineEvent(m, b) {
          const _ = m.range, v = this._bufferService.buffer.ydisp, w = this._createLinkUnderlineEvent(_.start.x - 1, _.start.y - v - 1, _.end.x, _.end.y - v - 1, void 0);
          (b ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(w);
        }
        _linkLeave(m, b, _) {
          this._currentLink?.state && (this._currentLink.state.isHovered = !1, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(b, !1), this._currentLink.state.decorations.pointerCursor && m.classList.remove("xterm-cursor-pointer")), b.leave && b.leave(_, b.text);
        }
        _linkAtPosition(m, b) {
          const _ = m.range.start.y * this._bufferService.cols + m.range.start.x, v = m.range.end.y * this._bufferService.cols + m.range.end.x, w = b.y * this._bufferService.cols + b.x;
          return _ <= w && w <= v;
        }
        _positionFromMouseEvent(m, b, _) {
          const v = _.getCoords(m, b, this._bufferService.cols, this._bufferService.rows);
          if (v) return { x: v[0], y: v[1] + this._bufferService.buffer.ydisp };
        }
        _createLinkUnderlineEvent(m, b, _, v, w) {
          return { x1: m, y1: b, x2: _, y2: v, cols: this._bufferService.cols, fg: w };
        }
      };
      a.Linkifier = p = c([u(1, y.IMouseService), u(2, y.IRenderService), u(3, g.IBufferService), u(4, y.ILinkProviderService)], p);
    }, 9042: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.tooMuchOutput = a.promptLabel = void 0, a.promptLabel = "Terminal input", a.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
    }, 3730: function(o, a, l) {
      var c = this && this.__decorate || function(y, p, m, b) {
        var _, v = arguments.length, w = v < 3 ? p : b === null ? b = Object.getOwnPropertyDescriptor(p, m) : b;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(y, p, m, b);
        else for (var E = y.length - 1; E >= 0; E--) (_ = y[E]) && (w = (v < 3 ? _(w) : v > 3 ? _(p, m, w) : _(p, m)) || w);
        return v > 3 && w && Object.defineProperty(p, m, w), w;
      }, u = this && this.__param || function(y, p) {
        return function(m, b) {
          p(m, b, y);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OscLinkProvider = void 0;
      const h = l(511), d = l(2585);
      let f = a.OscLinkProvider = class {
        constructor(y, p, m) {
          this._bufferService = y, this._optionsService = p, this._oscLinkService = m;
        }
        provideLinks(y, p) {
          const m = this._bufferService.buffer.lines.get(y - 1);
          if (!m) return void p(void 0);
          const b = [], _ = this._optionsService.rawOptions.linkHandler, v = new h.CellData(), w = m.getTrimmedLength();
          let E = -1, x = -1, S = !1;
          for (let T = 0; T < w; T++) if (x !== -1 || m.hasContent(T)) {
            if (m.loadCell(T, v), v.hasExtendedAttrs() && v.extended.urlId) {
              if (x === -1) {
                x = T, E = v.extended.urlId;
                continue;
              }
              S = v.extended.urlId !== E;
            } else x !== -1 && (S = !0);
            if (S || x !== -1 && T === w - 1) {
              const R = this._oscLinkService.getLinkData(E)?.uri;
              if (R) {
                const F = { start: { x: x + 1, y }, end: { x: T + (S || T !== w - 1 ? 0 : 1), y } };
                let P = !1;
                if (!_?.allowNonHttpProtocols) try {
                  const M = new URL(R);
                  ["http:", "https:"].includes(M.protocol) || (P = !0);
                } catch {
                  P = !0;
                }
                P || b.push({ text: R, range: F, activate: (M, A) => _ ? _.activate(M, A, F) : g(0, A), hover: (M, A) => _?.hover?.(M, A, F), leave: (M, A) => _?.leave?.(M, A, F) });
              }
              S = !1, v.hasExtendedAttrs() && v.extended.urlId ? (x = T, E = v.extended.urlId) : (x = -1, E = -1);
            }
          }
          p(b);
        }
      };
      function g(y, p) {
        if (confirm(`Do you want to navigate to ${p}?

WARNING: This link could potentially be dangerous`)) {
          const m = window.open();
          if (m) {
            try {
              m.opener = null;
            } catch {
            }
            m.location.href = p;
          } else console.warn("Opening link blocked as opener could not be cleared");
        }
      }
      a.OscLinkProvider = f = c([u(0, d.IBufferService), u(1, d.IOptionsService), u(2, d.IOscLinkService)], f);
    }, 6193: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.RenderDebouncer = void 0, a.RenderDebouncer = class {
        constructor(l, c) {
          this._renderCallback = l, this._coreBrowserService = c, this._refreshCallbacks = [];
        }
        dispose() {
          this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
        }
        addRefreshCallback(l) {
          return this._refreshCallbacks.push(l), this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
        }
        refresh(l, c, u) {
          this._rowCount = u, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._animationFrame = void 0, this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return void this._runRefreshCallbacks();
          const l = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(l, c), this._runRefreshCallbacks();
        }
        _runRefreshCallbacks() {
          for (const l of this._refreshCallbacks) l(0);
          this._refreshCallbacks = [];
        }
      };
    }, 3236: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Terminal = void 0;
      const c = l(3614), u = l(3656), h = l(3551), d = l(9042), f = l(3730), g = l(1680), y = l(3107), p = l(5744), m = l(2950), b = l(1296), _ = l(428), v = l(4269), w = l(5114), E = l(8934), x = l(3230), S = l(9312), T = l(4725), R = l(6731), F = l(8055), P = l(8969), M = l(8460), A = l(844), V = l(6114), ee = l(8437), K = l(2584), te = l(7399), N = l(5941), L = l(9074), j = l(2585), H = l(5435), U = l(4567), Y = l(779);
      class ne extends P.CoreTerminal {
        get onFocus() {
          return this._onFocus.event;
        }
        get onBlur() {
          return this._onBlur.event;
        }
        get onA11yChar() {
          return this._onA11yCharEmitter.event;
        }
        get onA11yTab() {
          return this._onA11yTabEmitter.event;
        }
        get onWillOpen() {
          return this._onWillOpen.event;
        }
        constructor(X = {}) {
          super(X), this.browser = V, this._keyDownHandled = !1, this._keyDownSeen = !1, this._keyPressHandled = !1, this._unprocessedDeadKey = !1, this._accessibilityManager = this.register(new A.MutableDisposable()), this._onCursorMove = this.register(new M.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new M.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new M.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new M.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new M.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new M.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new M.EventEmitter()), this._onBlur = this.register(new M.EventEmitter()), this._onA11yCharEmitter = this.register(new M.EventEmitter()), this._onA11yTabEmitter = this.register(new M.EventEmitter()), this._onWillOpen = this.register(new M.EventEmitter()), this._setup(), this._decorationService = this._instantiationService.createInstance(L.DecorationService), this._instantiationService.setService(j.IDecorationService, this._decorationService), this._linkProviderService = this._instantiationService.createInstance(Y.LinkProviderService), this._instantiationService.setService(T.ILinkProviderService, this._linkProviderService), this._linkProviderService.registerLinkProvider(this._instantiationService.createInstance(f.OscLinkProvider)), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((z, ue) => this.refresh(z, ue))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((z) => this._reportWindowsOptions(z))), this.register(this._inputHandler.onColor((z) => this._handleColorEvent(z))), this.register((0, M.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, M.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, M.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, M.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((z) => this._afterResize(z.cols, z.rows))), this.register((0, A.toDisposable)(() => {
            this._customKeyEventHandler = void 0, this.element?.parentNode?.removeChild(this.element);
          }));
        }
        _handleColorEvent(X) {
          if (this._themeService) for (const z of X) {
            let ue, ae = "";
            switch (z.index) {
              case 256:
                ue = "foreground", ae = "10";
                break;
              case 257:
                ue = "background", ae = "11";
                break;
              case 258:
                ue = "cursor", ae = "12";
                break;
              default:
                ue = "ansi", ae = "4;" + z.index;
            }
            switch (z.type) {
              case 0:
                const be = F.color.toColorRGB(ue === "ansi" ? this._themeService.colors.ansi[z.index] : this._themeService.colors[ue]);
                this.coreService.triggerDataEvent(`${K.C0.ESC}]${ae};${(0, N.toRgbString)(be)}${K.C1_ESCAPED.ST}`);
                break;
              case 1:
                if (ue === "ansi") this._themeService.modifyColors((de) => de.ansi[z.index] = F.channels.toColor(...z.color));
                else {
                  const de = ue;
                  this._themeService.modifyColors((_e) => _e[de] = F.channels.toColor(...z.color));
                }
                break;
              case 2:
                this._themeService.restoreColor(z.index);
            }
          }
        }
        _setup() {
          super._setup(), this._customKeyEventHandler = void 0;
        }
        get buffer() {
          return this.buffers.active;
        }
        focus() {
          this.textarea && this.textarea.focus({ preventScroll: !0 });
        }
        _handleScreenReaderModeOptionChange(X) {
          X ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(U.AccessibilityManager, this)) : this._accessibilityManager.clear();
        }
        _handleTextAreaFocus(X) {
          this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(K.C0.ESC + "[I"), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
        }
        blur() {
          return this.textarea?.blur();
        }
        _handleTextAreaBlur() {
          this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(K.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
        }
        _syncTextArea() {
          if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
          const X = this.buffer.ybase + this.buffer.y, z = this.buffer.lines.get(X);
          if (!z) return;
          const ue = Math.min(this.buffer.x, this.cols - 1), ae = this._renderService.dimensions.css.cell.height, be = z.getWidth(ue), de = this._renderService.dimensions.css.cell.width * be, _e = this.buffer.y * this._renderService.dimensions.css.cell.height, $ = ue * this._renderService.dimensions.css.cell.width;
          this.textarea.style.left = $ + "px", this.textarea.style.top = _e + "px", this.textarea.style.width = de + "px", this.textarea.style.height = ae + "px", this.textarea.style.lineHeight = ae + "px", this.textarea.style.zIndex = "-5";
        }
        _initGlobal() {
          this._bindKeys(), this.register((0, u.addDisposableDomListener)(this.element, "copy", (z) => {
            this.hasSelection() && (0, c.copyHandler)(z, this._selectionService);
          }));
          const X = (z) => (0, c.handlePasteEvent)(z, this.textarea, this.coreService, this.optionsService);
          this.register((0, u.addDisposableDomListener)(this.textarea, "paste", X)), this.register((0, u.addDisposableDomListener)(this.element, "paste", X)), V.isFirefox ? this.register((0, u.addDisposableDomListener)(this.element, "mousedown", (z) => {
            z.button === 2 && (0, c.rightClickHandler)(z, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })) : this.register((0, u.addDisposableDomListener)(this.element, "contextmenu", (z) => {
            (0, c.rightClickHandler)(z, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })), V.isLinux && this.register((0, u.addDisposableDomListener)(this.element, "auxclick", (z) => {
            z.button === 1 && (0, c.moveTextAreaUnderMouseCursor)(z, this.textarea, this.screenElement);
          }));
        }
        _bindKeys() {
          this.register((0, u.addDisposableDomListener)(this.textarea, "keyup", (X) => this._keyUp(X), !0)), this.register((0, u.addDisposableDomListener)(this.textarea, "keydown", (X) => this._keyDown(X), !0)), this.register((0, u.addDisposableDomListener)(this.textarea, "keypress", (X) => this._keyPress(X), !0)), this.register((0, u.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, u.addDisposableDomListener)(this.textarea, "compositionupdate", (X) => this._compositionHelper.compositionupdate(X))), this.register((0, u.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, u.addDisposableDomListener)(this.textarea, "input", (X) => this._inputEvent(X), !0)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
        }
        open(X) {
          if (!X) throw new Error("Terminal requires a parent element.");
          if (X.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this.element?.ownerDocument.defaultView && this._coreBrowserService) return void (this.element.ownerDocument.defaultView !== this._coreBrowserService.window && (this._coreBrowserService.window = this.element.ownerDocument.defaultView));
          this._document = X.ownerDocument, this.options.documentOverride && this.options.documentOverride instanceof Document && (this._document = this.optionsService.rawOptions.documentOverride), this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), X.appendChild(this.element);
          const z = this._document.createDocumentFragment();
          this._viewportElement = this._document.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), z.appendChild(this._viewportElement), this._viewportScrollArea = this._document.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = this._document.createElement("div"), this.screenElement.classList.add("xterm-screen"), this.register((0, u.addDisposableDomListener)(this.screenElement, "mousemove", (ue) => this.updateCursorStyle(ue))), this._helperContainer = this._document.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), z.appendChild(this.screenElement), this.textarea = this._document.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", d.promptLabel), V.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this.register(this._instantiationService.createInstance(w.CoreBrowserService, this.textarea, X.ownerDocument.defaultView ?? window, this._document ?? typeof window < "u" ? window.document : null)), this._instantiationService.setService(T.ICoreBrowserService, this._coreBrowserService), this.register((0, u.addDisposableDomListener)(this.textarea, "focus", (ue) => this._handleTextAreaFocus(ue))), this.register((0, u.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(_.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(T.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(R.ThemeService), this._instantiationService.setService(T.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(v.CharacterJoinerService), this._instantiationService.setService(T.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(x.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(T.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((ue) => this._onRender.fire(ue))), this.onResize((ue) => this._renderService.resize(ue.cols, ue.rows)), this._compositionView = this._document.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(m.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this._mouseService = this._instantiationService.createInstance(E.MouseService), this._instantiationService.setService(T.IMouseService, this._mouseService), this.linkifier = this.register(this._instantiationService.createInstance(h.Linkifier, this.screenElement)), this.element.appendChild(z);
          try {
            this._onWillOpen.fire(this.element);
          } catch {
          }
          this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this.viewport = this._instantiationService.createInstance(g.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((ue) => this.scrollLines(ue.amount, ue.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
            this._renderService.handleCursorMove(), this._syncTextArea();
          })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(S.SelectionService, this.element, this.screenElement, this.linkifier)), this._instantiationService.setService(T.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((ue) => this.scrollLines(ue.amount, ue.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((ue) => this._renderService.handleSelectionChanged(ue.start, ue.end, ue.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((ue) => {
            this.textarea.value = ue, this.textarea.focus(), this.textarea.select();
          })), this.register(this._onScroll.event((ue) => {
            this.viewport.syncScrollArea(), this._selectionService.refresh();
          })), this.register((0, u.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.register(this._instantiationService.createInstance(y.BufferDecorationRenderer, this.screenElement)), this.register((0, u.addDisposableDomListener)(this.element, "mousedown", (ue) => this._selectionService.handleMouseDown(ue))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(U.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (ue) => this._handleScreenReaderModeOptionChange(ue))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(p.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (ue) => {
            !this._overviewRulerRenderer && ue && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(p.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
          }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
        }
        _createRenderer() {
          return this._instantiationService.createInstance(b.DomRenderer, this, this._document, this.element, this.screenElement, this._viewportElement, this._helperContainer, this.linkifier);
        }
        bindMouse() {
          const X = this, z = this.element;
          function ue(de) {
            const _e = X._mouseService.getMouseReportCoords(de, X.screenElement);
            if (!_e) return !1;
            let $, ce;
            switch (de.overrideType || de.type) {
              case "mousemove":
                ce = 32, de.buttons === void 0 ? ($ = 3, de.button !== void 0 && ($ = de.button < 3 ? de.button : 3)) : $ = 1 & de.buttons ? 0 : 4 & de.buttons ? 1 : 2 & de.buttons ? 2 : 3;
                break;
              case "mouseup":
                ce = 0, $ = de.button < 3 ? de.button : 3;
                break;
              case "mousedown":
                ce = 1, $ = de.button < 3 ? de.button : 3;
                break;
              case "wheel":
                if (X._customWheelEventHandler && X._customWheelEventHandler(de) === !1 || X.viewport.getLinesScrolled(de) === 0) return !1;
                ce = de.deltaY < 0 ? 0 : 1, $ = 4;
                break;
              default:
                return !1;
            }
            return !(ce === void 0 || $ === void 0 || $ > 4) && X.coreMouseService.triggerMouseEvent({ col: _e.col, row: _e.row, x: _e.x, y: _e.y, button: $, action: ce, ctrl: de.ctrlKey, alt: de.altKey, shift: de.shiftKey });
          }
          const ae = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, be = { mouseup: (de) => (ue(de), de.buttons || (this._document.removeEventListener("mouseup", ae.mouseup), ae.mousedrag && this._document.removeEventListener("mousemove", ae.mousedrag)), this.cancel(de)), wheel: (de) => (ue(de), this.cancel(de, !0)), mousedrag: (de) => {
            de.buttons && ue(de);
          }, mousemove: (de) => {
            de.buttons || ue(de);
          } };
          this.register(this.coreMouseService.onProtocolChange((de) => {
            de ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(de)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & de ? ae.mousemove || (z.addEventListener("mousemove", be.mousemove), ae.mousemove = be.mousemove) : (z.removeEventListener("mousemove", ae.mousemove), ae.mousemove = null), 16 & de ? ae.wheel || (z.addEventListener("wheel", be.wheel, { passive: !1 }), ae.wheel = be.wheel) : (z.removeEventListener("wheel", ae.wheel), ae.wheel = null), 2 & de ? ae.mouseup || (ae.mouseup = be.mouseup) : (this._document.removeEventListener("mouseup", ae.mouseup), ae.mouseup = null), 4 & de ? ae.mousedrag || (ae.mousedrag = be.mousedrag) : (this._document.removeEventListener("mousemove", ae.mousedrag), ae.mousedrag = null);
          })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, u.addDisposableDomListener)(z, "mousedown", (de) => {
            if (de.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(de)) return ue(de), ae.mouseup && this._document.addEventListener("mouseup", ae.mouseup), ae.mousedrag && this._document.addEventListener("mousemove", ae.mousedrag), this.cancel(de);
          })), this.register((0, u.addDisposableDomListener)(z, "wheel", (de) => {
            if (!ae.wheel) {
              if (this._customWheelEventHandler && this._customWheelEventHandler(de) === !1) return !1;
              if (!this.buffer.hasScrollback) {
                const _e = this.viewport.getLinesScrolled(de);
                if (_e === 0) return;
                const $ = K.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (de.deltaY < 0 ? "A" : "B");
                let ce = "";
                for (let re = 0; re < Math.abs(_e); re++) ce += $;
                return this.coreService.triggerDataEvent(ce, !0), this.cancel(de, !0);
              }
              return this.viewport.handleWheel(de) ? this.cancel(de) : void 0;
            }
          }, { passive: !1 })), this.register((0, u.addDisposableDomListener)(z, "touchstart", (de) => {
            if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(de), this.cancel(de);
          }, { passive: !0 })), this.register((0, u.addDisposableDomListener)(z, "touchmove", (de) => {
            if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(de) ? void 0 : this.cancel(de);
          }, { passive: !1 }));
        }
        refresh(X, z) {
          this._renderService?.refreshRows(X, z);
        }
        updateCursorStyle(X) {
          this._selectionService?.shouldColumnSelect(X) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
        }
        _showCursor() {
          this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0, this.refresh(this.buffer.y, this.buffer.y));
        }
        scrollLines(X, z, ue = 0) {
          ue === 1 ? (super.scrollLines(X, z, ue), this.refresh(0, this.rows - 1)) : this.viewport?.scrollLines(X);
        }
        paste(X) {
          (0, c.paste)(X, this.textarea, this.coreService, this.optionsService);
        }
        attachCustomKeyEventHandler(X) {
          this._customKeyEventHandler = X;
        }
        attachCustomWheelEventHandler(X) {
          this._customWheelEventHandler = X;
        }
        registerLinkProvider(X) {
          return this._linkProviderService.registerLinkProvider(X);
        }
        registerCharacterJoiner(X) {
          if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
          const z = this._characterJoinerService.register(X);
          return this.refresh(0, this.rows - 1), z;
        }
        deregisterCharacterJoiner(X) {
          if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
          this._characterJoinerService.deregister(X) && this.refresh(0, this.rows - 1);
        }
        get markers() {
          return this.buffer.markers;
        }
        registerMarker(X) {
          return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + X);
        }
        registerDecoration(X) {
          return this._decorationService.registerDecoration(X);
        }
        hasSelection() {
          return !!this._selectionService && this._selectionService.hasSelection;
        }
        select(X, z, ue) {
          this._selectionService.setSelection(X, z, ue);
        }
        getSelection() {
          return this._selectionService ? this._selectionService.selectionText : "";
        }
        getSelectionPosition() {
          if (this._selectionService && this._selectionService.hasSelection) return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
        }
        clearSelection() {
          this._selectionService?.clearSelection();
        }
        selectAll() {
          this._selectionService?.selectAll();
        }
        selectLines(X, z) {
          this._selectionService?.selectLines(X, z);
        }
        _keyDown(X) {
          if (this._keyDownHandled = !1, this._keyDownSeen = !0, this._customKeyEventHandler && this._customKeyEventHandler(X) === !1) return !1;
          const z = this.browser.isMac && this.options.macOptionIsMeta && X.altKey;
          if (!z && !this._compositionHelper.keydown(X)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), !1;
          z || X.key !== "Dead" && X.key !== "AltGraph" || (this._unprocessedDeadKey = !0);
          const ue = (0, te.evaluateKeyboardEvent)(X, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
          if (this.updateCursorStyle(X), ue.type === 3 || ue.type === 2) {
            const ae = this.rows - 1;
            return this.scrollLines(ue.type === 2 ? -ae : ae), this.cancel(X, !0);
          }
          return ue.type === 1 && this.selectAll(), !!this._isThirdLevelShift(this.browser, X) || (ue.cancel && this.cancel(X, !0), !ue.key || !!(X.key && !X.ctrlKey && !X.altKey && !X.metaKey && X.key.length === 1 && X.key.charCodeAt(0) >= 65 && X.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1, !0) : (ue.key !== K.C0.ETX && ue.key !== K.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: ue.key, domEvent: X }), this._showCursor(), this.coreService.triggerDataEvent(ue.key, !0), !this.optionsService.rawOptions.screenReaderMode || X.altKey || X.ctrlKey ? this.cancel(X, !0) : void (this._keyDownHandled = !0))));
        }
        _isThirdLevelShift(X, z) {
          const ue = X.isMac && !this.options.macOptionIsMeta && z.altKey && !z.ctrlKey && !z.metaKey || X.isWindows && z.altKey && z.ctrlKey && !z.metaKey || X.isWindows && z.getModifierState("AltGraph");
          return z.type === "keypress" ? ue : ue && (!z.keyCode || z.keyCode > 47);
        }
        _keyUp(X) {
          this._keyDownSeen = !1, this._customKeyEventHandler && this._customKeyEventHandler(X) === !1 || (function(z) {
            return z.keyCode === 16 || z.keyCode === 17 || z.keyCode === 18;
          }(X) || this.focus(), this.updateCursorStyle(X), this._keyPressHandled = !1);
        }
        _keyPress(X) {
          let z;
          if (this._keyPressHandled = !1, this._keyDownHandled || this._customKeyEventHandler && this._customKeyEventHandler(X) === !1) return !1;
          if (this.cancel(X), X.charCode) z = X.charCode;
          else if (X.which === null || X.which === void 0) z = X.keyCode;
          else {
            if (X.which === 0 || X.charCode === 0) return !1;
            z = X.which;
          }
          return !(!z || (X.altKey || X.ctrlKey || X.metaKey) && !this._isThirdLevelShift(this.browser, X) || (z = String.fromCharCode(z), this._onKey.fire({ key: z, domEvent: X }), this._showCursor(), this.coreService.triggerDataEvent(z, !0), this._keyPressHandled = !0, this._unprocessedDeadKey = !1, 0));
        }
        _inputEvent(X) {
          if (X.data && X.inputType === "insertText" && (!X.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
            if (this._keyPressHandled) return !1;
            this._unprocessedDeadKey = !1;
            const z = X.data;
            return this.coreService.triggerDataEvent(z, !0), this.cancel(X), !0;
          }
          return !1;
        }
        resize(X, z) {
          X !== this.cols || z !== this.rows ? super.resize(X, z) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
        }
        _afterResize(X, z) {
          this._charSizeService?.measure(), this.viewport?.syncScrollArea(!0);
        }
        clear() {
          if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
            this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
            for (let X = 1; X < this.rows; X++) this.buffer.lines.push(this.buffer.getBlankLine(ee.DEFAULT_ATTR_DATA));
            this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), this.viewport?.reset(), this.refresh(0, this.rows - 1);
          }
        }
        reset() {
          this.options.rows = this.rows, this.options.cols = this.cols;
          const X = this._customKeyEventHandler;
          this._setup(), super.reset(), this._selectionService?.reset(), this._decorationService.reset(), this.viewport?.reset(), this._customKeyEventHandler = X, this.refresh(0, this.rows - 1);
        }
        clearTextureAtlas() {
          this._renderService?.clearTextureAtlas();
        }
        _reportFocus() {
          this.element?.classList.contains("focus") ? this.coreService.triggerDataEvent(K.C0.ESC + "[I") : this.coreService.triggerDataEvent(K.C0.ESC + "[O");
        }
        _reportWindowsOptions(X) {
          if (this._renderService) switch (X) {
            case H.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
              const z = this._renderService.dimensions.css.canvas.width.toFixed(0), ue = this._renderService.dimensions.css.canvas.height.toFixed(0);
              this.coreService.triggerDataEvent(`${K.C0.ESC}[4;${ue};${z}t`);
              break;
            case H.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
              const ae = this._renderService.dimensions.css.cell.width.toFixed(0), be = this._renderService.dimensions.css.cell.height.toFixed(0);
              this.coreService.triggerDataEvent(`${K.C0.ESC}[6;${be};${ae}t`);
          }
        }
        cancel(X, z) {
          if (this.options.cancelEvents || z) return X.preventDefault(), X.stopPropagation(), !1;
        }
      }
      a.Terminal = ne;
    }, 9924: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.TimeBasedDebouncer = void 0, a.TimeBasedDebouncer = class {
        constructor(l, c = 1e3) {
          this._renderCallback = l, this._debounceThresholdMS = c, this._lastRefreshMs = 0, this._additionalRefreshRequested = !1;
        }
        dispose() {
          this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
        }
        refresh(l, c, u) {
          this._rowCount = u, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c;
          const h = Date.now();
          if (h - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = h, this._innerRefresh();
          else if (!this._additionalRefreshRequested) {
            const d = h - this._lastRefreshMs, f = this._debounceThresholdMS - d;
            this._additionalRefreshRequested = !0, this._refreshTimeoutID = window.setTimeout(() => {
              this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = !1, this._refreshTimeoutID = void 0;
            }, f);
          }
        }
        _innerRefresh() {
          if (this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return;
          const l = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(l, c);
        }
      };
    }, 1680: function(o, a, l) {
      var c = this && this.__decorate || function(m, b, _, v) {
        var w, E = arguments.length, x = E < 3 ? b : v === null ? v = Object.getOwnPropertyDescriptor(b, _) : v;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") x = Reflect.decorate(m, b, _, v);
        else for (var S = m.length - 1; S >= 0; S--) (w = m[S]) && (x = (E < 3 ? w(x) : E > 3 ? w(b, _, x) : w(b, _)) || x);
        return E > 3 && x && Object.defineProperty(b, _, x), x;
      }, u = this && this.__param || function(m, b) {
        return function(_, v) {
          b(_, v, m);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Viewport = void 0;
      const h = l(3656), d = l(4725), f = l(8460), g = l(844), y = l(2585);
      let p = a.Viewport = class extends g.Disposable {
        constructor(m, b, _, v, w, E, x, S) {
          super(), this._viewportElement = m, this._scrollArea = b, this._bufferService = _, this._optionsService = v, this._charSizeService = w, this._renderService = E, this._coreBrowserService = x, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = !1, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new f.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, h.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((T) => this._activeBuffer = T.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((T) => this._renderDimensions = T)), this._handleThemeChange(S.colors), this.register(S.onChangeColors((T) => this._handleThemeChange(T))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
        }
        _handleThemeChange(m) {
          this._viewportElement.style.backgroundColor = m.background.css;
        }
        reset() {
          this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
        }
        _refresh(m) {
          if (m) return this._innerRefresh(), void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
          this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._charSizeService.height > 0) {
            this._currentRowHeight = this._renderDimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderDimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
            const b = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderDimensions.css.canvas.height);
            this._lastRecordedBufferHeight !== b && (this._lastRecordedBufferHeight = b, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
          }
          const m = this._bufferService.buffer.ydisp * this._currentRowHeight;
          this._viewportElement.scrollTop !== m && (this._ignoreNextScrollEvent = !0, this._viewportElement.scrollTop = m), this._refreshAnimationFrame = null;
        }
        syncScrollArea(m = !1) {
          if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(m);
          this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(m);
        }
        _handleScroll(m) {
          if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
          if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = !1, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: !0 });
          const b = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
          this._onRequestScrollLines.fire({ amount: b, suppressScrollEvent: !0 });
        }
        _smoothScroll() {
          if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1) return;
          const m = this._smoothScrollPercent();
          this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(m * (this._smoothScrollState.target - this._smoothScrollState.origin)), m < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
        }
        _smoothScrollPercent() {
          return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
        }
        _clearSmoothScrollState() {
          this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
        }
        _bubbleScroll(m, b) {
          const _ = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
          return !(b < 0 && this._viewportElement.scrollTop !== 0 || b > 0 && _ < this._lastRecordedBufferHeight) || (m.cancelable && m.preventDefault(), !1);
        }
        handleWheel(m) {
          const b = this._getPixelsScrolled(m);
          return b !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + b : this._smoothScrollState.target += b, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += b, this._bubbleScroll(m, b));
        }
        scrollLines(m) {
          if (m !== 0) if (this._optionsService.rawOptions.smoothScrollDuration) {
            const b = m * this._currentRowHeight;
            this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + b, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
          } else this._onRequestScrollLines.fire({ amount: m, suppressScrollEvent: !1 });
        }
        _getPixelsScrolled(m) {
          if (m.deltaY === 0 || m.shiftKey) return 0;
          let b = this._applyScrollModifier(m.deltaY, m);
          return m.deltaMode === WheelEvent.DOM_DELTA_LINE ? b *= this._currentRowHeight : m.deltaMode === WheelEvent.DOM_DELTA_PAGE && (b *= this._currentRowHeight * this._bufferService.rows), b;
        }
        getBufferElements(m, b) {
          let _, v = "";
          const w = [], E = b ?? this._bufferService.buffer.lines.length, x = this._bufferService.buffer.lines;
          for (let S = m; S < E; S++) {
            const T = x.get(S);
            if (!T) continue;
            const R = x.get(S + 1)?.isWrapped;
            if (v += T.translateToString(!R), !R || S === x.length - 1) {
              const F = document.createElement("div");
              F.textContent = v, w.push(F), v.length > 0 && (_ = F), v = "";
            }
          }
          return { bufferElements: w, cursorElement: _ };
        }
        getLinesScrolled(m) {
          if (m.deltaY === 0 || m.shiftKey) return 0;
          let b = this._applyScrollModifier(m.deltaY, m);
          return m.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (b /= this._currentRowHeight + 0, this._wheelPartialScroll += b, b = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : m.deltaMode === WheelEvent.DOM_DELTA_PAGE && (b *= this._bufferService.rows), b;
        }
        _applyScrollModifier(m, b) {
          const _ = this._optionsService.rawOptions.fastScrollModifier;
          return _ === "alt" && b.altKey || _ === "ctrl" && b.ctrlKey || _ === "shift" && b.shiftKey ? m * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : m * this._optionsService.rawOptions.scrollSensitivity;
        }
        handleTouchStart(m) {
          this._lastTouchY = m.touches[0].pageY;
        }
        handleTouchMove(m) {
          const b = this._lastTouchY - m.touches[0].pageY;
          return this._lastTouchY = m.touches[0].pageY, b !== 0 && (this._viewportElement.scrollTop += b, this._bubbleScroll(m, b));
        }
      };
      a.Viewport = p = c([u(2, y.IBufferService), u(3, y.IOptionsService), u(4, d.ICharSizeService), u(5, d.IRenderService), u(6, d.ICoreBrowserService), u(7, d.IThemeService)], p);
    }, 3107: function(o, a, l) {
      var c = this && this.__decorate || function(y, p, m, b) {
        var _, v = arguments.length, w = v < 3 ? p : b === null ? b = Object.getOwnPropertyDescriptor(p, m) : b;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(y, p, m, b);
        else for (var E = y.length - 1; E >= 0; E--) (_ = y[E]) && (w = (v < 3 ? _(w) : v > 3 ? _(p, m, w) : _(p, m)) || w);
        return v > 3 && w && Object.defineProperty(p, m, w), w;
      }, u = this && this.__param || function(y, p) {
        return function(m, b) {
          p(m, b, y);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferDecorationRenderer = void 0;
      const h = l(4725), d = l(844), f = l(2585);
      let g = a.BufferDecorationRenderer = class extends d.Disposable {
        constructor(y, p, m, b, _) {
          super(), this._screenElement = y, this._bufferService = p, this._coreBrowserService = m, this._decorationService = b, this._renderService = _, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = !1, this._dimensionsChanged = !1, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
            this._dimensionsChanged = !0, this._queueRefresh();
          })), this.register(this._coreBrowserService.onDprChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
          })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((v) => this._removeDecoration(v))), this.register((0, d.toDisposable)(() => {
            this._container.remove(), this._decorationElements.clear();
          }));
        }
        _queueRefresh() {
          this._animationFrame === void 0 && (this._animationFrame = this._renderService.addRefreshCallback(() => {
            this._doRefreshDecorations(), this._animationFrame = void 0;
          }));
        }
        _doRefreshDecorations() {
          for (const y of this._decorationService.decorations) this._renderDecoration(y);
          this._dimensionsChanged = !1;
        }
        _renderDecoration(y) {
          this._refreshStyle(y), this._dimensionsChanged && this._refreshXPosition(y);
        }
        _createElement(y) {
          const p = this._coreBrowserService.mainDocument.createElement("div");
          p.classList.add("xterm-decoration"), p.classList.toggle("xterm-decoration-top-layer", y?.options?.layer === "top"), p.style.width = `${Math.round((y.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, p.style.height = (y.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", p.style.top = (y.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", p.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
          const m = y.options.x ?? 0;
          return m && m > this._bufferService.cols && (p.style.display = "none"), this._refreshXPosition(y, p), p;
        }
        _refreshStyle(y) {
          const p = y.marker.line - this._bufferService.buffers.active.ydisp;
          if (p < 0 || p >= this._bufferService.rows) y.element && (y.element.style.display = "none", y.onRenderEmitter.fire(y.element));
          else {
            let m = this._decorationElements.get(y);
            m || (m = this._createElement(y), y.element = m, this._decorationElements.set(y, m), this._container.appendChild(m), y.onDispose(() => {
              this._decorationElements.delete(y), m.remove();
            })), m.style.top = p * this._renderService.dimensions.css.cell.height + "px", m.style.display = this._altBufferIsActive ? "none" : "block", y.onRenderEmitter.fire(m);
          }
        }
        _refreshXPosition(y, p = y.element) {
          if (!p) return;
          const m = y.options.x ?? 0;
          (y.options.anchor || "left") === "right" ? p.style.right = m ? m * this._renderService.dimensions.css.cell.width + "px" : "" : p.style.left = m ? m * this._renderService.dimensions.css.cell.width + "px" : "";
        }
        _removeDecoration(y) {
          this._decorationElements.get(y)?.remove(), this._decorationElements.delete(y), y.dispose();
        }
      };
      a.BufferDecorationRenderer = g = c([u(1, f.IBufferService), u(2, h.ICoreBrowserService), u(3, f.IDecorationService), u(4, h.IRenderService)], g);
    }, 5871: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ColorZoneStore = void 0, a.ColorZoneStore = class {
        constructor() {
          this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
        }
        get zones() {
          return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
        }
        clear() {
          this._zones.length = 0, this._zonePoolIndex = 0;
        }
        addDecoration(l) {
          if (l.options.overviewRulerOptions) {
            for (const c of this._zones) if (c.color === l.options.overviewRulerOptions.color && c.position === l.options.overviewRulerOptions.position) {
              if (this._lineIntersectsZone(c, l.marker.line)) return;
              if (this._lineAdjacentToZone(c, l.marker.line, l.options.overviewRulerOptions.position)) return void this._addLineToZone(c, l.marker.line);
            }
            if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = l.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = l.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = l.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = l.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
            this._zones.push({ color: l.options.overviewRulerOptions.color, position: l.options.overviewRulerOptions.position, startBufferLine: l.marker.line, endBufferLine: l.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
          }
        }
        setPadding(l) {
          this._linePadding = l;
        }
        _lineIntersectsZone(l, c) {
          return c >= l.startBufferLine && c <= l.endBufferLine;
        }
        _lineAdjacentToZone(l, c, u) {
          return c >= l.startBufferLine - this._linePadding[u || "full"] && c <= l.endBufferLine + this._linePadding[u || "full"];
        }
        _addLineToZone(l, c) {
          l.startBufferLine = Math.min(l.startBufferLine, c), l.endBufferLine = Math.max(l.endBufferLine, c);
        }
      };
    }, 5744: function(o, a, l) {
      var c = this && this.__decorate || function(_, v, w, E) {
        var x, S = arguments.length, T = S < 3 ? v : E === null ? E = Object.getOwnPropertyDescriptor(v, w) : E;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") T = Reflect.decorate(_, v, w, E);
        else for (var R = _.length - 1; R >= 0; R--) (x = _[R]) && (T = (S < 3 ? x(T) : S > 3 ? x(v, w, T) : x(v, w)) || T);
        return S > 3 && T && Object.defineProperty(v, w, T), T;
      }, u = this && this.__param || function(_, v) {
        return function(w, E) {
          v(w, E, _);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OverviewRulerRenderer = void 0;
      const h = l(5871), d = l(4725), f = l(844), g = l(2585), y = { full: 0, left: 0, center: 0, right: 0 }, p = { full: 0, left: 0, center: 0, right: 0 }, m = { full: 0, left: 0, center: 0, right: 0 };
      let b = a.OverviewRulerRenderer = class extends f.Disposable {
        get _width() {
          return this._optionsService.options.overviewRulerWidth || 0;
        }
        constructor(_, v, w, E, x, S, T) {
          super(), this._viewportElement = _, this._screenElement = v, this._bufferService = w, this._decorationService = E, this._renderService = x, this._optionsService = S, this._coreBrowserService = T, this._colorZoneStore = new h.ColorZoneStore(), this._shouldUpdateDimensions = !0, this._shouldUpdateAnchor = !0, this._lastKnownBufferLength = 0, this._canvas = this._coreBrowserService.mainDocument.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), this._viewportElement.parentElement?.insertBefore(this._canvas, this._viewportElement);
          const R = this._canvas.getContext("2d");
          if (!R) throw new Error("Ctx cannot be null");
          this._ctx = R, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, f.toDisposable)(() => {
            this._canvas?.remove();
          }));
        }
        _registerDecorationListeners() {
          this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, !0))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, !0)));
        }
        _registerBufferChangeListeners() {
          this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
          })), this.register(this._bufferService.onScroll(() => {
            this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
          }));
        }
        _registerDimensionChangeListeners() {
          this.register(this._renderService.onRender(() => {
            this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0), this._containerHeight = this._screenElement.clientHeight);
          })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(!0))), this.register(this._coreBrowserService.onDprChange(() => this._queueRefresh(!0))), this._queueRefresh(!0);
        }
        _refreshDrawConstants() {
          const _ = Math.floor(this._canvas.width / 3), v = Math.ceil(this._canvas.width / 3);
          p.full = this._canvas.width, p.left = _, p.center = v, p.right = _, this._refreshDrawHeightConstants(), m.full = 0, m.left = 0, m.center = p.left, m.right = p.left + p.center;
        }
        _refreshDrawHeightConstants() {
          y.full = Math.round(2 * this._coreBrowserService.dpr);
          const _ = this._canvas.height / this._bufferService.buffer.lines.length, v = Math.round(Math.max(Math.min(_, 12), 6) * this._coreBrowserService.dpr);
          y.left = v, y.center = v, y.right = v;
        }
        _refreshColorZonePadding() {
          this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * y.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * y.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * y.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * y.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
        }
        _refreshCanvasDimensions() {
          this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowserService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowserService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
        }
        _refreshDecorations() {
          this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
          for (const v of this._decorationService.decorations) this._colorZoneStore.addDecoration(v);
          this._ctx.lineWidth = 1;
          const _ = this._colorZoneStore.zones;
          for (const v of _) v.position !== "full" && this._renderColorZone(v);
          for (const v of _) v.position === "full" && this._renderColorZone(v);
          this._shouldUpdateDimensions = !1, this._shouldUpdateAnchor = !1;
        }
        _renderColorZone(_) {
          this._ctx.fillStyle = _.color, this._ctx.fillRect(m[_.position || "full"], Math.round((this._canvas.height - 1) * (_.startBufferLine / this._bufferService.buffers.active.lines.length) - y[_.position || "full"] / 2), p[_.position || "full"], Math.round((this._canvas.height - 1) * ((_.endBufferLine - _.startBufferLine) / this._bufferService.buffers.active.lines.length) + y[_.position || "full"]));
        }
        _queueRefresh(_, v) {
          this._shouldUpdateDimensions = _ || this._shouldUpdateDimensions, this._shouldUpdateAnchor = v || this._shouldUpdateAnchor, this._animationFrame === void 0 && (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
            this._refreshDecorations(), this._animationFrame = void 0;
          }));
        }
      };
      a.OverviewRulerRenderer = b = c([u(2, g.IBufferService), u(3, g.IDecorationService), u(4, d.IRenderService), u(5, g.IOptionsService), u(6, d.ICoreBrowserService)], b);
    }, 2950: function(o, a, l) {
      var c = this && this.__decorate || function(y, p, m, b) {
        var _, v = arguments.length, w = v < 3 ? p : b === null ? b = Object.getOwnPropertyDescriptor(p, m) : b;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(y, p, m, b);
        else for (var E = y.length - 1; E >= 0; E--) (_ = y[E]) && (w = (v < 3 ? _(w) : v > 3 ? _(p, m, w) : _(p, m)) || w);
        return v > 3 && w && Object.defineProperty(p, m, w), w;
      }, u = this && this.__param || function(y, p) {
        return function(m, b) {
          p(m, b, y);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CompositionHelper = void 0;
      const h = l(4725), d = l(2585), f = l(2584);
      let g = a.CompositionHelper = class {
        get isComposing() {
          return this._isComposing;
        }
        constructor(y, p, m, b, _, v) {
          this._textarea = y, this._compositionView = p, this._bufferService = m, this._optionsService = b, this._coreService = _, this._renderService = v, this._isComposing = !1, this._isSendingComposition = !1, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
        }
        compositionstart() {
          this._isComposing = !0, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
        }
        compositionupdate(y) {
          this._compositionView.textContent = y.data, this.updateCompositionElements(), setTimeout(() => {
            this._compositionPosition.end = this._textarea.value.length;
          }, 0);
        }
        compositionend() {
          this._finalizeComposition(!0);
        }
        keydown(y) {
          if (this._isComposing || this._isSendingComposition) {
            if (y.keyCode === 229 || y.keyCode === 16 || y.keyCode === 17 || y.keyCode === 18) return !1;
            this._finalizeComposition(!1);
          }
          return y.keyCode !== 229 || (this._handleAnyTextareaChanges(), !1);
        }
        _finalizeComposition(y) {
          if (this._compositionView.classList.remove("active"), this._isComposing = !1, y) {
            const p = { start: this._compositionPosition.start, end: this._compositionPosition.end };
            this._isSendingComposition = !0, setTimeout(() => {
              if (this._isSendingComposition) {
                let m;
                this._isSendingComposition = !1, p.start += this._dataAlreadySent.length, m = this._isComposing ? this._textarea.value.substring(p.start, p.end) : this._textarea.value.substring(p.start), m.length > 0 && this._coreService.triggerDataEvent(m, !0);
              }
            }, 0);
          } else {
            this._isSendingComposition = !1;
            const p = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
            this._coreService.triggerDataEvent(p, !0);
          }
        }
        _handleAnyTextareaChanges() {
          const y = this._textarea.value;
          setTimeout(() => {
            if (!this._isComposing) {
              const p = this._textarea.value, m = p.replace(y, "");
              this._dataAlreadySent = m, p.length > y.length ? this._coreService.triggerDataEvent(m, !0) : p.length < y.length ? this._coreService.triggerDataEvent(`${f.C0.DEL}`, !0) : p.length === y.length && p !== y && this._coreService.triggerDataEvent(p, !0);
            }
          }, 0);
        }
        updateCompositionElements(y) {
          if (this._isComposing) {
            if (this._bufferService.buffer.isCursorInViewport) {
              const p = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), m = this._renderService.dimensions.css.cell.height, b = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, _ = p * this._renderService.dimensions.css.cell.width;
              this._compositionView.style.left = _ + "px", this._compositionView.style.top = b + "px", this._compositionView.style.height = m + "px", this._compositionView.style.lineHeight = m + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
              const v = this._compositionView.getBoundingClientRect();
              this._textarea.style.left = _ + "px", this._textarea.style.top = b + "px", this._textarea.style.width = Math.max(v.width, 1) + "px", this._textarea.style.height = Math.max(v.height, 1) + "px", this._textarea.style.lineHeight = v.height + "px";
            }
            y || setTimeout(() => this.updateCompositionElements(!0), 0);
          }
        }
      };
      a.CompositionHelper = g = c([u(2, d.IBufferService), u(3, d.IOptionsService), u(4, d.ICoreService), u(5, h.IRenderService)], g);
    }, 9806: (o, a) => {
      function l(c, u, h) {
        const d = h.getBoundingClientRect(), f = c.getComputedStyle(h), g = parseInt(f.getPropertyValue("padding-left")), y = parseInt(f.getPropertyValue("padding-top"));
        return [u.clientX - d.left - g, u.clientY - d.top - y];
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getCoords = a.getCoordsRelativeToElement = void 0, a.getCoordsRelativeToElement = l, a.getCoords = function(c, u, h, d, f, g, y, p, m) {
        if (!g) return;
        const b = l(c, u, h);
        return b ? (b[0] = Math.ceil((b[0] + (m ? y / 2 : 0)) / y), b[1] = Math.ceil(b[1] / p), b[0] = Math.min(Math.max(b[0], 1), d + (m ? 1 : 0)), b[1] = Math.min(Math.max(b[1], 1), f), b) : void 0;
      };
    }, 9504: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.moveToCellSequence = void 0;
      const c = l(2584);
      function u(p, m, b, _) {
        const v = p - h(p, b), w = m - h(m, b), E = Math.abs(v - w) - function(x, S, T) {
          let R = 0;
          const F = x - h(x, T), P = S - h(S, T);
          for (let M = 0; M < Math.abs(F - P); M++) {
            const A = d(x, S) === "A" ? -1 : 1;
            T.buffer.lines.get(F + A * M)?.isWrapped && R++;
          }
          return R;
        }(p, m, b);
        return y(E, g(d(p, m), _));
      }
      function h(p, m) {
        let b = 0, _ = m.buffer.lines.get(p), v = _?.isWrapped;
        for (; v && p >= 0 && p < m.rows; ) b++, _ = m.buffer.lines.get(--p), v = _?.isWrapped;
        return b;
      }
      function d(p, m) {
        return p > m ? "A" : "B";
      }
      function f(p, m, b, _, v, w) {
        let E = p, x = m, S = "";
        for (; E !== b || x !== _; ) E += v ? 1 : -1, v && E > w.cols - 1 ? (S += w.buffer.translateBufferLineToString(x, !1, p, E), E = 0, p = 0, x++) : !v && E < 0 && (S += w.buffer.translateBufferLineToString(x, !1, 0, p + 1), E = w.cols - 1, p = E, x--);
        return S + w.buffer.translateBufferLineToString(x, !1, p, E);
      }
      function g(p, m) {
        const b = m ? "O" : "[";
        return c.C0.ESC + b + p;
      }
      function y(p, m) {
        p = Math.floor(p);
        let b = "";
        for (let _ = 0; _ < p; _++) b += m;
        return b;
      }
      a.moveToCellSequence = function(p, m, b, _) {
        const v = b.buffer.x, w = b.buffer.y;
        if (!b.buffer.hasScrollback) return function(S, T, R, F, P, M) {
          return u(T, F, P, M).length === 0 ? "" : y(f(S, T, S, T - h(T, P), !1, P).length, g("D", M));
        }(v, w, 0, m, b, _) + u(w, m, b, _) + function(S, T, R, F, P, M) {
          let A;
          A = u(T, F, P, M).length > 0 ? F - h(F, P) : T;
          const V = F, ee = function(K, te, N, L, j, H) {
            let U;
            return U = u(N, L, j, H).length > 0 ? L - h(L, j) : te, K < N && U <= L || K >= N && U < L ? "C" : "D";
          }(S, T, R, F, P, M);
          return y(f(S, A, R, V, ee === "C", P).length, g(ee, M));
        }(v, w, p, m, b, _);
        let E;
        if (w === m) return E = v > p ? "D" : "C", y(Math.abs(v - p), g(E, _));
        E = w > m ? "D" : "C";
        const x = Math.abs(w - m);
        return y(function(S, T) {
          return T.cols - S;
        }(w > m ? p : v, b) + (x - 1) * b.cols + 1 + ((w > m ? v : p) - 1), g(E, _));
      };
    }, 1296: function(o, a, l) {
      var c = this && this.__decorate || function(M, A, V, ee) {
        var K, te = arguments.length, N = te < 3 ? A : ee === null ? ee = Object.getOwnPropertyDescriptor(A, V) : ee;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") N = Reflect.decorate(M, A, V, ee);
        else for (var L = M.length - 1; L >= 0; L--) (K = M[L]) && (N = (te < 3 ? K(N) : te > 3 ? K(A, V, N) : K(A, V)) || N);
        return te > 3 && N && Object.defineProperty(A, V, N), N;
      }, u = this && this.__param || function(M, A) {
        return function(V, ee) {
          A(V, ee, M);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DomRenderer = void 0;
      const h = l(3787), d = l(2550), f = l(2223), g = l(6171), y = l(6052), p = l(4725), m = l(8055), b = l(8460), _ = l(844), v = l(2585), w = "xterm-dom-renderer-owner-", E = "xterm-rows", x = "xterm-fg-", S = "xterm-bg-", T = "xterm-focus", R = "xterm-selection";
      let F = 1, P = a.DomRenderer = class extends _.Disposable {
        constructor(M, A, V, ee, K, te, N, L, j, H, U, Y, ne) {
          super(), this._terminal = M, this._document = A, this._element = V, this._screenElement = ee, this._viewportElement = K, this._helperContainer = te, this._linkifier2 = N, this._charSizeService = j, this._optionsService = H, this._bufferService = U, this._coreBrowserService = Y, this._themeService = ne, this._terminalClass = F++, this._rowElements = [], this._selectionRenderModel = (0, y.createSelectionRenderModel)(), this.onRequestRedraw = this.register(new b.EventEmitter()).event, this._rowContainer = this._document.createElement("div"), this._rowContainer.classList.add(E), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = this._document.createElement("div"), this._selectionContainer.classList.add(R), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, g.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((he) => this._injectCss(he))), this._injectCss(this._themeService.colors), this._rowFactory = L.createInstance(h.DomRendererRowFactory, document), this._element.classList.add(w + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((he) => this._handleLinkHover(he))), this.register(this._linkifier2.onHideLinkUnderline((he) => this._handleLinkLeave(he))), this.register((0, _.toDisposable)(() => {
            this._element.classList.remove(w + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
          })), this._widthCache = new d.WidthCache(this._document, this._helperContainer), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        _updateDimensions() {
          const M = this._coreBrowserService.dpr;
          this.dimensions.device.char.width = this._charSizeService.width * M, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * M), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / M), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / M), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
          for (const V of this._rowElements) V.style.width = `${this.dimensions.css.canvas.width}px`, V.style.height = `${this.dimensions.css.cell.height}px`, V.style.lineHeight = `${this.dimensions.css.cell.height}px`, V.style.overflow = "hidden";
          this._dimensionsStyleElement || (this._dimensionsStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
          const A = `${this._terminalSelector} .${E} span { display: inline-block; height: 100%; vertical-align: top;}`;
          this._dimensionsStyleElement.textContent = A, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
        }
        _injectCss(M) {
          this._themeStyleElement || (this._themeStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
          let A = `${this._terminalSelector} .${E} { color: ${M.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
          A += `${this._terminalSelector} .${E} .xterm-dim { color: ${m.color.multiplyOpacity(M.foreground, 0.5).css};}`, A += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`;
          const V = `blink_underline_${this._terminalClass}`, ee = `blink_bar_${this._terminalClass}`, K = `blink_block_${this._terminalClass}`;
          A += `@keyframes ${V} { 50% {  border-bottom-style: hidden; }}`, A += `@keyframes ${ee} { 50% {  box-shadow: none; }}`, A += `@keyframes ${K} { 0% {  background-color: ${M.cursor.css};  color: ${M.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${M.cursor.css}; }}`, A += `${this._terminalSelector} .${E}.${T} .xterm-cursor.xterm-cursor-blink.xterm-cursor-underline { animation: ${V} 1s step-end infinite;}${this._terminalSelector} .${E}.${T} .xterm-cursor.xterm-cursor-blink.xterm-cursor-bar { animation: ${ee} 1s step-end infinite;}${this._terminalSelector} .${E}.${T} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: ${K} 1s step-end infinite;}${this._terminalSelector} .${E} .xterm-cursor.xterm-cursor-block { background-color: ${M.cursor.css}; color: ${M.cursorAccent.css};}${this._terminalSelector} .${E} .xterm-cursor.xterm-cursor-block:not(.xterm-cursor-blink) { background-color: ${M.cursor.css} !important; color: ${M.cursorAccent.css} !important;}${this._terminalSelector} .${E} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${M.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${E} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${M.cursor.css} inset;}${this._terminalSelector} .${E} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${M.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, A += `${this._terminalSelector} .${R} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${R} div { position: absolute; background-color: ${M.selectionBackgroundOpaque.css};}${this._terminalSelector} .${R} div { position: absolute; background-color: ${M.selectionInactiveBackgroundOpaque.css};}`;
          for (const [te, N] of M.ansi.entries()) A += `${this._terminalSelector} .${x}${te} { color: ${N.css}; }${this._terminalSelector} .${x}${te}.xterm-dim { color: ${m.color.multiplyOpacity(N, 0.5).css}; }${this._terminalSelector} .${S}${te} { background-color: ${N.css}; }`;
          A += `${this._terminalSelector} .${x}${f.INVERTED_DEFAULT_COLOR} { color: ${m.color.opaque(M.background).css}; }${this._terminalSelector} .${x}${f.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${m.color.multiplyOpacity(m.color.opaque(M.background), 0.5).css}; }${this._terminalSelector} .${S}${f.INVERTED_DEFAULT_COLOR} { background-color: ${M.foreground.css}; }`, this._themeStyleElement.textContent = A;
        }
        _setDefaultSpacing() {
          const M = this.dimensions.css.cell.width - this._widthCache.get("W", !1, !1);
          this._rowContainer.style.letterSpacing = `${M}px`, this._rowFactory.defaultSpacing = M;
        }
        handleDevicePixelRatioChange() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        _refreshRowElements(M, A) {
          for (let V = this._rowElements.length; V <= A; V++) {
            const ee = this._document.createElement("div");
            this._rowContainer.appendChild(ee), this._rowElements.push(ee);
          }
          for (; this._rowElements.length > A; ) this._rowContainer.removeChild(this._rowElements.pop());
        }
        handleResize(M, A) {
          this._refreshRowElements(M, A), this._updateDimensions(), this.handleSelectionChanged(this._selectionRenderModel.selectionStart, this._selectionRenderModel.selectionEnd, this._selectionRenderModel.columnSelectMode);
        }
        handleCharSizeChanged() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        handleBlur() {
          this._rowContainer.classList.remove(T), this.renderRows(0, this._bufferService.rows - 1);
        }
        handleFocus() {
          this._rowContainer.classList.add(T), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
        }
        handleSelectionChanged(M, A, V) {
          if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(M, A, V), this.renderRows(0, this._bufferService.rows - 1), !M || !A) return;
          this._selectionRenderModel.update(this._terminal, M, A, V);
          const ee = this._selectionRenderModel.viewportStartRow, K = this._selectionRenderModel.viewportEndRow, te = this._selectionRenderModel.viewportCappedStartRow, N = this._selectionRenderModel.viewportCappedEndRow;
          if (te >= this._bufferService.rows || N < 0) return;
          const L = this._document.createDocumentFragment();
          if (V) {
            const j = M[0] > A[0];
            L.appendChild(this._createSelectionElement(te, j ? A[0] : M[0], j ? M[0] : A[0], N - te + 1));
          } else {
            const j = ee === te ? M[0] : 0, H = te === K ? A[0] : this._bufferService.cols;
            L.appendChild(this._createSelectionElement(te, j, H));
            const U = N - te - 1;
            if (L.appendChild(this._createSelectionElement(te + 1, 0, this._bufferService.cols, U)), te !== N) {
              const Y = K === N ? A[0] : this._bufferService.cols;
              L.appendChild(this._createSelectionElement(N, 0, Y));
            }
          }
          this._selectionContainer.appendChild(L);
        }
        _createSelectionElement(M, A, V, ee = 1) {
          const K = this._document.createElement("div"), te = A * this.dimensions.css.cell.width;
          let N = this.dimensions.css.cell.width * (V - A);
          return te + N > this.dimensions.css.canvas.width && (N = this.dimensions.css.canvas.width - te), K.style.height = ee * this.dimensions.css.cell.height + "px", K.style.top = M * this.dimensions.css.cell.height + "px", K.style.left = `${te}px`, K.style.width = `${N}px`, K;
        }
        handleCursorMove() {
        }
        _handleOptionsChanged() {
          this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        clear() {
          for (const M of this._rowElements) M.replaceChildren();
        }
        renderRows(M, A) {
          const V = this._bufferService.buffer, ee = V.ybase + V.y, K = Math.min(V.x, this._bufferService.cols - 1), te = this._optionsService.rawOptions.cursorBlink, N = this._optionsService.rawOptions.cursorStyle, L = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let j = M; j <= A; j++) {
            const H = j + V.ydisp, U = this._rowElements[j], Y = V.lines.get(H);
            if (!U || !Y) break;
            U.replaceChildren(...this._rowFactory.createRow(Y, H, H === ee, N, L, K, te, this.dimensions.css.cell.width, this._widthCache, -1, -1));
          }
        }
        get _terminalSelector() {
          return `.${w}${this._terminalClass}`;
        }
        _handleLinkHover(M) {
          this._setCellUnderline(M.x1, M.x2, M.y1, M.y2, M.cols, !0);
        }
        _handleLinkLeave(M) {
          this._setCellUnderline(M.x1, M.x2, M.y1, M.y2, M.cols, !1);
        }
        _setCellUnderline(M, A, V, ee, K, te) {
          V < 0 && (M = 0), ee < 0 && (A = 0);
          const N = this._bufferService.rows - 1;
          V = Math.max(Math.min(V, N), 0), ee = Math.max(Math.min(ee, N), 0), K = Math.min(K, this._bufferService.cols);
          const L = this._bufferService.buffer, j = L.ybase + L.y, H = Math.min(L.x, K - 1), U = this._optionsService.rawOptions.cursorBlink, Y = this._optionsService.rawOptions.cursorStyle, ne = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let he = V; he <= ee; ++he) {
            const X = he + L.ydisp, z = this._rowElements[he], ue = L.lines.get(X);
            if (!z || !ue) break;
            z.replaceChildren(...this._rowFactory.createRow(ue, X, X === j, Y, ne, H, U, this.dimensions.css.cell.width, this._widthCache, te ? he === V ? M : 0 : -1, te ? (he === ee ? A : K) - 1 : -1));
          }
        }
      };
      a.DomRenderer = P = c([u(7, v.IInstantiationService), u(8, p.ICharSizeService), u(9, v.IOptionsService), u(10, v.IBufferService), u(11, p.ICoreBrowserService), u(12, p.IThemeService)], P);
    }, 3787: function(o, a, l) {
      var c = this && this.__decorate || function(E, x, S, T) {
        var R, F = arguments.length, P = F < 3 ? x : T === null ? T = Object.getOwnPropertyDescriptor(x, S) : T;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") P = Reflect.decorate(E, x, S, T);
        else for (var M = E.length - 1; M >= 0; M--) (R = E[M]) && (P = (F < 3 ? R(P) : F > 3 ? R(x, S, P) : R(x, S)) || P);
        return F > 3 && P && Object.defineProperty(x, S, P), P;
      }, u = this && this.__param || function(E, x) {
        return function(S, T) {
          x(S, T, E);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DomRendererRowFactory = void 0;
      const h = l(2223), d = l(643), f = l(511), g = l(2585), y = l(8055), p = l(4725), m = l(4269), b = l(6171), _ = l(3734);
      let v = a.DomRendererRowFactory = class {
        constructor(E, x, S, T, R, F, P) {
          this._document = E, this._characterJoinerService = x, this._optionsService = S, this._coreBrowserService = T, this._coreService = R, this._decorationService = F, this._themeService = P, this._workCell = new f.CellData(), this._columnSelectMode = !1, this.defaultSpacing = 0;
        }
        handleSelectionChanged(E, x, S) {
          this._selectionStart = E, this._selectionEnd = x, this._columnSelectMode = S;
        }
        createRow(E, x, S, T, R, F, P, M, A, V, ee) {
          const K = [], te = this._characterJoinerService.getJoinedCharacters(x), N = this._themeService.colors;
          let L, j = E.getNoBgTrimmedLength();
          S && j < F + 1 && (j = F + 1);
          let H = 0, U = "", Y = 0, ne = 0, he = 0, X = !1, z = 0, ue = !1, ae = 0;
          const be = [], de = V !== -1 && ee !== -1;
          for (let _e = 0; _e < j; _e++) {
            E.loadCell(_e, this._workCell);
            let $ = this._workCell.getWidth();
            if ($ === 0) continue;
            let ce = !1, re = _e, W = this._workCell;
            if (te.length > 0 && _e === te[0][0]) {
              ce = !0;
              const B = te.shift();
              W = new m.JoinedCellData(this._workCell, E.translateToString(!0, B[0], B[1]), B[1] - B[0]), re = B[1] - 1, $ = W.getWidth();
            }
            const q = this._isCellInSelection(_e, x), ie = S && _e === F, ye = de && _e >= V && _e <= ee;
            let xe = !1;
            this._decorationService.forEachDecorationAtCell(_e, x, void 0, (B) => {
              xe = !0;
            });
            let fe = W.getChars() || d.WHITESPACE_CELL_CHAR;
            if (fe === " " && (W.isUnderline() || W.isOverline()) && (fe = ""), ae = $ * M - A.get(fe, W.isBold(), W.isItalic()), L) {
              if (H && (q && ue || !q && !ue && W.bg === Y) && (q && ue && N.selectionForeground || W.fg === ne) && W.extended.ext === he && ye === X && ae === z && !ie && !ce && !xe) {
                W.isInvisible() ? U += d.WHITESPACE_CELL_CHAR : U += fe, H++;
                continue;
              }
              H && (L.textContent = U), L = this._document.createElement("span"), H = 0, U = "";
            } else L = this._document.createElement("span");
            if (Y = W.bg, ne = W.fg, he = W.extended.ext, X = ye, z = ae, ue = q, ce && F >= _e && F <= re && (F = _e), !this._coreService.isCursorHidden && ie && this._coreService.isCursorInitialized) {
              if (be.push("xterm-cursor"), this._coreBrowserService.isFocused) P && be.push("xterm-cursor-blink"), be.push(T === "bar" ? "xterm-cursor-bar" : T === "underline" ? "xterm-cursor-underline" : "xterm-cursor-block");
              else if (R) switch (R) {
                case "outline":
                  be.push("xterm-cursor-outline");
                  break;
                case "block":
                  be.push("xterm-cursor-block");
                  break;
                case "bar":
                  be.push("xterm-cursor-bar");
                  break;
                case "underline":
                  be.push("xterm-cursor-underline");
              }
            }
            if (W.isBold() && be.push("xterm-bold"), W.isItalic() && be.push("xterm-italic"), W.isDim() && be.push("xterm-dim"), U = W.isInvisible() ? d.WHITESPACE_CELL_CHAR : W.getChars() || d.WHITESPACE_CELL_CHAR, W.isUnderline() && (be.push(`xterm-underline-${W.extended.underlineStyle}`), U === " " && (U = ""), !W.isUnderlineColorDefault())) if (W.isUnderlineColorRGB()) L.style.textDecorationColor = `rgb(${_.AttributeData.toColorRGB(W.getUnderlineColor()).join(",")})`;
            else {
              let B = W.getUnderlineColor();
              this._optionsService.rawOptions.drawBoldTextInBrightColors && W.isBold() && B < 8 && (B += 8), L.style.textDecorationColor = N.ansi[B].css;
            }
            W.isOverline() && (be.push("xterm-overline"), U === " " && (U = "")), W.isStrikethrough() && be.push("xterm-strikethrough"), ye && (L.style.textDecoration = "underline");
            let Ce = W.getFgColor(), ve = W.getFgColorMode(), Ee = W.getBgColor(), oe = W.getBgColorMode();
            const Te = !!W.isInverse();
            if (Te) {
              const B = Ce;
              Ce = Ee, Ee = B;
              const Z = ve;
              ve = oe, oe = Z;
            }
            let ke, Ge, G, O = !1;
            switch (this._decorationService.forEachDecorationAtCell(_e, x, void 0, (B) => {
              B.options.layer !== "top" && O || (B.backgroundColorRGB && (oe = 50331648, Ee = B.backgroundColorRGB.rgba >> 8 & 16777215, ke = B.backgroundColorRGB), B.foregroundColorRGB && (ve = 50331648, Ce = B.foregroundColorRGB.rgba >> 8 & 16777215, Ge = B.foregroundColorRGB), O = B.options.layer === "top");
            }), !O && q && (ke = this._coreBrowserService.isFocused ? N.selectionBackgroundOpaque : N.selectionInactiveBackgroundOpaque, Ee = ke.rgba >> 8 & 16777215, oe = 50331648, O = !0, N.selectionForeground && (ve = 50331648, Ce = N.selectionForeground.rgba >> 8 & 16777215, Ge = N.selectionForeground)), O && be.push("xterm-decoration-top"), oe) {
              case 16777216:
              case 33554432:
                G = N.ansi[Ee], be.push(`xterm-bg-${Ee}`);
                break;
              case 50331648:
                G = y.channels.toColor(Ee >> 16, Ee >> 8 & 255, 255 & Ee), this._addStyle(L, `background-color:#${w((Ee >>> 0).toString(16), "0", 6)}`);
                break;
              default:
                Te ? (G = N.foreground, be.push(`xterm-bg-${h.INVERTED_DEFAULT_COLOR}`)) : G = N.background;
            }
            switch (ke || W.isDim() && (ke = y.color.multiplyOpacity(G, 0.5)), ve) {
              case 16777216:
              case 33554432:
                W.isBold() && Ce < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (Ce += 8), this._applyMinimumContrast(L, G, N.ansi[Ce], W, ke, void 0) || be.push(`xterm-fg-${Ce}`);
                break;
              case 50331648:
                const B = y.channels.toColor(Ce >> 16 & 255, Ce >> 8 & 255, 255 & Ce);
                this._applyMinimumContrast(L, G, B, W, ke, Ge) || this._addStyle(L, `color:#${w(Ce.toString(16), "0", 6)}`);
                break;
              default:
                this._applyMinimumContrast(L, G, N.foreground, W, ke, Ge) || Te && be.push(`xterm-fg-${h.INVERTED_DEFAULT_COLOR}`);
            }
            be.length && (L.className = be.join(" "), be.length = 0), ie || ce || xe ? L.textContent = U : H++, ae !== this.defaultSpacing && (L.style.letterSpacing = `${ae}px`), K.push(L), _e = re;
          }
          return L && H && (L.textContent = U), K;
        }
        _applyMinimumContrast(E, x, S, T, R, F) {
          if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0, b.treatGlyphAsBackgroundColor)(T.getCode())) return !1;
          const P = this._getContrastCache(T);
          let M;
          if (R || F || (M = P.getColor(x.rgba, S.rgba)), M === void 0) {
            const A = this._optionsService.rawOptions.minimumContrastRatio / (T.isDim() ? 2 : 1);
            M = y.color.ensureContrastRatio(R || x, F || S, A), P.setColor((R || x).rgba, (F || S).rgba, M ?? null);
          }
          return !!M && (this._addStyle(E, `color:${M.css}`), !0);
        }
        _getContrastCache(E) {
          return E.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
        }
        _addStyle(E, x) {
          E.setAttribute("style", `${E.getAttribute("style") || ""}${x};`);
        }
        _isCellInSelection(E, x) {
          const S = this._selectionStart, T = this._selectionEnd;
          return !(!S || !T) && (this._columnSelectMode ? S[0] <= T[0] ? E >= S[0] && x >= S[1] && E < T[0] && x <= T[1] : E < S[0] && x >= S[1] && E >= T[0] && x <= T[1] : x > S[1] && x < T[1] || S[1] === T[1] && x === S[1] && E >= S[0] && E < T[0] || S[1] < T[1] && x === T[1] && E < T[0] || S[1] < T[1] && x === S[1] && E >= S[0]);
        }
      };
      function w(E, x, S) {
        for (; E.length < S; ) E = x + E;
        return E;
      }
      a.DomRendererRowFactory = v = c([u(1, p.ICharacterJoinerService), u(2, g.IOptionsService), u(3, p.ICoreBrowserService), u(4, g.ICoreService), u(5, g.IDecorationService), u(6, p.IThemeService)], v);
    }, 2550: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.WidthCache = void 0, a.WidthCache = class {
        constructor(l, c) {
          this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = l.createElement("div"), this._container.classList.add("xterm-width-cache-measure-container"), this._container.setAttribute("aria-hidden", "true"), this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
          const u = l.createElement("span");
          u.classList.add("xterm-char-measure-element");
          const h = l.createElement("span");
          h.classList.add("xterm-char-measure-element"), h.style.fontWeight = "bold";
          const d = l.createElement("span");
          d.classList.add("xterm-char-measure-element"), d.style.fontStyle = "italic";
          const f = l.createElement("span");
          f.classList.add("xterm-char-measure-element"), f.style.fontWeight = "bold", f.style.fontStyle = "italic", this._measureElements = [u, h, d, f], this._container.appendChild(u), this._container.appendChild(h), this._container.appendChild(d), this._container.appendChild(f), c.appendChild(this._container), this.clear();
        }
        dispose() {
          this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
        }
        clear() {
          this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
        }
        setFont(l, c, u, h) {
          l === this._font && c === this._fontSize && u === this._weight && h === this._weightBold || (this._font = l, this._fontSize = c, this._weight = u, this._weightBold = h, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${u}`, this._measureElements[1].style.fontWeight = `${h}`, this._measureElements[2].style.fontWeight = `${u}`, this._measureElements[3].style.fontWeight = `${h}`, this.clear());
        }
        get(l, c, u) {
          let h = 0;
          if (!c && !u && l.length === 1 && (h = l.charCodeAt(0)) < 256) {
            if (this._flat[h] !== -9999) return this._flat[h];
            const g = this._measure(l, 0);
            return g > 0 && (this._flat[h] = g), g;
          }
          let d = l;
          c && (d += "B"), u && (d += "I");
          let f = this._holey.get(d);
          if (f === void 0) {
            let g = 0;
            c && (g |= 1), u && (g |= 2), f = this._measure(l, g), f > 0 && this._holey.set(d, f);
          }
          return f;
        }
        _measure(l, c) {
          const u = this._measureElements[c];
          return u.textContent = l.repeat(32), u.offsetWidth / 32;
        }
      };
    }, 2223: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.TEXT_BASELINE = a.DIM_OPACITY = a.INVERTED_DEFAULT_COLOR = void 0;
      const c = l(6114);
      a.INVERTED_DEFAULT_COLOR = 257, a.DIM_OPACITY = 0.5, a.TEXT_BASELINE = c.isFirefox || c.isLegacyEdge ? "bottom" : "ideographic";
    }, 6171: (o, a) => {
      function l(u) {
        return 57508 <= u && u <= 57558;
      }
      function c(u) {
        return u >= 128512 && u <= 128591 || u >= 127744 && u <= 128511 || u >= 128640 && u <= 128767 || u >= 9728 && u <= 9983 || u >= 9984 && u <= 10175 || u >= 65024 && u <= 65039 || u >= 129280 && u <= 129535 || u >= 127462 && u <= 127487;
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.computeNextVariantOffset = a.createRenderDimensions = a.treatGlyphAsBackgroundColor = a.allowRescaling = a.isEmoji = a.isRestrictedPowerlineGlyph = a.isPowerlineGlyph = a.throwIfFalsy = void 0, a.throwIfFalsy = function(u) {
        if (!u) throw new Error("value must not be falsy");
        return u;
      }, a.isPowerlineGlyph = l, a.isRestrictedPowerlineGlyph = function(u) {
        return 57520 <= u && u <= 57527;
      }, a.isEmoji = c, a.allowRescaling = function(u, h, d, f) {
        return h === 1 && d > Math.ceil(1.5 * f) && u !== void 0 && u > 255 && !c(u) && !l(u) && !function(g) {
          return 57344 <= g && g <= 63743;
        }(u);
      }, a.treatGlyphAsBackgroundColor = function(u) {
        return l(u) || function(h) {
          return 9472 <= h && h <= 9631;
        }(u);
      }, a.createRenderDimensions = function() {
        return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
      }, a.computeNextVariantOffset = function(u, h, d = 0) {
        return (u - (2 * Math.round(h) - d)) % (2 * Math.round(h));
      };
    }, 6052: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.createSelectionRenderModel = void 0;
      class l {
        constructor() {
          this.clear();
        }
        clear() {
          this.hasSelection = !1, this.columnSelectMode = !1, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0;
        }
        update(u, h, d, f = !1) {
          if (this.selectionStart = h, this.selectionEnd = d, !h || !d || h[0] === d[0] && h[1] === d[1]) return void this.clear();
          const g = u.buffers.active.ydisp, y = h[1] - g, p = d[1] - g, m = Math.max(y, 0), b = Math.min(p, u.rows - 1);
          m >= u.rows || b < 0 ? this.clear() : (this.hasSelection = !0, this.columnSelectMode = f, this.viewportStartRow = y, this.viewportEndRow = p, this.viewportCappedStartRow = m, this.viewportCappedEndRow = b, this.startCol = h[0], this.endCol = d[0]);
        }
        isCellSelected(u, h, d) {
          return !!this.hasSelection && (d -= u.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? h >= this.startCol && d >= this.viewportCappedStartRow && h < this.endCol && d <= this.viewportCappedEndRow : h < this.startCol && d >= this.viewportCappedStartRow && h >= this.endCol && d <= this.viewportCappedEndRow : d > this.viewportStartRow && d < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && d === this.viewportStartRow && h >= this.startCol && h < this.endCol || this.viewportStartRow < this.viewportEndRow && d === this.viewportEndRow && h < this.endCol || this.viewportStartRow < this.viewportEndRow && d === this.viewportStartRow && h >= this.startCol);
        }
      }
      a.createSelectionRenderModel = function() {
        return new l();
      };
    }, 456: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.SelectionModel = void 0, a.SelectionModel = class {
        constructor(l) {
          this._bufferService = l, this.isSelectAllActive = !1, this.selectionStartLength = 0;
        }
        clearSelection() {
          this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = !1, this.selectionStartLength = 0;
        }
        get finalSelectionStart() {
          return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
        }
        get finalSelectionEnd() {
          if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
          if (this.selectionStart) {
            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
              const l = this.selectionStart[0] + this.selectionStartLength;
              return l > this._bufferService.cols ? l % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols) - 1] : [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [l, this.selectionStart[1]];
            }
            if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
              const l = this.selectionStart[0] + this.selectionStartLength;
              return l > this._bufferService.cols ? [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [Math.max(l, this.selectionEnd[0]), this.selectionEnd[1]];
            }
            return this.selectionEnd;
          }
        }
        areSelectionValuesReversed() {
          const l = this.selectionStart, c = this.selectionEnd;
          return !(!l || !c) && (l[1] > c[1] || l[1] === c[1] && l[0] > c[0]);
        }
        handleTrim(l) {
          return this.selectionStart && (this.selectionStart[1] -= l), this.selectionEnd && (this.selectionEnd[1] -= l), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), !1);
        }
      };
    }, 428: function(o, a, l) {
      var c = this && this.__decorate || function(b, _, v, w) {
        var E, x = arguments.length, S = x < 3 ? _ : w === null ? w = Object.getOwnPropertyDescriptor(_, v) : w;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") S = Reflect.decorate(b, _, v, w);
        else for (var T = b.length - 1; T >= 0; T--) (E = b[T]) && (S = (x < 3 ? E(S) : x > 3 ? E(_, v, S) : E(_, v)) || S);
        return x > 3 && S && Object.defineProperty(_, v, S), S;
      }, u = this && this.__param || function(b, _) {
        return function(v, w) {
          _(v, w, b);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CharSizeService = void 0;
      const h = l(2585), d = l(8460), f = l(844);
      let g = a.CharSizeService = class extends f.Disposable {
        get hasValidSize() {
          return this.width > 0 && this.height > 0;
        }
        constructor(b, _, v) {
          super(), this._optionsService = v, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new d.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event;
          try {
            this._measureStrategy = this.register(new m(this._optionsService));
          } catch {
            this._measureStrategy = this.register(new p(b, _, this._optionsService));
          }
          this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
        }
        measure() {
          const b = this._measureStrategy.measure();
          b.width === this.width && b.height === this.height || (this.width = b.width, this.height = b.height, this._onCharSizeChange.fire());
        }
      };
      a.CharSizeService = g = c([u(2, h.IOptionsService)], g);
      class y extends f.Disposable {
        constructor() {
          super(...arguments), this._result = { width: 0, height: 0 };
        }
        _validateAndSet(_, v) {
          _ !== void 0 && _ > 0 && v !== void 0 && v > 0 && (this._result.width = _, this._result.height = v);
        }
      }
      class p extends y {
        constructor(_, v, w) {
          super(), this._document = _, this._parentElement = v, this._optionsService = w, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
        }
        measure() {
          return this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`, this._validateAndSet(Number(this._measureElement.offsetWidth) / 32, Number(this._measureElement.offsetHeight)), this._result;
        }
      }
      class m extends y {
        constructor(_) {
          super(), this._optionsService = _, this._canvas = new OffscreenCanvas(100, 100), this._ctx = this._canvas.getContext("2d");
          const v = this._ctx.measureText("W");
          if (!("width" in v && "fontBoundingBoxAscent" in v && "fontBoundingBoxDescent" in v)) throw new Error("Required font metrics not supported");
        }
        measure() {
          this._ctx.font = `${this._optionsService.rawOptions.fontSize}px ${this._optionsService.rawOptions.fontFamily}`;
          const _ = this._ctx.measureText("W");
          return this._validateAndSet(_.width, _.fontBoundingBoxAscent + _.fontBoundingBoxDescent), this._result;
        }
      }
    }, 4269: function(o, a, l) {
      var c = this && this.__decorate || function(m, b, _, v) {
        var w, E = arguments.length, x = E < 3 ? b : v === null ? v = Object.getOwnPropertyDescriptor(b, _) : v;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") x = Reflect.decorate(m, b, _, v);
        else for (var S = m.length - 1; S >= 0; S--) (w = m[S]) && (x = (E < 3 ? w(x) : E > 3 ? w(b, _, x) : w(b, _)) || x);
        return E > 3 && x && Object.defineProperty(b, _, x), x;
      }, u = this && this.__param || function(m, b) {
        return function(_, v) {
          b(_, v, m);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CharacterJoinerService = a.JoinedCellData = void 0;
      const h = l(3734), d = l(643), f = l(511), g = l(2585);
      class y extends h.AttributeData {
        constructor(b, _, v) {
          super(), this.content = 0, this.combinedData = "", this.fg = b.fg, this.bg = b.bg, this.combinedData = _, this._width = v;
        }
        isCombined() {
          return 2097152;
        }
        getWidth() {
          return this._width;
        }
        getChars() {
          return this.combinedData;
        }
        getCode() {
          return 2097151;
        }
        setFromCharData(b) {
          throw new Error("not implemented");
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      a.JoinedCellData = y;
      let p = a.CharacterJoinerService = class hq {
        constructor(b) {
          this._bufferService = b, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new f.CellData();
        }
        register(b) {
          const _ = { id: this._nextCharacterJoinerId++, handler: b };
          return this._characterJoiners.push(_), _.id;
        }
        deregister(b) {
          for (let _ = 0; _ < this._characterJoiners.length; _++) if (this._characterJoiners[_].id === b) return this._characterJoiners.splice(_, 1), !0;
          return !1;
        }
        getJoinedCharacters(b) {
          if (this._characterJoiners.length === 0) return [];
          const _ = this._bufferService.buffer.lines.get(b);
          if (!_ || _.length === 0) return [];
          const v = [], w = _.translateToString(!0);
          let E = 0, x = 0, S = 0, T = _.getFg(0), R = _.getBg(0);
          for (let F = 0; F < _.getTrimmedLength(); F++) if (_.loadCell(F, this._workCell), this._workCell.getWidth() !== 0) {
            if (this._workCell.fg !== T || this._workCell.bg !== R) {
              if (F - E > 1) {
                const P = this._getJoinedRanges(w, S, x, _, E);
                for (let M = 0; M < P.length; M++) v.push(P[M]);
              }
              E = F, S = x, T = this._workCell.fg, R = this._workCell.bg;
            }
            x += this._workCell.getChars().length || d.WHITESPACE_CELL_CHAR.length;
          }
          if (this._bufferService.cols - E > 1) {
            const F = this._getJoinedRanges(w, S, x, _, E);
            for (let P = 0; P < F.length; P++) v.push(F[P]);
          }
          return v;
        }
        _getJoinedRanges(b, _, v, w, E) {
          const x = b.substring(_, v);
          let S = [];
          try {
            S = this._characterJoiners[0].handler(x);
          } catch (T) {
            console.error(T);
          }
          for (let T = 1; T < this._characterJoiners.length; T++) try {
            const R = this._characterJoiners[T].handler(x);
            for (let F = 0; F < R.length; F++) hq._mergeRanges(S, R[F]);
          } catch (R) {
            console.error(R);
          }
          return this._stringRangesToCellRanges(S, w, E), S;
        }
        _stringRangesToCellRanges(b, _, v) {
          let w = 0, E = !1, x = 0, S = b[w];
          if (S) {
            for (let T = v; T < this._bufferService.cols; T++) {
              const R = _.getWidth(T), F = _.getString(T).length || d.WHITESPACE_CELL_CHAR.length;
              if (R !== 0) {
                if (!E && S[0] <= x && (S[0] = T, E = !0), S[1] <= x) {
                  if (S[1] = T, S = b[++w], !S) break;
                  S[0] <= x ? (S[0] = T, E = !0) : E = !1;
                }
                x += F;
              }
            }
            S && (S[1] = this._bufferService.cols);
          }
        }
        static _mergeRanges(b, _) {
          let v = !1;
          for (let w = 0; w < b.length; w++) {
            const E = b[w];
            if (v) {
              if (_[1] <= E[0]) return b[w - 1][1] = _[1], b;
              if (_[1] <= E[1]) return b[w - 1][1] = Math.max(_[1], E[1]), b.splice(w, 1), b;
              b.splice(w, 1), w--;
            } else {
              if (_[1] <= E[0]) return b.splice(w, 0, _), b;
              if (_[1] <= E[1]) return E[0] = Math.min(_[0], E[0]), b;
              _[0] < E[1] && (E[0] = Math.min(_[0], E[0]), v = !0);
            }
          }
          return v ? b[b.length - 1][1] = _[1] : b.push(_), b;
        }
      };
      a.CharacterJoinerService = p = c([u(0, g.IBufferService)], p);
    }, 5114: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreBrowserService = void 0;
      const c = l(844), u = l(8460), h = l(3656);
      class d extends c.Disposable {
        constructor(y, p, m) {
          super(), this._textarea = y, this._window = p, this.mainDocument = m, this._isFocused = !1, this._cachedIsFocused = void 0, this._screenDprMonitor = new f(this._window), this._onDprChange = this.register(new u.EventEmitter()), this.onDprChange = this._onDprChange.event, this._onWindowChange = this.register(new u.EventEmitter()), this.onWindowChange = this._onWindowChange.event, this.register(this.onWindowChange((b) => this._screenDprMonitor.setWindow(b))), this.register((0, u.forwardEvent)(this._screenDprMonitor.onDprChange, this._onDprChange)), this._textarea.addEventListener("focus", () => this._isFocused = !0), this._textarea.addEventListener("blur", () => this._isFocused = !1);
        }
        get window() {
          return this._window;
        }
        set window(y) {
          this._window !== y && (this._window = y, this._onWindowChange.fire(this._window));
        }
        get dpr() {
          return this.window.devicePixelRatio;
        }
        get isFocused() {
          return this._cachedIsFocused === void 0 && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
        }
      }
      a.CoreBrowserService = d;
      class f extends c.Disposable {
        constructor(y) {
          super(), this._parentWindow = y, this._windowResizeListener = this.register(new c.MutableDisposable()), this._onDprChange = this.register(new u.EventEmitter()), this.onDprChange = this._onDprChange.event, this._outerListener = () => this._setDprAndFireIfDiffers(), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._updateDpr(), this._setWindowResizeListener(), this.register((0, c.toDisposable)(() => this.clearListener()));
        }
        setWindow(y) {
          this._parentWindow = y, this._setWindowResizeListener(), this._setDprAndFireIfDiffers();
        }
        _setWindowResizeListener() {
          this._windowResizeListener.value = (0, h.addDisposableDomListener)(this._parentWindow, "resize", () => this._setDprAndFireIfDiffers());
        }
        _setDprAndFireIfDiffers() {
          this._parentWindow.devicePixelRatio !== this._currentDevicePixelRatio && this._onDprChange.fire(this._parentWindow.devicePixelRatio), this._updateDpr();
        }
        _updateDpr() {
          this._outerListener && (this._resolutionMediaMatchList?.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
        }
        clearListener() {
          this._resolutionMediaMatchList && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._outerListener = void 0);
        }
      }
    }, 779: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.LinkProviderService = void 0;
      const c = l(844);
      class u extends c.Disposable {
        constructor() {
          super(), this.linkProviders = [], this.register((0, c.toDisposable)(() => this.linkProviders.length = 0));
        }
        registerLinkProvider(d) {
          return this.linkProviders.push(d), { dispose: () => {
            const f = this.linkProviders.indexOf(d);
            f !== -1 && this.linkProviders.splice(f, 1);
          } };
        }
      }
      a.LinkProviderService = u;
    }, 8934: function(o, a, l) {
      var c = this && this.__decorate || function(g, y, p, m) {
        var b, _ = arguments.length, v = _ < 3 ? y : m === null ? m = Object.getOwnPropertyDescriptor(y, p) : m;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") v = Reflect.decorate(g, y, p, m);
        else for (var w = g.length - 1; w >= 0; w--) (b = g[w]) && (v = (_ < 3 ? b(v) : _ > 3 ? b(y, p, v) : b(y, p)) || v);
        return _ > 3 && v && Object.defineProperty(y, p, v), v;
      }, u = this && this.__param || function(g, y) {
        return function(p, m) {
          y(p, m, g);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.MouseService = void 0;
      const h = l(4725), d = l(9806);
      let f = a.MouseService = class {
        constructor(g, y) {
          this._renderService = g, this._charSizeService = y;
        }
        getCoords(g, y, p, m, b) {
          return (0, d.getCoords)(window, g, y, p, m, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, b);
        }
        getMouseReportCoords(g, y) {
          const p = (0, d.getCoordsRelativeToElement)(window, g, y);
          if (this._charSizeService.hasValidSize) return p[0] = Math.min(Math.max(p[0], 0), this._renderService.dimensions.css.canvas.width - 1), p[1] = Math.min(Math.max(p[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(p[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(p[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(p[0]), y: Math.floor(p[1]) };
        }
      };
      a.MouseService = f = c([u(0, h.IRenderService), u(1, h.ICharSizeService)], f);
    }, 3230: function(o, a, l) {
      var c = this && this.__decorate || function(b, _, v, w) {
        var E, x = arguments.length, S = x < 3 ? _ : w === null ? w = Object.getOwnPropertyDescriptor(_, v) : w;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") S = Reflect.decorate(b, _, v, w);
        else for (var T = b.length - 1; T >= 0; T--) (E = b[T]) && (S = (x < 3 ? E(S) : x > 3 ? E(_, v, S) : E(_, v)) || S);
        return x > 3 && S && Object.defineProperty(_, v, S), S;
      }, u = this && this.__param || function(b, _) {
        return function(v, w) {
          _(v, w, b);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.RenderService = void 0;
      const h = l(6193), d = l(4725), f = l(8460), g = l(844), y = l(7226), p = l(2585);
      let m = a.RenderService = class extends g.Disposable {
        get dimensions() {
          return this._renderer.value.dimensions;
        }
        constructor(b, _, v, w, E, x, S, T) {
          super(), this._rowCount = b, this._charSizeService = w, this._renderer = this.register(new g.MutableDisposable()), this._pausedResizeTask = new y.DebouncedIdleTask(), this._observerDisposable = this.register(new g.MutableDisposable()), this._isPaused = !1, this._needsFullRefresh = !1, this._isNextRenderRedrawOnly = !0, this._needsSelectionRefresh = !1, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: !1 }, this._onDimensionsChange = this.register(new f.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new f.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new f.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new f.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new h.RenderDebouncer((R, F) => this._renderRows(R, F), S), this.register(this._renderDebouncer), this.register(S.onDprChange(() => this.handleDevicePixelRatioChange())), this.register(x.onResize(() => this._fullRefresh())), this.register(x.buffers.onBufferActivate(() => this._renderer.value?.clear())), this.register(v.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(E.onDecorationRegistered(() => this._fullRefresh())), this.register(E.onDecorationRemoved(() => this._fullRefresh())), this.register(v.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio", "rescaleOverlappingGlyphs"], () => {
            this.clear(), this.handleResize(x.cols, x.rows), this._fullRefresh();
          })), this.register(v.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(x.buffer.y, x.buffer.y, !0))), this.register(T.onChangeColors(() => this._fullRefresh())), this._registerIntersectionObserver(S.window, _), this.register(S.onWindowChange((R) => this._registerIntersectionObserver(R, _)));
        }
        _registerIntersectionObserver(b, _) {
          if ("IntersectionObserver" in b) {
            const v = new b.IntersectionObserver((w) => this._handleIntersectionChange(w[w.length - 1]), { threshold: 0 });
            v.observe(_), this._observerDisposable.value = (0, g.toDisposable)(() => v.disconnect());
          }
        }
        _handleIntersectionChange(b) {
          this._isPaused = b.isIntersecting === void 0 ? b.intersectionRatio === 0 : !b.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = !1);
        }
        refreshRows(b, _, v = !1) {
          this._isPaused ? this._needsFullRefresh = !0 : (v || (this._isNextRenderRedrawOnly = !1), this._renderDebouncer.refresh(b, _, this._rowCount));
        }
        _renderRows(b, _) {
          this._renderer.value && (b = Math.min(b, this._rowCount - 1), _ = Math.min(_, this._rowCount - 1), this._renderer.value.renderRows(b, _), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = !1), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: b, end: _ }), this._onRender.fire({ start: b, end: _ }), this._isNextRenderRedrawOnly = !0);
        }
        resize(b, _) {
          this._rowCount = _, this._fireOnCanvasResize();
        }
        _handleOptionsChanged() {
          this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
        }
        _fireOnCanvasResize() {
          this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
        }
        hasRenderer() {
          return !!this._renderer.value;
        }
        setRenderer(b) {
          this._renderer.value = b, this._renderer.value && (this._renderer.value.onRequestRedraw((_) => this.refreshRows(_.start, _.end, !0)), this._needsSelectionRefresh = !0, this._fullRefresh());
        }
        addRefreshCallback(b) {
          return this._renderDebouncer.addRefreshCallback(b);
        }
        _fullRefresh() {
          this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1);
        }
        clearTextureAtlas() {
          this._renderer.value && (this._renderer.value.clearTextureAtlas?.(), this._fullRefresh());
        }
        handleDevicePixelRatioChange() {
          this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
        }
        handleResize(b, _) {
          this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value?.handleResize(b, _)) : this._renderer.value.handleResize(b, _), this._fullRefresh());
        }
        handleCharSizeChanged() {
          this._renderer.value?.handleCharSizeChanged();
        }
        handleBlur() {
          this._renderer.value?.handleBlur();
        }
        handleFocus() {
          this._renderer.value?.handleFocus();
        }
        handleSelectionChanged(b, _, v) {
          this._selectionState.start = b, this._selectionState.end = _, this._selectionState.columnSelectMode = v, this._renderer.value?.handleSelectionChanged(b, _, v);
        }
        handleCursorMove() {
          this._renderer.value?.handleCursorMove();
        }
        clear() {
          this._renderer.value?.clear();
        }
      };
      a.RenderService = m = c([u(2, p.IOptionsService), u(3, d.ICharSizeService), u(4, p.IDecorationService), u(5, p.IBufferService), u(6, d.ICoreBrowserService), u(7, d.IThemeService)], m);
    }, 9312: function(o, a, l) {
      var c = this && this.__decorate || function(S, T, R, F) {
        var P, M = arguments.length, A = M < 3 ? T : F === null ? F = Object.getOwnPropertyDescriptor(T, R) : F;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") A = Reflect.decorate(S, T, R, F);
        else for (var V = S.length - 1; V >= 0; V--) (P = S[V]) && (A = (M < 3 ? P(A) : M > 3 ? P(T, R, A) : P(T, R)) || A);
        return M > 3 && A && Object.defineProperty(T, R, A), A;
      }, u = this && this.__param || function(S, T) {
        return function(R, F) {
          T(R, F, S);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.SelectionService = void 0;
      const h = l(9806), d = l(9504), f = l(456), g = l(4725), y = l(8460), p = l(844), m = l(6114), b = l(4841), _ = l(511), v = l(2585), w = "", E = new RegExp(w, "g");
      let x = a.SelectionService = class extends p.Disposable {
        constructor(S, T, R, F, P, M, A, V, ee) {
          super(), this._element = S, this._screenElement = T, this._linkifier = R, this._bufferService = F, this._coreService = P, this._mouseService = M, this._optionsService = A, this._renderService = V, this._coreBrowserService = ee, this._dragScrollAmount = 0, this._enabled = !0, this._workCell = new _.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = !1, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new y.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new y.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new y.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new y.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (K) => this._handleMouseMove(K), this._mouseUpListener = (K) => this._handleMouseUp(K), this._coreService.onUserInput(() => {
            this.hasSelection && this.clearSelection();
          }), this._trimListener = this._bufferService.buffer.lines.onTrim((K) => this._handleTrim(K)), this.register(this._bufferService.buffers.onBufferActivate((K) => this._handleBufferActivate(K))), this.enable(), this._model = new f.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, p.toDisposable)(() => {
            this._removeMouseDownListeners();
          }));
        }
        reset() {
          this.clearSelection();
        }
        disable() {
          this.clearSelection(), this._enabled = !1;
        }
        enable() {
          this._enabled = !0;
        }
        get selectionStart() {
          return this._model.finalSelectionStart;
        }
        get selectionEnd() {
          return this._model.finalSelectionEnd;
        }
        get hasSelection() {
          const S = this._model.finalSelectionStart, T = this._model.finalSelectionEnd;
          return !(!S || !T || S[0] === T[0] && S[1] === T[1]);
        }
        get selectionText() {
          const S = this._model.finalSelectionStart, T = this._model.finalSelectionEnd;
          if (!S || !T) return "";
          const R = this._bufferService.buffer, F = [];
          if (this._activeSelectionMode === 3) {
            if (S[0] === T[0]) return "";
            const P = S[0] < T[0] ? S[0] : T[0], M = S[0] < T[0] ? T[0] : S[0];
            for (let A = S[1]; A <= T[1]; A++) {
              const V = R.translateBufferLineToString(A, !0, P, M);
              F.push(V);
            }
          } else {
            const P = S[1] === T[1] ? T[0] : void 0;
            F.push(R.translateBufferLineToString(S[1], !0, S[0], P));
            for (let M = S[1] + 1; M <= T[1] - 1; M++) {
              const A = R.lines.get(M), V = R.translateBufferLineToString(M, !0);
              A?.isWrapped ? F[F.length - 1] += V : F.push(V);
            }
            if (S[1] !== T[1]) {
              const M = R.lines.get(T[1]), A = R.translateBufferLineToString(T[1], !0, 0, T[0]);
              M && M.isWrapped ? F[F.length - 1] += A : F.push(A);
            }
          }
          return F.map((P) => P.replace(E, " ")).join(m.isWindows ? `\r
` : `
`);
        }
        clearSelection() {
          this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
        }
        refresh(S) {
          this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), m.isLinux && S && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
        }
        _refresh() {
          this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: this._activeSelectionMode === 3 });
        }
        _isClickInSelection(S) {
          const T = this._getMouseBufferCoords(S), R = this._model.finalSelectionStart, F = this._model.finalSelectionEnd;
          return !!(R && F && T) && this._areCoordsInSelection(T, R, F);
        }
        isCellInSelection(S, T) {
          const R = this._model.finalSelectionStart, F = this._model.finalSelectionEnd;
          return !(!R || !F) && this._areCoordsInSelection([S, T], R, F);
        }
        _areCoordsInSelection(S, T, R) {
          return S[1] > T[1] && S[1] < R[1] || T[1] === R[1] && S[1] === T[1] && S[0] >= T[0] && S[0] < R[0] || T[1] < R[1] && S[1] === R[1] && S[0] < R[0] || T[1] < R[1] && S[1] === T[1] && S[0] >= T[0];
        }
        _selectWordAtCursor(S, T) {
          const R = this._linkifier.currentLink?.link?.range;
          if (R) return this._model.selectionStart = [R.start.x - 1, R.start.y - 1], this._model.selectionStartLength = (0, b.getRangeLength)(R, this._bufferService.cols), this._model.selectionEnd = void 0, !0;
          const F = this._getMouseBufferCoords(S);
          return !!F && (this._selectWordAt(F, T), this._model.selectionEnd = void 0, !0);
        }
        selectAll() {
          this._model.isSelectAllActive = !0, this.refresh(), this._onSelectionChange.fire();
        }
        selectLines(S, T) {
          this._model.clearSelection(), S = Math.max(S, 0), T = Math.min(T, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, S], this._model.selectionEnd = [this._bufferService.cols, T], this.refresh(), this._onSelectionChange.fire();
        }
        _handleTrim(S) {
          this._model.handleTrim(S) && this.refresh();
        }
        _getMouseBufferCoords(S) {
          const T = this._mouseService.getCoords(S, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0);
          if (T) return T[0]--, T[1]--, T[1] += this._bufferService.buffer.ydisp, T;
        }
        _getMouseEventScrollAmount(S) {
          let T = (0, h.getCoordsRelativeToElement)(this._coreBrowserService.window, S, this._screenElement)[1];
          const R = this._renderService.dimensions.css.canvas.height;
          return T >= 0 && T <= R ? 0 : (T > R && (T -= R), T = Math.min(Math.max(T, -50), 50), T /= 50, T / Math.abs(T) + Math.round(14 * T));
        }
        shouldForceSelection(S) {
          return m.isMac ? S.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : S.shiftKey;
        }
        handleMouseDown(S) {
          if (this._mouseDownTimeStamp = S.timeStamp, (S.button !== 2 || !this.hasSelection) && S.button === 0) {
            if (!this._enabled) {
              if (!this.shouldForceSelection(S)) return;
              S.stopPropagation();
            }
            S.preventDefault(), this._dragScrollAmount = 0, this._enabled && S.shiftKey ? this._handleIncrementalClick(S) : S.detail === 1 ? this._handleSingleClick(S) : S.detail === 2 ? this._handleDoubleClick(S) : S.detail === 3 && this._handleTripleClick(S), this._addMouseDownListeners(), this.refresh(!0);
          }
        }
        _addMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
        }
        _removeMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
        }
        _handleIncrementalClick(S) {
          this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(S));
        }
        _handleSingleClick(S) {
          if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = !1, this._activeSelectionMode = this.shouldColumnSelect(S) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(S), !this._model.selectionStart) return;
          this._model.selectionEnd = void 0;
          const T = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
          T && T.length !== this._model.selectionStart[0] && T.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++;
        }
        _handleDoubleClick(S) {
          this._selectWordAtCursor(S, !0) && (this._activeSelectionMode = 1);
        }
        _handleTripleClick(S) {
          const T = this._getMouseBufferCoords(S);
          T && (this._activeSelectionMode = 2, this._selectLineAt(T[1]));
        }
        shouldColumnSelect(S) {
          return S.altKey && !(m.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
        }
        _handleMouseMove(S) {
          if (S.stopImmediatePropagation(), !this._model.selectionStart) return;
          const T = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
          if (this._model.selectionEnd = this._getMouseBufferCoords(S), !this._model.selectionEnd) return void this.refresh(!0);
          this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(S), this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
          const R = this._bufferService.buffer;
          if (this._model.selectionEnd[1] < R.lines.length) {
            const F = R.lines.get(this._model.selectionEnd[1]);
            F && F.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0] < this._bufferService.cols && this._model.selectionEnd[0]++;
          }
          T && T[0] === this._model.selectionEnd[0] && T[1] === this._model.selectionEnd[1] || this.refresh(!0);
        }
        _dragScroll() {
          if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
            this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: !1 });
            const S = this._bufferService.buffer;
            this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(S.ydisp + this._bufferService.rows, S.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = S.ydisp), this.refresh();
          }
        }
        _handleMouseUp(S) {
          const T = S.timeStamp - this._mouseDownTimeStamp;
          if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && T < 500 && S.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
            if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
              const R = this._mouseService.getCoords(S, this._element, this._bufferService.cols, this._bufferService.rows, !1);
              if (R && R[0] !== void 0 && R[1] !== void 0) {
                const F = (0, d.moveToCellSequence)(R[0] - 1, R[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                this._coreService.triggerDataEvent(F, !0);
              }
            }
          } else this._fireEventIfSelectionChanged();
        }
        _fireEventIfSelectionChanged() {
          const S = this._model.finalSelectionStart, T = this._model.finalSelectionEnd, R = !(!S || !T || S[0] === T[0] && S[1] === T[1]);
          R ? S && T && (this._oldSelectionStart && this._oldSelectionEnd && S[0] === this._oldSelectionStart[0] && S[1] === this._oldSelectionStart[1] && T[0] === this._oldSelectionEnd[0] && T[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(S, T, R)) : this._oldHasSelection && this._fireOnSelectionChange(S, T, R);
        }
        _fireOnSelectionChange(S, T, R) {
          this._oldSelectionStart = S, this._oldSelectionEnd = T, this._oldHasSelection = R, this._onSelectionChange.fire();
        }
        _handleBufferActivate(S) {
          this.clearSelection(), this._trimListener.dispose(), this._trimListener = S.activeBuffer.lines.onTrim((T) => this._handleTrim(T));
        }
        _convertViewportColToCharacterIndex(S, T) {
          let R = T;
          for (let F = 0; T >= F; F++) {
            const P = S.loadCell(F, this._workCell).getChars().length;
            this._workCell.getWidth() === 0 ? R-- : P > 1 && T !== F && (R += P - 1);
          }
          return R;
        }
        setSelection(S, T, R) {
          this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [S, T], this._model.selectionStartLength = R, this.refresh(), this._fireEventIfSelectionChanged();
        }
        rightClickSelect(S) {
          this._isClickInSelection(S) || (this._selectWordAtCursor(S, !1) && this.refresh(!0), this._fireEventIfSelectionChanged());
        }
        _getWordAt(S, T, R = !0, F = !0) {
          if (S[0] >= this._bufferService.cols) return;
          const P = this._bufferService.buffer, M = P.lines.get(S[1]);
          if (!M) return;
          const A = P.translateBufferLineToString(S[1], !1);
          let V = this._convertViewportColToCharacterIndex(M, S[0]), ee = V;
          const K = S[0] - V;
          let te = 0, N = 0, L = 0, j = 0;
          if (A.charAt(V) === " ") {
            for (; V > 0 && A.charAt(V - 1) === " "; ) V--;
            for (; ee < A.length && A.charAt(ee + 1) === " "; ) ee++;
          } else {
            let Y = S[0], ne = S[0];
            M.getWidth(Y) === 0 && (te++, Y--), M.getWidth(ne) === 2 && (N++, ne++);
            const he = M.getString(ne).length;
            for (he > 1 && (j += he - 1, ee += he - 1); Y > 0 && V > 0 && !this._isCharWordSeparator(M.loadCell(Y - 1, this._workCell)); ) {
              M.loadCell(Y - 1, this._workCell);
              const X = this._workCell.getChars().length;
              this._workCell.getWidth() === 0 ? (te++, Y--) : X > 1 && (L += X - 1, V -= X - 1), V--, Y--;
            }
            for (; ne < M.length && ee + 1 < A.length && !this._isCharWordSeparator(M.loadCell(ne + 1, this._workCell)); ) {
              M.loadCell(ne + 1, this._workCell);
              const X = this._workCell.getChars().length;
              this._workCell.getWidth() === 2 ? (N++, ne++) : X > 1 && (j += X - 1, ee += X - 1), ee++, ne++;
            }
          }
          ee++;
          let H = V + K - te + L, U = Math.min(this._bufferService.cols, ee - V + te + N - L - j);
          if (T || A.slice(V, ee).trim() !== "") {
            if (R && H === 0 && M.getCodePoint(0) !== 32) {
              const Y = P.lines.get(S[1] - 1);
              if (Y && M.isWrapped && Y.getCodePoint(this._bufferService.cols - 1) !== 32) {
                const ne = this._getWordAt([this._bufferService.cols - 1, S[1] - 1], !1, !0, !1);
                if (ne) {
                  const he = this._bufferService.cols - ne.start;
                  H -= he, U += he;
                }
              }
            }
            if (F && H + U === this._bufferService.cols && M.getCodePoint(this._bufferService.cols - 1) !== 32) {
              const Y = P.lines.get(S[1] + 1);
              if (Y?.isWrapped && Y.getCodePoint(0) !== 32) {
                const ne = this._getWordAt([0, S[1] + 1], !1, !1, !0);
                ne && (U += ne.length);
              }
            }
            return { start: H, length: U };
          }
        }
        _selectWordAt(S, T) {
          const R = this._getWordAt(S, T);
          if (R) {
            for (; R.start < 0; ) R.start += this._bufferService.cols, S[1]--;
            this._model.selectionStart = [R.start, S[1]], this._model.selectionStartLength = R.length;
          }
        }
        _selectToWordAt(S) {
          const T = this._getWordAt(S, !0);
          if (T) {
            let R = S[1];
            for (; T.start < 0; ) T.start += this._bufferService.cols, R--;
            if (!this._model.areSelectionValuesReversed()) for (; T.start + T.length > this._bufferService.cols; ) T.length -= this._bufferService.cols, R++;
            this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? T.start : T.start + T.length, R];
          }
        }
        _isCharWordSeparator(S) {
          return S.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(S.getChars()) >= 0;
        }
        _selectLineAt(S) {
          const T = this._bufferService.buffer.getWrappedRangeForLine(S), R = { start: { x: 0, y: T.first }, end: { x: this._bufferService.cols - 1, y: T.last } };
          this._model.selectionStart = [0, T.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, b.getRangeLength)(R, this._bufferService.cols);
        }
      };
      a.SelectionService = x = c([u(3, v.IBufferService), u(4, v.ICoreService), u(5, g.IMouseService), u(6, v.IOptionsService), u(7, g.IRenderService), u(8, g.ICoreBrowserService)], x);
    }, 4725: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ILinkProviderService = a.IThemeService = a.ICharacterJoinerService = a.ISelectionService = a.IRenderService = a.IMouseService = a.ICoreBrowserService = a.ICharSizeService = void 0;
      const c = l(8343);
      a.ICharSizeService = (0, c.createDecorator)("CharSizeService"), a.ICoreBrowserService = (0, c.createDecorator)("CoreBrowserService"), a.IMouseService = (0, c.createDecorator)("MouseService"), a.IRenderService = (0, c.createDecorator)("RenderService"), a.ISelectionService = (0, c.createDecorator)("SelectionService"), a.ICharacterJoinerService = (0, c.createDecorator)("CharacterJoinerService"), a.IThemeService = (0, c.createDecorator)("ThemeService"), a.ILinkProviderService = (0, c.createDecorator)("LinkProviderService");
    }, 6731: function(o, a, l) {
      var c = this && this.__decorate || function(x, S, T, R) {
        var F, P = arguments.length, M = P < 3 ? S : R === null ? R = Object.getOwnPropertyDescriptor(S, T) : R;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") M = Reflect.decorate(x, S, T, R);
        else for (var A = x.length - 1; A >= 0; A--) (F = x[A]) && (M = (P < 3 ? F(M) : P > 3 ? F(S, T, M) : F(S, T)) || M);
        return P > 3 && M && Object.defineProperty(S, T, M), M;
      }, u = this && this.__param || function(x, S) {
        return function(T, R) {
          S(T, R, x);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ThemeService = a.DEFAULT_ANSI_COLORS = void 0;
      const h = l(7239), d = l(8055), f = l(8460), g = l(844), y = l(2585), p = d.css.toColor("#ffffff"), m = d.css.toColor("#000000"), b = d.css.toColor("#ffffff"), _ = d.css.toColor("#000000"), v = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
      a.DEFAULT_ANSI_COLORS = Object.freeze((() => {
        const x = [d.css.toColor("#2e3436"), d.css.toColor("#cc0000"), d.css.toColor("#4e9a06"), d.css.toColor("#c4a000"), d.css.toColor("#3465a4"), d.css.toColor("#75507b"), d.css.toColor("#06989a"), d.css.toColor("#d3d7cf"), d.css.toColor("#555753"), d.css.toColor("#ef2929"), d.css.toColor("#8ae234"), d.css.toColor("#fce94f"), d.css.toColor("#729fcf"), d.css.toColor("#ad7fa8"), d.css.toColor("#34e2e2"), d.css.toColor("#eeeeec")], S = [0, 95, 135, 175, 215, 255];
        for (let T = 0; T < 216; T++) {
          const R = S[T / 36 % 6 | 0], F = S[T / 6 % 6 | 0], P = S[T % 6];
          x.push({ css: d.channels.toCss(R, F, P), rgba: d.channels.toRgba(R, F, P) });
        }
        for (let T = 0; T < 24; T++) {
          const R = 8 + 10 * T;
          x.push({ css: d.channels.toCss(R, R, R), rgba: d.channels.toRgba(R, R, R) });
        }
        return x;
      })());
      let w = a.ThemeService = class extends g.Disposable {
        get colors() {
          return this._colors;
        }
        constructor(x) {
          super(), this._optionsService = x, this._contrastCache = new h.ColorContrastCache(), this._halfContrastCache = new h.ColorContrastCache(), this._onChangeColors = this.register(new f.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: p, background: m, cursor: b, cursorAccent: _, selectionForeground: void 0, selectionBackgroundTransparent: v, selectionBackgroundOpaque: d.color.blend(m, v), selectionInactiveBackgroundTransparent: v, selectionInactiveBackgroundOpaque: d.color.blend(m, v), ansi: a.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
        }
        _setTheme(x = {}) {
          const S = this._colors;
          if (S.foreground = E(x.foreground, p), S.background = E(x.background, m), S.cursor = E(x.cursor, b), S.cursorAccent = E(x.cursorAccent, _), S.selectionBackgroundTransparent = E(x.selectionBackground, v), S.selectionBackgroundOpaque = d.color.blend(S.background, S.selectionBackgroundTransparent), S.selectionInactiveBackgroundTransparent = E(x.selectionInactiveBackground, S.selectionBackgroundTransparent), S.selectionInactiveBackgroundOpaque = d.color.blend(S.background, S.selectionInactiveBackgroundTransparent), S.selectionForeground = x.selectionForeground ? E(x.selectionForeground, d.NULL_COLOR) : void 0, S.selectionForeground === d.NULL_COLOR && (S.selectionForeground = void 0), d.color.isOpaque(S.selectionBackgroundTransparent) && (S.selectionBackgroundTransparent = d.color.opacity(S.selectionBackgroundTransparent, 0.3)), d.color.isOpaque(S.selectionInactiveBackgroundTransparent) && (S.selectionInactiveBackgroundTransparent = d.color.opacity(S.selectionInactiveBackgroundTransparent, 0.3)), S.ansi = a.DEFAULT_ANSI_COLORS.slice(), S.ansi[0] = E(x.black, a.DEFAULT_ANSI_COLORS[0]), S.ansi[1] = E(x.red, a.DEFAULT_ANSI_COLORS[1]), S.ansi[2] = E(x.green, a.DEFAULT_ANSI_COLORS[2]), S.ansi[3] = E(x.yellow, a.DEFAULT_ANSI_COLORS[3]), S.ansi[4] = E(x.blue, a.DEFAULT_ANSI_COLORS[4]), S.ansi[5] = E(x.magenta, a.DEFAULT_ANSI_COLORS[5]), S.ansi[6] = E(x.cyan, a.DEFAULT_ANSI_COLORS[6]), S.ansi[7] = E(x.white, a.DEFAULT_ANSI_COLORS[7]), S.ansi[8] = E(x.brightBlack, a.DEFAULT_ANSI_COLORS[8]), S.ansi[9] = E(x.brightRed, a.DEFAULT_ANSI_COLORS[9]), S.ansi[10] = E(x.brightGreen, a.DEFAULT_ANSI_COLORS[10]), S.ansi[11] = E(x.brightYellow, a.DEFAULT_ANSI_COLORS[11]), S.ansi[12] = E(x.brightBlue, a.DEFAULT_ANSI_COLORS[12]), S.ansi[13] = E(x.brightMagenta, a.DEFAULT_ANSI_COLORS[13]), S.ansi[14] = E(x.brightCyan, a.DEFAULT_ANSI_COLORS[14]), S.ansi[15] = E(x.brightWhite, a.DEFAULT_ANSI_COLORS[15]), x.extendedAnsi) {
            const T = Math.min(S.ansi.length - 16, x.extendedAnsi.length);
            for (let R = 0; R < T; R++) S.ansi[R + 16] = E(x.extendedAnsi[R], a.DEFAULT_ANSI_COLORS[R + 16]);
          }
          this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
        }
        restoreColor(x) {
          this._restoreColor(x), this._onChangeColors.fire(this.colors);
        }
        _restoreColor(x) {
          if (x !== void 0) switch (x) {
            case 256:
              this._colors.foreground = this._restoreColors.foreground;
              break;
            case 257:
              this._colors.background = this._restoreColors.background;
              break;
            case 258:
              this._colors.cursor = this._restoreColors.cursor;
              break;
            default:
              this._colors.ansi[x] = this._restoreColors.ansi[x];
          }
          else for (let S = 0; S < this._restoreColors.ansi.length; ++S) this._colors.ansi[S] = this._restoreColors.ansi[S];
        }
        modifyColors(x) {
          x(this._colors), this._onChangeColors.fire(this.colors);
        }
        _updateRestoreColors() {
          this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
        }
      };
      function E(x, S) {
        if (x !== void 0) try {
          return d.css.toColor(x);
        } catch {
        }
        return S;
      }
      a.ThemeService = w = c([u(0, y.IOptionsService)], w);
    }, 6349: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CircularList = void 0;
      const c = l(8460), u = l(844);
      class h extends u.Disposable {
        constructor(f) {
          super(), this._maxLength = f, this.onDeleteEmitter = this.register(new c.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new c.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new c.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
        }
        get maxLength() {
          return this._maxLength;
        }
        set maxLength(f) {
          if (this._maxLength === f) return;
          const g = new Array(f);
          for (let y = 0; y < Math.min(f, this.length); y++) g[y] = this._array[this._getCyclicIndex(y)];
          this._array = g, this._maxLength = f, this._startIndex = 0;
        }
        get length() {
          return this._length;
        }
        set length(f) {
          if (f > this._length) for (let g = this._length; g < f; g++) this._array[g] = void 0;
          this._length = f;
        }
        get(f) {
          return this._array[this._getCyclicIndex(f)];
        }
        set(f, g) {
          this._array[this._getCyclicIndex(f)] = g;
        }
        push(f) {
          this._array[this._getCyclicIndex(this._length)] = f, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
        }
        recycle() {
          if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
          return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
        }
        get isFull() {
          return this._length === this._maxLength;
        }
        pop() {
          return this._array[this._getCyclicIndex(this._length-- - 1)];
        }
        splice(f, g, ...y) {
          if (g) {
            for (let p = f; p < this._length - g; p++) this._array[this._getCyclicIndex(p)] = this._array[this._getCyclicIndex(p + g)];
            this._length -= g, this.onDeleteEmitter.fire({ index: f, amount: g });
          }
          for (let p = this._length - 1; p >= f; p--) this._array[this._getCyclicIndex(p + y.length)] = this._array[this._getCyclicIndex(p)];
          for (let p = 0; p < y.length; p++) this._array[this._getCyclicIndex(f + p)] = y[p];
          if (y.length && this.onInsertEmitter.fire({ index: f, amount: y.length }), this._length + y.length > this._maxLength) {
            const p = this._length + y.length - this._maxLength;
            this._startIndex += p, this._length = this._maxLength, this.onTrimEmitter.fire(p);
          } else this._length += y.length;
        }
        trimStart(f) {
          f > this._length && (f = this._length), this._startIndex += f, this._length -= f, this.onTrimEmitter.fire(f);
        }
        shiftElements(f, g, y) {
          if (!(g <= 0)) {
            if (f < 0 || f >= this._length) throw new Error("start argument out of range");
            if (f + y < 0) throw new Error("Cannot shift elements in list beyond index 0");
            if (y > 0) {
              for (let m = g - 1; m >= 0; m--) this.set(f + m + y, this.get(f + m));
              const p = f + g + y - this._length;
              if (p > 0) for (this._length += p; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
            } else for (let p = 0; p < g; p++) this.set(f + p + y, this.get(f + p));
          }
        }
        _getCyclicIndex(f) {
          return (this._startIndex + f) % this._maxLength;
        }
      }
      a.CircularList = h;
    }, 1439: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.clone = void 0, a.clone = function l(c, u = 5) {
        if (typeof c != "object") return c;
        const h = Array.isArray(c) ? [] : {};
        for (const d in c) h[d] = u <= 1 ? c[d] : c[d] && l(c[d], u - 1);
        return h;
      };
    }, 8055: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.contrastRatio = a.toPaddedHex = a.rgba = a.rgb = a.css = a.color = a.channels = a.NULL_COLOR = void 0;
      let l = 0, c = 0, u = 0, h = 0;
      var d, f, g, y, p;
      function m(_) {
        const v = _.toString(16);
        return v.length < 2 ? "0" + v : v;
      }
      function b(_, v) {
        return _ < v ? (v + 0.05) / (_ + 0.05) : (_ + 0.05) / (v + 0.05);
      }
      a.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(_) {
        _.toCss = function(v, w, E, x) {
          return x !== void 0 ? `#${m(v)}${m(w)}${m(E)}${m(x)}` : `#${m(v)}${m(w)}${m(E)}`;
        }, _.toRgba = function(v, w, E, x = 255) {
          return (v << 24 | w << 16 | E << 8 | x) >>> 0;
        }, _.toColor = function(v, w, E, x) {
          return { css: _.toCss(v, w, E, x), rgba: _.toRgba(v, w, E, x) };
        };
      }(d || (a.channels = d = {})), function(_) {
        function v(w, E) {
          return h = Math.round(255 * E), [l, c, u] = p.toChannels(w.rgba), { css: d.toCss(l, c, u, h), rgba: d.toRgba(l, c, u, h) };
        }
        _.blend = function(w, E) {
          if (h = (255 & E.rgba) / 255, h === 1) return { css: E.css, rgba: E.rgba };
          const x = E.rgba >> 24 & 255, S = E.rgba >> 16 & 255, T = E.rgba >> 8 & 255, R = w.rgba >> 24 & 255, F = w.rgba >> 16 & 255, P = w.rgba >> 8 & 255;
          return l = R + Math.round((x - R) * h), c = F + Math.round((S - F) * h), u = P + Math.round((T - P) * h), { css: d.toCss(l, c, u), rgba: d.toRgba(l, c, u) };
        }, _.isOpaque = function(w) {
          return (255 & w.rgba) == 255;
        }, _.ensureContrastRatio = function(w, E, x) {
          const S = p.ensureContrastRatio(w.rgba, E.rgba, x);
          if (S) return d.toColor(S >> 24 & 255, S >> 16 & 255, S >> 8 & 255);
        }, _.opaque = function(w) {
          const E = (255 | w.rgba) >>> 0;
          return [l, c, u] = p.toChannels(E), { css: d.toCss(l, c, u), rgba: E };
        }, _.opacity = v, _.multiplyOpacity = function(w, E) {
          return h = 255 & w.rgba, v(w, h * E / 255);
        }, _.toColorRGB = function(w) {
          return [w.rgba >> 24 & 255, w.rgba >> 16 & 255, w.rgba >> 8 & 255];
        };
      }(f || (a.color = f = {})), function(_) {
        let v, w;
        try {
          const E = document.createElement("canvas");
          E.width = 1, E.height = 1;
          const x = E.getContext("2d", { willReadFrequently: !0 });
          x && (v = x, v.globalCompositeOperation = "copy", w = v.createLinearGradient(0, 0, 1, 1));
        } catch {
        }
        _.toColor = function(E) {
          if (E.match(/#[\da-f]{3,8}/i)) switch (E.length) {
            case 4:
              return l = parseInt(E.slice(1, 2).repeat(2), 16), c = parseInt(E.slice(2, 3).repeat(2), 16), u = parseInt(E.slice(3, 4).repeat(2), 16), d.toColor(l, c, u);
            case 5:
              return l = parseInt(E.slice(1, 2).repeat(2), 16), c = parseInt(E.slice(2, 3).repeat(2), 16), u = parseInt(E.slice(3, 4).repeat(2), 16), h = parseInt(E.slice(4, 5).repeat(2), 16), d.toColor(l, c, u, h);
            case 7:
              return { css: E, rgba: (parseInt(E.slice(1), 16) << 8 | 255) >>> 0 };
            case 9:
              return { css: E, rgba: parseInt(E.slice(1), 16) >>> 0 };
          }
          const x = E.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
          if (x) return l = parseInt(x[1]), c = parseInt(x[2]), u = parseInt(x[3]), h = Math.round(255 * (x[5] === void 0 ? 1 : parseFloat(x[5]))), d.toColor(l, c, u, h);
          if (!v || !w) throw new Error("css.toColor: Unsupported css format");
          if (v.fillStyle = w, v.fillStyle = E, typeof v.fillStyle != "string") throw new Error("css.toColor: Unsupported css format");
          if (v.fillRect(0, 0, 1, 1), [l, c, u, h] = v.getImageData(0, 0, 1, 1).data, h !== 255) throw new Error("css.toColor: Unsupported css format");
          return { rgba: d.toRgba(l, c, u, h), css: E };
        };
      }(g || (a.css = g = {})), function(_) {
        function v(w, E, x) {
          const S = w / 255, T = E / 255, R = x / 255;
          return 0.2126 * (S <= 0.03928 ? S / 12.92 : Math.pow((S + 0.055) / 1.055, 2.4)) + 0.7152 * (T <= 0.03928 ? T / 12.92 : Math.pow((T + 0.055) / 1.055, 2.4)) + 0.0722 * (R <= 0.03928 ? R / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4));
        }
        _.relativeLuminance = function(w) {
          return v(w >> 16 & 255, w >> 8 & 255, 255 & w);
        }, _.relativeLuminance2 = v;
      }(y || (a.rgb = y = {})), function(_) {
        function v(E, x, S) {
          const T = E >> 24 & 255, R = E >> 16 & 255, F = E >> 8 & 255;
          let P = x >> 24 & 255, M = x >> 16 & 255, A = x >> 8 & 255, V = b(y.relativeLuminance2(P, M, A), y.relativeLuminance2(T, R, F));
          for (; V < S && (P > 0 || M > 0 || A > 0); ) P -= Math.max(0, Math.ceil(0.1 * P)), M -= Math.max(0, Math.ceil(0.1 * M)), A -= Math.max(0, Math.ceil(0.1 * A)), V = b(y.relativeLuminance2(P, M, A), y.relativeLuminance2(T, R, F));
          return (P << 24 | M << 16 | A << 8 | 255) >>> 0;
        }
        function w(E, x, S) {
          const T = E >> 24 & 255, R = E >> 16 & 255, F = E >> 8 & 255;
          let P = x >> 24 & 255, M = x >> 16 & 255, A = x >> 8 & 255, V = b(y.relativeLuminance2(P, M, A), y.relativeLuminance2(T, R, F));
          for (; V < S && (P < 255 || M < 255 || A < 255); ) P = Math.min(255, P + Math.ceil(0.1 * (255 - P))), M = Math.min(255, M + Math.ceil(0.1 * (255 - M))), A = Math.min(255, A + Math.ceil(0.1 * (255 - A))), V = b(y.relativeLuminance2(P, M, A), y.relativeLuminance2(T, R, F));
          return (P << 24 | M << 16 | A << 8 | 255) >>> 0;
        }
        _.blend = function(E, x) {
          if (h = (255 & x) / 255, h === 1) return x;
          const S = x >> 24 & 255, T = x >> 16 & 255, R = x >> 8 & 255, F = E >> 24 & 255, P = E >> 16 & 255, M = E >> 8 & 255;
          return l = F + Math.round((S - F) * h), c = P + Math.round((T - P) * h), u = M + Math.round((R - M) * h), d.toRgba(l, c, u);
        }, _.ensureContrastRatio = function(E, x, S) {
          const T = y.relativeLuminance(E >> 8), R = y.relativeLuminance(x >> 8);
          if (b(T, R) < S) {
            if (R < T) {
              const M = v(E, x, S), A = b(T, y.relativeLuminance(M >> 8));
              if (A < S) {
                const V = w(E, x, S);
                return A > b(T, y.relativeLuminance(V >> 8)) ? M : V;
              }
              return M;
            }
            const F = w(E, x, S), P = b(T, y.relativeLuminance(F >> 8));
            if (P < S) {
              const M = v(E, x, S);
              return P > b(T, y.relativeLuminance(M >> 8)) ? F : M;
            }
            return F;
          }
        }, _.reduceLuminance = v, _.increaseLuminance = w, _.toChannels = function(E) {
          return [E >> 24 & 255, E >> 16 & 255, E >> 8 & 255, 255 & E];
        };
      }(p || (a.rgba = p = {})), a.toPaddedHex = m, a.contrastRatio = b;
    }, 8969: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreTerminal = void 0;
      const c = l(844), u = l(2585), h = l(4348), d = l(7866), f = l(744), g = l(7302), y = l(6975), p = l(8460), m = l(1753), b = l(1480), _ = l(7994), v = l(9282), w = l(5435), E = l(5981), x = l(2660);
      let S = !1;
      class T extends c.Disposable {
        get onScroll() {
          return this._onScrollApi || (this._onScrollApi = this.register(new p.EventEmitter()), this._onScroll.event((F) => {
            this._onScrollApi?.fire(F.position);
          })), this._onScrollApi.event;
        }
        get cols() {
          return this._bufferService.cols;
        }
        get rows() {
          return this._bufferService.rows;
        }
        get buffers() {
          return this._bufferService.buffers;
        }
        get options() {
          return this.optionsService.options;
        }
        set options(F) {
          for (const P in F) this.optionsService.options[P] = F[P];
        }
        constructor(F) {
          super(), this._windowsWrappingHeuristics = this.register(new c.MutableDisposable()), this._onBinary = this.register(new p.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new p.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new p.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new p.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new p.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new p.EventEmitter()), this._instantiationService = new h.InstantiationService(), this.optionsService = this.register(new g.OptionsService(F)), this._instantiationService.setService(u.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(f.BufferService)), this._instantiationService.setService(u.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(d.LogService)), this._instantiationService.setService(u.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(y.CoreService)), this._instantiationService.setService(u.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(m.CoreMouseService)), this._instantiationService.setService(u.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(b.UnicodeService)), this._instantiationService.setService(u.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(_.CharsetService), this._instantiationService.setService(u.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(x.OscLinkService), this._instantiationService.setService(u.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new w.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, p.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, p.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, p.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, p.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((P) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this.register(this._inputHandler.onScroll((P) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this._writeBuffer = this.register(new E.WriteBuffer((P, M) => this._inputHandler.parse(P, M))), this.register((0, p.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
        }
        write(F, P) {
          this._writeBuffer.write(F, P);
        }
        writeSync(F, P) {
          this._logService.logLevel <= u.LogLevelEnum.WARN && !S && (this._logService.warn("writeSync is unreliable and will be removed soon."), S = !0), this._writeBuffer.writeSync(F, P);
        }
        input(F, P = !0) {
          this.coreService.triggerDataEvent(F, P);
        }
        resize(F, P) {
          isNaN(F) || isNaN(P) || (F = Math.max(F, f.MINIMUM_COLS), P = Math.max(P, f.MINIMUM_ROWS), this._bufferService.resize(F, P));
        }
        scroll(F, P = !1) {
          this._bufferService.scroll(F, P);
        }
        scrollLines(F, P, M) {
          this._bufferService.scrollLines(F, P, M);
        }
        scrollPages(F) {
          this.scrollLines(F * (this.rows - 1));
        }
        scrollToTop() {
          this.scrollLines(-this._bufferService.buffer.ydisp);
        }
        scrollToBottom() {
          this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
        }
        scrollToLine(F) {
          const P = F - this._bufferService.buffer.ydisp;
          P !== 0 && this.scrollLines(P);
        }
        registerEscHandler(F, P) {
          return this._inputHandler.registerEscHandler(F, P);
        }
        registerDcsHandler(F, P) {
          return this._inputHandler.registerDcsHandler(F, P);
        }
        registerCsiHandler(F, P) {
          return this._inputHandler.registerCsiHandler(F, P);
        }
        registerOscHandler(F, P) {
          return this._inputHandler.registerOscHandler(F, P);
        }
        _setup() {
          this._handleWindowsPtyOptionChange();
        }
        reset() {
          this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
        }
        _handleWindowsPtyOptionChange() {
          let F = !1;
          const P = this.optionsService.rawOptions.windowsPty;
          P && P.buildNumber !== void 0 && P.buildNumber !== void 0 ? F = P.backend === "conpty" && P.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (F = !0), F ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
        }
        _enableWindowsWrappingHeuristics() {
          if (!this._windowsWrappingHeuristics.value) {
            const F = [];
            F.push(this.onLineFeed(v.updateWindowsModeWrappedState.bind(null, this._bufferService))), F.push(this.registerCsiHandler({ final: "H" }, () => ((0, v.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsWrappingHeuristics.value = (0, c.toDisposable)(() => {
              for (const P of F) P.dispose();
            });
          }
        }
      }
      a.CoreTerminal = T;
    }, 8460: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.runAndSubscribe = a.forwardEvent = a.EventEmitter = void 0, a.EventEmitter = class {
        constructor() {
          this._listeners = [], this._disposed = !1;
        }
        get event() {
          return this._event || (this._event = (l) => (this._listeners.push(l), { dispose: () => {
            if (!this._disposed) {
              for (let c = 0; c < this._listeners.length; c++) if (this._listeners[c] === l) return void this._listeners.splice(c, 1);
            }
          } })), this._event;
        }
        fire(l, c) {
          const u = [];
          for (let h = 0; h < this._listeners.length; h++) u.push(this._listeners[h]);
          for (let h = 0; h < u.length; h++) u[h].call(void 0, l, c);
        }
        dispose() {
          this.clearListeners(), this._disposed = !0;
        }
        clearListeners() {
          this._listeners && (this._listeners.length = 0);
        }
      }, a.forwardEvent = function(l, c) {
        return l((u) => c.fire(u));
      }, a.runAndSubscribe = function(l, c) {
        return c(void 0), l((u) => c(u));
      };
    }, 5435: function(o, a, l) {
      var c = this && this.__decorate || function(te, N, L, j) {
        var H, U = arguments.length, Y = U < 3 ? N : j === null ? j = Object.getOwnPropertyDescriptor(N, L) : j;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") Y = Reflect.decorate(te, N, L, j);
        else for (var ne = te.length - 1; ne >= 0; ne--) (H = te[ne]) && (Y = (U < 3 ? H(Y) : U > 3 ? H(N, L, Y) : H(N, L)) || Y);
        return U > 3 && Y && Object.defineProperty(N, L, Y), Y;
      }, u = this && this.__param || function(te, N) {
        return function(L, j) {
          N(L, j, te);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.InputHandler = a.WindowsOptionsReportType = void 0;
      const h = l(2584), d = l(7116), f = l(2015), g = l(844), y = l(482), p = l(8437), m = l(8460), b = l(643), _ = l(511), v = l(3734), w = l(2585), E = l(1480), x = l(6242), S = l(6351), T = l(5941), R = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, F = 131072;
      function P(te, N) {
        if (te > 24) return N.setWinLines || !1;
        switch (te) {
          case 1:
            return !!N.restoreWin;
          case 2:
            return !!N.minimizeWin;
          case 3:
            return !!N.setWinPosition;
          case 4:
            return !!N.setWinSizePixels;
          case 5:
            return !!N.raiseWin;
          case 6:
            return !!N.lowerWin;
          case 7:
            return !!N.refreshWin;
          case 8:
            return !!N.setWinSizeChars;
          case 9:
            return !!N.maximizeWin;
          case 10:
            return !!N.fullscreenWin;
          case 11:
            return !!N.getWinState;
          case 13:
            return !!N.getWinPosition;
          case 14:
            return !!N.getWinSizePixels;
          case 15:
            return !!N.getScreenSizePixels;
          case 16:
            return !!N.getCellSizePixels;
          case 18:
            return !!N.getWinSizeChars;
          case 19:
            return !!N.getScreenSizeChars;
          case 20:
            return !!N.getIconTitle;
          case 21:
            return !!N.getWinTitle;
          case 22:
            return !!N.pushTitle;
          case 23:
            return !!N.popTitle;
          case 24:
            return !!N.setWinLines;
        }
        return !1;
      }
      var M;
      (function(te) {
        te[te.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", te[te.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
      })(M || (a.WindowsOptionsReportType = M = {}));
      let A = 0;
      class V extends g.Disposable {
        getAttrData() {
          return this._curAttrData;
        }
        constructor(N, L, j, H, U, Y, ne, he, X = new f.EscapeSequenceParser()) {
          super(), this._bufferService = N, this._charsetService = L, this._coreService = j, this._logService = H, this._optionsService = U, this._oscLinkService = Y, this._coreMouseService = ne, this._unicodeService = he, this._parser = X, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new y.StringToUtf32(), this._utf8Decoder = new y.Utf8ToUtf32(), this._workCell = new _.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = p.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = p.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new m.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new m.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new m.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new m.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new m.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new m.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new m.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new m.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new m.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new m.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new m.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new m.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new m.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: !1, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new ee(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((z) => this._activeBuffer = z.activeBuffer)), this._parser.setCsiHandlerFallback((z, ue) => {
            this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(z), params: ue.toArray() });
          }), this._parser.setEscHandlerFallback((z) => {
            this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(z) });
          }), this._parser.setExecuteHandlerFallback((z) => {
            this._logService.debug("Unknown EXECUTE code: ", { code: z });
          }), this._parser.setOscHandlerFallback((z, ue, ae) => {
            this._logService.debug("Unknown OSC code: ", { identifier: z, action: ue, data: ae });
          }), this._parser.setDcsHandlerFallback((z, ue, ae) => {
            ue === "HOOK" && (ae = ae.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(z), action: ue, payload: ae });
          }), this._parser.setPrintHandler((z, ue, ae) => this.print(z, ue, ae)), this._parser.registerCsiHandler({ final: "@" }, (z) => this.insertChars(z)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (z) => this.scrollLeft(z)), this._parser.registerCsiHandler({ final: "A" }, (z) => this.cursorUp(z)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (z) => this.scrollRight(z)), this._parser.registerCsiHandler({ final: "B" }, (z) => this.cursorDown(z)), this._parser.registerCsiHandler({ final: "C" }, (z) => this.cursorForward(z)), this._parser.registerCsiHandler({ final: "D" }, (z) => this.cursorBackward(z)), this._parser.registerCsiHandler({ final: "E" }, (z) => this.cursorNextLine(z)), this._parser.registerCsiHandler({ final: "F" }, (z) => this.cursorPrecedingLine(z)), this._parser.registerCsiHandler({ final: "G" }, (z) => this.cursorCharAbsolute(z)), this._parser.registerCsiHandler({ final: "H" }, (z) => this.cursorPosition(z)), this._parser.registerCsiHandler({ final: "I" }, (z) => this.cursorForwardTab(z)), this._parser.registerCsiHandler({ final: "J" }, (z) => this.eraseInDisplay(z, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (z) => this.eraseInDisplay(z, !0)), this._parser.registerCsiHandler({ final: "K" }, (z) => this.eraseInLine(z, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (z) => this.eraseInLine(z, !0)), this._parser.registerCsiHandler({ final: "L" }, (z) => this.insertLines(z)), this._parser.registerCsiHandler({ final: "M" }, (z) => this.deleteLines(z)), this._parser.registerCsiHandler({ final: "P" }, (z) => this.deleteChars(z)), this._parser.registerCsiHandler({ final: "S" }, (z) => this.scrollUp(z)), this._parser.registerCsiHandler({ final: "T" }, (z) => this.scrollDown(z)), this._parser.registerCsiHandler({ final: "X" }, (z) => this.eraseChars(z)), this._parser.registerCsiHandler({ final: "Z" }, (z) => this.cursorBackwardTab(z)), this._parser.registerCsiHandler({ final: "`" }, (z) => this.charPosAbsolute(z)), this._parser.registerCsiHandler({ final: "a" }, (z) => this.hPositionRelative(z)), this._parser.registerCsiHandler({ final: "b" }, (z) => this.repeatPrecedingCharacter(z)), this._parser.registerCsiHandler({ final: "c" }, (z) => this.sendDeviceAttributesPrimary(z)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (z) => this.sendDeviceAttributesSecondary(z)), this._parser.registerCsiHandler({ final: "d" }, (z) => this.linePosAbsolute(z)), this._parser.registerCsiHandler({ final: "e" }, (z) => this.vPositionRelative(z)), this._parser.registerCsiHandler({ final: "f" }, (z) => this.hVPosition(z)), this._parser.registerCsiHandler({ final: "g" }, (z) => this.tabClear(z)), this._parser.registerCsiHandler({ final: "h" }, (z) => this.setMode(z)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (z) => this.setModePrivate(z)), this._parser.registerCsiHandler({ final: "l" }, (z) => this.resetMode(z)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (z) => this.resetModePrivate(z)), this._parser.registerCsiHandler({ final: "m" }, (z) => this.charAttributes(z)), this._parser.registerCsiHandler({ final: "n" }, (z) => this.deviceStatus(z)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (z) => this.deviceStatusPrivate(z)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (z) => this.softReset(z)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (z) => this.setCursorStyle(z)), this._parser.registerCsiHandler({ final: "r" }, (z) => this.setScrollRegion(z)), this._parser.registerCsiHandler({ final: "s" }, (z) => this.saveCursor(z)), this._parser.registerCsiHandler({ final: "t" }, (z) => this.windowOptions(z)), this._parser.registerCsiHandler({ final: "u" }, (z) => this.restoreCursor(z)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (z) => this.insertColumns(z)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (z) => this.deleteColumns(z)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (z) => this.selectProtected(z)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (z) => this.requestMode(z, !0)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (z) => this.requestMode(z, !1)), this._parser.setExecuteHandler(h.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(h.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(h.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(h.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(h.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(h.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(h.C0.HT, () => this.tab()), this._parser.setExecuteHandler(h.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(h.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(h.C1.IND, () => this.index()), this._parser.setExecuteHandler(h.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(h.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new x.OscHandler((z) => (this.setTitle(z), this.setIconName(z), !0))), this._parser.registerOscHandler(1, new x.OscHandler((z) => this.setIconName(z))), this._parser.registerOscHandler(2, new x.OscHandler((z) => this.setTitle(z))), this._parser.registerOscHandler(4, new x.OscHandler((z) => this.setOrReportIndexedColor(z))), this._parser.registerOscHandler(8, new x.OscHandler((z) => this.setHyperlink(z))), this._parser.registerOscHandler(10, new x.OscHandler((z) => this.setOrReportFgColor(z))), this._parser.registerOscHandler(11, new x.OscHandler((z) => this.setOrReportBgColor(z))), this._parser.registerOscHandler(12, new x.OscHandler((z) => this.setOrReportCursorColor(z))), this._parser.registerOscHandler(104, new x.OscHandler((z) => this.restoreIndexedColor(z))), this._parser.registerOscHandler(110, new x.OscHandler((z) => this.restoreFgColor(z))), this._parser.registerOscHandler(111, new x.OscHandler((z) => this.restoreBgColor(z))), this._parser.registerOscHandler(112, new x.OscHandler((z) => this.restoreCursorColor(z))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
          for (const z in d.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: z }, () => this.selectCharset("(" + z)), this._parser.registerEscHandler({ intermediates: ")", final: z }, () => this.selectCharset(")" + z)), this._parser.registerEscHandler({ intermediates: "*", final: z }, () => this.selectCharset("*" + z)), this._parser.registerEscHandler({ intermediates: "+", final: z }, () => this.selectCharset("+" + z)), this._parser.registerEscHandler({ intermediates: "-", final: z }, () => this.selectCharset("-" + z)), this._parser.registerEscHandler({ intermediates: ".", final: z }, () => this.selectCharset("." + z)), this._parser.registerEscHandler({ intermediates: "/", final: z }, () => this.selectCharset("/" + z));
          this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((z) => (this._logService.error("Parsing error: ", z), z)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new S.DcsHandler((z, ue) => this.requestStatusString(z, ue)));
        }
        _preserveStack(N, L, j, H) {
          this._parseStack.paused = !0, this._parseStack.cursorStartX = N, this._parseStack.cursorStartY = L, this._parseStack.decodedLength = j, this._parseStack.position = H;
        }
        _logSlowResolvingAsync(N) {
          this._logService.logLevel <= w.LogLevelEnum.WARN && Promise.race([N, new Promise((L, j) => setTimeout(() => j("#SLOW_TIMEOUT"), 5e3))]).catch((L) => {
            if (L !== "#SLOW_TIMEOUT") throw L;
            console.warn("async parser handler taking longer than 5000 ms");
          });
        }
        _getCurrentLinkId() {
          return this._curAttrData.extended.urlId;
        }
        parse(N, L) {
          let j, H = this._activeBuffer.x, U = this._activeBuffer.y, Y = 0;
          const ne = this._parseStack.paused;
          if (ne) {
            if (j = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, L)) return this._logSlowResolvingAsync(j), j;
            H = this._parseStack.cursorStartX, U = this._parseStack.cursorStartY, this._parseStack.paused = !1, N.length > F && (Y = this._parseStack.position + F);
          }
          if (this._logService.logLevel <= w.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof N == "string" ? ` "${N}"` : ` "${Array.prototype.map.call(N, (z) => String.fromCharCode(z)).join("")}"`), typeof N == "string" ? N.split("").map((z) => z.charCodeAt(0)) : N), this._parseBuffer.length < N.length && this._parseBuffer.length < F && (this._parseBuffer = new Uint32Array(Math.min(N.length, F))), ne || this._dirtyRowTracker.clearRange(), N.length > F) for (let z = Y; z < N.length; z += F) {
            const ue = z + F < N.length ? z + F : N.length, ae = typeof N == "string" ? this._stringDecoder.decode(N.substring(z, ue), this._parseBuffer) : this._utf8Decoder.decode(N.subarray(z, ue), this._parseBuffer);
            if (j = this._parser.parse(this._parseBuffer, ae)) return this._preserveStack(H, U, ae, z), this._logSlowResolvingAsync(j), j;
          }
          else if (!ne) {
            const z = typeof N == "string" ? this._stringDecoder.decode(N, this._parseBuffer) : this._utf8Decoder.decode(N, this._parseBuffer);
            if (j = this._parser.parse(this._parseBuffer, z)) return this._preserveStack(H, U, z, 0), this._logSlowResolvingAsync(j), j;
          }
          this._activeBuffer.x === H && this._activeBuffer.y === U || this._onCursorMove.fire();
          const he = this._dirtyRowTracker.end + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp), X = this._dirtyRowTracker.start + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
          X < this._bufferService.rows && this._onRequestRefreshRows.fire(Math.min(X, this._bufferService.rows - 1), Math.min(he, this._bufferService.rows - 1));
        }
        print(N, L, j) {
          let H, U;
          const Y = this._charsetService.charset, ne = this._optionsService.rawOptions.screenReaderMode, he = this._bufferService.cols, X = this._coreService.decPrivateModes.wraparound, z = this._coreService.modes.insertMode, ue = this._curAttrData;
          let ae = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && j - L > 0 && ae.getWidth(this._activeBuffer.x - 1) === 2 && ae.setCellFromCodepoint(this._activeBuffer.x - 1, 0, 1, ue);
          let be = this._parser.precedingJoinState;
          for (let de = L; de < j; ++de) {
            if (H = N[de], H < 127 && Y) {
              const re = Y[String.fromCharCode(H)];
              re && (H = re.charCodeAt(0));
            }
            const _e = this._unicodeService.charProperties(H, be);
            U = E.UnicodeService.extractWidth(_e);
            const $ = E.UnicodeService.extractShouldJoin(_e), ce = $ ? E.UnicodeService.extractWidth(be) : 0;
            if (be = _e, ne && this._onA11yChar.fire((0, y.stringFromCodePoint)(H)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), this._activeBuffer.x + U - ce > he) {
              if (X) {
                const re = ae;
                let W = this._activeBuffer.x - ce;
                for (this._activeBuffer.x = ce, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), ae = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y), ce > 0 && ae instanceof p.BufferLine && ae.copyCellsFrom(re, W, 0, ce, !1); W < he; ) re.setCellFromCodepoint(W++, 0, 1, ue);
              } else if (this._activeBuffer.x = he - 1, U === 2) continue;
            }
            if ($ && this._activeBuffer.x) {
              const re = ae.getWidth(this._activeBuffer.x - 1) ? 1 : 2;
              ae.addCodepointToCell(this._activeBuffer.x - re, H, U);
              for (let W = U - ce; --W >= 0; ) ae.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, ue);
            } else if (z && (ae.insertCells(this._activeBuffer.x, U - ce, this._activeBuffer.getNullCell(ue)), ae.getWidth(he - 1) === 2 && ae.setCellFromCodepoint(he - 1, b.NULL_CELL_CODE, b.NULL_CELL_WIDTH, ue)), ae.setCellFromCodepoint(this._activeBuffer.x++, H, U, ue), U > 0) for (; --U; ) ae.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, ue);
          }
          this._parser.precedingJoinState = be, this._activeBuffer.x < he && j - L > 0 && ae.getWidth(this._activeBuffer.x) === 0 && !ae.hasContent(this._activeBuffer.x) && ae.setCellFromCodepoint(this._activeBuffer.x, 0, 1, ue), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        registerCsiHandler(N, L) {
          return N.final !== "t" || N.prefix || N.intermediates ? this._parser.registerCsiHandler(N, L) : this._parser.registerCsiHandler(N, (j) => !P(j.params[0], this._optionsService.rawOptions.windowOptions) || L(j));
        }
        registerDcsHandler(N, L) {
          return this._parser.registerDcsHandler(N, new S.DcsHandler(L));
        }
        registerEscHandler(N, L) {
          return this._parser.registerEscHandler(N, L);
        }
        registerOscHandler(N, L) {
          return this._parser.registerOscHandler(N, new x.OscHandler(L));
        }
        bell() {
          return this._onRequestBell.fire(), !0;
        }
        lineFeed() {
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0;
        }
        carriageReturn() {
          return this._activeBuffer.x = 0, !0;
        }
        backspace() {
          if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0;
          if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
          else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)?.isWrapped) {
            this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
            const N = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            N.hasWidth(this._activeBuffer.x) && !N.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
          }
          return this._restrictCursor(), !0;
        }
        tab() {
          if (this._activeBuffer.x >= this._bufferService.cols) return !0;
          const N = this._activeBuffer.x;
          return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - N), !0;
        }
        shiftOut() {
          return this._charsetService.setgLevel(1), !0;
        }
        shiftIn() {
          return this._charsetService.setgLevel(0), !0;
        }
        _restrictCursor(N = this._bufferService.cols - 1) {
          this._activeBuffer.x = Math.min(N, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _setCursor(N, L) {
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = N, this._activeBuffer.y = this._activeBuffer.scrollTop + L) : (this._activeBuffer.x = N, this._activeBuffer.y = L), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _moveCursor(N, L) {
          this._restrictCursor(), this._setCursor(this._activeBuffer.x + N, this._activeBuffer.y + L);
        }
        cursorUp(N) {
          const L = this._activeBuffer.y - this._activeBuffer.scrollTop;
          return L >= 0 ? this._moveCursor(0, -Math.min(L, N.params[0] || 1)) : this._moveCursor(0, -(N.params[0] || 1)), !0;
        }
        cursorDown(N) {
          const L = this._activeBuffer.scrollBottom - this._activeBuffer.y;
          return L >= 0 ? this._moveCursor(0, Math.min(L, N.params[0] || 1)) : this._moveCursor(0, N.params[0] || 1), !0;
        }
        cursorForward(N) {
          return this._moveCursor(N.params[0] || 1, 0), !0;
        }
        cursorBackward(N) {
          return this._moveCursor(-(N.params[0] || 1), 0), !0;
        }
        cursorNextLine(N) {
          return this.cursorDown(N), this._activeBuffer.x = 0, !0;
        }
        cursorPrecedingLine(N) {
          return this.cursorUp(N), this._activeBuffer.x = 0, !0;
        }
        cursorCharAbsolute(N) {
          return this._setCursor((N.params[0] || 1) - 1, this._activeBuffer.y), !0;
        }
        cursorPosition(N) {
          return this._setCursor(N.length >= 2 ? (N.params[1] || 1) - 1 : 0, (N.params[0] || 1) - 1), !0;
        }
        charPosAbsolute(N) {
          return this._setCursor((N.params[0] || 1) - 1, this._activeBuffer.y), !0;
        }
        hPositionRelative(N) {
          return this._moveCursor(N.params[0] || 1, 0), !0;
        }
        linePosAbsolute(N) {
          return this._setCursor(this._activeBuffer.x, (N.params[0] || 1) - 1), !0;
        }
        vPositionRelative(N) {
          return this._moveCursor(0, N.params[0] || 1), !0;
        }
        hVPosition(N) {
          return this.cursorPosition(N), !0;
        }
        tabClear(N) {
          const L = N.params[0];
          return L === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : L === 3 && (this._activeBuffer.tabs = {}), !0;
        }
        cursorForwardTab(N) {
          if (this._activeBuffer.x >= this._bufferService.cols) return !0;
          let L = N.params[0] || 1;
          for (; L--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
          return !0;
        }
        cursorBackwardTab(N) {
          if (this._activeBuffer.x >= this._bufferService.cols) return !0;
          let L = N.params[0] || 1;
          for (; L--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
          return !0;
        }
        selectProtected(N) {
          const L = N.params[0];
          return L === 1 && (this._curAttrData.bg |= 536870912), L !== 2 && L !== 0 || (this._curAttrData.bg &= -536870913), !0;
        }
        _eraseInBufferLine(N, L, j, H = !1, U = !1) {
          const Y = this._activeBuffer.lines.get(this._activeBuffer.ybase + N);
          Y.replaceCells(L, j, this._activeBuffer.getNullCell(this._eraseAttrData()), U), H && (Y.isWrapped = !1);
        }
        _resetBufferLine(N, L = !1) {
          const j = this._activeBuffer.lines.get(this._activeBuffer.ybase + N);
          j && (j.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), L), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + N), j.isWrapped = !1);
        }
        eraseInDisplay(N, L = !1) {
          let j;
          switch (this._restrictCursor(this._bufferService.cols), N.params[0]) {
            case 0:
              for (j = this._activeBuffer.y, this._dirtyRowTracker.markDirty(j), this._eraseInBufferLine(j++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, L); j < this._bufferService.rows; j++) this._resetBufferLine(j, L);
              this._dirtyRowTracker.markDirty(j);
              break;
            case 1:
              for (j = this._activeBuffer.y, this._dirtyRowTracker.markDirty(j), this._eraseInBufferLine(j, 0, this._activeBuffer.x + 1, !0, L), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(j + 1).isWrapped = !1); j--; ) this._resetBufferLine(j, L);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 2:
              for (j = this._bufferService.rows, this._dirtyRowTracker.markDirty(j - 1); j--; ) this._resetBufferLine(j, L);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 3:
              const H = this._activeBuffer.lines.length - this._bufferService.rows;
              H > 0 && (this._activeBuffer.lines.trimStart(H), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - H, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - H, 0), this._onScroll.fire(0));
          }
          return !0;
        }
        eraseInLine(N, L = !1) {
          switch (this._restrictCursor(this._bufferService.cols), N.params[0]) {
            case 0:
              this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, L);
              break;
            case 1:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, L);
              break;
            case 2:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, L);
          }
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0;
        }
        insertLines(N) {
          this._restrictCursor();
          let L = N.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const j = this._activeBuffer.ybase + this._activeBuffer.y, H = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, U = this._bufferService.rows - 1 + this._activeBuffer.ybase - H + 1;
          for (; L--; ) this._activeBuffer.lines.splice(U - 1, 1), this._activeBuffer.lines.splice(j, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
        }
        deleteLines(N) {
          this._restrictCursor();
          let L = N.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const j = this._activeBuffer.ybase + this._activeBuffer.y;
          let H;
          for (H = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, H = this._bufferService.rows - 1 + this._activeBuffer.ybase - H; L--; ) this._activeBuffer.lines.splice(j, 1), this._activeBuffer.lines.splice(H, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
        }
        insertChars(N) {
          this._restrictCursor();
          const L = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return L && (L.insertCells(this._activeBuffer.x, N.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
        }
        deleteChars(N) {
          this._restrictCursor();
          const L = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return L && (L.deleteCells(this._activeBuffer.x, N.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
        }
        scrollUp(N) {
          let L = N.params[0] || 1;
          for (; L--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        scrollDown(N) {
          let L = N.params[0] || 1;
          for (; L--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(p.DEFAULT_ATTR_DATA));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        scrollLeft(N) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const L = N.params[0] || 1;
          for (let j = this._activeBuffer.scrollTop; j <= this._activeBuffer.scrollBottom; ++j) {
            const H = this._activeBuffer.lines.get(this._activeBuffer.ybase + j);
            H.deleteCells(0, L, this._activeBuffer.getNullCell(this._eraseAttrData())), H.isWrapped = !1;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        scrollRight(N) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const L = N.params[0] || 1;
          for (let j = this._activeBuffer.scrollTop; j <= this._activeBuffer.scrollBottom; ++j) {
            const H = this._activeBuffer.lines.get(this._activeBuffer.ybase + j);
            H.insertCells(0, L, this._activeBuffer.getNullCell(this._eraseAttrData())), H.isWrapped = !1;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        insertColumns(N) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const L = N.params[0] || 1;
          for (let j = this._activeBuffer.scrollTop; j <= this._activeBuffer.scrollBottom; ++j) {
            const H = this._activeBuffer.lines.get(this._activeBuffer.ybase + j);
            H.insertCells(this._activeBuffer.x, L, this._activeBuffer.getNullCell(this._eraseAttrData())), H.isWrapped = !1;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        deleteColumns(N) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const L = N.params[0] || 1;
          for (let j = this._activeBuffer.scrollTop; j <= this._activeBuffer.scrollBottom; ++j) {
            const H = this._activeBuffer.lines.get(this._activeBuffer.ybase + j);
            H.deleteCells(this._activeBuffer.x, L, this._activeBuffer.getNullCell(this._eraseAttrData())), H.isWrapped = !1;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        eraseChars(N) {
          this._restrictCursor();
          const L = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return L && (L.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (N.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
        }
        repeatPrecedingCharacter(N) {
          const L = this._parser.precedingJoinState;
          if (!L) return !0;
          const j = N.params[0] || 1, H = E.UnicodeService.extractWidth(L), U = this._activeBuffer.x - H, Y = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).getString(U), ne = new Uint32Array(Y.length * j);
          let he = 0;
          for (let z = 0; z < Y.length; ) {
            const ue = Y.codePointAt(z) || 0;
            ne[he++] = ue, z += ue > 65535 ? 2 : 1;
          }
          let X = he;
          for (let z = 1; z < j; ++z) ne.copyWithin(X, 0, he), X += he;
          return this.print(ne, 0, X), !0;
        }
        sendDeviceAttributesPrimary(N) {
          return N.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(h.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(h.C0.ESC + "[?6c")), !0;
        }
        sendDeviceAttributesSecondary(N) {
          return N.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(h.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(h.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(N.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(h.C0.ESC + "[>83;40003;0c")), !0;
        }
        _is(N) {
          return (this._optionsService.rawOptions.termName + "").indexOf(N) === 0;
        }
        setMode(N) {
          for (let L = 0; L < N.length; L++) switch (N.params[L]) {
            case 4:
              this._coreService.modes.insertMode = !0;
              break;
            case 20:
              this._optionsService.options.convertEol = !0;
          }
          return !0;
        }
        setModePrivate(N) {
          for (let L = 0; L < N.length; L++) switch (N.params[L]) {
            case 1:
              this._coreService.decPrivateModes.applicationCursorKeys = !0;
              break;
            case 2:
              this._charsetService.setgCharset(0, d.DEFAULT_CHARSET), this._charsetService.setgCharset(1, d.DEFAULT_CHARSET), this._charsetService.setgCharset(2, d.DEFAULT_CHARSET), this._charsetService.setgCharset(3, d.DEFAULT_CHARSET);
              break;
            case 3:
              this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
              break;
            case 6:
              this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0);
              break;
            case 7:
              this._coreService.decPrivateModes.wraparound = !0;
              break;
            case 12:
              this._optionsService.options.cursorBlink = !0;
              break;
            case 45:
              this._coreService.decPrivateModes.reverseWraparound = !0;
              break;
            case 66:
              this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire();
              break;
            case 9:
              this._coreMouseService.activeProtocol = "X10";
              break;
            case 1e3:
              this._coreMouseService.activeProtocol = "VT200";
              break;
            case 1002:
              this._coreMouseService.activeProtocol = "DRAG";
              break;
            case 1003:
              this._coreMouseService.activeProtocol = "ANY";
              break;
            case 1004:
              this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire();
              break;
            case 1005:
              this._logService.debug("DECSET 1005 not supported (see #2507)");
              break;
            case 1006:
              this._coreMouseService.activeEncoding = "SGR";
              break;
            case 1015:
              this._logService.debug("DECSET 1015 not supported (see #2507)");
              break;
            case 1016:
              this._coreMouseService.activeEncoding = "SGR_PIXELS";
              break;
            case 25:
              this._coreService.isCursorHidden = !1;
              break;
            case 1048:
              this.saveCursor();
              break;
            case 1049:
              this.saveCursor();
            case 47:
            case 1047:
              this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
              break;
            case 2004:
              this._coreService.decPrivateModes.bracketedPasteMode = !0;
          }
          return !0;
        }
        resetMode(N) {
          for (let L = 0; L < N.length; L++) switch (N.params[L]) {
            case 4:
              this._coreService.modes.insertMode = !1;
              break;
            case 20:
              this._optionsService.options.convertEol = !1;
          }
          return !0;
        }
        resetModePrivate(N) {
          for (let L = 0; L < N.length; L++) switch (N.params[L]) {
            case 1:
              this._coreService.decPrivateModes.applicationCursorKeys = !1;
              break;
            case 3:
              this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
              break;
            case 6:
              this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0);
              break;
            case 7:
              this._coreService.decPrivateModes.wraparound = !1;
              break;
            case 12:
              this._optionsService.options.cursorBlink = !1;
              break;
            case 45:
              this._coreService.decPrivateModes.reverseWraparound = !1;
              break;
            case 66:
              this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire();
              break;
            case 9:
            case 1e3:
            case 1002:
            case 1003:
              this._coreMouseService.activeProtocol = "NONE";
              break;
            case 1004:
              this._coreService.decPrivateModes.sendFocus = !1;
              break;
            case 1005:
              this._logService.debug("DECRST 1005 not supported (see #2507)");
              break;
            case 1006:
            case 1016:
              this._coreMouseService.activeEncoding = "DEFAULT";
              break;
            case 1015:
              this._logService.debug("DECRST 1015 not supported (see #2507)");
              break;
            case 25:
              this._coreService.isCursorHidden = !0;
              break;
            case 1048:
              this.restoreCursor();
              break;
            case 1049:
            case 47:
            case 1047:
              this._bufferService.buffers.activateNormalBuffer(), N.params[L] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
              break;
            case 2004:
              this._coreService.decPrivateModes.bracketedPasteMode = !1;
          }
          return !0;
        }
        requestMode(N, L) {
          const j = this._coreService.decPrivateModes, { activeProtocol: H, activeEncoding: U } = this._coreMouseService, Y = this._coreService, { buffers: ne, cols: he } = this._bufferService, { active: X, alt: z } = ne, ue = this._optionsService.rawOptions, ae = ($) => $ ? 1 : 2, be = N.params[0];
          return de = be, _e = L ? be === 2 ? 4 : be === 4 ? ae(Y.modes.insertMode) : be === 12 ? 3 : be === 20 ? ae(ue.convertEol) : 0 : be === 1 ? ae(j.applicationCursorKeys) : be === 3 ? ue.windowOptions.setWinLines ? he === 80 ? 2 : he === 132 ? 1 : 0 : 0 : be === 6 ? ae(j.origin) : be === 7 ? ae(j.wraparound) : be === 8 ? 3 : be === 9 ? ae(H === "X10") : be === 12 ? ae(ue.cursorBlink) : be === 25 ? ae(!Y.isCursorHidden) : be === 45 ? ae(j.reverseWraparound) : be === 66 ? ae(j.applicationKeypad) : be === 67 ? 4 : be === 1e3 ? ae(H === "VT200") : be === 1002 ? ae(H === "DRAG") : be === 1003 ? ae(H === "ANY") : be === 1004 ? ae(j.sendFocus) : be === 1005 ? 4 : be === 1006 ? ae(U === "SGR") : be === 1015 ? 4 : be === 1016 ? ae(U === "SGR_PIXELS") : be === 1048 ? 1 : be === 47 || be === 1047 || be === 1049 ? ae(X === z) : be === 2004 ? ae(j.bracketedPasteMode) : 0, Y.triggerDataEvent(`${h.C0.ESC}[${L ? "" : "?"}${de};${_e}$y`), !0;
          var de, _e;
        }
        _updateAttrColor(N, L, j, H, U) {
          return L === 2 ? (N |= 50331648, N &= -16777216, N |= v.AttributeData.fromColorRGB([j, H, U])) : L === 5 && (N &= -50331904, N |= 33554432 | 255 & j), N;
        }
        _extractColor(N, L, j) {
          const H = [0, 0, -1, 0, 0, 0];
          let U = 0, Y = 0;
          do {
            if (H[Y + U] = N.params[L + Y], N.hasSubParams(L + Y)) {
              const ne = N.getSubParams(L + Y);
              let he = 0;
              do
                H[1] === 5 && (U = 1), H[Y + he + 1 + U] = ne[he];
              while (++he < ne.length && he + Y + 1 + U < H.length);
              break;
            }
            if (H[1] === 5 && Y + U >= 2 || H[1] === 2 && Y + U >= 5) break;
            H[1] && (U = 1);
          } while (++Y + L < N.length && Y + U < H.length);
          for (let ne = 2; ne < H.length; ++ne) H[ne] === -1 && (H[ne] = 0);
          switch (H[0]) {
            case 38:
              j.fg = this._updateAttrColor(j.fg, H[1], H[3], H[4], H[5]);
              break;
            case 48:
              j.bg = this._updateAttrColor(j.bg, H[1], H[3], H[4], H[5]);
              break;
            case 58:
              j.extended = j.extended.clone(), j.extended.underlineColor = this._updateAttrColor(j.extended.underlineColor, H[1], H[3], H[4], H[5]);
          }
          return Y;
        }
        _processUnderline(N, L) {
          L.extended = L.extended.clone(), (!~N || N > 5) && (N = 1), L.extended.underlineStyle = N, L.fg |= 268435456, N === 0 && (L.fg &= -268435457), L.updateExtended();
        }
        _processSGR0(N) {
          N.fg = p.DEFAULT_ATTR_DATA.fg, N.bg = p.DEFAULT_ATTR_DATA.bg, N.extended = N.extended.clone(), N.extended.underlineStyle = 0, N.extended.underlineColor &= -67108864, N.updateExtended();
        }
        charAttributes(N) {
          if (N.length === 1 && N.params[0] === 0) return this._processSGR0(this._curAttrData), !0;
          const L = N.length;
          let j;
          const H = this._curAttrData;
          for (let U = 0; U < L; U++) j = N.params[U], j >= 30 && j <= 37 ? (H.fg &= -50331904, H.fg |= 16777216 | j - 30) : j >= 40 && j <= 47 ? (H.bg &= -50331904, H.bg |= 16777216 | j - 40) : j >= 90 && j <= 97 ? (H.fg &= -50331904, H.fg |= 16777224 | j - 90) : j >= 100 && j <= 107 ? (H.bg &= -50331904, H.bg |= 16777224 | j - 100) : j === 0 ? this._processSGR0(H) : j === 1 ? H.fg |= 134217728 : j === 3 ? H.bg |= 67108864 : j === 4 ? (H.fg |= 268435456, this._processUnderline(N.hasSubParams(U) ? N.getSubParams(U)[0] : 1, H)) : j === 5 ? H.fg |= 536870912 : j === 7 ? H.fg |= 67108864 : j === 8 ? H.fg |= 1073741824 : j === 9 ? H.fg |= 2147483648 : j === 2 ? H.bg |= 134217728 : j === 21 ? this._processUnderline(2, H) : j === 22 ? (H.fg &= -134217729, H.bg &= -134217729) : j === 23 ? H.bg &= -67108865 : j === 24 ? (H.fg &= -268435457, this._processUnderline(0, H)) : j === 25 ? H.fg &= -536870913 : j === 27 ? H.fg &= -67108865 : j === 28 ? H.fg &= -1073741825 : j === 29 ? H.fg &= 2147483647 : j === 39 ? (H.fg &= -67108864, H.fg |= 16777215 & p.DEFAULT_ATTR_DATA.fg) : j === 49 ? (H.bg &= -67108864, H.bg |= 16777215 & p.DEFAULT_ATTR_DATA.bg) : j === 38 || j === 48 || j === 58 ? U += this._extractColor(N, U, H) : j === 53 ? H.bg |= 1073741824 : j === 55 ? H.bg &= -1073741825 : j === 59 ? (H.extended = H.extended.clone(), H.extended.underlineColor = -1, H.updateExtended()) : j === 100 ? (H.fg &= -67108864, H.fg |= 16777215 & p.DEFAULT_ATTR_DATA.fg, H.bg &= -67108864, H.bg |= 16777215 & p.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", j);
          return !0;
        }
        deviceStatus(N) {
          switch (N.params[0]) {
            case 5:
              this._coreService.triggerDataEvent(`${h.C0.ESC}[0n`);
              break;
            case 6:
              const L = this._activeBuffer.y + 1, j = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${h.C0.ESC}[${L};${j}R`);
          }
          return !0;
        }
        deviceStatusPrivate(N) {
          if (N.params[0] === 6) {
            const L = this._activeBuffer.y + 1, j = this._activeBuffer.x + 1;
            this._coreService.triggerDataEvent(`${h.C0.ESC}[?${L};${j}R`);
          }
          return !0;
        }
        softReset(N) {
          return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = p.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0;
        }
        setCursorStyle(N) {
          const L = N.params[0] || 1;
          switch (L) {
            case 1:
            case 2:
              this._optionsService.options.cursorStyle = "block";
              break;
            case 3:
            case 4:
              this._optionsService.options.cursorStyle = "underline";
              break;
            case 5:
            case 6:
              this._optionsService.options.cursorStyle = "bar";
          }
          const j = L % 2 == 1;
          return this._optionsService.options.cursorBlink = j, !0;
        }
        setScrollRegion(N) {
          const L = N.params[0] || 1;
          let j;
          return (N.length < 2 || (j = N.params[1]) > this._bufferService.rows || j === 0) && (j = this._bufferService.rows), j > L && (this._activeBuffer.scrollTop = L - 1, this._activeBuffer.scrollBottom = j - 1, this._setCursor(0, 0)), !0;
        }
        windowOptions(N) {
          if (!P(N.params[0], this._optionsService.rawOptions.windowOptions)) return !0;
          const L = N.length > 1 ? N.params[1] : 0;
          switch (N.params[0]) {
            case 14:
              L !== 2 && this._onRequestWindowsOptionsReport.fire(M.GET_WIN_SIZE_PIXELS);
              break;
            case 16:
              this._onRequestWindowsOptionsReport.fire(M.GET_CELL_SIZE_PIXELS);
              break;
            case 18:
              this._bufferService && this._coreService.triggerDataEvent(`${h.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
              break;
            case 22:
              L !== 0 && L !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), L !== 0 && L !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
              break;
            case 23:
              L !== 0 && L !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), L !== 0 && L !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
          }
          return !0;
        }
        saveCursor(N) {
          return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0;
        }
        restoreCursor(N) {
          return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0;
        }
        setTitle(N) {
          return this._windowTitle = N, this._onTitleChange.fire(N), !0;
        }
        setIconName(N) {
          return this._iconName = N, !0;
        }
        setOrReportIndexedColor(N) {
          const L = [], j = N.split(";");
          for (; j.length > 1; ) {
            const H = j.shift(), U = j.shift();
            if (/^\d+$/.exec(H)) {
              const Y = parseInt(H);
              if (K(Y)) if (U === "?") L.push({ type: 0, index: Y });
              else {
                const ne = (0, T.parseColor)(U);
                ne && L.push({ type: 1, index: Y, color: ne });
              }
            }
          }
          return L.length && this._onColor.fire(L), !0;
        }
        setHyperlink(N) {
          const L = N.split(";");
          return !(L.length < 2) && (L[1] ? this._createHyperlink(L[0], L[1]) : !L[0] && this._finishHyperlink());
        }
        _createHyperlink(N, L) {
          this._getCurrentLinkId() && this._finishHyperlink();
          const j = N.split(":");
          let H;
          const U = j.findIndex((Y) => Y.startsWith("id="));
          return U !== -1 && (H = j[U].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: H, uri: L }), this._curAttrData.updateExtended(), !0;
        }
        _finishHyperlink() {
          return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), !0;
        }
        _setOrReportSpecialColor(N, L) {
          const j = N.split(";");
          for (let H = 0; H < j.length && !(L >= this._specialColors.length); ++H, ++L) if (j[H] === "?") this._onColor.fire([{ type: 0, index: this._specialColors[L] }]);
          else {
            const U = (0, T.parseColor)(j[H]);
            U && this._onColor.fire([{ type: 1, index: this._specialColors[L], color: U }]);
          }
          return !0;
        }
        setOrReportFgColor(N) {
          return this._setOrReportSpecialColor(N, 0);
        }
        setOrReportBgColor(N) {
          return this._setOrReportSpecialColor(N, 1);
        }
        setOrReportCursorColor(N) {
          return this._setOrReportSpecialColor(N, 2);
        }
        restoreIndexedColor(N) {
          if (!N) return this._onColor.fire([{ type: 2 }]), !0;
          const L = [], j = N.split(";");
          for (let H = 0; H < j.length; ++H) if (/^\d+$/.exec(j[H])) {
            const U = parseInt(j[H]);
            K(U) && L.push({ type: 2, index: U });
          }
          return L.length && this._onColor.fire(L), !0;
        }
        restoreFgColor(N) {
          return this._onColor.fire([{ type: 2, index: 256 }]), !0;
        }
        restoreBgColor(N) {
          return this._onColor.fire([{ type: 2, index: 257 }]), !0;
        }
        restoreCursorColor(N) {
          return this._onColor.fire([{ type: 2, index: 258 }]), !0;
        }
        nextLine() {
          return this._activeBuffer.x = 0, this.index(), !0;
        }
        keypadApplicationMode() {
          return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0;
        }
        keypadNumericMode() {
          return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0;
        }
        selectDefaultCharset() {
          return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, d.DEFAULT_CHARSET), !0;
        }
        selectCharset(N) {
          return N.length !== 2 ? (this.selectDefaultCharset(), !0) : (N[0] === "/" || this._charsetService.setgCharset(R[N[0]], d.CHARSETS[N[1]] || d.DEFAULT_CHARSET), !0);
        }
        index() {
          return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0;
        }
        tabSet() {
          return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0;
        }
        reverseIndex() {
          if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
            const N = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
            this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, N, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
          } else this._activeBuffer.y--, this._restrictCursor();
          return !0;
        }
        fullReset() {
          return this._parser.reset(), this._onRequestReset.fire(), !0;
        }
        reset() {
          this._curAttrData = p.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = p.DEFAULT_ATTR_DATA.clone();
        }
        _eraseAttrData() {
          return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
        }
        setgLevel(N) {
          return this._charsetService.setgLevel(N), !0;
        }
        screenAlignmentPattern() {
          const N = new _.CellData();
          N.content = 4194373, N.fg = this._curAttrData.fg, N.bg = this._curAttrData.bg, this._setCursor(0, 0);
          for (let L = 0; L < this._bufferService.rows; ++L) {
            const j = this._activeBuffer.ybase + this._activeBuffer.y + L, H = this._activeBuffer.lines.get(j);
            H && (H.fill(N), H.isWrapped = !1);
          }
          return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), !0;
        }
        requestStatusString(N, L) {
          const j = this._bufferService.buffer, H = this._optionsService.rawOptions;
          return ((U) => (this._coreService.triggerDataEvent(`${h.C0.ESC}${U}${h.C0.ESC}\\`), !0))(N === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : N === '"p' ? 'P1$r61;1"p' : N === "r" ? `P1$r${j.scrollTop + 1};${j.scrollBottom + 1}r` : N === "m" ? "P1$r0m" : N === " q" ? `P1$r${{ block: 2, underline: 4, bar: 6 }[H.cursorStyle] - (H.cursorBlink ? 1 : 0)} q` : "P0$r");
        }
        markRangeDirty(N, L) {
          this._dirtyRowTracker.markRangeDirty(N, L);
        }
      }
      a.InputHandler = V;
      let ee = class {
        constructor(te) {
          this._bufferService = te, this.clearRange();
        }
        clearRange() {
          this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
        }
        markDirty(te) {
          te < this.start ? this.start = te : te > this.end && (this.end = te);
        }
        markRangeDirty(te, N) {
          te > N && (A = te, te = N, N = A), te < this.start && (this.start = te), N > this.end && (this.end = N);
        }
        markAllDirty() {
          this.markRangeDirty(0, this._bufferService.rows - 1);
        }
      };
      function K(te) {
        return 0 <= te && te < 256;
      }
      ee = c([u(0, w.IBufferService)], ee);
    }, 844: (o, a) => {
      function l(c) {
        for (const u of c) u.dispose();
        c.length = 0;
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getDisposeArrayDisposable = a.disposeArray = a.toDisposable = a.MutableDisposable = a.Disposable = void 0, a.Disposable = class {
        constructor() {
          this._disposables = [], this._isDisposed = !1;
        }
        dispose() {
          this._isDisposed = !0;
          for (const c of this._disposables) c.dispose();
          this._disposables.length = 0;
        }
        register(c) {
          return this._disposables.push(c), c;
        }
        unregister(c) {
          const u = this._disposables.indexOf(c);
          u !== -1 && this._disposables.splice(u, 1);
        }
      }, a.MutableDisposable = class {
        constructor() {
          this._isDisposed = !1;
        }
        get value() {
          return this._isDisposed ? void 0 : this._value;
        }
        set value(c) {
          this._isDisposed || c === this._value || (this._value?.dispose(), this._value = c);
        }
        clear() {
          this.value = void 0;
        }
        dispose() {
          this._isDisposed = !0, this._value?.dispose(), this._value = void 0;
        }
      }, a.toDisposable = function(c) {
        return { dispose: c };
      }, a.disposeArray = l, a.getDisposeArrayDisposable = function(c) {
        return { dispose: () => l(c) };
      };
    }, 1505: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.FourKeyMap = a.TwoKeyMap = void 0;
      class l {
        constructor() {
          this._data = {};
        }
        set(u, h, d) {
          this._data[u] || (this._data[u] = {}), this._data[u][h] = d;
        }
        get(u, h) {
          return this._data[u] ? this._data[u][h] : void 0;
        }
        clear() {
          this._data = {};
        }
      }
      a.TwoKeyMap = l, a.FourKeyMap = class {
        constructor() {
          this._data = new l();
        }
        set(c, u, h, d, f) {
          this._data.get(c, u) || this._data.set(c, u, new l()), this._data.get(c, u).set(h, d, f);
        }
        get(c, u, h, d) {
          return this._data.get(c, u)?.get(h, d);
        }
        clear() {
          this._data.clear();
        }
      };
    }, 6114: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.isChromeOS = a.isLinux = a.isWindows = a.isIphone = a.isIpad = a.isMac = a.getSafariVersion = a.isSafari = a.isLegacyEdge = a.isFirefox = a.isNode = void 0, a.isNode = typeof je < "u" && "title" in je;
      const l = a.isNode ? "node" : navigator.userAgent, c = a.isNode ? "node" : navigator.platform;
      a.isFirefox = l.includes("Firefox"), a.isLegacyEdge = l.includes("Edge"), a.isSafari = /^((?!chrome|android).)*safari/i.test(l), a.getSafariVersion = function() {
        if (!a.isSafari) return 0;
        const u = l.match(/Version\/(\d+)/);
        return u === null || u.length < 2 ? 0 : parseInt(u[1]);
      }, a.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(c), a.isIpad = c === "iPad", a.isIphone = c === "iPhone", a.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(c), a.isLinux = c.indexOf("Linux") >= 0, a.isChromeOS = /\bCrOS\b/.test(l);
    }, 6106: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.SortedList = void 0;
      let l = 0;
      a.SortedList = class {
        constructor(c) {
          this._getKey = c, this._array = [];
        }
        clear() {
          this._array.length = 0;
        }
        insert(c) {
          this._array.length !== 0 ? (l = this._search(this._getKey(c)), this._array.splice(l, 0, c)) : this._array.push(c);
        }
        delete(c) {
          if (this._array.length === 0) return !1;
          const u = this._getKey(c);
          if (u === void 0 || (l = this._search(u), l === -1) || this._getKey(this._array[l]) !== u) return !1;
          do
            if (this._array[l] === c) return this._array.splice(l, 1), !0;
          while (++l < this._array.length && this._getKey(this._array[l]) === u);
          return !1;
        }
        *getKeyIterator(c) {
          if (this._array.length !== 0 && (l = this._search(c), !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c)) do
            yield this._array[l];
          while (++l < this._array.length && this._getKey(this._array[l]) === c);
        }
        forEachByKey(c, u) {
          if (this._array.length !== 0 && (l = this._search(c), !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c)) do
            u(this._array[l]);
          while (++l < this._array.length && this._getKey(this._array[l]) === c);
        }
        values() {
          return [...this._array].values();
        }
        _search(c) {
          let u = 0, h = this._array.length - 1;
          for (; h >= u; ) {
            let d = u + h >> 1;
            const f = this._getKey(this._array[d]);
            if (f > c) h = d - 1;
            else {
              if (!(f < c)) {
                for (; d > 0 && this._getKey(this._array[d - 1]) === c; ) d--;
                return d;
              }
              u = d + 1;
            }
          }
          return u;
        }
      };
    }, 7226: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DebouncedIdleTask = a.IdleTaskQueue = a.PriorityTaskQueue = void 0;
      const c = l(6114);
      class u {
        constructor() {
          this._tasks = [], this._i = 0;
        }
        enqueue(f) {
          this._tasks.push(f), this._start();
        }
        flush() {
          for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
          this.clear();
        }
        clear() {
          this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
        }
        _start() {
          this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
        }
        _process(f) {
          this._idleCallback = void 0;
          let g = 0, y = 0, p = f.timeRemaining(), m = 0;
          for (; this._i < this._tasks.length; ) {
            if (g = Date.now(), this._tasks[this._i]() || this._i++, g = Math.max(1, Date.now() - g), y = Math.max(g, y), m = f.timeRemaining(), 1.5 * y > m) return p - g < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(p - g))}ms`), void this._start();
            p = m;
          }
          this.clear();
        }
      }
      class h extends u {
        _requestCallback(f) {
          return setTimeout(() => f(this._createDeadline(16)));
        }
        _cancelCallback(f) {
          clearTimeout(f);
        }
        _createDeadline(f) {
          const g = Date.now() + f;
          return { timeRemaining: () => Math.max(0, g - Date.now()) };
        }
      }
      a.PriorityTaskQueue = h, a.IdleTaskQueue = !c.isNode && "requestIdleCallback" in window ? class extends u {
        _requestCallback(d) {
          return requestIdleCallback(d);
        }
        _cancelCallback(d) {
          cancelIdleCallback(d);
        }
      } : h, a.DebouncedIdleTask = class {
        constructor() {
          this._queue = new a.IdleTaskQueue();
        }
        set(d) {
          this._queue.clear(), this._queue.enqueue(d);
        }
        flush() {
          this._queue.flush();
        }
      };
    }, 9282: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.updateWindowsModeWrappedState = void 0;
      const c = l(643);
      a.updateWindowsModeWrappedState = function(u) {
        const h = u.buffer.lines.get(u.buffer.ybase + u.buffer.y - 1), d = h?.get(u.cols - 1), f = u.buffer.lines.get(u.buffer.ybase + u.buffer.y);
        f && d && (f.isWrapped = d[c.CHAR_DATA_CODE_INDEX] !== c.NULL_CELL_CODE && d[c.CHAR_DATA_CODE_INDEX] !== c.WHITESPACE_CELL_CODE);
      };
    }, 3734: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ExtendedAttrs = a.AttributeData = void 0;
      class l {
        constructor() {
          this.fg = 0, this.bg = 0, this.extended = new c();
        }
        static toColorRGB(h) {
          return [h >>> 16 & 255, h >>> 8 & 255, 255 & h];
        }
        static fromColorRGB(h) {
          return (255 & h[0]) << 16 | (255 & h[1]) << 8 | 255 & h[2];
        }
        clone() {
          const h = new l();
          return h.fg = this.fg, h.bg = this.bg, h.extended = this.extended.clone(), h;
        }
        isInverse() {
          return 67108864 & this.fg;
        }
        isBold() {
          return 134217728 & this.fg;
        }
        isUnderline() {
          return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
        }
        isBlink() {
          return 536870912 & this.fg;
        }
        isInvisible() {
          return 1073741824 & this.fg;
        }
        isItalic() {
          return 67108864 & this.bg;
        }
        isDim() {
          return 134217728 & this.bg;
        }
        isStrikethrough() {
          return 2147483648 & this.fg;
        }
        isProtected() {
          return 536870912 & this.bg;
        }
        isOverline() {
          return 1073741824 & this.bg;
        }
        getFgColorMode() {
          return 50331648 & this.fg;
        }
        getBgColorMode() {
          return 50331648 & this.bg;
        }
        isFgRGB() {
          return (50331648 & this.fg) == 50331648;
        }
        isBgRGB() {
          return (50331648 & this.bg) == 50331648;
        }
        isFgPalette() {
          return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
        }
        isBgPalette() {
          return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
        }
        isFgDefault() {
          return (50331648 & this.fg) == 0;
        }
        isBgDefault() {
          return (50331648 & this.bg) == 0;
        }
        isAttributeDefault() {
          return this.fg === 0 && this.bg === 0;
        }
        getFgColor() {
          switch (50331648 & this.fg) {
            case 16777216:
            case 33554432:
              return 255 & this.fg;
            case 50331648:
              return 16777215 & this.fg;
            default:
              return -1;
          }
        }
        getBgColor() {
          switch (50331648 & this.bg) {
            case 16777216:
            case 33554432:
              return 255 & this.bg;
            case 50331648:
              return 16777215 & this.bg;
            default:
              return -1;
          }
        }
        hasExtendedAttrs() {
          return 268435456 & this.bg;
        }
        updateExtended() {
          this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
        }
        getUnderlineColor() {
          if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
            case 16777216:
            case 33554432:
              return 255 & this.extended.underlineColor;
            case 50331648:
              return 16777215 & this.extended.underlineColor;
            default:
              return this.getFgColor();
          }
          return this.getFgColor();
        }
        getUnderlineColorMode() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
        }
        isUnderlineColorRGB() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
        }
        isUnderlineColorPalette() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
        }
        isUnderlineColorDefault() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
        }
        getUnderlineStyle() {
          return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
        }
        getUnderlineVariantOffset() {
          return this.extended.underlineVariantOffset;
        }
      }
      a.AttributeData = l;
      class c {
        get ext() {
          return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
        }
        set ext(h) {
          this._ext = h;
        }
        get underlineStyle() {
          return this._urlId ? 5 : (469762048 & this._ext) >> 26;
        }
        set underlineStyle(h) {
          this._ext &= -469762049, this._ext |= h << 26 & 469762048;
        }
        get underlineColor() {
          return 67108863 & this._ext;
        }
        set underlineColor(h) {
          this._ext &= -67108864, this._ext |= 67108863 & h;
        }
        get urlId() {
          return this._urlId;
        }
        set urlId(h) {
          this._urlId = h;
        }
        get underlineVariantOffset() {
          const h = (3758096384 & this._ext) >> 29;
          return h < 0 ? 4294967288 ^ h : h;
        }
        set underlineVariantOffset(h) {
          this._ext &= 536870911, this._ext |= h << 29 & 3758096384;
        }
        constructor(h = 0, d = 0) {
          this._ext = 0, this._urlId = 0, this._ext = h, this._urlId = d;
        }
        clone() {
          return new c(this._ext, this._urlId);
        }
        isEmpty() {
          return this.underlineStyle === 0 && this._urlId === 0;
        }
      }
      a.ExtendedAttrs = c;
    }, 9092: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Buffer = a.MAX_BUFFER_SIZE = void 0;
      const c = l(6349), u = l(7226), h = l(3734), d = l(8437), f = l(4634), g = l(511), y = l(643), p = l(4863), m = l(7116);
      a.MAX_BUFFER_SIZE = 4294967295, a.Buffer = class {
        constructor(b, _, v) {
          this._hasScrollback = b, this._optionsService = _, this._bufferService = v, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = d.DEFAULT_ATTR_DATA.clone(), this.savedCharset = m.DEFAULT_CHARSET, this.markers = [], this._nullCell = g.CellData.fromCharData([0, y.NULL_CELL_CHAR, y.NULL_CELL_WIDTH, y.NULL_CELL_CODE]), this._whitespaceCell = g.CellData.fromCharData([0, y.WHITESPACE_CELL_CHAR, y.WHITESPACE_CELL_WIDTH, y.WHITESPACE_CELL_CODE]), this._isClearing = !1, this._memoryCleanupQueue = new u.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        getNullCell(b) {
          return b ? (this._nullCell.fg = b.fg, this._nullCell.bg = b.bg, this._nullCell.extended = b.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new h.ExtendedAttrs()), this._nullCell;
        }
        getWhitespaceCell(b) {
          return b ? (this._whitespaceCell.fg = b.fg, this._whitespaceCell.bg = b.bg, this._whitespaceCell.extended = b.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new h.ExtendedAttrs()), this._whitespaceCell;
        }
        getBlankLine(b, _) {
          return new d.BufferLine(this._bufferService.cols, this.getNullCell(b), _);
        }
        get hasScrollback() {
          return this._hasScrollback && this.lines.maxLength > this._rows;
        }
        get isCursorInViewport() {
          const b = this.ybase + this.y - this.ydisp;
          return b >= 0 && b < this._rows;
        }
        _getCorrectBufferLength(b) {
          if (!this._hasScrollback) return b;
          const _ = b + this._optionsService.rawOptions.scrollback;
          return _ > a.MAX_BUFFER_SIZE ? a.MAX_BUFFER_SIZE : _;
        }
        fillViewportRows(b) {
          if (this.lines.length === 0) {
            b === void 0 && (b = d.DEFAULT_ATTR_DATA);
            let _ = this._rows;
            for (; _--; ) this.lines.push(this.getBlankLine(b));
          }
        }
        clear() {
          this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        resize(b, _) {
          const v = this.getNullCell(d.DEFAULT_ATTR_DATA);
          let w = 0;
          const E = this._getCorrectBufferLength(_);
          if (E > this.lines.maxLength && (this.lines.maxLength = E), this.lines.length > 0) {
            if (this._cols < b) for (let S = 0; S < this.lines.length; S++) w += +this.lines.get(S).resize(b, v);
            let x = 0;
            if (this._rows < _) for (let S = this._rows; S < _; S++) this.lines.length < _ + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new d.BufferLine(b, v)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + x + 1 ? (this.ybase--, x++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new d.BufferLine(b, v)));
            else for (let S = this._rows; S > _; S--) this.lines.length > _ + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
            if (E < this.lines.maxLength) {
              const S = this.lines.length - E;
              S > 0 && (this.lines.trimStart(S), this.ybase = Math.max(this.ybase - S, 0), this.ydisp = Math.max(this.ydisp - S, 0), this.savedY = Math.max(this.savedY - S, 0)), this.lines.maxLength = E;
            }
            this.x = Math.min(this.x, b - 1), this.y = Math.min(this.y, _ - 1), x && (this.y += x), this.savedX = Math.min(this.savedX, b - 1), this.scrollTop = 0;
          }
          if (this.scrollBottom = _ - 1, this._isReflowEnabled && (this._reflow(b, _), this._cols > b)) for (let x = 0; x < this.lines.length; x++) w += +this.lines.get(x).resize(b, v);
          this._cols = b, this._rows = _, this._memoryCleanupQueue.clear(), w > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
        }
        _batchedMemoryCleanup() {
          let b = !0;
          this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, b = !1);
          let _ = 0;
          for (; this._memoryCleanupPosition < this.lines.length; ) if (_ += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), _ > 100) return !0;
          return b;
        }
        get _isReflowEnabled() {
          const b = this._optionsService.rawOptions.windowsPty;
          return b && b.buildNumber ? this._hasScrollback && b.backend === "conpty" && b.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
        }
        _reflow(b, _) {
          this._cols !== b && (b > this._cols ? this._reflowLarger(b, _) : this._reflowSmaller(b, _));
        }
        _reflowLarger(b, _) {
          const v = (0, f.reflowLargerGetLinesToRemove)(this.lines, this._cols, b, this.ybase + this.y, this.getNullCell(d.DEFAULT_ATTR_DATA));
          if (v.length > 0) {
            const w = (0, f.reflowLargerCreateNewLayout)(this.lines, v);
            (0, f.reflowLargerApplyNewLayout)(this.lines, w.layout), this._reflowLargerAdjustViewport(b, _, w.countRemoved);
          }
        }
        _reflowLargerAdjustViewport(b, _, v) {
          const w = this.getNullCell(d.DEFAULT_ATTR_DATA);
          let E = v;
          for (; E-- > 0; ) this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < _ && this.lines.push(new d.BufferLine(b, w))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
          this.savedY = Math.max(this.savedY - v, 0);
        }
        _reflowSmaller(b, _) {
          const v = this.getNullCell(d.DEFAULT_ATTR_DATA), w = [];
          let E = 0;
          for (let x = this.lines.length - 1; x >= 0; x--) {
            let S = this.lines.get(x);
            if (!S || !S.isWrapped && S.getTrimmedLength() <= b) continue;
            const T = [S];
            for (; S.isWrapped && x > 0; ) S = this.lines.get(--x), T.unshift(S);
            const R = this.ybase + this.y;
            if (R >= x && R < x + T.length) continue;
            const F = T[T.length - 1].getTrimmedLength(), P = (0, f.reflowSmallerGetNewLineLengths)(T, this._cols, b), M = P.length - T.length;
            let A;
            A = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + M) : Math.max(0, this.lines.length - this.lines.maxLength + M);
            const V = [];
            for (let j = 0; j < M; j++) {
              const H = this.getBlankLine(d.DEFAULT_ATTR_DATA, !0);
              V.push(H);
            }
            V.length > 0 && (w.push({ start: x + T.length + E, newLines: V }), E += V.length), T.push(...V);
            let ee = P.length - 1, K = P[ee];
            K === 0 && (ee--, K = P[ee]);
            let te = T.length - M - 1, N = F;
            for (; te >= 0; ) {
              const j = Math.min(N, K);
              if (T[ee] === void 0) break;
              if (T[ee].copyCellsFrom(T[te], N - j, K - j, j, !0), K -= j, K === 0 && (ee--, K = P[ee]), N -= j, N === 0) {
                te--;
                const H = Math.max(te, 0);
                N = (0, f.getWrappedLineTrimmedLength)(T, H, this._cols);
              }
            }
            for (let j = 0; j < T.length; j++) P[j] < b && T[j].setCell(P[j], v);
            let L = M - A;
            for (; L-- > 0; ) this.ybase === 0 ? this.y < _ - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + E) - _ && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
            this.savedY = Math.min(this.savedY + M, this.ybase + _ - 1);
          }
          if (w.length > 0) {
            const x = [], S = [];
            for (let ee = 0; ee < this.lines.length; ee++) S.push(this.lines.get(ee));
            const T = this.lines.length;
            let R = T - 1, F = 0, P = w[F];
            this.lines.length = Math.min(this.lines.maxLength, this.lines.length + E);
            let M = 0;
            for (let ee = Math.min(this.lines.maxLength - 1, T + E - 1); ee >= 0; ee--) if (P && P.start > R + M) {
              for (let K = P.newLines.length - 1; K >= 0; K--) this.lines.set(ee--, P.newLines[K]);
              ee++, x.push({ index: R + 1, amount: P.newLines.length }), M += P.newLines.length, P = w[++F];
            } else this.lines.set(ee, S[R--]);
            let A = 0;
            for (let ee = x.length - 1; ee >= 0; ee--) x[ee].index += A, this.lines.onInsertEmitter.fire(x[ee]), A += x[ee].amount;
            const V = Math.max(0, T + E - this.lines.maxLength);
            V > 0 && this.lines.onTrimEmitter.fire(V);
          }
        }
        translateBufferLineToString(b, _, v = 0, w) {
          const E = this.lines.get(b);
          return E ? E.translateToString(_, v, w) : "";
        }
        getWrappedRangeForLine(b) {
          let _ = b, v = b;
          for (; _ > 0 && this.lines.get(_).isWrapped; ) _--;
          for (; v + 1 < this.lines.length && this.lines.get(v + 1).isWrapped; ) v++;
          return { first: _, last: v };
        }
        setupTabStops(b) {
          for (b != null ? this.tabs[b] || (b = this.prevStop(b)) : (this.tabs = {}, b = 0); b < this._cols; b += this._optionsService.rawOptions.tabStopWidth) this.tabs[b] = !0;
        }
        prevStop(b) {
          for (b == null && (b = this.x); !this.tabs[--b] && b > 0; ) ;
          return b >= this._cols ? this._cols - 1 : b < 0 ? 0 : b;
        }
        nextStop(b) {
          for (b == null && (b = this.x); !this.tabs[++b] && b < this._cols; ) ;
          return b >= this._cols ? this._cols - 1 : b < 0 ? 0 : b;
        }
        clearMarkers(b) {
          this._isClearing = !0;
          for (let _ = 0; _ < this.markers.length; _++) this.markers[_].line === b && (this.markers[_].dispose(), this.markers.splice(_--, 1));
          this._isClearing = !1;
        }
        clearAllMarkers() {
          this._isClearing = !0;
          for (let b = 0; b < this.markers.length; b++) this.markers[b].dispose(), this.markers.splice(b--, 1);
          this._isClearing = !1;
        }
        addMarker(b) {
          const _ = new p.Marker(b);
          return this.markers.push(_), _.register(this.lines.onTrim((v) => {
            _.line -= v, _.line < 0 && _.dispose();
          })), _.register(this.lines.onInsert((v) => {
            _.line >= v.index && (_.line += v.amount);
          })), _.register(this.lines.onDelete((v) => {
            _.line >= v.index && _.line < v.index + v.amount && _.dispose(), _.line > v.index && (_.line -= v.amount);
          })), _.register(_.onDispose(() => this._removeMarker(_))), _;
        }
        _removeMarker(b) {
          this._isClearing || this.markers.splice(this.markers.indexOf(b), 1);
        }
      };
    }, 8437: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferLine = a.DEFAULT_ATTR_DATA = void 0;
      const c = l(3734), u = l(511), h = l(643), d = l(482);
      a.DEFAULT_ATTR_DATA = Object.freeze(new c.AttributeData());
      let f = 0;
      class g {
        constructor(p, m, b = !1) {
          this.isWrapped = b, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * p);
          const _ = m || u.CellData.fromCharData([0, h.NULL_CELL_CHAR, h.NULL_CELL_WIDTH, h.NULL_CELL_CODE]);
          for (let v = 0; v < p; ++v) this.setCell(v, _);
          this.length = p;
        }
        get(p) {
          const m = this._data[3 * p + 0], b = 2097151 & m;
          return [this._data[3 * p + 1], 2097152 & m ? this._combined[p] : b ? (0, d.stringFromCodePoint)(b) : "", m >> 22, 2097152 & m ? this._combined[p].charCodeAt(this._combined[p].length - 1) : b];
        }
        set(p, m) {
          this._data[3 * p + 1] = m[h.CHAR_DATA_ATTR_INDEX], m[h.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[p] = m[1], this._data[3 * p + 0] = 2097152 | p | m[h.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * p + 0] = m[h.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | m[h.CHAR_DATA_WIDTH_INDEX] << 22;
        }
        getWidth(p) {
          return this._data[3 * p + 0] >> 22;
        }
        hasWidth(p) {
          return 12582912 & this._data[3 * p + 0];
        }
        getFg(p) {
          return this._data[3 * p + 1];
        }
        getBg(p) {
          return this._data[3 * p + 2];
        }
        hasContent(p) {
          return 4194303 & this._data[3 * p + 0];
        }
        getCodePoint(p) {
          const m = this._data[3 * p + 0];
          return 2097152 & m ? this._combined[p].charCodeAt(this._combined[p].length - 1) : 2097151 & m;
        }
        isCombined(p) {
          return 2097152 & this._data[3 * p + 0];
        }
        getString(p) {
          const m = this._data[3 * p + 0];
          return 2097152 & m ? this._combined[p] : 2097151 & m ? (0, d.stringFromCodePoint)(2097151 & m) : "";
        }
        isProtected(p) {
          return 536870912 & this._data[3 * p + 2];
        }
        loadCell(p, m) {
          return f = 3 * p, m.content = this._data[f + 0], m.fg = this._data[f + 1], m.bg = this._data[f + 2], 2097152 & m.content && (m.combinedData = this._combined[p]), 268435456 & m.bg && (m.extended = this._extendedAttrs[p]), m;
        }
        setCell(p, m) {
          2097152 & m.content && (this._combined[p] = m.combinedData), 268435456 & m.bg && (this._extendedAttrs[p] = m.extended), this._data[3 * p + 0] = m.content, this._data[3 * p + 1] = m.fg, this._data[3 * p + 2] = m.bg;
        }
        setCellFromCodepoint(p, m, b, _) {
          268435456 & _.bg && (this._extendedAttrs[p] = _.extended), this._data[3 * p + 0] = m | b << 22, this._data[3 * p + 1] = _.fg, this._data[3 * p + 2] = _.bg;
        }
        addCodepointToCell(p, m, b) {
          let _ = this._data[3 * p + 0];
          2097152 & _ ? this._combined[p] += (0, d.stringFromCodePoint)(m) : 2097151 & _ ? (this._combined[p] = (0, d.stringFromCodePoint)(2097151 & _) + (0, d.stringFromCodePoint)(m), _ &= -2097152, _ |= 2097152) : _ = m | 4194304, b && (_ &= -12582913, _ |= b << 22), this._data[3 * p + 0] = _;
        }
        insertCells(p, m, b) {
          if ((p %= this.length) && this.getWidth(p - 1) === 2 && this.setCellFromCodepoint(p - 1, 0, 1, b), m < this.length - p) {
            const _ = new u.CellData();
            for (let v = this.length - p - m - 1; v >= 0; --v) this.setCell(p + m + v, this.loadCell(p + v, _));
            for (let v = 0; v < m; ++v) this.setCell(p + v, b);
          } else for (let _ = p; _ < this.length; ++_) this.setCell(_, b);
          this.getWidth(this.length - 1) === 2 && this.setCellFromCodepoint(this.length - 1, 0, 1, b);
        }
        deleteCells(p, m, b) {
          if (p %= this.length, m < this.length - p) {
            const _ = new u.CellData();
            for (let v = 0; v < this.length - p - m; ++v) this.setCell(p + v, this.loadCell(p + m + v, _));
            for (let v = this.length - m; v < this.length; ++v) this.setCell(v, b);
          } else for (let _ = p; _ < this.length; ++_) this.setCell(_, b);
          p && this.getWidth(p - 1) === 2 && this.setCellFromCodepoint(p - 1, 0, 1, b), this.getWidth(p) !== 0 || this.hasContent(p) || this.setCellFromCodepoint(p, 0, 1, b);
        }
        replaceCells(p, m, b, _ = !1) {
          if (_) for (p && this.getWidth(p - 1) === 2 && !this.isProtected(p - 1) && this.setCellFromCodepoint(p - 1, 0, 1, b), m < this.length && this.getWidth(m - 1) === 2 && !this.isProtected(m) && this.setCellFromCodepoint(m, 0, 1, b); p < m && p < this.length; ) this.isProtected(p) || this.setCell(p, b), p++;
          else for (p && this.getWidth(p - 1) === 2 && this.setCellFromCodepoint(p - 1, 0, 1, b), m < this.length && this.getWidth(m - 1) === 2 && this.setCellFromCodepoint(m, 0, 1, b); p < m && p < this.length; ) this.setCell(p++, b);
        }
        resize(p, m) {
          if (p === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
          const b = 3 * p;
          if (p > this.length) {
            if (this._data.buffer.byteLength >= 4 * b) this._data = new Uint32Array(this._data.buffer, 0, b);
            else {
              const _ = new Uint32Array(b);
              _.set(this._data), this._data = _;
            }
            for (let _ = this.length; _ < p; ++_) this.setCell(_, m);
          } else {
            this._data = this._data.subarray(0, b);
            const _ = Object.keys(this._combined);
            for (let w = 0; w < _.length; w++) {
              const E = parseInt(_[w], 10);
              E >= p && delete this._combined[E];
            }
            const v = Object.keys(this._extendedAttrs);
            for (let w = 0; w < v.length; w++) {
              const E = parseInt(v[w], 10);
              E >= p && delete this._extendedAttrs[E];
            }
          }
          return this.length = p, 4 * b * 2 < this._data.buffer.byteLength;
        }
        cleanupMemory() {
          if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
            const p = new Uint32Array(this._data.length);
            return p.set(this._data), this._data = p, 1;
          }
          return 0;
        }
        fill(p, m = !1) {
          if (m) for (let b = 0; b < this.length; ++b) this.isProtected(b) || this.setCell(b, p);
          else {
            this._combined = {}, this._extendedAttrs = {};
            for (let b = 0; b < this.length; ++b) this.setCell(b, p);
          }
        }
        copyFrom(p) {
          this.length !== p.length ? this._data = new Uint32Array(p._data) : this._data.set(p._data), this.length = p.length, this._combined = {};
          for (const m in p._combined) this._combined[m] = p._combined[m];
          this._extendedAttrs = {};
          for (const m in p._extendedAttrs) this._extendedAttrs[m] = p._extendedAttrs[m];
          this.isWrapped = p.isWrapped;
        }
        clone() {
          const p = new g(0);
          p._data = new Uint32Array(this._data), p.length = this.length;
          for (const m in this._combined) p._combined[m] = this._combined[m];
          for (const m in this._extendedAttrs) p._extendedAttrs[m] = this._extendedAttrs[m];
          return p.isWrapped = this.isWrapped, p;
        }
        getTrimmedLength() {
          for (let p = this.length - 1; p >= 0; --p) if (4194303 & this._data[3 * p + 0]) return p + (this._data[3 * p + 0] >> 22);
          return 0;
        }
        getNoBgTrimmedLength() {
          for (let p = this.length - 1; p >= 0; --p) if (4194303 & this._data[3 * p + 0] || 50331648 & this._data[3 * p + 2]) return p + (this._data[3 * p + 0] >> 22);
          return 0;
        }
        copyCellsFrom(p, m, b, _, v) {
          const w = p._data;
          if (v) for (let x = _ - 1; x >= 0; x--) {
            for (let S = 0; S < 3; S++) this._data[3 * (b + x) + S] = w[3 * (m + x) + S];
            268435456 & w[3 * (m + x) + 2] && (this._extendedAttrs[b + x] = p._extendedAttrs[m + x]);
          }
          else for (let x = 0; x < _; x++) {
            for (let S = 0; S < 3; S++) this._data[3 * (b + x) + S] = w[3 * (m + x) + S];
            268435456 & w[3 * (m + x) + 2] && (this._extendedAttrs[b + x] = p._extendedAttrs[m + x]);
          }
          const E = Object.keys(p._combined);
          for (let x = 0; x < E.length; x++) {
            const S = parseInt(E[x], 10);
            S >= m && (this._combined[S - m + b] = p._combined[S]);
          }
        }
        translateToString(p, m, b, _) {
          m = m ?? 0, b = b ?? this.length, p && (b = Math.min(b, this.getTrimmedLength())), _ && (_.length = 0);
          let v = "";
          for (; m < b; ) {
            const w = this._data[3 * m + 0], E = 2097151 & w, x = 2097152 & w ? this._combined[m] : E ? (0, d.stringFromCodePoint)(E) : h.WHITESPACE_CELL_CHAR;
            if (v += x, _) for (let S = 0; S < x.length; ++S) _.push(m);
            m += w >> 22 || 1;
          }
          return _ && _.push(m), v;
        }
      }
      a.BufferLine = g;
    }, 4841: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getRangeLength = void 0, a.getRangeLength = function(l, c) {
        if (l.start.y > l.end.y) throw new Error(`Buffer range end (${l.end.x}, ${l.end.y}) cannot be before start (${l.start.x}, ${l.start.y})`);
        return c * (l.end.y - l.start.y) + (l.end.x - l.start.x + 1);
      };
    }, 4634: (o, a) => {
      function l(c, u, h) {
        if (u === c.length - 1) return c[u].getTrimmedLength();
        const d = !c[u].hasContent(h - 1) && c[u].getWidth(h - 1) === 1, f = c[u + 1].getWidth(0) === 2;
        return d && f ? h - 1 : h;
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getWrappedLineTrimmedLength = a.reflowSmallerGetNewLineLengths = a.reflowLargerApplyNewLayout = a.reflowLargerCreateNewLayout = a.reflowLargerGetLinesToRemove = void 0, a.reflowLargerGetLinesToRemove = function(c, u, h, d, f) {
        const g = [];
        for (let y = 0; y < c.length - 1; y++) {
          let p = y, m = c.get(++p);
          if (!m.isWrapped) continue;
          const b = [c.get(y)];
          for (; p < c.length && m.isWrapped; ) b.push(m), m = c.get(++p);
          if (d >= y && d < p) {
            y += b.length - 1;
            continue;
          }
          let _ = 0, v = l(b, _, u), w = 1, E = 0;
          for (; w < b.length; ) {
            const S = l(b, w, u), T = S - E, R = h - v, F = Math.min(T, R);
            b[_].copyCellsFrom(b[w], E, v, F, !1), v += F, v === h && (_++, v = 0), E += F, E === S && (w++, E = 0), v === 0 && _ !== 0 && b[_ - 1].getWidth(h - 1) === 2 && (b[_].copyCellsFrom(b[_ - 1], h - 1, v++, 1, !1), b[_ - 1].setCell(h - 1, f));
          }
          b[_].replaceCells(v, h, f);
          let x = 0;
          for (let S = b.length - 1; S > 0 && (S > _ || b[S].getTrimmedLength() === 0); S--) x++;
          x > 0 && (g.push(y + b.length - x), g.push(x)), y += b.length - 1;
        }
        return g;
      }, a.reflowLargerCreateNewLayout = function(c, u) {
        const h = [];
        let d = 0, f = u[d], g = 0;
        for (let y = 0; y < c.length; y++) if (f === y) {
          const p = u[++d];
          c.onDeleteEmitter.fire({ index: y - g, amount: p }), y += p - 1, g += p, f = u[++d];
        } else h.push(y);
        return { layout: h, countRemoved: g };
      }, a.reflowLargerApplyNewLayout = function(c, u) {
        const h = [];
        for (let d = 0; d < u.length; d++) h.push(c.get(u[d]));
        for (let d = 0; d < h.length; d++) c.set(d, h[d]);
        c.length = u.length;
      }, a.reflowSmallerGetNewLineLengths = function(c, u, h) {
        const d = [], f = c.map((m, b) => l(c, b, u)).reduce((m, b) => m + b);
        let g = 0, y = 0, p = 0;
        for (; p < f; ) {
          if (f - p < h) {
            d.push(f - p);
            break;
          }
          g += h;
          const m = l(c, y, u);
          g > m && (g -= m, y++);
          const b = c[y].getWidth(g - 1) === 2;
          b && g--;
          const _ = b ? h - 1 : h;
          d.push(_), p += _;
        }
        return d;
      }, a.getWrappedLineTrimmedLength = l;
    }, 5295: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferSet = void 0;
      const c = l(8460), u = l(844), h = l(9092);
      class d extends u.Disposable {
        constructor(g, y) {
          super(), this._optionsService = g, this._bufferService = y, this._onBufferActivate = this.register(new c.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
        }
        reset() {
          this._normal = new h.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new h.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
        }
        get alt() {
          return this._alt;
        }
        get active() {
          return this._activeBuffer;
        }
        get normal() {
          return this._normal;
        }
        activateNormalBuffer() {
          this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
        }
        activateAltBuffer(g) {
          this._activeBuffer !== this._alt && (this._alt.fillViewportRows(g), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
        }
        resize(g, y) {
          this._normal.resize(g, y), this._alt.resize(g, y), this.setupTabStops(g);
        }
        setupTabStops(g) {
          this._normal.setupTabStops(g), this._alt.setupTabStops(g);
        }
      }
      a.BufferSet = d;
    }, 511: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CellData = void 0;
      const c = l(482), u = l(643), h = l(3734);
      class d extends h.AttributeData {
        constructor() {
          super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new h.ExtendedAttrs(), this.combinedData = "";
        }
        static fromCharData(g) {
          const y = new d();
          return y.setFromCharData(g), y;
        }
        isCombined() {
          return 2097152 & this.content;
        }
        getWidth() {
          return this.content >> 22;
        }
        getChars() {
          return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, c.stringFromCodePoint)(2097151 & this.content) : "";
        }
        getCode() {
          return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
        }
        setFromCharData(g) {
          this.fg = g[u.CHAR_DATA_ATTR_INDEX], this.bg = 0;
          let y = !1;
          if (g[u.CHAR_DATA_CHAR_INDEX].length > 2) y = !0;
          else if (g[u.CHAR_DATA_CHAR_INDEX].length === 2) {
            const p = g[u.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
            if (55296 <= p && p <= 56319) {
              const m = g[u.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
              56320 <= m && m <= 57343 ? this.content = 1024 * (p - 55296) + m - 56320 + 65536 | g[u.CHAR_DATA_WIDTH_INDEX] << 22 : y = !0;
            } else y = !0;
          } else this.content = g[u.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | g[u.CHAR_DATA_WIDTH_INDEX] << 22;
          y && (this.combinedData = g[u.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | g[u.CHAR_DATA_WIDTH_INDEX] << 22);
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      a.CellData = d;
    }, 643: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.WHITESPACE_CELL_CODE = a.WHITESPACE_CELL_WIDTH = a.WHITESPACE_CELL_CHAR = a.NULL_CELL_CODE = a.NULL_CELL_WIDTH = a.NULL_CELL_CHAR = a.CHAR_DATA_CODE_INDEX = a.CHAR_DATA_WIDTH_INDEX = a.CHAR_DATA_CHAR_INDEX = a.CHAR_DATA_ATTR_INDEX = a.DEFAULT_EXT = a.DEFAULT_ATTR = a.DEFAULT_COLOR = void 0, a.DEFAULT_COLOR = 0, a.DEFAULT_ATTR = 256 | a.DEFAULT_COLOR << 9, a.DEFAULT_EXT = 0, a.CHAR_DATA_ATTR_INDEX = 0, a.CHAR_DATA_CHAR_INDEX = 1, a.CHAR_DATA_WIDTH_INDEX = 2, a.CHAR_DATA_CODE_INDEX = 3, a.NULL_CELL_CHAR = "", a.NULL_CELL_WIDTH = 1, a.NULL_CELL_CODE = 0, a.WHITESPACE_CELL_CHAR = " ", a.WHITESPACE_CELL_WIDTH = 1, a.WHITESPACE_CELL_CODE = 32;
    }, 4863: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Marker = void 0;
      const c = l(8460), u = l(844);
      class h {
        get id() {
          return this._id;
        }
        constructor(f) {
          this.line = f, this.isDisposed = !1, this._disposables = [], this._id = h._nextId++, this._onDispose = this.register(new c.EventEmitter()), this.onDispose = this._onDispose.event;
        }
        dispose() {
          this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), (0, u.disposeArray)(this._disposables), this._disposables.length = 0);
        }
        register(f) {
          return this._disposables.push(f), f;
        }
      }
      a.Marker = h, h._nextId = 1;
    }, 7116: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DEFAULT_CHARSET = a.CHARSETS = void 0, a.CHARSETS = {}, a.DEFAULT_CHARSET = a.CHARSETS.B, a.CHARSETS[0] = { "`": "", a: "", b: "", c: "", d: "", e: "", f: "", g: "", h: "", i: "", j: "", k: "", l: "", m: "", n: "", o: "", p: "", q: "", r: "", s: "", t: "", u: "", v: "", w: "", x: "", y: "", z: "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.A = { "#": "" }, a.CHARSETS.B = void 0, a.CHARSETS[4] = { "#": "", "@": "", "[": "ij", "\\": "", "]": "|", "{": "", "|": "f", "}": "", "~": "" }, a.CHARSETS.C = a.CHARSETS[5] = { "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.R = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Q = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.K = { "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Y = { "#": "", "@": "", "[": "", "\\": "", "]": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.E = a.CHARSETS[6] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Z = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "" }, a.CHARSETS.H = a.CHARSETS[7] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS["="] = { "#": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "" };
    }, 2584: (o, a) => {
      var l, c, u;
      Object.defineProperty(a, "__esModule", { value: !0 }), a.C1_ESCAPED = a.C1 = a.C0 = void 0, function(h) {
        h.NUL = "\0", h.SOH = "", h.STX = "", h.ETX = "", h.EOT = "", h.ENQ = "", h.ACK = "", h.BEL = "\x07", h.BS = "\b", h.HT = "	", h.LF = `
`, h.VT = "\v", h.FF = "\f", h.CR = "\r", h.SO = "", h.SI = "", h.DLE = "", h.DC1 = "", h.DC2 = "", h.DC3 = "", h.DC4 = "", h.NAK = "", h.SYN = "", h.ETB = "", h.CAN = "", h.EM = "", h.SUB = "", h.ESC = "\x1B", h.FS = "", h.GS = "", h.RS = "", h.US = "", h.SP = " ", h.DEL = "";
      }(l || (a.C0 = l = {})), function(h) {
        h.PAD = "", h.HOP = "", h.BPH = "", h.NBH = "", h.IND = "", h.NEL = "", h.SSA = "", h.ESA = "", h.HTS = "", h.HTJ = "", h.VTS = "", h.PLD = "", h.PLU = "", h.RI = "", h.SS2 = "", h.SS3 = "", h.DCS = "", h.PU1 = "", h.PU2 = "", h.STS = "", h.CCH = "", h.MW = "", h.SPA = "", h.EPA = "", h.SOS = "", h.SGCI = "", h.SCI = "", h.CSI = "", h.ST = "", h.OSC = "", h.PM = "", h.APC = "";
      }(c || (a.C1 = c = {})), function(h) {
        h.ST = `${l.ESC}\\`;
      }(u || (a.C1_ESCAPED = u = {}));
    }, 7399: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.evaluateKeyboardEvent = void 0;
      const c = l(2584), u = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
      a.evaluateKeyboardEvent = function(h, d, f, g) {
        const y = { type: 0, cancel: !1, key: void 0 }, p = (h.shiftKey ? 1 : 0) | (h.altKey ? 2 : 0) | (h.ctrlKey ? 4 : 0) | (h.metaKey ? 8 : 0);
        switch (h.keyCode) {
          case 0:
            h.key === "UIKeyInputUpArrow" ? y.key = d ? c.C0.ESC + "OA" : c.C0.ESC + "[A" : h.key === "UIKeyInputLeftArrow" ? y.key = d ? c.C0.ESC + "OD" : c.C0.ESC + "[D" : h.key === "UIKeyInputRightArrow" ? y.key = d ? c.C0.ESC + "OC" : c.C0.ESC + "[C" : h.key === "UIKeyInputDownArrow" && (y.key = d ? c.C0.ESC + "OB" : c.C0.ESC + "[B");
            break;
          case 8:
            y.key = h.ctrlKey ? "\b" : c.C0.DEL, h.altKey && (y.key = c.C0.ESC + y.key);
            break;
          case 9:
            if (h.shiftKey) {
              y.key = c.C0.ESC + "[Z";
              break;
            }
            y.key = c.C0.HT, y.cancel = !0;
            break;
          case 13:
            y.key = h.altKey ? c.C0.ESC + c.C0.CR : c.C0.CR, y.cancel = !0;
            break;
          case 27:
            y.key = c.C0.ESC, h.altKey && (y.key = c.C0.ESC + c.C0.ESC), y.cancel = !0;
            break;
          case 37:
            if (h.metaKey) break;
            p ? (y.key = c.C0.ESC + "[1;" + (p + 1) + "D", y.key === c.C0.ESC + "[1;3D" && (y.key = c.C0.ESC + (f ? "b" : "[1;5D"))) : y.key = d ? c.C0.ESC + "OD" : c.C0.ESC + "[D";
            break;
          case 39:
            if (h.metaKey) break;
            p ? (y.key = c.C0.ESC + "[1;" + (p + 1) + "C", y.key === c.C0.ESC + "[1;3C" && (y.key = c.C0.ESC + (f ? "f" : "[1;5C"))) : y.key = d ? c.C0.ESC + "OC" : c.C0.ESC + "[C";
            break;
          case 38:
            if (h.metaKey) break;
            p ? (y.key = c.C0.ESC + "[1;" + (p + 1) + "A", f || y.key !== c.C0.ESC + "[1;3A" || (y.key = c.C0.ESC + "[1;5A")) : y.key = d ? c.C0.ESC + "OA" : c.C0.ESC + "[A";
            break;
          case 40:
            if (h.metaKey) break;
            p ? (y.key = c.C0.ESC + "[1;" + (p + 1) + "B", f || y.key !== c.C0.ESC + "[1;3B" || (y.key = c.C0.ESC + "[1;5B")) : y.key = d ? c.C0.ESC + "OB" : c.C0.ESC + "[B";
            break;
          case 45:
            h.shiftKey || h.ctrlKey || (y.key = c.C0.ESC + "[2~");
            break;
          case 46:
            y.key = p ? c.C0.ESC + "[3;" + (p + 1) + "~" : c.C0.ESC + "[3~";
            break;
          case 36:
            y.key = p ? c.C0.ESC + "[1;" + (p + 1) + "H" : d ? c.C0.ESC + "OH" : c.C0.ESC + "[H";
            break;
          case 35:
            y.key = p ? c.C0.ESC + "[1;" + (p + 1) + "F" : d ? c.C0.ESC + "OF" : c.C0.ESC + "[F";
            break;
          case 33:
            h.shiftKey ? y.type = 2 : h.ctrlKey ? y.key = c.C0.ESC + "[5;" + (p + 1) + "~" : y.key = c.C0.ESC + "[5~";
            break;
          case 34:
            h.shiftKey ? y.type = 3 : h.ctrlKey ? y.key = c.C0.ESC + "[6;" + (p + 1) + "~" : y.key = c.C0.ESC + "[6~";
            break;
          case 112:
            y.key = p ? c.C0.ESC + "[1;" + (p + 1) + "P" : c.C0.ESC + "OP";
            break;
          case 113:
            y.key = p ? c.C0.ESC + "[1;" + (p + 1) + "Q" : c.C0.ESC + "OQ";
            break;
          case 114:
            y.key = p ? c.C0.ESC + "[1;" + (p + 1) + "R" : c.C0.ESC + "OR";
            break;
          case 115:
            y.key = p ? c.C0.ESC + "[1;" + (p + 1) + "S" : c.C0.ESC + "OS";
            break;
          case 116:
            y.key = p ? c.C0.ESC + "[15;" + (p + 1) + "~" : c.C0.ESC + "[15~";
            break;
          case 117:
            y.key = p ? c.C0.ESC + "[17;" + (p + 1) + "~" : c.C0.ESC + "[17~";
            break;
          case 118:
            y.key = p ? c.C0.ESC + "[18;" + (p + 1) + "~" : c.C0.ESC + "[18~";
            break;
          case 119:
            y.key = p ? c.C0.ESC + "[19;" + (p + 1) + "~" : c.C0.ESC + "[19~";
            break;
          case 120:
            y.key = p ? c.C0.ESC + "[20;" + (p + 1) + "~" : c.C0.ESC + "[20~";
            break;
          case 121:
            y.key = p ? c.C0.ESC + "[21;" + (p + 1) + "~" : c.C0.ESC + "[21~";
            break;
          case 122:
            y.key = p ? c.C0.ESC + "[23;" + (p + 1) + "~" : c.C0.ESC + "[23~";
            break;
          case 123:
            y.key = p ? c.C0.ESC + "[24;" + (p + 1) + "~" : c.C0.ESC + "[24~";
            break;
          default:
            if (!h.ctrlKey || h.shiftKey || h.altKey || h.metaKey) if (f && !g || !h.altKey || h.metaKey) !f || h.altKey || h.ctrlKey || h.shiftKey || !h.metaKey ? h.key && !h.ctrlKey && !h.altKey && !h.metaKey && h.keyCode >= 48 && h.key.length === 1 ? y.key = h.key : h.key && h.ctrlKey && (h.key === "_" && (y.key = c.C0.US), h.key === "@" && (y.key = c.C0.NUL)) : h.keyCode === 65 && (y.type = 1);
            else {
              const m = u[h.keyCode], b = m?.[h.shiftKey ? 1 : 0];
              if (b) y.key = c.C0.ESC + b;
              else if (h.keyCode >= 65 && h.keyCode <= 90) {
                const _ = h.ctrlKey ? h.keyCode - 64 : h.keyCode + 32;
                let v = String.fromCharCode(_);
                h.shiftKey && (v = v.toUpperCase()), y.key = c.C0.ESC + v;
              } else if (h.keyCode === 32) y.key = c.C0.ESC + (h.ctrlKey ? c.C0.NUL : " ");
              else if (h.key === "Dead" && h.code.startsWith("Key")) {
                let _ = h.code.slice(3, 4);
                h.shiftKey || (_ = _.toLowerCase()), y.key = c.C0.ESC + _, y.cancel = !0;
              }
            }
            else h.keyCode >= 65 && h.keyCode <= 90 ? y.key = String.fromCharCode(h.keyCode - 64) : h.keyCode === 32 ? y.key = c.C0.NUL : h.keyCode >= 51 && h.keyCode <= 55 ? y.key = String.fromCharCode(h.keyCode - 51 + 27) : h.keyCode === 56 ? y.key = c.C0.DEL : h.keyCode === 219 ? y.key = c.C0.ESC : h.keyCode === 220 ? y.key = c.C0.FS : h.keyCode === 221 && (y.key = c.C0.GS);
        }
        return y;
      };
    }, 482: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Utf8ToUtf32 = a.StringToUtf32 = a.utf32ToString = a.stringFromCodePoint = void 0, a.stringFromCodePoint = function(l) {
        return l > 65535 ? (l -= 65536, String.fromCharCode(55296 + (l >> 10)) + String.fromCharCode(l % 1024 + 56320)) : String.fromCharCode(l);
      }, a.utf32ToString = function(l, c = 0, u = l.length) {
        let h = "";
        for (let d = c; d < u; ++d) {
          let f = l[d];
          f > 65535 ? (f -= 65536, h += String.fromCharCode(55296 + (f >> 10)) + String.fromCharCode(f % 1024 + 56320)) : h += String.fromCharCode(f);
        }
        return h;
      }, a.StringToUtf32 = class {
        constructor() {
          this._interim = 0;
        }
        clear() {
          this._interim = 0;
        }
        decode(l, c) {
          const u = l.length;
          if (!u) return 0;
          let h = 0, d = 0;
          if (this._interim) {
            const f = l.charCodeAt(d++);
            56320 <= f && f <= 57343 ? c[h++] = 1024 * (this._interim - 55296) + f - 56320 + 65536 : (c[h++] = this._interim, c[h++] = f), this._interim = 0;
          }
          for (let f = d; f < u; ++f) {
            const g = l.charCodeAt(f);
            if (55296 <= g && g <= 56319) {
              if (++f >= u) return this._interim = g, h;
              const y = l.charCodeAt(f);
              56320 <= y && y <= 57343 ? c[h++] = 1024 * (g - 55296) + y - 56320 + 65536 : (c[h++] = g, c[h++] = y);
            } else g !== 65279 && (c[h++] = g);
          }
          return h;
        }
      }, a.Utf8ToUtf32 = class {
        constructor() {
          this.interim = new Uint8Array(3);
        }
        clear() {
          this.interim.fill(0);
        }
        decode(l, c) {
          const u = l.length;
          if (!u) return 0;
          let h, d, f, g, y = 0, p = 0, m = 0;
          if (this.interim[0]) {
            let v = !1, w = this.interim[0];
            w &= (224 & w) == 192 ? 31 : (240 & w) == 224 ? 15 : 7;
            let E, x = 0;
            for (; (E = 63 & this.interim[++x]) && x < 4; ) w <<= 6, w |= E;
            const S = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, T = S - x;
            for (; m < T; ) {
              if (m >= u) return 0;
              if (E = l[m++], (192 & E) != 128) {
                m--, v = !0;
                break;
              }
              this.interim[x++] = E, w <<= 6, w |= 63 & E;
            }
            v || (S === 2 ? w < 128 ? m-- : c[y++] = w : S === 3 ? w < 2048 || w >= 55296 && w <= 57343 || w === 65279 || (c[y++] = w) : w < 65536 || w > 1114111 || (c[y++] = w)), this.interim.fill(0);
          }
          const b = u - 4;
          let _ = m;
          for (; _ < u; ) {
            for (; !(!(_ < b) || 128 & (h = l[_]) || 128 & (d = l[_ + 1]) || 128 & (f = l[_ + 2]) || 128 & (g = l[_ + 3])); ) c[y++] = h, c[y++] = d, c[y++] = f, c[y++] = g, _ += 4;
            if (h = l[_++], h < 128) c[y++] = h;
            else if ((224 & h) == 192) {
              if (_ >= u) return this.interim[0] = h, y;
              if (d = l[_++], (192 & d) != 128) {
                _--;
                continue;
              }
              if (p = (31 & h) << 6 | 63 & d, p < 128) {
                _--;
                continue;
              }
              c[y++] = p;
            } else if ((240 & h) == 224) {
              if (_ >= u) return this.interim[0] = h, y;
              if (d = l[_++], (192 & d) != 128) {
                _--;
                continue;
              }
              if (_ >= u) return this.interim[0] = h, this.interim[1] = d, y;
              if (f = l[_++], (192 & f) != 128) {
                _--;
                continue;
              }
              if (p = (15 & h) << 12 | (63 & d) << 6 | 63 & f, p < 2048 || p >= 55296 && p <= 57343 || p === 65279) continue;
              c[y++] = p;
            } else if ((248 & h) == 240) {
              if (_ >= u) return this.interim[0] = h, y;
              if (d = l[_++], (192 & d) != 128) {
                _--;
                continue;
              }
              if (_ >= u) return this.interim[0] = h, this.interim[1] = d, y;
              if (f = l[_++], (192 & f) != 128) {
                _--;
                continue;
              }
              if (_ >= u) return this.interim[0] = h, this.interim[1] = d, this.interim[2] = f, y;
              if (g = l[_++], (192 & g) != 128) {
                _--;
                continue;
              }
              if (p = (7 & h) << 18 | (63 & d) << 12 | (63 & f) << 6 | 63 & g, p < 65536 || p > 1114111) continue;
              c[y++] = p;
            }
          }
          return y;
        }
      };
    }, 225: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeV6 = void 0;
      const c = l(1480), u = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], h = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
      let d;
      a.UnicodeV6 = class {
        constructor() {
          if (this.version = "6", !d) {
            d = new Uint8Array(65536), d.fill(1), d[0] = 0, d.fill(0, 1, 32), d.fill(0, 127, 160), d.fill(2, 4352, 4448), d[9001] = 2, d[9002] = 2, d.fill(2, 11904, 42192), d[12351] = 1, d.fill(2, 44032, 55204), d.fill(2, 63744, 64256), d.fill(2, 65040, 65050), d.fill(2, 65072, 65136), d.fill(2, 65280, 65377), d.fill(2, 65504, 65511);
            for (let f = 0; f < u.length; ++f) d.fill(0, u[f][0], u[f][1] + 1);
          }
        }
        wcwidth(f) {
          return f < 32 ? 0 : f < 127 ? 1 : f < 65536 ? d[f] : function(g, y) {
            let p, m = 0, b = y.length - 1;
            if (g < y[0][0] || g > y[b][1]) return !1;
            for (; b >= m; ) if (p = m + b >> 1, g > y[p][1]) m = p + 1;
            else {
              if (!(g < y[p][0])) return !0;
              b = p - 1;
            }
            return !1;
          }(f, h) ? 0 : f >= 131072 && f <= 196605 || f >= 196608 && f <= 262141 ? 2 : 1;
        }
        charProperties(f, g) {
          let y = this.wcwidth(f), p = y === 0 && g !== 0;
          if (p) {
            const m = c.UnicodeService.extractWidth(g);
            m === 0 ? p = !1 : m > y && (y = m);
          }
          return c.UnicodeService.createPropertyValue(0, y, p);
        }
      };
    }, 5981: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.WriteBuffer = void 0;
      const c = l(8460), u = l(844);
      class h extends u.Disposable {
        constructor(f) {
          super(), this._action = f, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._didUserInput = !1, this._onWriteParsed = this.register(new c.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
        }
        handleUserInput() {
          this._didUserInput = !0;
        }
        writeSync(f, g) {
          if (g !== void 0 && this._syncCalls > g) return void (this._syncCalls = 0);
          if (this._pendingData += f.length, this._writeBuffer.push(f), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
          let y;
          for (this._isSyncWriting = !0; y = this._writeBuffer.shift(); ) {
            this._action(y);
            const p = this._callbacks.shift();
            p && p();
          }
          this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0;
        }
        write(f, g) {
          if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
          if (!this._writeBuffer.length) {
            if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = !1, this._pendingData += f.length, this._writeBuffer.push(f), this._callbacks.push(g), void this._innerWrite();
            setTimeout(() => this._innerWrite());
          }
          this._pendingData += f.length, this._writeBuffer.push(f), this._callbacks.push(g);
        }
        _innerWrite(f = 0, g = !0) {
          const y = f || Date.now();
          for (; this._writeBuffer.length > this._bufferOffset; ) {
            const p = this._writeBuffer[this._bufferOffset], m = this._action(p, g);
            if (m) {
              const _ = (v) => Date.now() - y >= 12 ? setTimeout(() => this._innerWrite(0, v)) : this._innerWrite(y, v);
              return void m.catch((v) => (queueMicrotask(() => {
                throw v;
              }), Promise.resolve(!1))).then(_);
            }
            const b = this._callbacks[this._bufferOffset];
            if (b && b(), this._bufferOffset++, this._pendingData -= p.length, Date.now() - y >= 12) break;
          }
          this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
        }
      }
      a.WriteBuffer = h;
    }, 5941: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.toRgbString = a.parseColor = void 0;
      const l = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, c = /^[\da-f]+$/;
      function u(h, d) {
        const f = h.toString(16), g = f.length < 2 ? "0" + f : f;
        switch (d) {
          case 4:
            return f[0];
          case 8:
            return g;
          case 12:
            return (g + g).slice(0, 3);
          default:
            return g + g;
        }
      }
      a.parseColor = function(h) {
        if (!h) return;
        let d = h.toLowerCase();
        if (d.indexOf("rgb:") === 0) {
          d = d.slice(4);
          const f = l.exec(d);
          if (f) {
            const g = f[1] ? 15 : f[4] ? 255 : f[7] ? 4095 : 65535;
            return [Math.round(parseInt(f[1] || f[4] || f[7] || f[10], 16) / g * 255), Math.round(parseInt(f[2] || f[5] || f[8] || f[11], 16) / g * 255), Math.round(parseInt(f[3] || f[6] || f[9] || f[12], 16) / g * 255)];
          }
        } else if (d.indexOf("#") === 0 && (d = d.slice(1), c.exec(d) && [3, 6, 9, 12].includes(d.length))) {
          const f = d.length / 3, g = [0, 0, 0];
          for (let y = 0; y < 3; ++y) {
            const p = parseInt(d.slice(f * y, f * y + f), 16);
            g[y] = f === 1 ? p << 4 : f === 2 ? p : f === 3 ? p >> 4 : p >> 8;
          }
          return g;
        }
      }, a.toRgbString = function(h, d = 16) {
        const [f, g, y] = h;
        return `rgb:${u(f, d)}/${u(g, d)}/${u(y, d)}`;
      };
    }, 5770: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.PAYLOAD_LIMIT = void 0, a.PAYLOAD_LIMIT = 1e7;
    }, 6351: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DcsHandler = a.DcsParser = void 0;
      const c = l(482), u = l(8742), h = l(5770), d = [];
      a.DcsParser = class {
        constructor() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._active = d, this._ident = 0, this._handlerFb = () => {
          }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
        }
        dispose() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._active = d;
        }
        registerHandler(g, y) {
          this._handlers[g] === void 0 && (this._handlers[g] = []);
          const p = this._handlers[g];
          return p.push(y), { dispose: () => {
            const m = p.indexOf(y);
            m !== -1 && p.splice(m, 1);
          } };
        }
        clearHandler(g) {
          this._handlers[g] && delete this._handlers[g];
        }
        setHandlerFallback(g) {
          this._handlerFb = g;
        }
        reset() {
          if (this._active.length) for (let g = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; g >= 0; --g) this._active[g].unhook(!1);
          this._stack.paused = !1, this._active = d, this._ident = 0;
        }
        hook(g, y) {
          if (this.reset(), this._ident = g, this._active = this._handlers[g] || d, this._active.length) for (let p = this._active.length - 1; p >= 0; p--) this._active[p].hook(y);
          else this._handlerFb(this._ident, "HOOK", y);
        }
        put(g, y, p) {
          if (this._active.length) for (let m = this._active.length - 1; m >= 0; m--) this._active[m].put(g, y, p);
          else this._handlerFb(this._ident, "PUT", (0, c.utf32ToString)(g, y, p));
        }
        unhook(g, y = !0) {
          if (this._active.length) {
            let p = !1, m = this._active.length - 1, b = !1;
            if (this._stack.paused && (m = this._stack.loopPosition - 1, p = y, b = this._stack.fallThrough, this._stack.paused = !1), !b && p === !1) {
              for (; m >= 0 && (p = this._active[m].unhook(g), p !== !0); m--) if (p instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = m, this._stack.fallThrough = !1, p;
              m--;
            }
            for (; m >= 0; m--) if (p = this._active[m].unhook(!1), p instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = m, this._stack.fallThrough = !0, p;
          } else this._handlerFb(this._ident, "UNHOOK", g);
          this._active = d, this._ident = 0;
        }
      };
      const f = new u.Params();
      f.addParam(0), a.DcsHandler = class {
        constructor(g) {
          this._handler = g, this._data = "", this._params = f, this._hitLimit = !1;
        }
        hook(g) {
          this._params = g.length > 1 || g.params[0] ? g.clone() : f, this._data = "", this._hitLimit = !1;
        }
        put(g, y, p) {
          this._hitLimit || (this._data += (0, c.utf32ToString)(g, y, p), this._data.length > h.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
        }
        unhook(g) {
          let y = !1;
          if (this._hitLimit) y = !1;
          else if (g && (y = this._handler(this._data, this._params), y instanceof Promise)) return y.then((p) => (this._params = f, this._data = "", this._hitLimit = !1, p));
          return this._params = f, this._data = "", this._hitLimit = !1, y;
        }
      };
    }, 2015: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.EscapeSequenceParser = a.VT500_TRANSITION_TABLE = a.TransitionTable = void 0;
      const c = l(844), u = l(8742), h = l(6242), d = l(6351);
      class f {
        constructor(m) {
          this.table = new Uint8Array(m);
        }
        setDefault(m, b) {
          this.table.fill(m << 4 | b);
        }
        add(m, b, _, v) {
          this.table[b << 8 | m] = _ << 4 | v;
        }
        addMany(m, b, _, v) {
          for (let w = 0; w < m.length; w++) this.table[b << 8 | m[w]] = _ << 4 | v;
        }
      }
      a.TransitionTable = f;
      const g = 160;
      a.VT500_TRANSITION_TABLE = function() {
        const p = new f(4095), m = Array.apply(null, Array(256)).map((x, S) => S), b = (x, S) => m.slice(x, S), _ = b(32, 127), v = b(0, 24);
        v.push(25), v.push.apply(v, b(28, 32));
        const w = b(0, 14);
        let E;
        for (E in p.setDefault(1, 0), p.addMany(_, 0, 2, 0), w) p.addMany([24, 26, 153, 154], E, 3, 0), p.addMany(b(128, 144), E, 3, 0), p.addMany(b(144, 152), E, 3, 0), p.add(156, E, 0, 0), p.add(27, E, 11, 1), p.add(157, E, 4, 8), p.addMany([152, 158, 159], E, 0, 7), p.add(155, E, 11, 3), p.add(144, E, 11, 9);
        return p.addMany(v, 0, 3, 0), p.addMany(v, 1, 3, 1), p.add(127, 1, 0, 1), p.addMany(v, 8, 0, 8), p.addMany(v, 3, 3, 3), p.add(127, 3, 0, 3), p.addMany(v, 4, 3, 4), p.add(127, 4, 0, 4), p.addMany(v, 6, 3, 6), p.addMany(v, 5, 3, 5), p.add(127, 5, 0, 5), p.addMany(v, 2, 3, 2), p.add(127, 2, 0, 2), p.add(93, 1, 4, 8), p.addMany(_, 8, 5, 8), p.add(127, 8, 5, 8), p.addMany([156, 27, 24, 26, 7], 8, 6, 0), p.addMany(b(28, 32), 8, 0, 8), p.addMany([88, 94, 95], 1, 0, 7), p.addMany(_, 7, 0, 7), p.addMany(v, 7, 0, 7), p.add(156, 7, 0, 0), p.add(127, 7, 0, 7), p.add(91, 1, 11, 3), p.addMany(b(64, 127), 3, 7, 0), p.addMany(b(48, 60), 3, 8, 4), p.addMany([60, 61, 62, 63], 3, 9, 4), p.addMany(b(48, 60), 4, 8, 4), p.addMany(b(64, 127), 4, 7, 0), p.addMany([60, 61, 62, 63], 4, 0, 6), p.addMany(b(32, 64), 6, 0, 6), p.add(127, 6, 0, 6), p.addMany(b(64, 127), 6, 0, 0), p.addMany(b(32, 48), 3, 9, 5), p.addMany(b(32, 48), 5, 9, 5), p.addMany(b(48, 64), 5, 0, 6), p.addMany(b(64, 127), 5, 7, 0), p.addMany(b(32, 48), 4, 9, 5), p.addMany(b(32, 48), 1, 9, 2), p.addMany(b(32, 48), 2, 9, 2), p.addMany(b(48, 127), 2, 10, 0), p.addMany(b(48, 80), 1, 10, 0), p.addMany(b(81, 88), 1, 10, 0), p.addMany([89, 90, 92], 1, 10, 0), p.addMany(b(96, 127), 1, 10, 0), p.add(80, 1, 11, 9), p.addMany(v, 9, 0, 9), p.add(127, 9, 0, 9), p.addMany(b(28, 32), 9, 0, 9), p.addMany(b(32, 48), 9, 9, 12), p.addMany(b(48, 60), 9, 8, 10), p.addMany([60, 61, 62, 63], 9, 9, 10), p.addMany(v, 11, 0, 11), p.addMany(b(32, 128), 11, 0, 11), p.addMany(b(28, 32), 11, 0, 11), p.addMany(v, 10, 0, 10), p.add(127, 10, 0, 10), p.addMany(b(28, 32), 10, 0, 10), p.addMany(b(48, 60), 10, 8, 10), p.addMany([60, 61, 62, 63], 10, 0, 11), p.addMany(b(32, 48), 10, 9, 12), p.addMany(v, 12, 0, 12), p.add(127, 12, 0, 12), p.addMany(b(28, 32), 12, 0, 12), p.addMany(b(32, 48), 12, 9, 12), p.addMany(b(48, 64), 12, 0, 11), p.addMany(b(64, 127), 12, 12, 13), p.addMany(b(64, 127), 10, 12, 13), p.addMany(b(64, 127), 9, 12, 13), p.addMany(v, 13, 13, 13), p.addMany(_, 13, 13, 13), p.add(127, 13, 0, 13), p.addMany([27, 156, 24, 26], 13, 14, 0), p.add(g, 0, 2, 0), p.add(g, 8, 5, 8), p.add(g, 6, 0, 6), p.add(g, 11, 0, 11), p.add(g, 13, 13, 13), p;
      }();
      class y extends c.Disposable {
        constructor(m = a.VT500_TRANSITION_TABLE) {
          super(), this._transitions = m, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new u.Params(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._printHandlerFb = (b, _, v) => {
          }, this._executeHandlerFb = (b) => {
          }, this._csiHandlerFb = (b, _) => {
          }, this._escHandlerFb = (b) => {
          }, this._errorHandlerFb = (b) => b, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, c.toDisposable)(() => {
            this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
          })), this._oscParser = this.register(new h.OscParser()), this._dcsParser = this.register(new d.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => !0);
        }
        _identifier(m, b = [64, 126]) {
          let _ = 0;
          if (m.prefix) {
            if (m.prefix.length > 1) throw new Error("only one byte as prefix supported");
            if (_ = m.prefix.charCodeAt(0), _ && 60 > _ || _ > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
          }
          if (m.intermediates) {
            if (m.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
            for (let w = 0; w < m.intermediates.length; ++w) {
              const E = m.intermediates.charCodeAt(w);
              if (32 > E || E > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
              _ <<= 8, _ |= E;
            }
          }
          if (m.final.length !== 1) throw new Error("final must be a single byte");
          const v = m.final.charCodeAt(0);
          if (b[0] > v || v > b[1]) throw new Error(`final must be in range ${b[0]} .. ${b[1]}`);
          return _ <<= 8, _ |= v, _;
        }
        identToString(m) {
          const b = [];
          for (; m; ) b.push(String.fromCharCode(255 & m)), m >>= 8;
          return b.reverse().join("");
        }
        setPrintHandler(m) {
          this._printHandler = m;
        }
        clearPrintHandler() {
          this._printHandler = this._printHandlerFb;
        }
        registerEscHandler(m, b) {
          const _ = this._identifier(m, [48, 126]);
          this._escHandlers[_] === void 0 && (this._escHandlers[_] = []);
          const v = this._escHandlers[_];
          return v.push(b), { dispose: () => {
            const w = v.indexOf(b);
            w !== -1 && v.splice(w, 1);
          } };
        }
        clearEscHandler(m) {
          this._escHandlers[this._identifier(m, [48, 126])] && delete this._escHandlers[this._identifier(m, [48, 126])];
        }
        setEscHandlerFallback(m) {
          this._escHandlerFb = m;
        }
        setExecuteHandler(m, b) {
          this._executeHandlers[m.charCodeAt(0)] = b;
        }
        clearExecuteHandler(m) {
          this._executeHandlers[m.charCodeAt(0)] && delete this._executeHandlers[m.charCodeAt(0)];
        }
        setExecuteHandlerFallback(m) {
          this._executeHandlerFb = m;
        }
        registerCsiHandler(m, b) {
          const _ = this._identifier(m);
          this._csiHandlers[_] === void 0 && (this._csiHandlers[_] = []);
          const v = this._csiHandlers[_];
          return v.push(b), { dispose: () => {
            const w = v.indexOf(b);
            w !== -1 && v.splice(w, 1);
          } };
        }
        clearCsiHandler(m) {
          this._csiHandlers[this._identifier(m)] && delete this._csiHandlers[this._identifier(m)];
        }
        setCsiHandlerFallback(m) {
          this._csiHandlerFb = m;
        }
        registerDcsHandler(m, b) {
          return this._dcsParser.registerHandler(this._identifier(m), b);
        }
        clearDcsHandler(m) {
          this._dcsParser.clearHandler(this._identifier(m));
        }
        setDcsHandlerFallback(m) {
          this._dcsParser.setHandlerFallback(m);
        }
        registerOscHandler(m, b) {
          return this._oscParser.registerHandler(m, b);
        }
        clearOscHandler(m) {
          this._oscParser.clearHandler(m);
        }
        setOscHandlerFallback(m) {
          this._oscParser.setHandlerFallback(m);
        }
        setErrorHandler(m) {
          this._errorHandler = m;
        }
        clearErrorHandler() {
          this._errorHandler = this._errorHandlerFb;
        }
        reset() {
          this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []);
        }
        _preserveStack(m, b, _, v, w) {
          this._parseStack.state = m, this._parseStack.handlers = b, this._parseStack.handlerPos = _, this._parseStack.transition = v, this._parseStack.chunkPos = w;
        }
        parse(m, b, _) {
          let v, w = 0, E = 0, x = 0;
          if (this._parseStack.state) if (this._parseStack.state === 2) this._parseStack.state = 0, x = this._parseStack.chunkPos + 1;
          else {
            if (_ === void 0 || this._parseStack.state === 1) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
            const S = this._parseStack.handlers;
            let T = this._parseStack.handlerPos - 1;
            switch (this._parseStack.state) {
              case 3:
                if (_ === !1 && T > -1) {
                  for (; T >= 0 && (v = S[T](this._params), v !== !0); T--) if (v instanceof Promise) return this._parseStack.handlerPos = T, v;
                }
                this._parseStack.handlers = [];
                break;
              case 4:
                if (_ === !1 && T > -1) {
                  for (; T >= 0 && (v = S[T](), v !== !0); T--) if (v instanceof Promise) return this._parseStack.handlerPos = T, v;
                }
                this._parseStack.handlers = [];
                break;
              case 6:
                if (w = m[this._parseStack.chunkPos], v = this._dcsParser.unhook(w !== 24 && w !== 26, _), v) return v;
                w === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                break;
              case 5:
                if (w = m[this._parseStack.chunkPos], v = this._oscParser.end(w !== 24 && w !== 26, _), v) return v;
                w === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
            }
            this._parseStack.state = 0, x = this._parseStack.chunkPos + 1, this.precedingJoinState = 0, this.currentState = 15 & this._parseStack.transition;
          }
          for (let S = x; S < b; ++S) {
            switch (w = m[S], E = this._transitions.table[this.currentState << 8 | (w < 160 ? w : g)], E >> 4) {
              case 2:
                for (let M = S + 1; ; ++M) {
                  if (M >= b || (w = m[M]) < 32 || w > 126 && w < g) {
                    this._printHandler(m, S, M), S = M - 1;
                    break;
                  }
                  if (++M >= b || (w = m[M]) < 32 || w > 126 && w < g) {
                    this._printHandler(m, S, M), S = M - 1;
                    break;
                  }
                  if (++M >= b || (w = m[M]) < 32 || w > 126 && w < g) {
                    this._printHandler(m, S, M), S = M - 1;
                    break;
                  }
                  if (++M >= b || (w = m[M]) < 32 || w > 126 && w < g) {
                    this._printHandler(m, S, M), S = M - 1;
                    break;
                  }
                }
                break;
              case 3:
                this._executeHandlers[w] ? this._executeHandlers[w]() : this._executeHandlerFb(w), this.precedingJoinState = 0;
                break;
              case 0:
                break;
              case 1:
                if (this._errorHandler({ position: S, code: w, currentState: this.currentState, collect: this._collect, params: this._params, abort: !1 }).abort) return;
                break;
              case 7:
                const T = this._csiHandlers[this._collect << 8 | w];
                let R = T ? T.length - 1 : -1;
                for (; R >= 0 && (v = T[R](this._params), v !== !0); R--) if (v instanceof Promise) return this._preserveStack(3, T, R, E, S), v;
                R < 0 && this._csiHandlerFb(this._collect << 8 | w, this._params), this.precedingJoinState = 0;
                break;
              case 8:
                do
                  switch (w) {
                    case 59:
                      this._params.addParam(0);
                      break;
                    case 58:
                      this._params.addSubParam(-1);
                      break;
                    default:
                      this._params.addDigit(w - 48);
                  }
                while (++S < b && (w = m[S]) > 47 && w < 60);
                S--;
                break;
              case 9:
                this._collect <<= 8, this._collect |= w;
                break;
              case 10:
                const F = this._escHandlers[this._collect << 8 | w];
                let P = F ? F.length - 1 : -1;
                for (; P >= 0 && (v = F[P](), v !== !0); P--) if (v instanceof Promise) return this._preserveStack(4, F, P, E, S), v;
                P < 0 && this._escHandlerFb(this._collect << 8 | w), this.precedingJoinState = 0;
                break;
              case 11:
                this._params.reset(), this._params.addParam(0), this._collect = 0;
                break;
              case 12:
                this._dcsParser.hook(this._collect << 8 | w, this._params);
                break;
              case 13:
                for (let M = S + 1; ; ++M) if (M >= b || (w = m[M]) === 24 || w === 26 || w === 27 || w > 127 && w < g) {
                  this._dcsParser.put(m, S, M), S = M - 1;
                  break;
                }
                break;
              case 14:
                if (v = this._dcsParser.unhook(w !== 24 && w !== 26), v) return this._preserveStack(6, [], 0, E, S), v;
                w === 27 && (E |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
                break;
              case 4:
                this._oscParser.start();
                break;
              case 5:
                for (let M = S + 1; ; M++) if (M >= b || (w = m[M]) < 32 || w > 127 && w < g) {
                  this._oscParser.put(m, S, M), S = M - 1;
                  break;
                }
                break;
              case 6:
                if (v = this._oscParser.end(w !== 24 && w !== 26), v) return this._preserveStack(5, [], 0, E, S), v;
                w === 27 && (E |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
            }
            this.currentState = 15 & E;
          }
        }
      }
      a.EscapeSequenceParser = y;
    }, 6242: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OscHandler = a.OscParser = void 0;
      const c = l(5770), u = l(482), h = [];
      a.OscParser = class {
        constructor() {
          this._state = 0, this._active = h, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
        }
        registerHandler(d, f) {
          this._handlers[d] === void 0 && (this._handlers[d] = []);
          const g = this._handlers[d];
          return g.push(f), { dispose: () => {
            const y = g.indexOf(f);
            y !== -1 && g.splice(y, 1);
          } };
        }
        clearHandler(d) {
          this._handlers[d] && delete this._handlers[d];
        }
        setHandlerFallback(d) {
          this._handlerFb = d;
        }
        dispose() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._active = h;
        }
        reset() {
          if (this._state === 2) for (let d = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; d >= 0; --d) this._active[d].end(!1);
          this._stack.paused = !1, this._active = h, this._id = -1, this._state = 0;
        }
        _start() {
          if (this._active = this._handlers[this._id] || h, this._active.length) for (let d = this._active.length - 1; d >= 0; d--) this._active[d].start();
          else this._handlerFb(this._id, "START");
        }
        _put(d, f, g) {
          if (this._active.length) for (let y = this._active.length - 1; y >= 0; y--) this._active[y].put(d, f, g);
          else this._handlerFb(this._id, "PUT", (0, u.utf32ToString)(d, f, g));
        }
        start() {
          this.reset(), this._state = 1;
        }
        put(d, f, g) {
          if (this._state !== 3) {
            if (this._state === 1) for (; f < g; ) {
              const y = d[f++];
              if (y === 59) {
                this._state = 2, this._start();
                break;
              }
              if (y < 48 || 57 < y) return void (this._state = 3);
              this._id === -1 && (this._id = 0), this._id = 10 * this._id + y - 48;
            }
            this._state === 2 && g - f > 0 && this._put(d, f, g);
          }
        }
        end(d, f = !0) {
          if (this._state !== 0) {
            if (this._state !== 3) if (this._state === 1 && this._start(), this._active.length) {
              let g = !1, y = this._active.length - 1, p = !1;
              if (this._stack.paused && (y = this._stack.loopPosition - 1, g = f, p = this._stack.fallThrough, this._stack.paused = !1), !p && g === !1) {
                for (; y >= 0 && (g = this._active[y].end(d), g !== !0); y--) if (g instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = y, this._stack.fallThrough = !1, g;
                y--;
              }
              for (; y >= 0; y--) if (g = this._active[y].end(!1), g instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = y, this._stack.fallThrough = !0, g;
            } else this._handlerFb(this._id, "END", d);
            this._active = h, this._id = -1, this._state = 0;
          }
        }
      }, a.OscHandler = class {
        constructor(d) {
          this._handler = d, this._data = "", this._hitLimit = !1;
        }
        start() {
          this._data = "", this._hitLimit = !1;
        }
        put(d, f, g) {
          this._hitLimit || (this._data += (0, u.utf32ToString)(d, f, g), this._data.length > c.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
        }
        end(d) {
          let f = !1;
          if (this._hitLimit) f = !1;
          else if (d && (f = this._handler(this._data), f instanceof Promise)) return f.then((g) => (this._data = "", this._hitLimit = !1, g));
          return this._data = "", this._hitLimit = !1, f;
        }
      };
    }, 8742: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Params = void 0;
      const l = 2147483647;
      class c {
        static fromArray(h) {
          const d = new c();
          if (!h.length) return d;
          for (let f = Array.isArray(h[0]) ? 1 : 0; f < h.length; ++f) {
            const g = h[f];
            if (Array.isArray(g)) for (let y = 0; y < g.length; ++y) d.addSubParam(g[y]);
            else d.addParam(g);
          }
          return d;
        }
        constructor(h = 32, d = 32) {
          if (this.maxLength = h, this.maxSubParamsLength = d, d > 256) throw new Error("maxSubParamsLength must not be greater than 256");
          this.params = new Int32Array(h), this.length = 0, this._subParams = new Int32Array(d), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(h), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
        }
        clone() {
          const h = new c(this.maxLength, this.maxSubParamsLength);
          return h.params.set(this.params), h.length = this.length, h._subParams.set(this._subParams), h._subParamsLength = this._subParamsLength, h._subParamsIdx.set(this._subParamsIdx), h._rejectDigits = this._rejectDigits, h._rejectSubDigits = this._rejectSubDigits, h._digitIsSub = this._digitIsSub, h;
        }
        toArray() {
          const h = [];
          for (let d = 0; d < this.length; ++d) {
            h.push(this.params[d]);
            const f = this._subParamsIdx[d] >> 8, g = 255 & this._subParamsIdx[d];
            g - f > 0 && h.push(Array.prototype.slice.call(this._subParams, f, g));
          }
          return h;
        }
        reset() {
          this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
        }
        addParam(h) {
          if (this._digitIsSub = !1, this.length >= this.maxLength) this._rejectDigits = !0;
          else {
            if (h < -1) throw new Error("values lesser than -1 are not allowed");
            this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = h > l ? l : h;
          }
        }
        addSubParam(h) {
          if (this._digitIsSub = !0, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = !0;
          else {
            if (h < -1) throw new Error("values lesser than -1 are not allowed");
            this._subParams[this._subParamsLength++] = h > l ? l : h, this._subParamsIdx[this.length - 1]++;
          }
        }
        hasSubParams(h) {
          return (255 & this._subParamsIdx[h]) - (this._subParamsIdx[h] >> 8) > 0;
        }
        getSubParams(h) {
          const d = this._subParamsIdx[h] >> 8, f = 255 & this._subParamsIdx[h];
          return f - d > 0 ? this._subParams.subarray(d, f) : null;
        }
        getSubParamsAll() {
          const h = {};
          for (let d = 0; d < this.length; ++d) {
            const f = this._subParamsIdx[d] >> 8, g = 255 & this._subParamsIdx[d];
            g - f > 0 && (h[d] = this._subParams.slice(f, g));
          }
          return h;
        }
        addDigit(h) {
          let d;
          if (this._rejectDigits || !(d = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
          const f = this._digitIsSub ? this._subParams : this.params, g = f[d - 1];
          f[d - 1] = ~g ? Math.min(10 * g + h, l) : h;
        }
      }
      a.Params = c;
    }, 5741: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.AddonManager = void 0, a.AddonManager = class {
        constructor() {
          this._addons = [];
        }
        dispose() {
          for (let l = this._addons.length - 1; l >= 0; l--) this._addons[l].instance.dispose();
        }
        loadAddon(l, c) {
          const u = { instance: c, dispose: c.dispose, isDisposed: !1 };
          this._addons.push(u), c.dispose = () => this._wrappedAddonDispose(u), c.activate(l);
        }
        _wrappedAddonDispose(l) {
          if (l.isDisposed) return;
          let c = -1;
          for (let u = 0; u < this._addons.length; u++) if (this._addons[u] === l) {
            c = u;
            break;
          }
          if (c === -1) throw new Error("Could not dispose an addon that has not been loaded");
          l.isDisposed = !0, l.dispose.apply(l.instance), this._addons.splice(c, 1);
        }
      };
    }, 8771: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferApiView = void 0;
      const c = l(3785), u = l(511);
      a.BufferApiView = class {
        constructor(h, d) {
          this._buffer = h, this.type = d;
        }
        init(h) {
          return this._buffer = h, this;
        }
        get cursorY() {
          return this._buffer.y;
        }
        get cursorX() {
          return this._buffer.x;
        }
        get viewportY() {
          return this._buffer.ydisp;
        }
        get baseY() {
          return this._buffer.ybase;
        }
        get length() {
          return this._buffer.lines.length;
        }
        getLine(h) {
          const d = this._buffer.lines.get(h);
          if (d) return new c.BufferLineApiView(d);
        }
        getNullCell() {
          return new u.CellData();
        }
      };
    }, 3785: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferLineApiView = void 0;
      const c = l(511);
      a.BufferLineApiView = class {
        constructor(u) {
          this._line = u;
        }
        get isWrapped() {
          return this._line.isWrapped;
        }
        get length() {
          return this._line.length;
        }
        getCell(u, h) {
          if (!(u < 0 || u >= this._line.length)) return h ? (this._line.loadCell(u, h), h) : this._line.loadCell(u, new c.CellData());
        }
        translateToString(u, h, d) {
          return this._line.translateToString(u, h, d);
        }
      };
    }, 8285: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferNamespaceApi = void 0;
      const c = l(8771), u = l(8460), h = l(844);
      class d extends h.Disposable {
        constructor(g) {
          super(), this._core = g, this._onBufferChange = this.register(new u.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new c.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new c.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
        }
        get active() {
          if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
          if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
          throw new Error("Active buffer is neither normal nor alternate");
        }
        get normal() {
          return this._normal.init(this._core.buffers.normal);
        }
        get alternate() {
          return this._alternate.init(this._core.buffers.alt);
        }
      }
      a.BufferNamespaceApi = d;
    }, 7975: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ParserApi = void 0, a.ParserApi = class {
        constructor(l) {
          this._core = l;
        }
        registerCsiHandler(l, c) {
          return this._core.registerCsiHandler(l, (u) => c(u.toArray()));
        }
        addCsiHandler(l, c) {
          return this.registerCsiHandler(l, c);
        }
        registerDcsHandler(l, c) {
          return this._core.registerDcsHandler(l, (u, h) => c(u, h.toArray()));
        }
        addDcsHandler(l, c) {
          return this.registerDcsHandler(l, c);
        }
        registerEscHandler(l, c) {
          return this._core.registerEscHandler(l, c);
        }
        addEscHandler(l, c) {
          return this.registerEscHandler(l, c);
        }
        registerOscHandler(l, c) {
          return this._core.registerOscHandler(l, c);
        }
        addOscHandler(l, c) {
          return this.registerOscHandler(l, c);
        }
      };
    }, 7090: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeApi = void 0, a.UnicodeApi = class {
        constructor(l) {
          this._core = l;
        }
        register(l) {
          this._core.unicodeService.register(l);
        }
        get versions() {
          return this._core.unicodeService.versions;
        }
        get activeVersion() {
          return this._core.unicodeService.activeVersion;
        }
        set activeVersion(l) {
          this._core.unicodeService.activeVersion = l;
        }
      };
    }, 744: function(o, a, l) {
      var c = this && this.__decorate || function(p, m, b, _) {
        var v, w = arguments.length, E = w < 3 ? m : _ === null ? _ = Object.getOwnPropertyDescriptor(m, b) : _;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") E = Reflect.decorate(p, m, b, _);
        else for (var x = p.length - 1; x >= 0; x--) (v = p[x]) && (E = (w < 3 ? v(E) : w > 3 ? v(m, b, E) : v(m, b)) || E);
        return w > 3 && E && Object.defineProperty(m, b, E), E;
      }, u = this && this.__param || function(p, m) {
        return function(b, _) {
          m(b, _, p);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferService = a.MINIMUM_ROWS = a.MINIMUM_COLS = void 0;
      const h = l(8460), d = l(844), f = l(5295), g = l(2585);
      a.MINIMUM_COLS = 2, a.MINIMUM_ROWS = 1;
      let y = a.BufferService = class extends d.Disposable {
        get buffer() {
          return this.buffers.active;
        }
        constructor(p) {
          super(), this.isUserScrolling = !1, this._onResize = this.register(new h.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new h.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(p.rawOptions.cols || 0, a.MINIMUM_COLS), this.rows = Math.max(p.rawOptions.rows || 0, a.MINIMUM_ROWS), this.buffers = this.register(new f.BufferSet(p, this));
        }
        resize(p, m) {
          this.cols = p, this.rows = m, this.buffers.resize(p, m), this._onResize.fire({ cols: p, rows: m });
        }
        reset() {
          this.buffers.reset(), this.isUserScrolling = !1;
        }
        scroll(p, m = !1) {
          const b = this.buffer;
          let _;
          _ = this._cachedBlankLine, _ && _.length === this.cols && _.getFg(0) === p.fg && _.getBg(0) === p.bg || (_ = b.getBlankLine(p, m), this._cachedBlankLine = _), _.isWrapped = m;
          const v = b.ybase + b.scrollTop, w = b.ybase + b.scrollBottom;
          if (b.scrollTop === 0) {
            const E = b.lines.isFull;
            w === b.lines.length - 1 ? E ? b.lines.recycle().copyFrom(_) : b.lines.push(_.clone()) : b.lines.splice(w + 1, 0, _.clone()), E ? this.isUserScrolling && (b.ydisp = Math.max(b.ydisp - 1, 0)) : (b.ybase++, this.isUserScrolling || b.ydisp++);
          } else {
            const E = w - v + 1;
            b.lines.shiftElements(v + 1, E - 1, -1), b.lines.set(w, _.clone());
          }
          this.isUserScrolling || (b.ydisp = b.ybase), this._onScroll.fire(b.ydisp);
        }
        scrollLines(p, m, b) {
          const _ = this.buffer;
          if (p < 0) {
            if (_.ydisp === 0) return;
            this.isUserScrolling = !0;
          } else p + _.ydisp >= _.ybase && (this.isUserScrolling = !1);
          const v = _.ydisp;
          _.ydisp = Math.max(Math.min(_.ydisp + p, _.ybase), 0), v !== _.ydisp && (m || this._onScroll.fire(_.ydisp));
        }
      };
      a.BufferService = y = c([u(0, g.IOptionsService)], y);
    }, 7994: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CharsetService = void 0, a.CharsetService = class {
        constructor() {
          this.glevel = 0, this._charsets = [];
        }
        reset() {
          this.charset = void 0, this._charsets = [], this.glevel = 0;
        }
        setgLevel(l) {
          this.glevel = l, this.charset = this._charsets[l];
        }
        setgCharset(l, c) {
          this._charsets[l] = c, this.glevel === l && (this.charset = c);
        }
      };
    }, 1753: function(o, a, l) {
      var c = this && this.__decorate || function(_, v, w, E) {
        var x, S = arguments.length, T = S < 3 ? v : E === null ? E = Object.getOwnPropertyDescriptor(v, w) : E;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") T = Reflect.decorate(_, v, w, E);
        else for (var R = _.length - 1; R >= 0; R--) (x = _[R]) && (T = (S < 3 ? x(T) : S > 3 ? x(v, w, T) : x(v, w)) || T);
        return S > 3 && T && Object.defineProperty(v, w, T), T;
      }, u = this && this.__param || function(_, v) {
        return function(w, E) {
          v(w, E, _);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreMouseService = void 0;
      const h = l(2585), d = l(8460), f = l(844), g = { NONE: { events: 0, restrict: () => !1 }, X10: { events: 1, restrict: (_) => _.button !== 4 && _.action === 1 && (_.ctrl = !1, _.alt = !1, _.shift = !1, !0) }, VT200: { events: 19, restrict: (_) => _.action !== 32 }, DRAG: { events: 23, restrict: (_) => _.action !== 32 || _.button !== 3 }, ANY: { events: 31, restrict: (_) => !0 } };
      function y(_, v) {
        let w = (_.ctrl ? 16 : 0) | (_.shift ? 4 : 0) | (_.alt ? 8 : 0);
        return _.button === 4 ? (w |= 64, w |= _.action) : (w |= 3 & _.button, 4 & _.button && (w |= 64), 8 & _.button && (w |= 128), _.action === 32 ? w |= 32 : _.action !== 0 || v || (w |= 3)), w;
      }
      const p = String.fromCharCode, m = { DEFAULT: (_) => {
        const v = [y(_, !1) + 32, _.col + 32, _.row + 32];
        return v[0] > 255 || v[1] > 255 || v[2] > 255 ? "" : `\x1B[M${p(v[0])}${p(v[1])}${p(v[2])}`;
      }, SGR: (_) => {
        const v = _.action === 0 && _.button !== 4 ? "m" : "M";
        return `\x1B[<${y(_, !0)};${_.col};${_.row}${v}`;
      }, SGR_PIXELS: (_) => {
        const v = _.action === 0 && _.button !== 4 ? "m" : "M";
        return `\x1B[<${y(_, !0)};${_.x};${_.y}${v}`;
      } };
      let b = a.CoreMouseService = class extends f.Disposable {
        constructor(_, v) {
          super(), this._bufferService = _, this._coreService = v, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new d.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
          for (const w of Object.keys(g)) this.addProtocol(w, g[w]);
          for (const w of Object.keys(m)) this.addEncoding(w, m[w]);
          this.reset();
        }
        addProtocol(_, v) {
          this._protocols[_] = v;
        }
        addEncoding(_, v) {
          this._encodings[_] = v;
        }
        get activeProtocol() {
          return this._activeProtocol;
        }
        get areMouseEventsActive() {
          return this._protocols[this._activeProtocol].events !== 0;
        }
        set activeProtocol(_) {
          if (!this._protocols[_]) throw new Error(`unknown protocol "${_}"`);
          this._activeProtocol = _, this._onProtocolChange.fire(this._protocols[_].events);
        }
        get activeEncoding() {
          return this._activeEncoding;
        }
        set activeEncoding(_) {
          if (!this._encodings[_]) throw new Error(`unknown encoding "${_}"`);
          this._activeEncoding = _;
        }
        reset() {
          this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
        }
        triggerMouseEvent(_) {
          if (_.col < 0 || _.col >= this._bufferService.cols || _.row < 0 || _.row >= this._bufferService.rows || _.button === 4 && _.action === 32 || _.button === 3 && _.action !== 32 || _.button !== 4 && (_.action === 2 || _.action === 3) || (_.col++, _.row++, _.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, _, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(_)) return !1;
          const v = this._encodings[this._activeEncoding](_);
          return v && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(v) : this._coreService.triggerDataEvent(v, !0)), this._lastEvent = _, !0;
        }
        explainEvents(_) {
          return { down: !!(1 & _), up: !!(2 & _), drag: !!(4 & _), move: !!(8 & _), wheel: !!(16 & _) };
        }
        _equalEvents(_, v, w) {
          if (w) {
            if (_.x !== v.x || _.y !== v.y) return !1;
          } else if (_.col !== v.col || _.row !== v.row) return !1;
          return _.button === v.button && _.action === v.action && _.ctrl === v.ctrl && _.alt === v.alt && _.shift === v.shift;
        }
      };
      a.CoreMouseService = b = c([u(0, h.IBufferService), u(1, h.ICoreService)], b);
    }, 6975: function(o, a, l) {
      var c = this && this.__decorate || function(b, _, v, w) {
        var E, x = arguments.length, S = x < 3 ? _ : w === null ? w = Object.getOwnPropertyDescriptor(_, v) : w;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") S = Reflect.decorate(b, _, v, w);
        else for (var T = b.length - 1; T >= 0; T--) (E = b[T]) && (S = (x < 3 ? E(S) : x > 3 ? E(_, v, S) : E(_, v)) || S);
        return x > 3 && S && Object.defineProperty(_, v, S), S;
      }, u = this && this.__param || function(b, _) {
        return function(v, w) {
          _(v, w, b);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreService = void 0;
      const h = l(1439), d = l(8460), f = l(844), g = l(2585), y = Object.freeze({ insertMode: !1 }), p = Object.freeze({ applicationCursorKeys: !1, applicationKeypad: !1, bracketedPasteMode: !1, origin: !1, reverseWraparound: !1, sendFocus: !1, wraparound: !0 });
      let m = a.CoreService = class extends f.Disposable {
        constructor(b, _, v) {
          super(), this._bufferService = b, this._logService = _, this._optionsService = v, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new d.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new d.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new d.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new d.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, h.clone)(y), this.decPrivateModes = (0, h.clone)(p);
        }
        reset() {
          this.modes = (0, h.clone)(y), this.decPrivateModes = (0, h.clone)(p);
        }
        triggerDataEvent(b, _ = !1) {
          if (this._optionsService.rawOptions.disableStdin) return;
          const v = this._bufferService.buffer;
          _ && this._optionsService.rawOptions.scrollOnUserInput && v.ybase !== v.ydisp && this._onRequestScrollToBottom.fire(), _ && this._onUserInput.fire(), this._logService.debug(`sending data "${b}"`, () => b.split("").map((w) => w.charCodeAt(0))), this._onData.fire(b);
        }
        triggerBinaryEvent(b) {
          this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${b}"`, () => b.split("").map((_) => _.charCodeAt(0))), this._onBinary.fire(b));
        }
      };
      a.CoreService = m = c([u(0, g.IBufferService), u(1, g.ILogService), u(2, g.IOptionsService)], m);
    }, 9074: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DecorationService = void 0;
      const c = l(8055), u = l(8460), h = l(844), d = l(6106);
      let f = 0, g = 0;
      class y extends h.Disposable {
        get decorations() {
          return this._decorations.values();
        }
        constructor() {
          super(), this._decorations = new d.SortedList((b) => b?.marker.line), this._onDecorationRegistered = this.register(new u.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new u.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, h.toDisposable)(() => this.reset()));
        }
        registerDecoration(b) {
          if (b.marker.isDisposed) return;
          const _ = new p(b);
          if (_) {
            const v = _.marker.onDispose(() => _.dispose());
            _.onDispose(() => {
              _ && (this._decorations.delete(_) && this._onDecorationRemoved.fire(_), v.dispose());
            }), this._decorations.insert(_), this._onDecorationRegistered.fire(_);
          }
          return _;
        }
        reset() {
          for (const b of this._decorations.values()) b.dispose();
          this._decorations.clear();
        }
        *getDecorationsAtCell(b, _, v) {
          let w = 0, E = 0;
          for (const x of this._decorations.getKeyIterator(_)) w = x.options.x ?? 0, E = w + (x.options.width ?? 1), b >= w && b < E && (!v || (x.options.layer ?? "bottom") === v) && (yield x);
        }
        forEachDecorationAtCell(b, _, v, w) {
          this._decorations.forEachByKey(_, (E) => {
            f = E.options.x ?? 0, g = f + (E.options.width ?? 1), b >= f && b < g && (!v || (E.options.layer ?? "bottom") === v) && w(E);
          });
        }
      }
      a.DecorationService = y;
      class p extends h.Disposable {
        get isDisposed() {
          return this._isDisposed;
        }
        get backgroundColorRGB() {
          return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = c.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
        }
        get foregroundColorRGB() {
          return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = c.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
        }
        constructor(b) {
          super(), this.options = b, this.onRenderEmitter = this.register(new u.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new u.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = b.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
        }
        dispose() {
          this._onDispose.fire(), super.dispose();
        }
      }
    }, 4348: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.InstantiationService = a.ServiceCollection = void 0;
      const c = l(2585), u = l(8343);
      class h {
        constructor(...f) {
          this._entries = /* @__PURE__ */ new Map();
          for (const [g, y] of f) this.set(g, y);
        }
        set(f, g) {
          const y = this._entries.get(f);
          return this._entries.set(f, g), y;
        }
        forEach(f) {
          for (const [g, y] of this._entries.entries()) f(g, y);
        }
        has(f) {
          return this._entries.has(f);
        }
        get(f) {
          return this._entries.get(f);
        }
      }
      a.ServiceCollection = h, a.InstantiationService = class {
        constructor() {
          this._services = new h(), this._services.set(c.IInstantiationService, this);
        }
        setService(d, f) {
          this._services.set(d, f);
        }
        getService(d) {
          return this._services.get(d);
        }
        createInstance(d, ...f) {
          const g = (0, u.getServiceDependencies)(d).sort((m, b) => m.index - b.index), y = [];
          for (const m of g) {
            const b = this._services.get(m.id);
            if (!b) throw new Error(`[createInstance] ${d.name} depends on UNKNOWN service ${m.id}.`);
            y.push(b);
          }
          const p = g.length > 0 ? g[0].index : f.length;
          if (f.length !== p) throw new Error(`[createInstance] First service dependency of ${d.name} at position ${p + 1} conflicts with ${f.length} static arguments`);
          return new d(...f, ...y);
        }
      };
    }, 7866: function(o, a, l) {
      var c = this && this.__decorate || function(p, m, b, _) {
        var v, w = arguments.length, E = w < 3 ? m : _ === null ? _ = Object.getOwnPropertyDescriptor(m, b) : _;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") E = Reflect.decorate(p, m, b, _);
        else for (var x = p.length - 1; x >= 0; x--) (v = p[x]) && (E = (w < 3 ? v(E) : w > 3 ? v(m, b, E) : v(m, b)) || E);
        return w > 3 && E && Object.defineProperty(m, b, E), E;
      }, u = this && this.__param || function(p, m) {
        return function(b, _) {
          m(b, _, p);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.traceCall = a.setTraceLogger = a.LogService = void 0;
      const h = l(844), d = l(2585), f = { trace: d.LogLevelEnum.TRACE, debug: d.LogLevelEnum.DEBUG, info: d.LogLevelEnum.INFO, warn: d.LogLevelEnum.WARN, error: d.LogLevelEnum.ERROR, off: d.LogLevelEnum.OFF };
      let g, y = a.LogService = class extends h.Disposable {
        get logLevel() {
          return this._logLevel;
        }
        constructor(p) {
          super(), this._optionsService = p, this._logLevel = d.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), g = this;
        }
        _updateLogLevel() {
          this._logLevel = f[this._optionsService.rawOptions.logLevel];
        }
        _evalLazyOptionalParams(p) {
          for (let m = 0; m < p.length; m++) typeof p[m] == "function" && (p[m] = p[m]());
        }
        _log(p, m, b) {
          this._evalLazyOptionalParams(b), p.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + m, ...b);
        }
        trace(p, ...m) {
          this._logLevel <= d.LogLevelEnum.TRACE && this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger) ?? console.log, p, m);
        }
        debug(p, ...m) {
          this._logLevel <= d.LogLevelEnum.DEBUG && this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger) ?? console.log, p, m);
        }
        info(p, ...m) {
          this._logLevel <= d.LogLevelEnum.INFO && this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger) ?? console.info, p, m);
        }
        warn(p, ...m) {
          this._logLevel <= d.LogLevelEnum.WARN && this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger) ?? console.warn, p, m);
        }
        error(p, ...m) {
          this._logLevel <= d.LogLevelEnum.ERROR && this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger) ?? console.error, p, m);
        }
      };
      a.LogService = y = c([u(0, d.IOptionsService)], y), a.setTraceLogger = function(p) {
        g = p;
      }, a.traceCall = function(p, m, b) {
        if (typeof b.value != "function") throw new Error("not supported");
        const _ = b.value;
        b.value = function(...v) {
          if (g.logLevel !== d.LogLevelEnum.TRACE) return _.apply(this, v);
          g.trace(`GlyphRenderer#${_.name}(${v.map((E) => JSON.stringify(E)).join(", ")})`);
          const w = _.apply(this, v);
          return g.trace(`GlyphRenderer#${_.name} return`, w), w;
        };
      };
    }, 7302: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OptionsService = a.DEFAULT_OPTIONS = void 0;
      const c = l(8460), u = l(844), h = l(6114);
      a.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: !1, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: !0, drawBoldTextInBrightColors: !0, documentOverride: null, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: !1, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: !0, scrollSensitivity: 1, screenReaderMode: !1, smoothScrollDuration: 0, macOptionIsMeta: !1, macOptionClickForcesSelection: !1, minimumContrastRatio: 1, disableStdin: !1, allowProposedApi: !1, allowTransparency: !1, tabStopWidth: 8, theme: {}, rescaleOverlappingGlyphs: !1, rightClickSelectsWord: h.isMac, windowOptions: {}, windowsMode: !1, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: !0, convertEol: !1, termName: "xterm", cancelEvents: !1, overviewRulerWidth: 0 };
      const d = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
      class f extends u.Disposable {
        constructor(y) {
          super(), this._onOptionChange = this.register(new c.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
          const p = { ...a.DEFAULT_OPTIONS };
          for (const m in y) if (m in p) try {
            const b = y[m];
            p[m] = this._sanitizeAndValidateOption(m, b);
          } catch (b) {
            console.error(b);
          }
          this.rawOptions = p, this.options = { ...p }, this._setupOptions(), this.register((0, u.toDisposable)(() => {
            this.rawOptions.linkHandler = null, this.rawOptions.documentOverride = null;
          }));
        }
        onSpecificOptionChange(y, p) {
          return this.onOptionChange((m) => {
            m === y && p(this.rawOptions[y]);
          });
        }
        onMultipleOptionChange(y, p) {
          return this.onOptionChange((m) => {
            y.indexOf(m) !== -1 && p();
          });
        }
        _setupOptions() {
          const y = (m) => {
            if (!(m in a.DEFAULT_OPTIONS)) throw new Error(`No option with key "${m}"`);
            return this.rawOptions[m];
          }, p = (m, b) => {
            if (!(m in a.DEFAULT_OPTIONS)) throw new Error(`No option with key "${m}"`);
            b = this._sanitizeAndValidateOption(m, b), this.rawOptions[m] !== b && (this.rawOptions[m] = b, this._onOptionChange.fire(m));
          };
          for (const m in this.rawOptions) {
            const b = { get: y.bind(this, m), set: p.bind(this, m) };
            Object.defineProperty(this.options, m, b);
          }
        }
        _sanitizeAndValidateOption(y, p) {
          switch (y) {
            case "cursorStyle":
              if (p || (p = a.DEFAULT_OPTIONS[y]), !/* @__PURE__ */ function(m) {
                return m === "block" || m === "underline" || m === "bar";
              }(p)) throw new Error(`"${p}" is not a valid value for ${y}`);
              break;
            case "wordSeparator":
              p || (p = a.DEFAULT_OPTIONS[y]);
              break;
            case "fontWeight":
            case "fontWeightBold":
              if (typeof p == "number" && 1 <= p && p <= 1e3) break;
              p = d.includes(p) ? p : a.DEFAULT_OPTIONS[y];
              break;
            case "cursorWidth":
              p = Math.floor(p);
            case "lineHeight":
            case "tabStopWidth":
              if (p < 1) throw new Error(`${y} cannot be less than 1, value: ${p}`);
              break;
            case "minimumContrastRatio":
              p = Math.max(1, Math.min(21, Math.round(10 * p) / 10));
              break;
            case "scrollback":
              if ((p = Math.min(p, 4294967295)) < 0) throw new Error(`${y} cannot be less than 0, value: ${p}`);
              break;
            case "fastScrollSensitivity":
            case "scrollSensitivity":
              if (p <= 0) throw new Error(`${y} cannot be less than or equal to 0, value: ${p}`);
              break;
            case "rows":
            case "cols":
              if (!p && p !== 0) throw new Error(`${y} must be numeric, value: ${p}`);
              break;
            case "windowsPty":
              p = p ?? {};
          }
          return p;
        }
      }
      a.OptionsService = f;
    }, 2660: function(o, a, l) {
      var c = this && this.__decorate || function(f, g, y, p) {
        var m, b = arguments.length, _ = b < 3 ? g : p === null ? p = Object.getOwnPropertyDescriptor(g, y) : p;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") _ = Reflect.decorate(f, g, y, p);
        else for (var v = f.length - 1; v >= 0; v--) (m = f[v]) && (_ = (b < 3 ? m(_) : b > 3 ? m(g, y, _) : m(g, y)) || _);
        return b > 3 && _ && Object.defineProperty(g, y, _), _;
      }, u = this && this.__param || function(f, g) {
        return function(y, p) {
          g(y, p, f);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OscLinkService = void 0;
      const h = l(2585);
      let d = a.OscLinkService = class {
        constructor(f) {
          this._bufferService = f, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
        }
        registerLink(f) {
          const g = this._bufferService.buffer;
          if (f.id === void 0) {
            const v = g.addMarker(g.ybase + g.y), w = { data: f, id: this._nextId++, lines: [v] };
            return v.onDispose(() => this._removeMarkerFromLink(w, v)), this._dataByLinkId.set(w.id, w), w.id;
          }
          const y = f, p = this._getEntryIdKey(y), m = this._entriesWithId.get(p);
          if (m) return this.addLineToLink(m.id, g.ybase + g.y), m.id;
          const b = g.addMarker(g.ybase + g.y), _ = { id: this._nextId++, key: this._getEntryIdKey(y), data: y, lines: [b] };
          return b.onDispose(() => this._removeMarkerFromLink(_, b)), this._entriesWithId.set(_.key, _), this._dataByLinkId.set(_.id, _), _.id;
        }
        addLineToLink(f, g) {
          const y = this._dataByLinkId.get(f);
          if (y && y.lines.every((p) => p.line !== g)) {
            const p = this._bufferService.buffer.addMarker(g);
            y.lines.push(p), p.onDispose(() => this._removeMarkerFromLink(y, p));
          }
        }
        getLinkData(f) {
          return this._dataByLinkId.get(f)?.data;
        }
        _getEntryIdKey(f) {
          return `${f.id};;${f.uri}`;
        }
        _removeMarkerFromLink(f, g) {
          const y = f.lines.indexOf(g);
          y !== -1 && (f.lines.splice(y, 1), f.lines.length === 0 && (f.data.id !== void 0 && this._entriesWithId.delete(f.key), this._dataByLinkId.delete(f.id)));
        }
      };
      a.OscLinkService = d = c([u(0, h.IBufferService)], d);
    }, 8343: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.createDecorator = a.getServiceDependencies = a.serviceRegistry = void 0;
      const l = "di$target", c = "di$dependencies";
      a.serviceRegistry = /* @__PURE__ */ new Map(), a.getServiceDependencies = function(u) {
        return u[c] || [];
      }, a.createDecorator = function(u) {
        if (a.serviceRegistry.has(u)) return a.serviceRegistry.get(u);
        const h = function(d, f, g) {
          if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
          (function(y, p, m) {
            p[l] === p ? p[c].push({ id: y, index: m }) : (p[c] = [{ id: y, index: m }], p[l] = p);
          })(h, d, g);
        };
        return h.toString = () => u, a.serviceRegistry.set(u, h), h;
      };
    }, 2585: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.IDecorationService = a.IUnicodeService = a.IOscLinkService = a.IOptionsService = a.ILogService = a.LogLevelEnum = a.IInstantiationService = a.ICharsetService = a.ICoreService = a.ICoreMouseService = a.IBufferService = void 0;
      const c = l(8343);
      var u;
      a.IBufferService = (0, c.createDecorator)("BufferService"), a.ICoreMouseService = (0, c.createDecorator)("CoreMouseService"), a.ICoreService = (0, c.createDecorator)("CoreService"), a.ICharsetService = (0, c.createDecorator)("CharsetService"), a.IInstantiationService = (0, c.createDecorator)("InstantiationService"), function(h) {
        h[h.TRACE = 0] = "TRACE", h[h.DEBUG = 1] = "DEBUG", h[h.INFO = 2] = "INFO", h[h.WARN = 3] = "WARN", h[h.ERROR = 4] = "ERROR", h[h.OFF = 5] = "OFF";
      }(u || (a.LogLevelEnum = u = {})), a.ILogService = (0, c.createDecorator)("LogService"), a.IOptionsService = (0, c.createDecorator)("OptionsService"), a.IOscLinkService = (0, c.createDecorator)("OscLinkService"), a.IUnicodeService = (0, c.createDecorator)("UnicodeService"), a.IDecorationService = (0, c.createDecorator)("DecorationService");
    }, 1480: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeService = void 0;
      const c = l(8460), u = l(225);
      class h {
        static extractShouldJoin(f) {
          return (1 & f) != 0;
        }
        static extractWidth(f) {
          return f >> 1 & 3;
        }
        static extractCharKind(f) {
          return f >> 3;
        }
        static createPropertyValue(f, g, y = !1) {
          return (16777215 & f) << 3 | (3 & g) << 1 | (y ? 1 : 0);
        }
        constructor() {
          this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new c.EventEmitter(), this.onChange = this._onChange.event;
          const f = new u.UnicodeV6();
          this.register(f), this._active = f.version, this._activeProvider = f;
        }
        dispose() {
          this._onChange.dispose();
        }
        get versions() {
          return Object.keys(this._providers);
        }
        get activeVersion() {
          return this._active;
        }
        set activeVersion(f) {
          if (!this._providers[f]) throw new Error(`unknown Unicode version "${f}"`);
          this._active = f, this._activeProvider = this._providers[f], this._onChange.fire(f);
        }
        register(f) {
          this._providers[f.version] = f;
        }
        wcwidth(f) {
          return this._activeProvider.wcwidth(f);
        }
        getStringCellWidth(f) {
          let g = 0, y = 0;
          const p = f.length;
          for (let m = 0; m < p; ++m) {
            let b = f.charCodeAt(m);
            if (55296 <= b && b <= 56319) {
              if (++m >= p) return g + this.wcwidth(b);
              const w = f.charCodeAt(m);
              56320 <= w && w <= 57343 ? b = 1024 * (b - 55296) + w - 56320 + 65536 : g += this.wcwidth(w);
            }
            const _ = this.charProperties(b, y);
            let v = h.extractWidth(_);
            h.extractShouldJoin(_) && (v -= h.extractWidth(y)), g += v, y = _;
          }
          return g;
        }
        charProperties(f, g) {
          return this._activeProvider.charProperties(f, g);
        }
      }
      a.UnicodeService = h;
    } }, r = {};
    function s(o) {
      var a = r[o];
      if (a !== void 0) return a.exports;
      var l = r[o] = { exports: {} };
      return n[o].call(l.exports, l, l.exports, s), l.exports;
    }
    var i = {};
    return (() => {
      var o = i;
      Object.defineProperty(o, "__esModule", { value: !0 }), o.Terminal = void 0;
      const a = s(9042), l = s(3236), c = s(844), u = s(5741), h = s(8285), d = s(7975), f = s(7090), g = ["cols", "rows"];
      class y extends c.Disposable {
        constructor(m) {
          super(), this._core = this.register(new l.Terminal(m)), this._addonManager = this.register(new u.AddonManager()), this._publicOptions = { ...this._core.options };
          const b = (v) => this._core.options[v], _ = (v, w) => {
            this._checkReadonlyOptions(v), this._core.options[v] = w;
          };
          for (const v in this._core.options) {
            const w = { get: b.bind(this, v), set: _.bind(this, v) };
            Object.defineProperty(this._publicOptions, v, w);
          }
        }
        _checkReadonlyOptions(m) {
          if (g.includes(m)) throw new Error(`Option "${m}" can only be set in the constructor`);
        }
        _checkProposedApi() {
          if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
        }
        get onBell() {
          return this._core.onBell;
        }
        get onBinary() {
          return this._core.onBinary;
        }
        get onCursorMove() {
          return this._core.onCursorMove;
        }
        get onData() {
          return this._core.onData;
        }
        get onKey() {
          return this._core.onKey;
        }
        get onLineFeed() {
          return this._core.onLineFeed;
        }
        get onRender() {
          return this._core.onRender;
        }
        get onResize() {
          return this._core.onResize;
        }
        get onScroll() {
          return this._core.onScroll;
        }
        get onSelectionChange() {
          return this._core.onSelectionChange;
        }
        get onTitleChange() {
          return this._core.onTitleChange;
        }
        get onWriteParsed() {
          return this._core.onWriteParsed;
        }
        get element() {
          return this._core.element;
        }
        get parser() {
          return this._parser || (this._parser = new d.ParserApi(this._core)), this._parser;
        }
        get unicode() {
          return this._checkProposedApi(), new f.UnicodeApi(this._core);
        }
        get textarea() {
          return this._core.textarea;
        }
        get rows() {
          return this._core.rows;
        }
        get cols() {
          return this._core.cols;
        }
        get buffer() {
          return this._buffer || (this._buffer = this.register(new h.BufferNamespaceApi(this._core))), this._buffer;
        }
        get markers() {
          return this._checkProposedApi(), this._core.markers;
        }
        get modes() {
          const m = this._core.coreService.decPrivateModes;
          let b = "none";
          switch (this._core.coreMouseService.activeProtocol) {
            case "X10":
              b = "x10";
              break;
            case "VT200":
              b = "vt200";
              break;
            case "DRAG":
              b = "drag";
              break;
            case "ANY":
              b = "any";
          }
          return { applicationCursorKeysMode: m.applicationCursorKeys, applicationKeypadMode: m.applicationKeypad, bracketedPasteMode: m.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: b, originMode: m.origin, reverseWraparoundMode: m.reverseWraparound, sendFocusMode: m.sendFocus, wraparoundMode: m.wraparound };
        }
        get options() {
          return this._publicOptions;
        }
        set options(m) {
          for (const b in m) this._publicOptions[b] = m[b];
        }
        blur() {
          this._core.blur();
        }
        focus() {
          this._core.focus();
        }
        input(m, b = !0) {
          this._core.input(m, b);
        }
        resize(m, b) {
          this._verifyIntegers(m, b), this._core.resize(m, b);
        }
        open(m) {
          this._core.open(m);
        }
        attachCustomKeyEventHandler(m) {
          this._core.attachCustomKeyEventHandler(m);
        }
        attachCustomWheelEventHandler(m) {
          this._core.attachCustomWheelEventHandler(m);
        }
        registerLinkProvider(m) {
          return this._core.registerLinkProvider(m);
        }
        registerCharacterJoiner(m) {
          return this._checkProposedApi(), this._core.registerCharacterJoiner(m);
        }
        deregisterCharacterJoiner(m) {
          this._checkProposedApi(), this._core.deregisterCharacterJoiner(m);
        }
        registerMarker(m = 0) {
          return this._verifyIntegers(m), this._core.registerMarker(m);
        }
        registerDecoration(m) {
          return this._checkProposedApi(), this._verifyPositiveIntegers(m.x ?? 0, m.width ?? 0, m.height ?? 0), this._core.registerDecoration(m);
        }
        hasSelection() {
          return this._core.hasSelection();
        }
        select(m, b, _) {
          this._verifyIntegers(m, b, _), this._core.select(m, b, _);
        }
        getSelection() {
          return this._core.getSelection();
        }
        getSelectionPosition() {
          return this._core.getSelectionPosition();
        }
        clearSelection() {
          this._core.clearSelection();
        }
        selectAll() {
          this._core.selectAll();
        }
        selectLines(m, b) {
          this._verifyIntegers(m, b), this._core.selectLines(m, b);
        }
        dispose() {
          super.dispose();
        }
        scrollLines(m) {
          this._verifyIntegers(m), this._core.scrollLines(m);
        }
        scrollPages(m) {
          this._verifyIntegers(m), this._core.scrollPages(m);
        }
        scrollToTop() {
          this._core.scrollToTop();
        }
        scrollToBottom() {
          this._core.scrollToBottom();
        }
        scrollToLine(m) {
          this._verifyIntegers(m), this._core.scrollToLine(m);
        }
        clear() {
          this._core.clear();
        }
        write(m, b) {
          this._core.write(m, b);
        }
        writeln(m, b) {
          this._core.write(m), this._core.write(`\r
`, b);
        }
        paste(m) {
          this._core.paste(m);
        }
        refresh(m, b) {
          this._verifyIntegers(m, b), this._core.refresh(m, b);
        }
        reset() {
          this._core.reset();
        }
        clearTextureAtlas() {
          this._core.clearTextureAtlas();
        }
        loadAddon(m) {
          this._addonManager.loadAddon(this, m);
        }
        static get strings() {
          return a;
        }
        _verifyIntegers(...m) {
          for (const b of m) if (b === 1 / 0 || isNaN(b) || b % 1 != 0) throw new Error("This API only accepts integers");
        }
        _verifyPositiveIntegers(...m) {
          for (const b of m) if (b && (b === 1 / 0 || isNaN(b) || b % 1 != 0 || b < 0)) throw new Error("This API only accepts positive integers");
        }
      }
      o.Terminal = y;
    })(), i;
  })());
})(uq);
var sMe = uq.exports;
const iMe = getComputedStyle(document.documentElement), Ht = (t) => iMe.getPropertyValue(t) || void 0;
function kw(t) {
  return {
    cursor: Ht("--bolt-elements-terminal-cursorColor"),
    cursorAccent: Ht("--bolt-elements-terminal-cursorColorAccent"),
    foreground: Ht("--bolt-elements-terminal-textColor"),
    background: Ht("--bolt-elements-terminal-backgroundColor"),
    selectionBackground: Ht("--bolt-elements-terminal-selection-backgroundColor"),
    selectionForeground: Ht("--bolt-elements-terminal-selection-textColor"),
    selectionInactiveBackground: Ht("--bolt-elements-terminal-selection-backgroundColorInactive"),
    // ansi escape code colors
    black: Ht("--bolt-elements-terminal-color-black"),
    red: Ht("--bolt-elements-terminal-color-red"),
    green: Ht("--bolt-elements-terminal-color-green"),
    yellow: Ht("--bolt-elements-terminal-color-yellow"),
    blue: Ht("--bolt-elements-terminal-color-blue"),
    magenta: Ht("--bolt-elements-terminal-color-magenta"),
    cyan: Ht("--bolt-elements-terminal-color-cyan"),
    white: Ht("--bolt-elements-terminal-color-white"),
    brightBlack: Ht("--bolt-elements-terminal-color-brightBlack"),
    brightRed: Ht("--bolt-elements-terminal-color-brightRed"),
    brightGreen: Ht("--bolt-elements-terminal-color-brightGreen"),
    brightYellow: Ht("--bolt-elements-terminal-color-brightYellow"),
    brightBlue: Ht("--bolt-elements-terminal-color-brightBlue"),
    brightMagenta: Ht("--bolt-elements-terminal-color-brightMagenta"),
    brightCyan: Ht("--bolt-elements-terminal-color-brightCyan"),
    brightWhite: Ht("--bolt-elements-terminal-color-brightWhite"),
    ...t
  };
}
const oMe = Sr("Terminal"), wL = I.memo(
  I.forwardRef(
    ({ className: t, theme: e, readonly: n, id: r, onTerminalReady: s, onTerminalResize: i }, o) => {
      const a = I.useRef(null), l = I.useRef();
      return I.useEffect(() => {
        const c = a.current, u = new nMe.FitAddon(), h = new rMe.WebLinksAddon(), d = new sMe.Terminal({
          cursorBlink: !0,
          convertEol: !0,
          disableStdin: n,
          theme: kw(n ? { cursor: "#00000000" } : {}),
          fontSize: 12,
          fontFamily: "Menlo, courier-new, courier, monospace"
        });
        l.current = d, d.loadAddon(u), d.loadAddon(h), d.open(c);
        const f = new ResizeObserver(() => {
          u.fit(), i?.(d.cols, d.rows);
        });
        return f.observe(c), oMe.debug(`Attach [${r}]`), s?.(d), () => {
          f.disconnect(), d.dispose();
        };
      }, []), I.useEffect(() => {
        const c = l.current;
        c.options.theme = kw(n ? { cursor: "#00000000" } : {}), c.options.disableStdin = n;
      }, [e, n]), I.useImperativeHandle(o, () => ({
        reloadStyles: () => {
          const c = l.current;
          c.options.theme = kw(n ? { cursor: "#00000000" } : {});
        }
      }), []), /* @__PURE__ */ k.jsx("div", { className: t, ref: a });
    }
  )
), aMe = Sr("Terminal"), EL = 3, jx = 25, lMe = I.memo(() => {
  const t = mt(We.showTerminal), e = mt(Vg), n = I.useRef([]), r = I.useRef(null), s = I.useRef(!1), [i, o] = I.useState(0), [a, l] = I.useState(1), c = () => {
    a < EL && (l(a + 1), o(a));
  };
  return I.useEffect(() => {
    const { current: u } = r;
    if (!u)
      return;
    const h = u.isCollapsed();
    !t && !h ? u.collapse() : t && h && u.resize(jx), s.current = !1;
  }, [t]), I.useEffect(() => {
    const u = B7.on("toggleTerminal", () => {
      s.current = !0;
    }), h = Vg.subscribe(() => {
      for (const d of Object.values(n.current))
        d?.reloadStyles();
    });
    return () => {
      u(), h();
    };
  }, []), /* @__PURE__ */ k.jsx(
    cd,
    {
      ref: r,
      defaultSize: t ? jx : 0,
      minSize: 10,
      collapsible: !0,
      onExpand: () => {
        s.current || We.toggleTerminal(!0);
      },
      onCollapse: () => {
        s.current || We.toggleTerminal(!1);
      },
      children: /* @__PURE__ */ k.jsx("div", { className: "h-full", children: /* @__PURE__ */ k.jsxs("div", { className: "bg-bolt-elements-terminals-background h-full flex flex-col", children: [
        /* @__PURE__ */ k.jsxs("div", { className: "flex items-center bg-bolt-elements-background-depth-2 border-y border-bolt-elements-borderColor gap-1.5 min-h-[34px] p-2", children: [
          Array.from({ length: a + 1 }, (u, h) => {
            const d = i === h;
            return /* @__PURE__ */ k.jsx(Qe.Fragment, { children: h == 0 ? /* @__PURE__ */ k.jsxs(
              "button",
              {
                className: qe(
                  "flex items-center text-sm cursor-pointer gap-1.5 px-3 py-2 h-full whitespace-nowrap rounded-full",
                  {
                    "bg-bolt-elements-terminals-buttonBackground text-bolt-elements-textSecondary hover:text-bolt-elements-textPrimary": d,
                    "bg-bolt-elements-background-depth-2 text-bolt-elements-textSecondary hover:bg-bolt-elements-terminals-buttonBackground": !d
                  }
                ),
                onClick: () => o(h),
                children: [
                  /* @__PURE__ */ k.jsx("div", { className: "i-ph:terminal-window-duotone text-lg" }),
                  "Bolt Terminal"
                ]
              },
              h
            ) : /* @__PURE__ */ k.jsx(Qe.Fragment, { children: /* @__PURE__ */ k.jsxs(
              "button",
              {
                className: qe(
                  "flex items-center text-sm cursor-pointer gap-1.5 px-3 py-2 h-full whitespace-nowrap rounded-full",
                  {
                    "bg-bolt-elements-terminals-buttonBackground text-bolt-elements-textPrimary": d,
                    "bg-bolt-elements-background-depth-2 text-bolt-elements-textSecondary hover:bg-bolt-elements-terminals-buttonBackground": !d
                  }
                ),
                onClick: () => o(h),
                children: [
                  /* @__PURE__ */ k.jsx("div", { className: "i-ph:terminal-window-duotone text-lg" }),
                  "Terminal ",
                  a > 1 && h
                ]
              },
              h
            ) }) }, h);
          }),
          a < EL && /* @__PURE__ */ k.jsx(Vt, { icon: "i-ph:plus", size: "md", onClick: c }),
          /* @__PURE__ */ k.jsx(
            Vt,
            {
              className: "ml-auto",
              icon: "i-ph:caret-down",
              title: "Close",
              size: "md",
              onClick: () => We.toggleTerminal(!1)
            }
          )
        ] }),
        Array.from({ length: a + 1 }, (u, h) => {
          const d = i === h;
          return aMe.debug(`Starting bolt terminal [${h}]`), h == 0 ? /* @__PURE__ */ k.jsx(
            wL,
            {
              id: `terminal_${h}`,
              className: qe("h-full overflow-hidden", {
                hidden: !d
              }),
              ref: (f) => {
                n.current.push(f);
              },
              onTerminalReady: (f) => We.attachBoltTerminal(f),
              onTerminalResize: (f, g) => We.onTerminalResize(f, g),
              theme: e
            },
            h
          ) : /* @__PURE__ */ k.jsx(
            wL,
            {
              id: `terminal_${h}`,
              className: qe("h-full overflow-hidden", {
                hidden: !d
              }),
              ref: (f) => {
                n.current.push(f);
              },
              onTerminalReady: (f) => We.attachTerminal(f),
              onTerminalResize: (f, g) => We.onTerminalResize(f, g),
              theme: e
            },
            h
          );
        })
      ] }) })
    }
  );
}), cMe = 100 - jx, uMe = { tabSize: 2 }, hMe = I.memo(
  ({
    files: t,
    unsavedFiles: e,
    editorDocument: n,
    selectedFile: r,
    isStreaming: s,
    onFileSelect: i,
    onEditorChange: o,
    onEditorScroll: a,
    onFileSave: l,
    onFileReset: c
  }) => {
    Eu.trace("EditorPanel");
    const u = mt(Vg), h = mt(We.showTerminal), d = I.useMemo(() => {
      if (n)
        return n.filePath.split("/");
    }, [n]), f = I.useMemo(() => n !== void 0 && e?.has(n.filePath), [n, e]);
    return /* @__PURE__ */ k.jsxs(Mx, { direction: "vertical", children: [
      /* @__PURE__ */ k.jsx(cd, { defaultSize: h ? cMe : 100, minSize: 20, children: /* @__PURE__ */ k.jsxs(Mx, { direction: "horizontal", children: [
        /* @__PURE__ */ k.jsx(cd, { defaultSize: 20, minSize: 10, collapsible: !0, children: /* @__PURE__ */ k.jsxs("div", { className: "flex flex-col border-r border-bolt-elements-borderColor h-full", children: [
          /* @__PURE__ */ k.jsxs(bL, { children: [
            /* @__PURE__ */ k.jsx("div", { className: "i-ph:tree-structure-duotone shrink-0" }),
            "Files"
          ] }),
          /* @__PURE__ */ k.jsx(
            iq,
            {
              className: "h-full",
              files: t,
              hideRoot: !0,
              unsavedFiles: e,
              rootFolder: ia,
              selectedFile: r,
              onFileSelect: i
            }
          )
        ] }) }),
        /* @__PURE__ */ k.jsx(Bx, {}),
        /* @__PURE__ */ k.jsxs(cd, { className: "flex flex-col", defaultSize: 80, minSize: 20, children: [
          /* @__PURE__ */ k.jsx(bL, { className: "overflow-x-auto", children: d?.length && /* @__PURE__ */ k.jsxs("div", { className: "flex items-center flex-1 text-sm", children: [
            /* @__PURE__ */ k.jsx(tMe, { pathSegments: d, files: t, onFileSelect: i }),
            f && /* @__PURE__ */ k.jsxs("div", { className: "flex gap-1 ml-auto -mr-1.5", children: [
              /* @__PURE__ */ k.jsxs(xc, { onClick: l, children: [
                /* @__PURE__ */ k.jsx("div", { className: "i-ph:floppy-disk-duotone" }),
                "Save"
              ] }),
              /* @__PURE__ */ k.jsxs(xc, { onClick: c, children: [
                /* @__PURE__ */ k.jsx("div", { className: "i-ph:clock-counter-clockwise-duotone" }),
                "Reset"
              ] })
            ] })
          ] }) }),
          /* @__PURE__ */ k.jsx("div", { className: "h-full flex-1 overflow-hidden", children: /* @__PURE__ */ k.jsx(
            IV,
            {
              theme: u,
              editable: !s && n !== void 0,
              settings: uMe,
              doc: n,
              autoFocusOnDocumentChange: !eNe(),
              onScroll: a,
              onChange: o,
              onSave: l
            }
          ) })
        ] })
      ] }) }),
      /* @__PURE__ */ k.jsx(Bx, {}),
      /* @__PURE__ */ k.jsx(lMe, {})
    ] });
  }
), dMe = I.memo(
  ({
    activePreviewIndex: t,
    setActivePreviewIndex: e,
    isDropdownOpen: n,
    setIsDropdownOpen: r,
    setHasSelectedPreview: s,
    previews: i
  }) => {
    const o = I.useRef(null), a = i.map((l, c) => ({ ...l, index: c })).sort((l, c) => l.port - c.port);
    return I.useEffect(() => {
      const l = (c) => {
        o.current && !o.current.contains(c.target) && r(!1);
      };
      return n ? window.addEventListener("mousedown", l) : window.removeEventListener("mousedown", l), () => {
        window.removeEventListener("mousedown", l);
      };
    }, [n]), /* @__PURE__ */ k.jsxs("div", { className: "relative z-port-dropdown", ref: o, children: [
      /* @__PURE__ */ k.jsx(Vt, { icon: "i-ph:plug", onClick: () => r(!n) }),
      n && /* @__PURE__ */ k.jsxs("div", { className: "absolute right-0 mt-2 bg-bolt-elements-background-depth-2 border border-bolt-elements-borderColor rounded shadow-sm min-w-[140px] dropdown-animation", children: [
        /* @__PURE__ */ k.jsx("div", { className: "px-4 py-2 border-b border-bolt-elements-borderColor text-sm font-semibold text-bolt-elements-textPrimary", children: "Ports" }),
        a.map((l) => /* @__PURE__ */ k.jsx(
          "div",
          {
            className: "flex items-center px-4 py-2 cursor-pointer hover:bg-bolt-elements-item-backgroundActive",
            onClick: () => {
              e(l.index), r(!1), s(!0);
            },
            children: /* @__PURE__ */ k.jsx(
              "span",
              {
                className: t === l.index ? "text-bolt-elements-item-contentAccent" : "text-bolt-elements-item-contentDefault group-hover:text-bolt-elements-item-contentActive",
                children: l.port
              }
            )
          },
          l.port
        ))
      ] })
    ] });
  }
), fMe = I.memo(
  ({ isSelectionMode: t, setIsSelectionMode: e, containerRef: n }) => {
    const [r, s] = I.useState(!1), [i, o] = I.useState(null), [a, l] = I.useState(null), c = I.useRef(null), u = I.useRef(null);
    I.useEffect(() => () => {
      u.current && (u.current.pause(), u.current.srcObject = null, u.current.remove(), u.current = null), c.current && (c.current.getTracks().forEach((y) => y.stop()), c.current = null);
    }, []);
    const h = async () => {
      if (!c.current)
        try {
          const y = await navigator.mediaDevices.getDisplayMedia({
            audio: !1,
            video: {
              displaySurface: "window",
              preferCurrentTab: !0,
              surfaceSwitching: "include",
              systemAudio: "exclude"
            }
          });
          if (y.addEventListener("inactive", () => {
            u.current && (u.current.pause(), u.current.srcObject = null, u.current.remove(), u.current = null), c.current && (c.current.getTracks().forEach((p) => p.stop()), c.current = null), e(!1), o(null), l(null), s(!1);
          }), c.current = y, !u.current) {
            const p = document.createElement("video");
            p.style.opacity = "0", p.style.position = "fixed", p.style.pointerEvents = "none", p.style.zIndex = "-1", document.body.appendChild(p), u.current = p;
          }
          u.current.srcObject = y, await u.current.play();
        } catch (y) {
          console.error("Failed to initialize stream:", y), e(!1), $e.error("Failed to initialize screen capture");
        }
      return c.current;
    }, d = I.useCallback(async () => {
      if (!(!t || !i || !a || !n.current)) {
        s(!0);
        try {
          if (!await h() || !u.current)
            return;
          await new Promise((K) => setTimeout(K, 300));
          const p = document.createElement("canvas");
          p.width = u.current.videoWidth, p.height = u.current.videoHeight;
          const m = p.getContext("2d");
          if (!m)
            throw new Error("Failed to get temporary canvas context");
          m.drawImage(u.current, 0, 0);
          const b = u.current.videoWidth / window.innerWidth, _ = u.current.videoHeight / window.innerHeight, v = window.scrollX, w = window.scrollY + 40, E = n.current.getBoundingClientRect(), x = -9, S = -14, T = Math.round(
            (E.left + Math.min(i.x, a.x) + v + x) * b
          ), R = Math.round(
            (E.top + Math.min(i.y, a.y) + w + S) * _
          ), F = Math.round(Math.abs(a.x - i.x) * b), P = Math.round(Math.abs(a.y - i.y) * _), M = document.createElement("canvas");
          M.width = Math.round(Math.abs(a.x - i.x)), M.height = Math.round(Math.abs(a.y - i.y));
          const A = M.getContext("2d");
          if (!A)
            throw new Error("Failed to get canvas context");
          A.drawImage(p, T, R, F, P, 0, 0, M.width, M.height);
          const V = await new Promise((K, te) => {
            M.toBlob((N) => {
              N ? K(N) : te(new Error("Failed to create blob"));
            }, "image/png");
          }), ee = new FileReader();
          ee.onload = (K) => {
            const te = K.target?.result;
            if (document.querySelector("textarea")) {
              const L = window.__BOLT_SET_UPLOADED_FILES__, j = window.__BOLT_SET_IMAGE_DATA_LIST__, H = window.__BOLT_UPLOADED_FILES__ || [], U = window.__BOLT_IMAGE_DATA_LIST__ || [];
              if (L && j) {
                const Y = new File([V], "screenshot.png", { type: "image/png" });
                L([...H, Y]), j([...U, te]), $e.success("Screenshot captured and added to chat");
              } else
                $e.error("Could not add screenshot to chat");
            }
          }, ee.readAsDataURL(V);
        } catch (y) {
          console.error("Failed to capture screenshot:", y), $e.error("Failed to capture screenshot"), c.current && (c.current.getTracks().forEach((p) => p.stop()), c.current = null);
        } finally {
          s(!1), o(null), l(null), e(!1);
        }
      }
    }, [t, i, a, n, e]), f = I.useCallback(
      (y) => {
        if (y.preventDefault(), y.stopPropagation(), !t)
          return;
        const p = y.currentTarget.getBoundingClientRect(), m = y.clientX - p.left, b = y.clientY - p.top;
        o({ x: m, y: b }), l({ x: m, y: b });
      },
      [t]
    ), g = I.useCallback(
      (y) => {
        if (y.preventDefault(), y.stopPropagation(), !t || !i)
          return;
        const p = y.currentTarget.getBoundingClientRect(), m = y.clientX - p.left, b = y.clientY - p.top;
        l({ x: m, y: b });
      },
      [t, i]
    );
    return t ? /* @__PURE__ */ k.jsx(
      "div",
      {
        className: "absolute inset-0 cursor-crosshair",
        onMouseDown: f,
        onMouseMove: g,
        onMouseUp: d,
        onMouseLeave: () => {
          i && o(null);
        },
        style: {
          backgroundColor: r ? "transparent" : "rgba(0, 0, 0, 0.1)",
          userSelect: "none",
          WebkitUserSelect: "none",
          pointerEvents: "all",
          opacity: r ? 0 : 1,
          zIndex: 50,
          transition: "opacity 0.1s ease-in-out"
        },
        children: i && a && !r && /* @__PURE__ */ k.jsx(
          "div",
          {
            className: "absolute border-2 border-blue-500 bg-blue-200 bg-opacity-20",
            style: {
              left: Math.min(i.x, a.x),
              top: Math.min(i.y, a.y),
              width: Math.abs(a.x - i.x),
              height: Math.abs(a.y - i.y)
            }
          }
        )
      }
    ) : null;
  }
), SL = [
  { name: "Mobile", width: 375, height: 667, icon: "i-ph:device-mobile" },
  { name: "Tablet", width: 768, height: 1024, icon: "i-ph:device-tablet" },
  { name: "Laptop", width: 1366, height: 768, icon: "i-ph:laptop" },
  { name: "Desktop", width: 1920, height: 1080, icon: "i-ph:monitor" }
], pMe = I.memo(() => {
  const t = I.useRef(null), e = I.useRef(null), n = I.useRef(null), [r, s] = I.useState(0), [i, o] = I.useState(!1), [a, l] = I.useState(!1), [c, u] = I.useState(!1), h = I.useRef(!1), d = mt(We.previews), f = d[r], [g, y] = I.useState(""), [p, m] = I.useState(), [b, _] = I.useState(!1), [v, w] = I.useState(!1), [E, x] = I.useState(37.5), S = I.useRef({
    isResizing: !1,
    side: null,
    startX: 0,
    startWidthPercent: 37.5,
    windowWidth: window.innerWidth
  }), T = 2, [R, F] = I.useState(!1), [P, M] = I.useState(SL[0]);
  I.useEffect(() => {
    if (!f) {
      y(""), m(void 0);
      return;
    }
    const { baseUrl: Y } = f;
    y(Y), m(Y);
  }, [f]);
  const A = I.useCallback(
    (Y) => {
      if (!f)
        return !1;
      const { baseUrl: ne } = f;
      return Y === ne ? !0 : Y.startsWith(ne) ? ["/", "?", "#"].includes(Y.charAt(ne.length)) : !1;
    },
    [f]
  ), V = I.useCallback(
    (Y, ne, he, X) => ne.port < X[Y].port ? he : Y,
    []
  );
  I.useEffect(() => {
    if (d.length > 1 && !h.current) {
      const Y = d.reduce(V, 0);
      s(Y);
    }
  }, [d, V]);
  const ee = () => {
    t.current && (t.current.src = t.current.src);
  }, K = async () => {
    !a && e.current ? await e.current.requestFullscreen() : document.fullscreenElement && await document.exitFullscreen();
  };
  I.useEffect(() => {
    const Y = () => {
      l(!!document.fullscreenElement);
    };
    return document.addEventListener("fullscreenchange", Y), () => {
      document.removeEventListener("fullscreenchange", Y);
    };
  }, []);
  const te = () => {
    w((Y) => !Y);
  }, N = (Y, ne) => {
    v && (document.body.style.userSelect = "none", S.current.isResizing = !0, S.current.side = ne, S.current.startX = Y.clientX, S.current.startWidthPercent = E, S.current.windowWidth = window.innerWidth, document.addEventListener("mousemove", L), document.addEventListener("mouseup", j), Y.preventDefault());
  }, L = (Y) => {
    if (!S.current.isResizing)
      return;
    const ne = Y.clientX - S.current.startX, he = S.current.windowWidth, X = ne / he * 100 * T;
    let z = S.current.startWidthPercent;
    S.current.side === "right" ? z = S.current.startWidthPercent + X : S.current.side === "left" && (z = S.current.startWidthPercent - X), z = Math.max(10, Math.min(z, 90)), x(z);
  }, j = () => {
    S.current.isResizing = !1, S.current.side = null, document.removeEventListener("mousemove", L), document.removeEventListener("mouseup", j), document.body.style.userSelect = "";
  };
  I.useEffect(() => {
    const Y = () => {
    };
    return window.addEventListener("resize", Y), () => {
      window.removeEventListener("resize", Y);
    };
  }, []);
  const H = () => /* @__PURE__ */ k.jsx(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        height: "100%",
        pointerEvents: "none"
      },
      children: /* @__PURE__ */ k.jsx(
        "div",
        {
          style: {
            color: "rgba(0,0,0,0.5)",
            fontSize: "10px",
            lineHeight: "5px",
            userSelect: "none",
            marginLeft: "1px"
          },
          children: " "
        }
      )
    }
  ), U = (Y) => {
    if (f?.baseUrl) {
      const ne = f.baseUrl.match(/^https?:\/\/([^.]+)\.local-credentialless\.webcontainer-api\.io/);
      if (ne) {
        const X = `/webcontainer/preview/${ne[1]}`, z = window.open(
          X,
          "_blank",
          `noopener,noreferrer,width=${Y.width},height=${Y.height},menubar=no,toolbar=no,location=no,status=no`
        );
        z && z.focus();
      } else
        console.warn("[Preview] Invalid WebContainer URL:", f.baseUrl);
    }
  };
  return /* @__PURE__ */ k.jsxs(
    "div",
    {
      ref: e,
      className: `w-full h-full flex flex-col relative ${c ? "fixed inset-0 z-50 bg-white" : ""}`,
      children: [
        i && /* @__PURE__ */ k.jsx("div", { className: "z-iframe-overlay w-full h-full absolute", onClick: () => o(!1) }),
        /* @__PURE__ */ k.jsxs("div", { className: "bg-bolt-elements-background-depth-2 p-2 flex items-center gap-2", children: [
          /* @__PURE__ */ k.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ k.jsx(Vt, { icon: "i-ph:arrow-clockwise", onClick: ee }),
            /* @__PURE__ */ k.jsx(
              Vt,
              {
                icon: "i-ph:selection",
                onClick: () => _(!b),
                className: b ? "bg-bolt-elements-background-depth-3" : ""
              }
            )
          ] }),
          /* @__PURE__ */ k.jsx("div", { className: "flex-grow flex items-center gap-1 bg-bolt-elements-preview-addressBar-background border border-bolt-elements-borderColor text-bolt-elements-preview-addressBar-text rounded-full px-3 py-1 text-sm hover:bg-bolt-elements-preview-addressBar-backgroundHover hover:focus-within:bg-bolt-elements-preview-addressBar-backgroundActive focus-within:bg-bolt-elements-preview-addressBar-backgroundActive focus-within-border-bolt-elements-borderColorActive focus-within:text-bolt-elements-preview-addressBar-textActive", children: /* @__PURE__ */ k.jsx(
            "input",
            {
              title: "URL",
              ref: n,
              className: "w-full bg-transparent outline-none",
              type: "text",
              value: g,
              onChange: (Y) => {
                y(Y.target.value);
              },
              onKeyDown: (Y) => {
                Y.key === "Enter" && A(g) && (m(g), n.current && n.current.blur());
              }
            }
          ) }),
          /* @__PURE__ */ k.jsxs("div", { className: "flex items-center gap-2", children: [
            d.length > 1 && /* @__PURE__ */ k.jsx(
              dMe,
              {
                activePreviewIndex: r,
                setActivePreviewIndex: s,
                isDropdownOpen: i,
                setHasSelectedPreview: (Y) => h.current = Y,
                setIsDropdownOpen: o,
                previews: d
              }
            ),
            /* @__PURE__ */ k.jsx(
              Vt,
              {
                icon: "i-ph:devices",
                onClick: te,
                title: v ? "Switch to Responsive Mode" : "Switch to Device Mode"
              }
            ),
            /* @__PURE__ */ k.jsx(
              Vt,
              {
                icon: "i-ph:layout-light",
                onClick: () => u(!c),
                title: c ? "Show Full Interface" : "Show Preview Only"
              }
            ),
            /* @__PURE__ */ k.jsx(
              Vt,
              {
                icon: a ? "i-ph:arrows-in" : "i-ph:arrows-out",
                onClick: K,
                title: a ? "Exit Full Screen" : "Full Screen"
              }
            ),
            /* @__PURE__ */ k.jsxs("div", { className: "flex items-center relative", children: [
              /* @__PURE__ */ k.jsx(
                Vt,
                {
                  icon: "i-ph:arrow-square-out",
                  onClick: () => U(P),
                  title: `Open Preview in ${P.name} Window`
                }
              ),
              /* @__PURE__ */ k.jsx(
                Vt,
                {
                  icon: "i-ph:caret-down",
                  onClick: () => F(!R),
                  className: "ml-1",
                  title: "Select Window Size"
                }
              ),
              R && /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
                /* @__PURE__ */ k.jsx("div", { className: "fixed inset-0 z-50", onClick: () => F(!1) }),
                /* @__PURE__ */ k.jsx("div", { className: "absolute right-0 top-full mt-2 z-50 min-w-[240px] bg-white dark:bg-black rounded-xl shadow-2xl border border-[#E5E7EB] dark:border-[rgba(255,255,255,0.1)] overflow-hidden", children: SL.map((Y) => /* @__PURE__ */ k.jsxs(
                  "button",
                  {
                    className: "w-full px-4 py-3.5 text-left text-[#111827] dark:text-gray-300 text-sm whitespace-nowrap flex items-center gap-3 group hover:bg-[#F5EEFF] dark:hover:bg-gray-900 bg-white dark:bg-black",
                    onClick: () => {
                      M(Y), F(!1), U(Y);
                    },
                    children: [
                      /* @__PURE__ */ k.jsx(
                        "div",
                        {
                          className: `${Y.icon} w-5 h-5 text-[#6B7280] dark:text-gray-400 group-hover:text-[#6D28D9] dark:group-hover:text-[#6D28D9] transition-colors duration-200`
                        }
                      ),
                      /* @__PURE__ */ k.jsxs("div", { className: "flex flex-col", children: [
                        /* @__PURE__ */ k.jsx("span", { className: "font-medium group-hover:text-[#6D28D9] dark:group-hover:text-[#6D28D9] transition-colors duration-200", children: Y.name }),
                        /* @__PURE__ */ k.jsxs("span", { className: "text-xs text-[#6B7280] dark:text-gray-400 group-hover:text-[#6D28D9] dark:group-hover:text-[#6D28D9] transition-colors duration-200", children: [
                          Y.width,
                          "  ",
                          Y.height
                        ] })
                      ] })
                    ]
                  },
                  Y.name
                )) })
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ k.jsx("div", { className: "flex-1 border-t border-bolt-elements-borderColor flex justify-center items-center overflow-auto", children: /* @__PURE__ */ k.jsxs(
          "div",
          {
            style: {
              width: v ? `${E}%` : "100%",
              height: "100%",
              overflow: "visible",
              background: "var(--bolt-elements-background-depth-1)",
              position: "relative",
              display: "flex"
            },
            children: [
              f ? /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
                /* @__PURE__ */ k.jsx(
                  "iframe",
                  {
                    ref: t,
                    title: "preview",
                    className: "border-none w-full h-full bg-bolt-elements-background-depth-1",
                    src: p,
                    sandbox: "allow-scripts allow-forms allow-popups allow-modals allow-storage-access-by-user-activation allow-same-origin",
                    allow: "cross-origin-isolated"
                  }
                ),
                /* @__PURE__ */ k.jsx(
                  fMe,
                  {
                    isSelectionMode: b,
                    setIsSelectionMode: _,
                    containerRef: t
                  }
                )
              ] }) : /* @__PURE__ */ k.jsx("div", { className: "flex w-full h-full justify-center items-center bg-bolt-elements-background-depth-1 text-bolt-elements-textPrimary", children: "No preview available" }),
              v && /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
                /* @__PURE__ */ k.jsx(
                  "div",
                  {
                    onMouseDown: (Y) => N(Y, "left"),
                    style: {
                      position: "absolute",
                      top: 0,
                      left: 0,
                      width: "15px",
                      marginLeft: "-15px",
                      height: "100%",
                      cursor: "ew-resize",
                      background: "rgba(255,255,255,.2)",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      transition: "background 0.2s",
                      userSelect: "none"
                    },
                    onMouseOver: (Y) => Y.currentTarget.style.background = "rgba(255,255,255,.5)",
                    onMouseOut: (Y) => Y.currentTarget.style.background = "rgba(255,255,255,.2)",
                    title: "Drag to resize width",
                    children: /* @__PURE__ */ k.jsx(H, {})
                  }
                ),
                /* @__PURE__ */ k.jsx(
                  "div",
                  {
                    onMouseDown: (Y) => N(Y, "right"),
                    style: {
                      position: "absolute",
                      top: 0,
                      right: 0,
                      width: "15px",
                      marginRight: "-15px",
                      height: "100%",
                      cursor: "ew-resize",
                      background: "rgba(255,255,255,.2)",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      transition: "background 0.2s",
                      userSelect: "none"
                    },
                    onMouseOver: (Y) => Y.currentTarget.style.background = "rgba(255,255,255,.5)",
                    onMouseOut: (Y) => Y.currentTarget.style.background = "rgba(255,255,255,.2)",
                    title: "Drag to resize width",
                    children: /* @__PURE__ */ k.jsx(H, {})
                  }
                )
              ] })
            ]
          }
        ) })
      ]
    }
  );
}), mMe = { ease: xs }, gMe = {
  left: {
    value: "code",
    text: "Code"
  },
  right: {
    value: "preview",
    text: "Preview"
  }
}, yMe = {
  closed: {
    width: 0,
    transition: {
      duration: 0.2,
      ease: xs
    }
  },
  open: {
    width: "var(--workbench-width)",
    transition: {
      duration: 0.2,
      ease: xs
    }
  }
}, bMe = I.memo(({ chatStarted: t, isStreaming: e }) => {
  Eu.trace("Workbench");
  const [n, r] = I.useState(!1), s = mt(MT(We.previews, (w) => w.length > 0)), i = mt(We.showWorkbench), o = mt(We.selectedFile), a = mt(We.currentDocument), l = mt(We.unsavedFiles), c = mt(We.files), u = mt(We.currentView), h = mt(vg), { updateChatMestaData: d } = oH(), f = F7(1024), g = (w) => {
    We.currentView.set(w);
  };
  I.useEffect(() => {
    s && g("preview");
  }, [s]), I.useEffect(() => {
    We.setDocuments(c);
  }, [c]);
  const y = I.useCallback((w) => {
    We.setCurrentDocumentContent(w.content);
  }, []), p = I.useCallback((w) => {
    We.setCurrentDocumentScrollPosition(w);
  }, []), m = I.useCallback((w) => {
    We.setSelectedFile(w);
  }, []), b = I.useCallback(() => {
    We.saveCurrentDocument().catch(() => {
      $e.error("Failed to update file content");
    });
  }, []), _ = I.useCallback(() => {
    We.resetCurrentDocument();
  }, []), v = I.useCallback(async () => {
    r(!0);
    try {
      const w = await window.showDirectoryPicker();
      await We.syncFiles(w), $e.success("Files synced successfully");
    } catch (w) {
      console.error("Error syncing files:", w), $e.error("Failed to sync files");
    } finally {
      r(!1);
    }
  }, []);
  return t && /* @__PURE__ */ k.jsx(
    hn.div,
    {
      initial: "closed",
      animate: i ? "open" : "closed",
      variants: yMe,
      className: "z-workbench",
      children: /* @__PURE__ */ k.jsx(
        "div",
        {
          className: qe(
            "fixed top-[calc(var(--header-height)+1.5rem)] bottom-6 w-[var(--workbench-inner-width)] mr-4 z-0 transition-[left,width] duration-200 bolt-ease-cubic-bezier",
            {
              "w-full": f,
              "left-0": i && f,
              "left-[var(--workbench-left)]": i,
              "left-[100%]": !i
            }
          ),
          children: /* @__PURE__ */ k.jsx("div", { className: "absolute inset-0 px-2 lg:px-6", children: /* @__PURE__ */ k.jsxs("div", { className: "h-full flex flex-col bg-bolt-elements-background-depth-2 border border-bolt-elements-borderColor shadow-sm rounded-lg overflow-hidden", children: [
            /* @__PURE__ */ k.jsxs("div", { className: "flex items-center px-3 py-2 border-b border-bolt-elements-borderColor", children: [
              /* @__PURE__ */ k.jsx(SDe, { selected: u, options: gMe, setSelected: g }),
              /* @__PURE__ */ k.jsx("div", { className: "ml-auto" }),
              u === "code" && /* @__PURE__ */ k.jsxs("div", { className: "flex overflow-y-auto", children: [
                /* @__PURE__ */ k.jsxs(
                  xc,
                  {
                    className: "mr-1 text-sm",
                    onClick: () => {
                      We.downloadZip();
                    },
                    children: [
                      /* @__PURE__ */ k.jsx("div", { className: "i-ph:code" }),
                      "Download Code"
                    ]
                  }
                ),
                /* @__PURE__ */ k.jsxs(xc, { className: "mr-1 text-sm", onClick: v, disabled: n, children: [
                  n ? /* @__PURE__ */ k.jsx("div", { className: "i-ph:spinner" }) : /* @__PURE__ */ k.jsx("div", { className: "i-ph:cloud-arrow-down" }),
                  n ? "Syncing..." : "Sync Files"
                ] }),
                /* @__PURE__ */ k.jsxs(
                  xc,
                  {
                    className: "mr-1 text-sm",
                    onClick: () => {
                      We.toggleTerminal(!We.showTerminal.get());
                    },
                    children: [
                      /* @__PURE__ */ k.jsx("div", { className: "i-ph:terminal" }),
                      "Toggle Terminal"
                    ]
                  }
                ),
                /* @__PURE__ */ k.jsxs(
                  xc,
                  {
                    className: "mr-1 text-sm",
                    onClick: () => {
                      let w = h?.gitUrl?.split("/").slice(-1)[0]?.replace(".git", "") || null, E = !0;
                      if (w && (E = confirm(`Do you want to push to the repository ${w}?`)), (!w || !E) && (w = prompt(
                        "Please enter a name for your new GitHub repository:",
                        "bolt-generated-project"
                      )), !w) {
                        alert("Repository name is required. Push to GitHub cancelled.");
                        return;
                      }
                      let x = nt.get("githubUsername"), S = nt.get("githubToken");
                      if (!x || !S) {
                        const R = prompt("Please enter your GitHub username:"), F = prompt("Please enter your GitHub personal access token:");
                        if (!R || !F) {
                          alert("GitHub username and token are required. Push to GitHub cancelled.");
                          return;
                        }
                        x = R, S = F, nt.set("githubUsername", R), nt.set("githubToken", F), nt.set(
                          "git:github.com",
                          JSON.stringify({ username: F, password: "x-oauth-basic" })
                        );
                      }
                      const T = prompt("Please enter a commit message:", "Initial commit") || "Initial commit";
                      We.pushToGitHub(w, T, x, S), h?.gitUrl || d({
                        ...h || {},
                        gitUrl: `https://github.com/${x}/${w}.git`
                      });
                    },
                    children: [
                      /* @__PURE__ */ k.jsx("div", { className: "i-ph:github-logo" }),
                      "Push to GitHub"
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ k.jsx(
                Vt,
                {
                  icon: "i-ph:x-circle",
                  className: "-mr-1",
                  size: "xl",
                  onClick: () => {
                    We.showWorkbench.set(!1);
                  }
                }
              )
            ] }),
            /* @__PURE__ */ k.jsxs("div", { className: "relative flex-1 overflow-hidden", children: [
              /* @__PURE__ */ k.jsx(
                xL,
                {
                  initial: { x: u === "code" ? 0 : "-100%" },
                  animate: { x: u === "code" ? 0 : "-100%" },
                  children: /* @__PURE__ */ k.jsx(
                    hMe,
                    {
                      editorDocument: a,
                      isStreaming: e,
                      selectedFile: o,
                      files: c,
                      unsavedFiles: l,
                      onFileSelect: m,
                      onEditorScroll: p,
                      onEditorChange: y,
                      onFileSave: b,
                      onFileReset: _
                    }
                  )
                }
              ),
              /* @__PURE__ */ k.jsx(
                xL,
                {
                  initial: { x: u === "preview" ? 0 : "100%" },
                  animate: { x: u === "preview" ? 0 : "100%" },
                  children: /* @__PURE__ */ k.jsx(pMe, {})
                }
              )
            ] })
          ] }) })
        }
      )
    }
  );
}), xL = I.memo(({ children: t, ...e }) => /* @__PURE__ */ k.jsx(hn.div, { className: "absolute inset-0", transition: mMe, ...e, children: t })), _Me = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, vMe = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, wMe = {};
function TL(t, e) {
  return (wMe.jsx ? vMe : _Me).test(t);
}
const EMe = /[ \t\n\f\r]/g;
function SMe(t) {
  return typeof t == "object" ? t.type === "text" ? CL(t.value) : !1 : CL(t);
}
function CL(t) {
  return t.replace(EMe, "") === "";
}
var dq = {}, kL = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, xMe = /\n/g, TMe = /^\s*/, CMe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, kMe = /^:\s*/, AMe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, RMe = /^[;\s]*/, IMe = /^\s+|\s+$/g, PMe = `
`, AL = "/", RL = "*", Fa = "", OMe = "comment", DMe = "declaration", NMe = function(t, e) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t) return [];
  e = e || {};
  var n = 1, r = 1;
  function s(g) {
    var y = g.match(xMe);
    y && (n += y.length);
    var p = g.lastIndexOf(PMe);
    r = ~p ? g.length - p : r + g.length;
  }
  function i() {
    var g = { line: n, column: r };
    return function(y) {
      return y.position = new o(g), c(), y;
    };
  }
  function o(g) {
    this.start = g, this.end = { line: n, column: r }, this.source = e.source;
  }
  o.prototype.content = t;
  function a(g) {
    var y = new Error(
      e.source + ":" + n + ":" + r + ": " + g
    );
    if (y.reason = g, y.filename = e.source, y.line = n, y.column = r, y.source = t, !e.silent) throw y;
  }
  function l(g) {
    var y = g.exec(t);
    if (y) {
      var p = y[0];
      return s(p), t = t.slice(p.length), y;
    }
  }
  function c() {
    l(TMe);
  }
  function u(g) {
    var y;
    for (g = g || []; y = h(); )
      y !== !1 && g.push(y);
    return g;
  }
  function h() {
    var g = i();
    if (!(AL != t.charAt(0) || RL != t.charAt(1))) {
      for (var y = 2; Fa != t.charAt(y) && (RL != t.charAt(y) || AL != t.charAt(y + 1)); )
        ++y;
      if (y += 2, Fa === t.charAt(y - 1))
        return a("End of comment missing");
      var p = t.slice(2, y - 2);
      return r += 2, s(p), t = t.slice(y), r += 2, g({
        type: OMe,
        comment: p
      });
    }
  }
  function d() {
    var g = i(), y = l(CMe);
    if (y) {
      if (h(), !l(kMe)) return a("property missing ':'");
      var p = l(AMe), m = g({
        type: DMe,
        property: IL(y[0].replace(kL, Fa)),
        value: p ? IL(p[0].replace(kL, Fa)) : Fa
      });
      return l(RMe), m;
    }
  }
  function f() {
    var g = [];
    u(g);
    for (var y; y = d(); )
      y !== !1 && (g.push(y), u(g));
    return g;
  }
  return c(), f();
};
function IL(t) {
  return t ? t.replace(IMe, Fa) : Fa;
}
var LMe = Jn && Jn.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(dq, "__esModule", { value: !0 });
var PL = dq.default = BMe, MMe = LMe(NMe);
function BMe(t, e) {
  var n = null;
  if (!t || typeof t != "string")
    return n;
  var r = (0, MMe.default)(t), s = typeof e == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var o = i.property, a = i.value;
      s ? e(o, a, i) : a && (n = n || {}, n[o] = a);
    }
  }), n;
}
const FMe = PL.default || PL, $Me = UMe("start");
function UMe(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function jMe(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? OL(t.position) : "start" in t || "end" in t ? OL(t) : "line" in t || "column" in t ? Hx(t) : "";
}
function Hx(t) {
  return DL(t && t.line) + ":" + DL(t && t.column);
}
function OL(t) {
  return Hx(t && t.start) + "-" + Hx(t && t.end);
}
function DL(t) {
  return t && typeof t == "number" ? t : 1;
}
class Dn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let s = "", i = {}, o = !1;
    if (n && ("line" in n && "column" in n ? i = { place: n } : "start" in n && "end" in n ? i = { place: n } : "type" in n ? i = {
      ancestors: [n],
      place: n.position
    } : i = { ...n }), typeof e == "string" ? s = e : !i.cause && e && (o = !0, s = e.message, i.cause = e), !i.ruleId && !i.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? i.ruleId = r : (i.source = r.slice(0, l), i.ruleId = r.slice(l + 1));
    }
    if (!i.place && i.ancestors && i.ancestors) {
      const l = i.ancestors[i.ancestors.length - 1];
      l && (i.place = l.position);
    }
    const a = i.place && "start" in i.place ? i.place.start : i.place;
    this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file, this.message = s, this.line = a ? a.line : void 0, this.name = jMe(i.place) || "1:1", this.place = i.place || void 0, this.reason = this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = o && i.cause && typeof i.cause.stack == "string" ? i.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Dn.prototype.file = "";
Dn.prototype.name = "";
Dn.prototype.reason = "";
Dn.prototype.message = "";
Dn.prototype.stack = "";
Dn.prototype.column = void 0;
Dn.prototype.line = void 0;
Dn.prototype.ancestors = void 0;
Dn.prototype.cause = void 0;
Dn.prototype.fatal = void 0;
Dn.prototype.place = void 0;
Dn.prototype.ruleId = void 0;
Dn.prototype.source = void 0;
const HA = {}.hasOwnProperty, HMe = /* @__PURE__ */ new Map(), zMe = /[A-Z]/g, GMe = /-([a-z])/g, VMe = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), WMe = /* @__PURE__ */ new Set(["td", "th"]), fq = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function qMe(t, e) {
  if (!e || e.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = e.filePath || void 0;
  let r;
  if (e.development) {
    if (typeof e.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = t3e(n, e.jsxDEV);
  } else {
    if (typeof e.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof e.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = e3e(n, e.jsx, e.jsxs);
  }
  const s = {
    Fragment: e.Fragment,
    ancestors: [],
    components: e.components || {},
    create: r,
    elementAttributeNameCase: e.elementAttributeNameCase || "react",
    evaluater: e.createEvaluater ? e.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: e.ignoreInvalidStyle || !1,
    passKeys: e.passKeys !== !1,
    passNode: e.passNode || !1,
    schema: e.space === "svg" ? Oi : Pu,
    stylePropertyNameCase: e.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: e.tableCellAlignToStyle !== !1
  }, i = pq(s, t, void 0);
  return i && typeof i != "string" ? i : s.create(
    t,
    s.Fragment,
    { children: i || void 0 },
    void 0
  );
}
function pq(t, e, n) {
  if (e.type === "element")
    return KMe(t, e, n);
  if (e.type === "mdxFlowExpression" || e.type === "mdxTextExpression")
    return YMe(t, e);
  if (e.type === "mdxJsxFlowElement" || e.type === "mdxJsxTextElement")
    return JMe(t, e, n);
  if (e.type === "mdxjsEsm")
    return ZMe(t, e);
  if (e.type === "root")
    return XMe(t, e, n);
  if (e.type === "text")
    return QMe(t, e);
}
function KMe(t, e, n) {
  const r = t.schema;
  let s = r;
  e.tagName.toLowerCase() === "svg" && r.space === "html" && (s = Oi, t.schema = s), t.ancestors.push(e);
  const i = gq(t, e.tagName, !1), o = n3e(t, e);
  let a = GA(t, e);
  return VMe.has(e.tagName) && (a = a.filter(function(l) {
    return typeof l == "string" ? !SMe(l) : !0;
  })), mq(t, o, i, e), zA(o, a), t.ancestors.pop(), t.schema = r, t.create(e, i, o, n);
}
function YMe(t, e) {
  if (e.data && e.data.estree && t.evaluater) {
    const r = e.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    t.evaluater.evaluateExpression(r.expression);
  }
  vf(t, e.position);
}
function ZMe(t, e) {
  if (e.data && e.data.estree && t.evaluater)
    return (
      /** @type {Child | undefined} */
      t.evaluater.evaluateProgram(e.data.estree)
    );
  vf(t, e.position);
}
function JMe(t, e, n) {
  const r = t.schema;
  let s = r;
  e.name === "svg" && r.space === "html" && (s = Oi, t.schema = s), t.ancestors.push(e);
  const i = e.name === null ? t.Fragment : gq(t, e.name, !0), o = r3e(t, e), a = GA(t, e);
  return mq(t, o, i, e), zA(o, a), t.ancestors.pop(), t.schema = r, t.create(e, i, o, n);
}
function XMe(t, e, n) {
  const r = {};
  return zA(r, GA(t, e)), t.create(e, t.Fragment, r, n);
}
function QMe(t, e) {
  return e.value;
}
function mq(t, e, n, r) {
  typeof n != "string" && n !== t.Fragment && t.passNode && (e.node = r);
}
function zA(t, e) {
  if (e.length > 0) {
    const n = e.length > 1 ? e : e[0];
    n && (t.children = n);
  }
}
function e3e(t, e, n) {
  return r;
  function r(s, i, o, a) {
    const c = Array.isArray(o.children) ? n : e;
    return a ? c(i, o, a) : c(i, o);
  }
}
function t3e(t, e) {
  return n;
  function n(r, s, i, o) {
    const a = Array.isArray(i.children), l = $Me(r);
    return e(
      s,
      i,
      o,
      a,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: t,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function n3e(t, e) {
  const n = {};
  let r, s;
  for (s in e.properties)
    if (s !== "children" && HA.call(e.properties, s)) {
      const i = s3e(t, s, e.properties[s]);
      if (i) {
        const [o, a] = i;
        t.tableCellAlignToStyle && o === "align" && typeof a == "string" && WMe.has(e.tagName) ? r = a : n[o] = a;
      }
    }
  if (r) {
    const i = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    i[t.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function r3e(t, e) {
  const n = {};
  for (const r of e.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && t.evaluater) {
        const i = r.data.estree.body[0];
        i.type;
        const o = i.expression;
        o.type;
        const a = o.properties[0];
        a.type, Object.assign(
          n,
          t.evaluater.evaluateExpression(a.argument)
        );
      } else
        vf(t, e.position);
    else {
      const s = r.name;
      let i;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && t.evaluater) {
          const a = r.value.data.estree.body[0];
          a.type, i = t.evaluater.evaluateExpression(a.expression);
        } else
          vf(t, e.position);
      else
        i = r.value === null ? !0 : r.value;
      n[s] = /** @type {Props[keyof Props]} */
      i;
    }
  return n;
}
function GA(t, e) {
  const n = [];
  let r = -1;
  const s = t.passKeys ? /* @__PURE__ */ new Map() : HMe;
  for (; ++r < e.children.length; ) {
    const i = e.children[r];
    let o;
    if (t.passKeys) {
      const l = i.type === "element" ? i.tagName : i.type === "mdxJsxFlowElement" || i.type === "mdxJsxTextElement" ? i.name : void 0;
      if (l) {
        const c = s.get(l) || 0;
        o = l + "-" + c, s.set(l, c + 1);
      }
    }
    const a = pq(t, i, o);
    a !== void 0 && n.push(a);
  }
  return n;
}
function s3e(t, e, n) {
  const r = ap(t.schema, e);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? mk(n) : gk(n)), r.property === "style") {
      let s = typeof n == "object" ? n : i3e(t, String(n));
      return t.stylePropertyNameCase === "css" && (s = o3e(s)), ["style", s];
    }
    return [
      t.elementAttributeNameCase === "react" && r.space ? z_e[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function i3e(t, e) {
  const n = {};
  try {
    FMe(e, r);
  } catch (s) {
    if (!t.ignoreInvalidStyle) {
      const i = (
        /** @type {Error} */
        s
      ), o = new Dn("Cannot parse `style` attribute", {
        ancestors: t.ancestors,
        cause: i,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw o.file = t.filePath || void 0, o.url = fq + "#cannot-parse-style-attribute", o;
    }
  }
  return n;
  function r(s, i) {
    let o = s;
    o.slice(0, 2) !== "--" && (o.slice(0, 4) === "-ms-" && (o = "ms-" + o.slice(4)), o = o.replace(GMe, l3e)), n[o] = i;
  }
}
function gq(t, e, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: e };
  else if (e.includes(".")) {
    const s = e.split(".");
    let i = -1, o;
    for (; ++i < s.length; ) {
      const a = TL(s[i]) ? { type: "Identifier", name: s[i] } : { type: "Literal", value: s[i] };
      o = o ? {
        type: "MemberExpression",
        object: o,
        property: a,
        computed: !!(i && a.type === "Literal"),
        optional: !1
      } : a;
    }
    r = o;
  } else
    r = TL(e) && !/^[a-z]/.test(e) ? { type: "Identifier", name: e } : { type: "Literal", value: e };
  if (r.type === "Literal") {
    const s = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return HA.call(t.components, s) ? t.components[s] : s;
  }
  if (t.evaluater)
    return t.evaluater.evaluateExpression(r);
  vf(t);
}
function vf(t, e) {
  const n = new Dn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: t.ancestors,
      place: e,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = t.filePath || void 0, n.url = fq + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function o3e(t) {
  const e = {};
  let n;
  for (n in t)
    HA.call(t, n) && (e[a3e(n)] = t[n]);
  return e;
}
function a3e(t) {
  let e = t.replace(zMe, c3e);
  return e.slice(0, 3) === "ms-" && (e = "-" + e), e;
}
function l3e(t, e) {
  return e.toUpperCase();
}
function c3e(t) {
  return "-" + t.toLowerCase();
}
const Aw = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, u3e = {};
function h3e(t, e) {
  const n = u3e, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, s = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return yq(t, r, s);
}
function yq(t, e, n) {
  if (d3e(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return NL(t.children, e, n);
  }
  return Array.isArray(t) ? NL(t, e, n) : "";
}
function NL(t, e, n) {
  const r = [];
  let s = -1;
  for (; ++s < t.length; )
    r[s] = yq(t[s], e, n);
  return r.join("");
}
function d3e(t) {
  return !!(t && typeof t == "object");
}
function Ai(t, e, n, r) {
  const s = t.length;
  let i = 0, o;
  if (e < 0 ? e = -e > s ? 0 : s + e : e = e > s ? s : e, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, n), t.splice(...o);
  else
    for (n && t.splice(e, n); i < r.length; )
      o = r.slice(i, i + 1e4), o.unshift(e, 0), t.splice(...o), i += 1e4, e += 1e4;
}
function Kr(t, e) {
  return t.length > 0 ? (Ai(t, t.length, 0, e), t) : e;
}
const LL = {}.hasOwnProperty;
function f3e(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    p3e(e, t[n]);
  return e;
}
function p3e(t, e) {
  let n;
  for (n in e) {
    const s = (LL.call(t, n) ? t[n] : void 0) || (t[n] = {}), i = e[n];
    let o;
    if (i)
      for (o in i) {
        LL.call(s, o) || (s[o] = []);
        const a = i[o];
        m3e(
          // @ts-expect-error Looks like a list.
          s[o],
          Array.isArray(a) ? a : a ? [a] : []
        );
      }
  }
}
function m3e(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  Ai(t, 0, 0, r);
}
function bq(t, e) {
  const n = Number.parseInt(t, e);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Hc(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const ci = wa(/[A-Za-z]/), bs = wa(/[\dA-Za-z]/), g3e = wa(/[#-'*+\--9=?A-Z^-~]/);
function zx(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
const Gx = wa(/\d/), y3e = wa(/[\dA-Fa-f]/), b3e = wa(/[!-/:-@[-`{-~]/);
function Xe(t) {
  return t !== null && t < -2;
}
function br(t) {
  return t !== null && (t < 0 || t === 32);
}
function Tt(t) {
  return t === -2 || t === -1 || t === 32;
}
const _3e = wa(/\p{P}|\p{S}/u), v3e = wa(/\s/);
function wa(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function Nt(t, e, n, r) {
  const s = r ? r - 1 : Number.POSITIVE_INFINITY;
  let i = 0;
  return o;
  function o(l) {
    return Tt(l) ? (t.enter(n), a(l)) : e(l);
  }
  function a(l) {
    return Tt(l) && i++ < s ? (t.consume(l), a) : (t.exit(n), e(l));
  }
}
const w3e = {
  tokenize: E3e
};
function E3e(t) {
  const e = t.attempt(this.parser.constructs.contentInitial, r, s);
  let n;
  return e;
  function r(a) {
    if (a === null) {
      t.consume(a);
      return;
    }
    return t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), Nt(t, e, "linePrefix");
  }
  function s(a) {
    return t.enter("paragraph"), i(a);
  }
  function i(a) {
    const l = t.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, o(a);
  }
  function o(a) {
    if (a === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(a);
      return;
    }
    return Xe(a) ? (t.consume(a), t.exit("chunkText"), i) : (t.consume(a), o);
  }
}
const S3e = {
  tokenize: x3e
}, ML = {
  tokenize: T3e
};
function x3e(t) {
  const e = this, n = [];
  let r = 0, s, i, o;
  return a;
  function a(_) {
    if (r < n.length) {
      const v = n[r];
      return e.containerState = v[1], t.attempt(v[0].continuation, l, c)(_);
    }
    return c(_);
  }
  function l(_) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, s && b();
      const v = e.events.length;
      let w = v, E;
      for (; w--; )
        if (e.events[w][0] === "exit" && e.events[w][1].type === "chunkFlow") {
          E = e.events[w][1].end;
          break;
        }
      m(r);
      let x = v;
      for (; x < e.events.length; )
        e.events[x][1].end = {
          ...E
        }, x++;
      return Ai(e.events, w + 1, 0, e.events.slice(v)), e.events.length = x, c(_);
    }
    return a(_);
  }
  function c(_) {
    if (r === n.length) {
      if (!s)
        return d(_);
      if (s.currentConstruct && s.currentConstruct.concrete)
        return g(_);
      e.interrupt = !!(s.currentConstruct && !s._gfmTableDynamicInterruptHack);
    }
    return e.containerState = {}, t.check(ML, u, h)(_);
  }
  function u(_) {
    return s && b(), m(r), d(_);
  }
  function h(_) {
    return e.parser.lazy[e.now().line] = r !== n.length, o = e.now().offset, g(_);
  }
  function d(_) {
    return e.containerState = {}, t.attempt(ML, f, g)(_);
  }
  function f(_) {
    return r++, n.push([e.currentConstruct, e.containerState]), d(_);
  }
  function g(_) {
    if (_ === null) {
      s && b(), m(0), t.consume(_);
      return;
    }
    return s = s || e.parser.flow(e.now()), t.enter("chunkFlow", {
      _tokenizer: s,
      contentType: "flow",
      previous: i
    }), y(_);
  }
  function y(_) {
    if (_ === null) {
      p(t.exit("chunkFlow"), !0), m(0), t.consume(_);
      return;
    }
    return Xe(_) ? (t.consume(_), p(t.exit("chunkFlow")), r = 0, e.interrupt = void 0, a) : (t.consume(_), y);
  }
  function p(_, v) {
    const w = e.sliceStream(_);
    if (v && w.push(null), _.previous = i, i && (i.next = _), i = _, s.defineSkip(_.start), s.write(w), e.parser.lazy[_.start.line]) {
      let E = s.events.length;
      for (; E--; )
        if (
          // The token starts before the line ending
          s.events[E][1].start.offset < o && // and either is not ended yet
          (!s.events[E][1].end || // or ends after it.
          s.events[E][1].end.offset > o)
        )
          return;
      const x = e.events.length;
      let S = x, T, R;
      for (; S--; )
        if (e.events[S][0] === "exit" && e.events[S][1].type === "chunkFlow") {
          if (T) {
            R = e.events[S][1].end;
            break;
          }
          T = !0;
        }
      for (m(r), E = x; E < e.events.length; )
        e.events[E][1].end = {
          ...R
        }, E++;
      Ai(e.events, S + 1, 0, e.events.slice(x)), e.events.length = E;
    }
  }
  function m(_) {
    let v = n.length;
    for (; v-- > _; ) {
      const w = n[v];
      e.containerState = w[1], w[0].exit.call(e, t);
    }
    n.length = _;
  }
  function b() {
    s.write([null]), i = void 0, s = void 0, e.containerState._closeFlow = void 0;
  }
}
function T3e(t, e, n) {
  return Nt(t, t.attempt(this.parser.constructs.document, e, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function BL(t) {
  if (t === null || br(t) || v3e(t))
    return 1;
  if (_3e(t))
    return 2;
}
function VA(t, e, n) {
  const r = [];
  let s = -1;
  for (; ++s < t.length; ) {
    const i = t[s].resolveAll;
    i && !r.includes(i) && (e = i(e, n), r.push(i));
  }
  return e;
}
const Vx = {
  name: "attention",
  resolveAll: C3e,
  tokenize: k3e
};
function C3e(t, e) {
  let n = -1, r, s, i, o, a, l, c, u;
  for (; ++n < t.length; )
    if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) {
      for (r = n; r--; )
        if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && // If the markers are the same:
        e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)) {
          if ((t[r][1]._close || t[n][1]._open) && (t[n][1].end.offset - t[n][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3))
            continue;
          l = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...t[r][1].end
          }, d = {
            ...t[n][1].start
          };
          FL(h, -l), FL(d, l), o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...t[r][1].end
            }
          }, a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...t[n][1].start
            },
            end: d
          }, i = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: {
              ...t[r][1].end
            },
            end: {
              ...t[n][1].start
            }
          }, s = {
            type: l > 1 ? "strong" : "emphasis",
            start: {
              ...o.start
            },
            end: {
              ...a.end
            }
          }, t[r][1].end = {
            ...o.start
          }, t[n][1].start = {
            ...a.end
          }, c = [], t[r][1].end.offset - t[r][1].start.offset && (c = Kr(c, [["enter", t[r][1], e], ["exit", t[r][1], e]])), c = Kr(c, [["enter", s, e], ["enter", o, e], ["exit", o, e], ["enter", i, e]]), c = Kr(c, VA(e.parser.constructs.insideSpan.null, t.slice(r + 1, n), e)), c = Kr(c, [["exit", i, e], ["enter", a, e], ["exit", a, e], ["exit", s, e]]), t[n][1].end.offset - t[n][1].start.offset ? (u = 2, c = Kr(c, [["enter", t[n][1], e], ["exit", t[n][1], e]])) : u = 0, Ai(t, r - 1, n - r + 3, c), n = r + c.length - u - 2;
          break;
        }
    }
  for (n = -1; ++n < t.length; )
    t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
  return t;
}
function k3e(t, e) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, s = BL(r);
  let i;
  return o;
  function o(l) {
    return i = l, t.enter("attentionSequence"), a(l);
  }
  function a(l) {
    if (l === i)
      return t.consume(l), a;
    const c = t.exit("attentionSequence"), u = BL(l), h = !u || u === 2 && s || n.includes(l), d = !s || s === 2 && u || n.includes(r);
    return c._open = !!(i === 42 ? h : h && (s || !d)), c._close = !!(i === 42 ? d : d && (u || !h)), e(l);
  }
}
function FL(t, e) {
  t.column += e, t.offset += e, t._bufferIndex += e;
}
const A3e = {
  name: "autolink",
  tokenize: R3e
};
function R3e(t, e, n) {
  let r = 0;
  return s;
  function s(f) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(f), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), i;
  }
  function i(f) {
    return ci(f) ? (t.consume(f), o) : f === 64 ? n(f) : c(f);
  }
  function o(f) {
    return f === 43 || f === 45 || f === 46 || bs(f) ? (r = 1, a(f)) : c(f);
  }
  function a(f) {
    return f === 58 ? (t.consume(f), r = 0, l) : (f === 43 || f === 45 || f === 46 || bs(f)) && r++ < 32 ? (t.consume(f), a) : (r = 0, c(f));
  }
  function l(f) {
    return f === 62 ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(f), t.exit("autolinkMarker"), t.exit("autolink"), e) : f === null || f === 32 || f === 60 || zx(f) ? n(f) : (t.consume(f), l);
  }
  function c(f) {
    return f === 64 ? (t.consume(f), u) : g3e(f) ? (t.consume(f), c) : n(f);
  }
  function u(f) {
    return bs(f) ? h(f) : n(f);
  }
  function h(f) {
    return f === 46 ? (t.consume(f), r = 0, u) : f === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", t.enter("autolinkMarker"), t.consume(f), t.exit("autolinkMarker"), t.exit("autolink"), e) : d(f);
  }
  function d(f) {
    if ((f === 45 || bs(f)) && r++ < 63) {
      const g = f === 45 ? d : h;
      return t.consume(f), g;
    }
    return n(f);
  }
}
const p_ = {
  partial: !0,
  tokenize: I3e
};
function I3e(t, e, n) {
  return r;
  function r(i) {
    return Tt(i) ? Nt(t, s, "linePrefix")(i) : s(i);
  }
  function s(i) {
    return i === null || Xe(i) ? e(i) : n(i);
  }
}
const _q = {
  continuation: {
    tokenize: O3e
  },
  exit: D3e,
  name: "blockQuote",
  tokenize: P3e
};
function P3e(t, e, n) {
  const r = this;
  return s;
  function s(o) {
    if (o === 62) {
      const a = r.containerState;
      return a.open || (t.enter("blockQuote", {
        _container: !0
      }), a.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(o), t.exit("blockQuoteMarker"), i;
    }
    return n(o);
  }
  function i(o) {
    return Tt(o) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(o), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), e) : (t.exit("blockQuotePrefix"), e(o));
  }
}
function O3e(t, e, n) {
  const r = this;
  return s;
  function s(o) {
    return Tt(o) ? Nt(t, i, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : i(o);
  }
  function i(o) {
    return t.attempt(_q, e, n)(o);
  }
}
function D3e(t) {
  t.exit("blockQuote");
}
const vq = {
  name: "characterEscape",
  tokenize: N3e
};
function N3e(t, e, n) {
  return r;
  function r(i) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(i), t.exit("escapeMarker"), s;
  }
  function s(i) {
    return b3e(i) ? (t.enter("characterEscapeValue"), t.consume(i), t.exit("characterEscapeValue"), t.exit("characterEscape"), e) : n(i);
  }
}
const wq = {
  name: "characterReference",
  tokenize: L3e
};
function L3e(t, e, n) {
  const r = this;
  let s = 0, i, o;
  return a;
  function a(h) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), l;
  }
  function l(h) {
    return h === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(h), t.exit("characterReferenceMarkerNumeric"), c) : (t.enter("characterReferenceValue"), i = 31, o = bs, u(h));
  }
  function c(h) {
    return h === 88 || h === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(h), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), i = 6, o = y3e, u) : (t.enter("characterReferenceValue"), i = 7, o = Gx, u(h));
  }
  function u(h) {
    if (h === 59 && s) {
      const d = t.exit("characterReferenceValue");
      return o === bs && !Ck(r.sliceSerialize(d)) ? n(h) : (t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), t.exit("characterReference"), e);
    }
    return o(h) && s++ < i ? (t.consume(h), u) : n(h);
  }
}
const $L = {
  partial: !0,
  tokenize: B3e
}, UL = {
  concrete: !0,
  name: "codeFenced",
  tokenize: M3e
};
function M3e(t, e, n) {
  const r = this, s = {
    partial: !0,
    tokenize: w
  };
  let i = 0, o = 0, a;
  return l;
  function l(E) {
    return c(E);
  }
  function c(E) {
    const x = r.events[r.events.length - 1];
    return i = x && x[1].type === "linePrefix" ? x[2].sliceSerialize(x[1], !0).length : 0, a = E, t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), u(E);
  }
  function u(E) {
    return E === a ? (o++, t.consume(E), u) : o < 3 ? n(E) : (t.exit("codeFencedFenceSequence"), Tt(E) ? Nt(t, h, "whitespace")(E) : h(E));
  }
  function h(E) {
    return E === null || Xe(E) ? (t.exit("codeFencedFence"), r.interrupt ? e(E) : t.check($L, y, v)(E)) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", {
      contentType: "string"
    }), d(E));
  }
  function d(E) {
    return E === null || Xe(E) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), h(E)) : Tt(E) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), Nt(t, f, "whitespace")(E)) : E === 96 && E === a ? n(E) : (t.consume(E), d);
  }
  function f(E) {
    return E === null || Xe(E) ? h(E) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", {
      contentType: "string"
    }), g(E));
  }
  function g(E) {
    return E === null || Xe(E) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), h(E)) : E === 96 && E === a ? n(E) : (t.consume(E), g);
  }
  function y(E) {
    return t.attempt(s, v, p)(E);
  }
  function p(E) {
    return t.enter("lineEnding"), t.consume(E), t.exit("lineEnding"), m;
  }
  function m(E) {
    return i > 0 && Tt(E) ? Nt(t, b, "linePrefix", i + 1)(E) : b(E);
  }
  function b(E) {
    return E === null || Xe(E) ? t.check($L, y, v)(E) : (t.enter("codeFlowValue"), _(E));
  }
  function _(E) {
    return E === null || Xe(E) ? (t.exit("codeFlowValue"), b(E)) : (t.consume(E), _);
  }
  function v(E) {
    return t.exit("codeFenced"), e(E);
  }
  function w(E, x, S) {
    let T = 0;
    return R;
    function R(V) {
      return E.enter("lineEnding"), E.consume(V), E.exit("lineEnding"), F;
    }
    function F(V) {
      return E.enter("codeFencedFence"), Tt(V) ? Nt(E, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(V) : P(V);
    }
    function P(V) {
      return V === a ? (E.enter("codeFencedFenceSequence"), M(V)) : S(V);
    }
    function M(V) {
      return V === a ? (T++, E.consume(V), M) : T >= o ? (E.exit("codeFencedFenceSequence"), Tt(V) ? Nt(E, A, "whitespace")(V) : A(V)) : S(V);
    }
    function A(V) {
      return V === null || Xe(V) ? (E.exit("codeFencedFence"), x(V)) : S(V);
    }
  }
}
function B3e(t, e, n) {
  const r = this;
  return s;
  function s(o) {
    return o === null ? n(o) : (t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), i);
  }
  function i(o) {
    return r.parser.lazy[r.now().line] ? n(o) : e(o);
  }
}
const Rw = {
  name: "codeIndented",
  tokenize: $3e
}, F3e = {
  partial: !0,
  tokenize: U3e
};
function $3e(t, e, n) {
  const r = this;
  return s;
  function s(c) {
    return t.enter("codeIndented"), Nt(t, i, "linePrefix", 5)(c);
  }
  function i(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : n(c);
  }
  function o(c) {
    return c === null ? l(c) : Xe(c) ? t.attempt(F3e, o, l)(c) : (t.enter("codeFlowValue"), a(c));
  }
  function a(c) {
    return c === null || Xe(c) ? (t.exit("codeFlowValue"), o(c)) : (t.consume(c), a);
  }
  function l(c) {
    return t.exit("codeIndented"), e(c);
  }
}
function U3e(t, e, n) {
  const r = this;
  return s;
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : Xe(o) ? (t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), s) : Nt(t, i, "linePrefix", 5)(o);
  }
  function i(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : Xe(o) ? s(o) : n(o);
  }
}
const j3e = {
  name: "codeText",
  previous: z3e,
  resolve: H3e,
  tokenize: G3e
};
function H3e(t) {
  let e = t.length - 4, n = 3, r, s;
  if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) {
    for (r = n; ++r < e; )
      if (t[r][1].type === "codeTextData") {
        t[n][1].type = "codeTextPadding", t[e][1].type = "codeTextPadding", n += 2, e -= 2;
        break;
      }
  }
  for (r = n - 1, e++; ++r <= e; )
    s === void 0 ? r !== e && t[r][1].type !== "lineEnding" && (s = r) : (r === e || t[r][1].type === "lineEnding") && (t[s][1].type = "codeTextData", r !== s + 2 && (t[s][1].end = t[r - 1][1].end, t.splice(s + 2, r - s - 2), e -= r - s - 2, r = s + 2), s = void 0);
  return t;
}
function z3e(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function G3e(t, e, n) {
  let r = 0, s, i;
  return o;
  function o(h) {
    return t.enter("codeText"), t.enter("codeTextSequence"), a(h);
  }
  function a(h) {
    return h === 96 ? (t.consume(h), r++, a) : (t.exit("codeTextSequence"), l(h));
  }
  function l(h) {
    return h === null ? n(h) : h === 32 ? (t.enter("space"), t.consume(h), t.exit("space"), l) : h === 96 ? (i = t.enter("codeTextSequence"), s = 0, u(h)) : Xe(h) ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), l) : (t.enter("codeTextData"), c(h));
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || Xe(h) ? (t.exit("codeTextData"), l(h)) : (t.consume(h), c);
  }
  function u(h) {
    return h === 96 ? (t.consume(h), s++, u) : s === r ? (t.exit("codeTextSequence"), t.exit("codeText"), e(h)) : (i.type = "codeTextData", c(h));
  }
}
class V3e {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(e) {
    this.left = e ? [...e] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(e, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(e, n, r) {
    const s = n || 0;
    this.setCursor(Math.trunc(e));
    const i = this.right.splice(this.right.length - s, Number.POSITIVE_INFINITY);
    return r && ph(this.left, r), i.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), ph(this.left, e);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(e) {
    this.setCursor(0), ph(this.right, e.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(e) {
    if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
      if (e < this.left.length) {
        const n = this.left.splice(e, Number.POSITIVE_INFINITY);
        ph(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        ph(this.left, n.reverse());
      }
  }
}
function ph(t, e) {
  let n = 0;
  if (e.length < 1e4)
    t.push(...e);
  else
    for (; n < e.length; )
      t.push(...e.slice(n, n + 1e4)), n += 1e4;
}
function Eq(t) {
  const e = {};
  let n = -1, r, s, i, o, a, l, c;
  const u = new V3e(t);
  for (; ++n < u.length; ) {
    for (; n in e; )
      n = e[n];
    if (r = u.get(n), n && r[1].type === "chunkFlow" && u.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, i = 0, i < l.length && l[i][1].type === "lineEndingBlank" && (i += 2), i < l.length && l[i][1].type === "content"))
      for (; ++i < l.length && l[i][1].type !== "content"; )
        l[i][1].type === "chunkText" && (l[i][1]._isInFirstContentOfListItem = !0, i++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, W3e(u, n)), n = e[n], c = !0);
    else if (r[1]._container) {
      for (i = n, s = void 0; i--; )
        if (o = u.get(i), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank")
          o[0] === "enter" && (s && (u.get(s)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", s = i);
        else if (o[1].type !== "linePrefix") break;
      s && (r[1].end = {
        ...u.get(s)[1].start
      }, a = u.slice(s, n), a.unshift(r), u.splice(s, n - s + 1, a));
    }
  }
  return Ai(t, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function W3e(t, e) {
  const n = t.get(e)[1], r = t.get(e)[2];
  let s = e - 1;
  const i = [], o = n._tokenizer || r.parser[n.contentType](n.start), a = o.events, l = [], c = {};
  let u, h, d = -1, f = n, g = 0, y = 0;
  const p = [y];
  for (; f; ) {
    for (; t.get(++s)[1] !== f; )
      ;
    i.push(s), f._tokenizer || (u = r.sliceStream(f), f.next || u.push(null), h && o.defineSkip(f.start), f._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), f._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = f, f = f.next;
  }
  for (f = n; ++d < a.length; )
    // Find a void token that includes a break.
    a[d][0] === "exit" && a[d - 1][0] === "enter" && a[d][1].type === a[d - 1][1].type && a[d][1].start.line !== a[d][1].end.line && (y = d + 1, p.push(y), f._tokenizer = void 0, f.previous = void 0, f = f.next);
  for (o.events = [], f ? (f._tokenizer = void 0, f.previous = void 0) : p.pop(), d = p.length; d--; ) {
    const m = a.slice(p[d], p[d + 1]), b = i.pop();
    l.push([b, b + m.length - 1]), t.splice(b, 2, m);
  }
  for (l.reverse(), d = -1; ++d < l.length; )
    c[g + l[d][0]] = g + l[d][1], g += l[d][1] - l[d][0] - 1;
  return c;
}
const q3e = {
  resolve: Y3e,
  tokenize: Z3e
}, K3e = {
  partial: !0,
  tokenize: J3e
};
function Y3e(t) {
  return Eq(t), t;
}
function Z3e(t, e) {
  let n;
  return r;
  function r(a) {
    return t.enter("content"), n = t.enter("chunkContent", {
      contentType: "content"
    }), s(a);
  }
  function s(a) {
    return a === null ? i(a) : Xe(a) ? t.check(K3e, o, i)(a) : (t.consume(a), s);
  }
  function i(a) {
    return t.exit("chunkContent"), t.exit("content"), e(a);
  }
  function o(a) {
    return t.consume(a), t.exit("chunkContent"), n.next = t.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, s;
  }
}
function J3e(t, e, n) {
  const r = this;
  return s;
  function s(o) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), Nt(t, i, "linePrefix");
  }
  function i(o) {
    if (o === null || Xe(o))
      return n(o);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : t.interrupt(r.parser.constructs.flow, n, e)(o);
  }
}
function Sq(t, e, n, r, s, i, o, a, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let u = 0;
  return h;
  function h(m) {
    return m === 60 ? (t.enter(r), t.enter(s), t.enter(i), t.consume(m), t.exit(i), d) : m === null || m === 32 || m === 41 || zx(m) ? n(m) : (t.enter(r), t.enter(o), t.enter(a), t.enter("chunkString", {
      contentType: "string"
    }), y(m));
  }
  function d(m) {
    return m === 62 ? (t.enter(i), t.consume(m), t.exit(i), t.exit(s), t.exit(r), e) : (t.enter(a), t.enter("chunkString", {
      contentType: "string"
    }), f(m));
  }
  function f(m) {
    return m === 62 ? (t.exit("chunkString"), t.exit(a), d(m)) : m === null || m === 60 || Xe(m) ? n(m) : (t.consume(m), m === 92 ? g : f);
  }
  function g(m) {
    return m === 60 || m === 62 || m === 92 ? (t.consume(m), f) : f(m);
  }
  function y(m) {
    return !u && (m === null || m === 41 || br(m)) ? (t.exit("chunkString"), t.exit(a), t.exit(o), t.exit(r), e(m)) : u < c && m === 40 ? (t.consume(m), u++, y) : m === 41 ? (t.consume(m), u--, y) : m === null || m === 32 || m === 40 || zx(m) ? n(m) : (t.consume(m), m === 92 ? p : y);
  }
  function p(m) {
    return m === 40 || m === 41 || m === 92 ? (t.consume(m), y) : y(m);
  }
}
function xq(t, e, n, r, s, i) {
  const o = this;
  let a = 0, l;
  return c;
  function c(f) {
    return t.enter(r), t.enter(s), t.consume(f), t.exit(s), t.enter(i), u;
  }
  function u(f) {
    return a > 999 || f === null || f === 91 || f === 93 && !l || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    f === 94 && !a && "_hiddenFootnoteSupport" in o.parser.constructs ? n(f) : f === 93 ? (t.exit(i), t.enter(s), t.consume(f), t.exit(s), t.exit(r), e) : Xe(f) ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), u) : (t.enter("chunkString", {
      contentType: "string"
    }), h(f));
  }
  function h(f) {
    return f === null || f === 91 || f === 93 || Xe(f) || a++ > 999 ? (t.exit("chunkString"), u(f)) : (t.consume(f), l || (l = !Tt(f)), f === 92 ? d : h);
  }
  function d(f) {
    return f === 91 || f === 92 || f === 93 ? (t.consume(f), a++, h) : h(f);
  }
}
function Tq(t, e, n, r, s, i) {
  let o;
  return a;
  function a(d) {
    return d === 34 || d === 39 || d === 40 ? (t.enter(r), t.enter(s), t.consume(d), t.exit(s), o = d === 40 ? 41 : d, l) : n(d);
  }
  function l(d) {
    return d === o ? (t.enter(s), t.consume(d), t.exit(s), t.exit(r), e) : (t.enter(i), c(d));
  }
  function c(d) {
    return d === o ? (t.exit(i), l(o)) : d === null ? n(d) : Xe(d) ? (t.enter("lineEnding"), t.consume(d), t.exit("lineEnding"), Nt(t, c, "linePrefix")) : (t.enter("chunkString", {
      contentType: "string"
    }), u(d));
  }
  function u(d) {
    return d === o || d === null || Xe(d) ? (t.exit("chunkString"), c(d)) : (t.consume(d), d === 92 ? h : u);
  }
  function h(d) {
    return d === o || d === 92 ? (t.consume(d), u) : u(d);
  }
}
function ud(t, e) {
  let n;
  return r;
  function r(s) {
    return Xe(s) ? (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), n = !0, r) : Tt(s) ? Nt(t, r, n ? "linePrefix" : "lineSuffix")(s) : e(s);
  }
}
const X3e = {
  name: "definition",
  tokenize: eBe
}, Q3e = {
  partial: !0,
  tokenize: tBe
};
function eBe(t, e, n) {
  const r = this;
  let s;
  return i;
  function i(f) {
    return t.enter("definition"), o(f);
  }
  function o(f) {
    return xq.call(
      r,
      t,
      a,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(f);
  }
  function a(f) {
    return s = Hc(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), f === 58 ? (t.enter("definitionMarker"), t.consume(f), t.exit("definitionMarker"), l) : n(f);
  }
  function l(f) {
    return br(f) ? ud(t, c)(f) : c(f);
  }
  function c(f) {
    return Sq(
      t,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(f);
  }
  function u(f) {
    return t.attempt(Q3e, h, h)(f);
  }
  function h(f) {
    return Tt(f) ? Nt(t, d, "whitespace")(f) : d(f);
  }
  function d(f) {
    return f === null || Xe(f) ? (t.exit("definition"), r.parser.defined.push(s), e(f)) : n(f);
  }
}
function tBe(t, e, n) {
  return r;
  function r(a) {
    return br(a) ? ud(t, s)(a) : n(a);
  }
  function s(a) {
    return Tq(t, i, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a);
  }
  function i(a) {
    return Tt(a) ? Nt(t, o, "whitespace")(a) : o(a);
  }
  function o(a) {
    return a === null || Xe(a) ? e(a) : n(a);
  }
}
const nBe = {
  name: "hardBreakEscape",
  tokenize: rBe
};
function rBe(t, e, n) {
  return r;
  function r(i) {
    return t.enter("hardBreakEscape"), t.consume(i), s;
  }
  function s(i) {
    return Xe(i) ? (t.exit("hardBreakEscape"), e(i)) : n(i);
  }
}
const sBe = {
  name: "headingAtx",
  resolve: iBe,
  tokenize: oBe
};
function iBe(t, e) {
  let n = t.length - 2, r = 3, s, i;
  return t[r][1].type === "whitespace" && (r += 2), n - 2 > r && t[n][1].type === "whitespace" && (n -= 2), t[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && t[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (s = {
    type: "atxHeadingText",
    start: t[r][1].start,
    end: t[n][1].end
  }, i = {
    type: "chunkText",
    start: t[r][1].start,
    end: t[n][1].end,
    contentType: "text"
  }, Ai(t, r, n - r + 1, [["enter", s, e], ["enter", i, e], ["exit", i, e], ["exit", s, e]])), t;
}
function oBe(t, e, n) {
  let r = 0;
  return s;
  function s(u) {
    return t.enter("atxHeading"), i(u);
  }
  function i(u) {
    return t.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (t.consume(u), o) : u === null || br(u) ? (t.exit("atxHeadingSequence"), a(u)) : n(u);
  }
  function a(u) {
    return u === 35 ? (t.enter("atxHeadingSequence"), l(u)) : u === null || Xe(u) ? (t.exit("atxHeading"), e(u)) : Tt(u) ? Nt(t, a, "whitespace")(u) : (t.enter("atxHeadingText"), c(u));
  }
  function l(u) {
    return u === 35 ? (t.consume(u), l) : (t.exit("atxHeadingSequence"), a(u));
  }
  function c(u) {
    return u === null || u === 35 || br(u) ? (t.exit("atxHeadingText"), a(u)) : (t.consume(u), c);
  }
}
const aBe = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], jL = ["pre", "script", "style", "textarea"], lBe = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: hBe,
  tokenize: dBe
}, cBe = {
  partial: !0,
  tokenize: pBe
}, uBe = {
  partial: !0,
  tokenize: fBe
};
function hBe(t) {
  let e = t.length;
  for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && t[e - 2][1].type === "linePrefix" && (t[e][1].start = t[e - 2][1].start, t[e + 1][1].start = t[e - 2][1].start, t.splice(e - 2, 2)), t;
}
function dBe(t, e, n) {
  const r = this;
  let s, i, o, a, l;
  return c;
  function c(U) {
    return u(U);
  }
  function u(U) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(U), h;
  }
  function h(U) {
    return U === 33 ? (t.consume(U), d) : U === 47 ? (t.consume(U), i = !0, y) : U === 63 ? (t.consume(U), s = 3, r.interrupt ? e : L) : ci(U) ? (t.consume(U), o = String.fromCharCode(U), p) : n(U);
  }
  function d(U) {
    return U === 45 ? (t.consume(U), s = 2, f) : U === 91 ? (t.consume(U), s = 5, a = 0, g) : ci(U) ? (t.consume(U), s = 4, r.interrupt ? e : L) : n(U);
  }
  function f(U) {
    return U === 45 ? (t.consume(U), r.interrupt ? e : L) : n(U);
  }
  function g(U) {
    const Y = "CDATA[";
    return U === Y.charCodeAt(a++) ? (t.consume(U), a === Y.length ? r.interrupt ? e : P : g) : n(U);
  }
  function y(U) {
    return ci(U) ? (t.consume(U), o = String.fromCharCode(U), p) : n(U);
  }
  function p(U) {
    if (U === null || U === 47 || U === 62 || br(U)) {
      const Y = U === 47, ne = o.toLowerCase();
      return !Y && !i && jL.includes(ne) ? (s = 1, r.interrupt ? e(U) : P(U)) : aBe.includes(o.toLowerCase()) ? (s = 6, Y ? (t.consume(U), m) : r.interrupt ? e(U) : P(U)) : (s = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(U) : i ? b(U) : _(U));
    }
    return U === 45 || bs(U) ? (t.consume(U), o += String.fromCharCode(U), p) : n(U);
  }
  function m(U) {
    return U === 62 ? (t.consume(U), r.interrupt ? e : P) : n(U);
  }
  function b(U) {
    return Tt(U) ? (t.consume(U), b) : R(U);
  }
  function _(U) {
    return U === 47 ? (t.consume(U), R) : U === 58 || U === 95 || ci(U) ? (t.consume(U), v) : Tt(U) ? (t.consume(U), _) : R(U);
  }
  function v(U) {
    return U === 45 || U === 46 || U === 58 || U === 95 || bs(U) ? (t.consume(U), v) : w(U);
  }
  function w(U) {
    return U === 61 ? (t.consume(U), E) : Tt(U) ? (t.consume(U), w) : _(U);
  }
  function E(U) {
    return U === null || U === 60 || U === 61 || U === 62 || U === 96 ? n(U) : U === 34 || U === 39 ? (t.consume(U), l = U, x) : Tt(U) ? (t.consume(U), E) : S(U);
  }
  function x(U) {
    return U === l ? (t.consume(U), l = null, T) : U === null || Xe(U) ? n(U) : (t.consume(U), x);
  }
  function S(U) {
    return U === null || U === 34 || U === 39 || U === 47 || U === 60 || U === 61 || U === 62 || U === 96 || br(U) ? w(U) : (t.consume(U), S);
  }
  function T(U) {
    return U === 47 || U === 62 || Tt(U) ? _(U) : n(U);
  }
  function R(U) {
    return U === 62 ? (t.consume(U), F) : n(U);
  }
  function F(U) {
    return U === null || Xe(U) ? P(U) : Tt(U) ? (t.consume(U), F) : n(U);
  }
  function P(U) {
    return U === 45 && s === 2 ? (t.consume(U), ee) : U === 60 && s === 1 ? (t.consume(U), K) : U === 62 && s === 4 ? (t.consume(U), j) : U === 63 && s === 3 ? (t.consume(U), L) : U === 93 && s === 5 ? (t.consume(U), N) : Xe(U) && (s === 6 || s === 7) ? (t.exit("htmlFlowData"), t.check(cBe, H, M)(U)) : U === null || Xe(U) ? (t.exit("htmlFlowData"), M(U)) : (t.consume(U), P);
  }
  function M(U) {
    return t.check(uBe, A, H)(U);
  }
  function A(U) {
    return t.enter("lineEnding"), t.consume(U), t.exit("lineEnding"), V;
  }
  function V(U) {
    return U === null || Xe(U) ? M(U) : (t.enter("htmlFlowData"), P(U));
  }
  function ee(U) {
    return U === 45 ? (t.consume(U), L) : P(U);
  }
  function K(U) {
    return U === 47 ? (t.consume(U), o = "", te) : P(U);
  }
  function te(U) {
    if (U === 62) {
      const Y = o.toLowerCase();
      return jL.includes(Y) ? (t.consume(U), j) : P(U);
    }
    return ci(U) && o.length < 8 ? (t.consume(U), o += String.fromCharCode(U), te) : P(U);
  }
  function N(U) {
    return U === 93 ? (t.consume(U), L) : P(U);
  }
  function L(U) {
    return U === 62 ? (t.consume(U), j) : U === 45 && s === 2 ? (t.consume(U), L) : P(U);
  }
  function j(U) {
    return U === null || Xe(U) ? (t.exit("htmlFlowData"), H(U)) : (t.consume(U), j);
  }
  function H(U) {
    return t.exit("htmlFlow"), e(U);
  }
}
function fBe(t, e, n) {
  const r = this;
  return s;
  function s(o) {
    return Xe(o) ? (t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), i) : n(o);
  }
  function i(o) {
    return r.parser.lazy[r.now().line] ? n(o) : e(o);
  }
}
function pBe(t, e, n) {
  return r;
  function r(s) {
    return t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), t.attempt(p_, e, n);
  }
}
const mBe = {
  name: "htmlText",
  tokenize: gBe
};
function gBe(t, e, n) {
  const r = this;
  let s, i, o;
  return a;
  function a(L) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(L), l;
  }
  function l(L) {
    return L === 33 ? (t.consume(L), c) : L === 47 ? (t.consume(L), w) : L === 63 ? (t.consume(L), _) : ci(L) ? (t.consume(L), S) : n(L);
  }
  function c(L) {
    return L === 45 ? (t.consume(L), u) : L === 91 ? (t.consume(L), i = 0, g) : ci(L) ? (t.consume(L), b) : n(L);
  }
  function u(L) {
    return L === 45 ? (t.consume(L), f) : n(L);
  }
  function h(L) {
    return L === null ? n(L) : L === 45 ? (t.consume(L), d) : Xe(L) ? (o = h, K(L)) : (t.consume(L), h);
  }
  function d(L) {
    return L === 45 ? (t.consume(L), f) : h(L);
  }
  function f(L) {
    return L === 62 ? ee(L) : L === 45 ? d(L) : h(L);
  }
  function g(L) {
    const j = "CDATA[";
    return L === j.charCodeAt(i++) ? (t.consume(L), i === j.length ? y : g) : n(L);
  }
  function y(L) {
    return L === null ? n(L) : L === 93 ? (t.consume(L), p) : Xe(L) ? (o = y, K(L)) : (t.consume(L), y);
  }
  function p(L) {
    return L === 93 ? (t.consume(L), m) : y(L);
  }
  function m(L) {
    return L === 62 ? ee(L) : L === 93 ? (t.consume(L), m) : y(L);
  }
  function b(L) {
    return L === null || L === 62 ? ee(L) : Xe(L) ? (o = b, K(L)) : (t.consume(L), b);
  }
  function _(L) {
    return L === null ? n(L) : L === 63 ? (t.consume(L), v) : Xe(L) ? (o = _, K(L)) : (t.consume(L), _);
  }
  function v(L) {
    return L === 62 ? ee(L) : _(L);
  }
  function w(L) {
    return ci(L) ? (t.consume(L), E) : n(L);
  }
  function E(L) {
    return L === 45 || bs(L) ? (t.consume(L), E) : x(L);
  }
  function x(L) {
    return Xe(L) ? (o = x, K(L)) : Tt(L) ? (t.consume(L), x) : ee(L);
  }
  function S(L) {
    return L === 45 || bs(L) ? (t.consume(L), S) : L === 47 || L === 62 || br(L) ? T(L) : n(L);
  }
  function T(L) {
    return L === 47 ? (t.consume(L), ee) : L === 58 || L === 95 || ci(L) ? (t.consume(L), R) : Xe(L) ? (o = T, K(L)) : Tt(L) ? (t.consume(L), T) : ee(L);
  }
  function R(L) {
    return L === 45 || L === 46 || L === 58 || L === 95 || bs(L) ? (t.consume(L), R) : F(L);
  }
  function F(L) {
    return L === 61 ? (t.consume(L), P) : Xe(L) ? (o = F, K(L)) : Tt(L) ? (t.consume(L), F) : T(L);
  }
  function P(L) {
    return L === null || L === 60 || L === 61 || L === 62 || L === 96 ? n(L) : L === 34 || L === 39 ? (t.consume(L), s = L, M) : Xe(L) ? (o = P, K(L)) : Tt(L) ? (t.consume(L), P) : (t.consume(L), A);
  }
  function M(L) {
    return L === s ? (t.consume(L), s = void 0, V) : L === null ? n(L) : Xe(L) ? (o = M, K(L)) : (t.consume(L), M);
  }
  function A(L) {
    return L === null || L === 34 || L === 39 || L === 60 || L === 61 || L === 96 ? n(L) : L === 47 || L === 62 || br(L) ? T(L) : (t.consume(L), A);
  }
  function V(L) {
    return L === 47 || L === 62 || br(L) ? T(L) : n(L);
  }
  function ee(L) {
    return L === 62 ? (t.consume(L), t.exit("htmlTextData"), t.exit("htmlText"), e) : n(L);
  }
  function K(L) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(L), t.exit("lineEnding"), te;
  }
  function te(L) {
    return Tt(L) ? Nt(t, N, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(L) : N(L);
  }
  function N(L) {
    return t.enter("htmlTextData"), o(L);
  }
}
const WA = {
  name: "labelEnd",
  resolveAll: vBe,
  resolveTo: wBe,
  tokenize: EBe
}, yBe = {
  tokenize: SBe
}, bBe = {
  tokenize: xBe
}, _Be = {
  tokenize: TBe
};
function vBe(t) {
  let e = -1;
  const n = [];
  for (; ++e < t.length; ) {
    const r = t[e][1];
    if (n.push(t[e]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const s = r.type === "labelImage" ? 4 : 2;
      r.type = "data", e += s;
    }
  }
  return t.length !== n.length && Ai(t, 0, t.length, n), t;
}
function wBe(t, e) {
  let n = t.length, r = 0, s, i, o, a;
  for (; n--; )
    if (s = t[n][1], i) {
      if (s.type === "link" || s.type === "labelLink" && s._inactive)
        break;
      t[n][0] === "enter" && s.type === "labelLink" && (s._inactive = !0);
    } else if (o) {
      if (t[n][0] === "enter" && (s.type === "labelImage" || s.type === "labelLink") && !s._balanced && (i = n, s.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else s.type === "labelEnd" && (o = n);
  const l = {
    type: t[i][1].type === "labelLink" ? "link" : "image",
    start: {
      ...t[i][1].start
    },
    end: {
      ...t[t.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...t[i][1].start
    },
    end: {
      ...t[o][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...t[i + r + 2][1].end
    },
    end: {
      ...t[o - 2][1].start
    }
  };
  return a = [["enter", l, e], ["enter", c, e]], a = Kr(a, t.slice(i + 1, i + r + 3)), a = Kr(a, [["enter", u, e]]), a = Kr(a, VA(e.parser.constructs.insideSpan.null, t.slice(i + r + 4, o - 3), e)), a = Kr(a, [["exit", u, e], t[o - 2], t[o - 1], ["exit", c, e]]), a = Kr(a, t.slice(o + 1)), a = Kr(a, [["exit", l, e]]), Ai(t, i, t.length, a), t;
}
function EBe(t, e, n) {
  const r = this;
  let s = r.events.length, i, o;
  for (; s--; )
    if ((r.events[s][1].type === "labelImage" || r.events[s][1].type === "labelLink") && !r.events[s][1]._balanced) {
      i = r.events[s][1];
      break;
    }
  return a;
  function a(d) {
    return i ? i._inactive ? h(d) : (o = r.parser.defined.includes(Hc(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }))), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(d), t.exit("labelMarker"), t.exit("labelEnd"), l) : n(d);
  }
  function l(d) {
    return d === 40 ? t.attempt(yBe, u, o ? u : h)(d) : d === 91 ? t.attempt(bBe, u, o ? c : h)(d) : o ? u(d) : h(d);
  }
  function c(d) {
    return t.attempt(_Be, u, h)(d);
  }
  function u(d) {
    return e(d);
  }
  function h(d) {
    return i._balanced = !0, n(d);
  }
}
function SBe(t, e, n) {
  return r;
  function r(h) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), s;
  }
  function s(h) {
    return br(h) ? ud(t, i)(h) : i(h);
  }
  function i(h) {
    return h === 41 ? u(h) : Sq(t, o, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function o(h) {
    return br(h) ? ud(t, l)(h) : u(h);
  }
  function a(h) {
    return n(h);
  }
  function l(h) {
    return h === 34 || h === 39 || h === 40 ? Tq(t, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h);
  }
  function c(h) {
    return br(h) ? ud(t, u)(h) : u(h);
  }
  function u(h) {
    return h === 41 ? (t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), t.exit("resource"), e) : n(h);
  }
}
function xBe(t, e, n) {
  const r = this;
  return s;
  function s(a) {
    return xq.call(r, t, i, o, "reference", "referenceMarker", "referenceString")(a);
  }
  function i(a) {
    return r.parser.defined.includes(Hc(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(a) : n(a);
  }
  function o(a) {
    return n(a);
  }
}
function TBe(t, e, n) {
  return r;
  function r(i) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(i), t.exit("referenceMarker"), s;
  }
  function s(i) {
    return i === 93 ? (t.enter("referenceMarker"), t.consume(i), t.exit("referenceMarker"), t.exit("reference"), e) : n(i);
  }
}
const CBe = {
  name: "labelStartImage",
  resolveAll: WA.resolveAll,
  tokenize: kBe
};
function kBe(t, e, n) {
  const r = this;
  return s;
  function s(a) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(a), t.exit("labelImageMarker"), i;
  }
  function i(a) {
    return a === 91 ? (t.enter("labelMarker"), t.consume(a), t.exit("labelMarker"), t.exit("labelImage"), o) : n(a);
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : e(a);
  }
}
const ABe = {
  name: "labelStartLink",
  resolveAll: WA.resolveAll,
  tokenize: RBe
};
function RBe(t, e, n) {
  const r = this;
  return s;
  function s(o) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(o), t.exit("labelMarker"), t.exit("labelLink"), i;
  }
  function i(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : e(o);
  }
}
const Iw = {
  name: "lineEnding",
  tokenize: IBe
};
function IBe(t, e) {
  return n;
  function n(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), Nt(t, e, "linePrefix");
  }
}
const Ng = {
  name: "thematicBreak",
  tokenize: PBe
};
function PBe(t, e, n) {
  let r = 0, s;
  return i;
  function i(c) {
    return t.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return s = c, a(c);
  }
  function a(c) {
    return c === s ? (t.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || Xe(c)) ? (t.exit("thematicBreak"), e(c)) : n(c);
  }
  function l(c) {
    return c === s ? (t.consume(c), r++, l) : (t.exit("thematicBreakSequence"), Tt(c) ? Nt(t, a, "whitespace")(c) : a(c));
  }
}
const lr = {
  continuation: {
    tokenize: LBe
  },
  exit: BBe,
  name: "list",
  tokenize: NBe
}, OBe = {
  partial: !0,
  tokenize: FBe
}, DBe = {
  partial: !0,
  tokenize: MBe
};
function NBe(t, e, n) {
  const r = this, s = r.events[r.events.length - 1];
  let i = s && s[1].type === "linePrefix" ? s[2].sliceSerialize(s[1], !0).length : 0, o = 0;
  return a;
  function a(f) {
    const g = r.containerState.type || (f === 42 || f === 43 || f === 45 ? "listUnordered" : "listOrdered");
    if (g === "listUnordered" ? !r.containerState.marker || f === r.containerState.marker : Gx(f)) {
      if (r.containerState.type || (r.containerState.type = g, t.enter(g, {
        _container: !0
      })), g === "listUnordered")
        return t.enter("listItemPrefix"), f === 42 || f === 45 ? t.check(Ng, n, c)(f) : c(f);
      if (!r.interrupt || f === 49)
        return t.enter("listItemPrefix"), t.enter("listItemValue"), l(f);
    }
    return n(f);
  }
  function l(f) {
    return Gx(f) && ++o < 10 ? (t.consume(f), l) : (!r.interrupt || o < 2) && (r.containerState.marker ? f === r.containerState.marker : f === 41 || f === 46) ? (t.exit("listItemValue"), c(f)) : n(f);
  }
  function c(f) {
    return t.enter("listItemMarker"), t.consume(f), t.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || f, t.check(
      p_,
      // Cant be empty when interrupting.
      r.interrupt ? n : u,
      t.attempt(OBe, d, h)
    );
  }
  function u(f) {
    return r.containerState.initialBlankLine = !0, i++, d(f);
  }
  function h(f) {
    return Tt(f) ? (t.enter("listItemPrefixWhitespace"), t.consume(f), t.exit("listItemPrefixWhitespace"), d) : n(f);
  }
  function d(f) {
    return r.containerState.size = i + r.sliceSerialize(t.exit("listItemPrefix"), !0).length, e(f);
  }
}
function LBe(t, e, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, t.check(p_, s, i);
  function s(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Nt(t, e, "listItemIndent", r.containerState.size + 1)(a);
  }
  function i(a) {
    return r.containerState.furtherBlankLines || !Tt(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, t.attempt(DBe, e, o)(a));
  }
  function o(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Nt(t, t.attempt(lr, e, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a);
  }
}
function MBe(t, e, n) {
  const r = this;
  return Nt(t, s, "listItemIndent", r.containerState.size + 1);
  function s(i) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(i) : n(i);
  }
}
function BBe(t) {
  t.exit(this.containerState.type);
}
function FBe(t, e, n) {
  const r = this;
  return Nt(t, s, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function s(i) {
    const o = r.events[r.events.length - 1];
    return !Tt(i) && o && o[1].type === "listItemPrefixWhitespace" ? e(i) : n(i);
  }
}
const HL = {
  name: "setextUnderline",
  resolveTo: $Be,
  tokenize: UBe
};
function $Be(t, e) {
  let n = t.length, r, s, i;
  for (; n--; )
    if (t[n][0] === "enter") {
      if (t[n][1].type === "content") {
        r = n;
        break;
      }
      t[n][1].type === "paragraph" && (s = n);
    } else
      t[n][1].type === "content" && t.splice(n, 1), !i && t[n][1].type === "definition" && (i = n);
  const o = {
    type: "setextHeading",
    start: {
      ...t[s][1].start
    },
    end: {
      ...t[t.length - 1][1].end
    }
  };
  return t[s][1].type = "setextHeadingText", i ? (t.splice(s, 0, ["enter", o, e]), t.splice(i + 1, 0, ["exit", t[r][1], e]), t[r][1].end = {
    ...t[i][1].end
  }) : t[r][1] = o, t.push(["exit", o, e]), t;
}
function UBe(t, e, n) {
  const r = this;
  let s;
  return i;
  function i(c) {
    let u = r.events.length, h;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        h = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (t.enter("setextHeadingLine"), s = c, o(c)) : n(c);
  }
  function o(c) {
    return t.enter("setextHeadingLineSequence"), a(c);
  }
  function a(c) {
    return c === s ? (t.consume(c), a) : (t.exit("setextHeadingLineSequence"), Tt(c) ? Nt(t, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || Xe(c) ? (t.exit("setextHeadingLine"), e(c)) : n(c);
  }
}
const jBe = {
  tokenize: HBe
};
function HBe(t) {
  const e = this, n = t.attempt(
    // Try to parse a blank line.
    p_,
    r,
    // Try to parse initial flow (essentially, only code).
    t.attempt(this.parser.constructs.flowInitial, s, Nt(t, t.attempt(this.parser.constructs.flow, s, t.attempt(q3e, s)), "linePrefix"))
  );
  return n;
  function r(i) {
    if (i === null) {
      t.consume(i);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(i), t.exit("lineEndingBlank"), e.currentConstruct = void 0, n;
  }
  function s(i) {
    if (i === null) {
      t.consume(i);
      return;
    }
    return t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), e.currentConstruct = void 0, n;
  }
}
const zBe = {
  resolveAll: kq()
}, GBe = Cq("string"), VBe = Cq("text");
function Cq(t) {
  return {
    resolveAll: kq(t === "text" ? WBe : void 0),
    tokenize: e
  };
  function e(n) {
    const r = this, s = this.parser.constructs[t], i = n.attempt(s, o, a);
    return o;
    function o(u) {
      return c(u) ? i(u) : a(u);
    }
    function a(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), l;
    }
    function l(u) {
      return c(u) ? (n.exit("data"), i(u)) : (n.consume(u), l);
    }
    function c(u) {
      if (u === null)
        return !0;
      const h = s[u];
      let d = -1;
      if (h)
        for (; ++d < h.length; ) {
          const f = h[d];
          if (!f.previous || f.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function kq(t) {
  return e;
  function e(n, r) {
    let s = -1, i;
    for (; ++s <= n.length; )
      i === void 0 ? n[s] && n[s][1].type === "data" && (i = s, s++) : (!n[s] || n[s][1].type !== "data") && (s !== i + 2 && (n[i][1].end = n[s - 1][1].end, n.splice(i + 2, s - i - 2), s = i + 2), i = void 0);
    return t ? t(n, r) : n;
  }
}
function WBe(t, e) {
  let n = 0;
  for (; ++n <= t.length; )
    if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") {
      const r = t[n - 1][1], s = e.sliceStream(r);
      let i = s.length, o = -1, a = 0, l;
      for (; i--; ) {
        const c = s[i];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            a++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2)
          l = !0, a++;
        else if (c !== -1) {
          i++;
          break;
        }
      }
      if (a) {
        const c = {
          type: n === t.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: i ? o : r.start._bufferIndex + o,
            _index: r.start._index + i,
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (t.splice(n, 0, ["enter", c, e], ["exit", c, e]), n += 2);
      }
      n++;
    }
  return t;
}
const qBe = {
  42: lr,
  43: lr,
  45: lr,
  48: lr,
  49: lr,
  50: lr,
  51: lr,
  52: lr,
  53: lr,
  54: lr,
  55: lr,
  56: lr,
  57: lr,
  62: _q
}, KBe = {
  91: X3e
}, YBe = {
  [-2]: Rw,
  [-1]: Rw,
  32: Rw
}, ZBe = {
  35: sBe,
  42: Ng,
  45: [HL, Ng],
  60: lBe,
  61: HL,
  95: Ng,
  96: UL,
  126: UL
}, JBe = {
  38: wq,
  92: vq
}, XBe = {
  [-5]: Iw,
  [-4]: Iw,
  [-3]: Iw,
  33: CBe,
  38: wq,
  42: Vx,
  60: [A3e, mBe],
  91: ABe,
  92: [nBe, vq],
  93: WA,
  95: Vx,
  96: j3e
}, QBe = {
  null: [Vx, zBe]
}, e6e = {
  null: [42, 95]
}, t6e = {
  null: []
}, n6e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: e6e,
  contentInitial: KBe,
  disable: t6e,
  document: qBe,
  flow: ZBe,
  flowInitial: YBe,
  insideSpan: QBe,
  string: JBe,
  text: XBe
}, Symbol.toStringTag, { value: "Module" }));
function r6e(t, e, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const s = {}, i = [];
  let o = [], a = [];
  const l = {
    attempt: x(w),
    check: x(E),
    consume: b,
    enter: _,
    exit: v,
    interrupt: x(E, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: y,
    events: [],
    now: g,
    parser: t,
    previous: null,
    sliceSerialize: d,
    sliceStream: f,
    write: h
  };
  let u = e.tokenize.call(c, l);
  return e.resolveAll && i.push(e), c;
  function h(F) {
    return o = Kr(o, F), p(), o[o.length - 1] !== null ? [] : (S(e, 0), c.events = VA(i, c.events, c), c.events);
  }
  function d(F, P) {
    return i6e(f(F), P);
  }
  function f(F) {
    return s6e(o, F);
  }
  function g() {
    const {
      _bufferIndex: F,
      _index: P,
      line: M,
      column: A,
      offset: V
    } = r;
    return {
      _bufferIndex: F,
      _index: P,
      line: M,
      column: A,
      offset: V
    };
  }
  function y(F) {
    s[F.line] = F.column, R();
  }
  function p() {
    let F;
    for (; r._index < o.length; ) {
      const P = o[r._index];
      if (typeof P == "string")
        for (F = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === F && r._bufferIndex < P.length; )
          m(P.charCodeAt(r._bufferIndex));
      else
        m(P);
    }
  }
  function m(F) {
    u = u(F);
  }
  function b(F) {
    Xe(F) ? (r.line++, r.column = 1, r.offset += F === -3 ? 2 : 1, R()) : F !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = F;
  }
  function _(F, P) {
    const M = P || {};
    return M.type = F, M.start = g(), c.events.push(["enter", M, c]), a.push(M), M;
  }
  function v(F) {
    const P = a.pop();
    return P.end = g(), c.events.push(["exit", P, c]), P;
  }
  function w(F, P) {
    S(F, P.from);
  }
  function E(F, P) {
    P.restore();
  }
  function x(F, P) {
    return M;
    function M(A, V, ee) {
      let K, te, N, L;
      return Array.isArray(A) ? (
        /* c8 ignore next 1 */
        H(A)
      ) : "tokenize" in A ? (
        // Looks like a construct.
        H([
          /** @type {Construct} */
          A
        ])
      ) : j(A);
      function j(he) {
        return X;
        function X(z) {
          const ue = z !== null && he[z], ae = z !== null && he.null, be = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ue) ? ue : ue ? [ue] : [],
            ...Array.isArray(ae) ? ae : ae ? [ae] : []
          ];
          return H(be)(z);
        }
      }
      function H(he) {
        return K = he, te = 0, he.length === 0 ? ee : U(he[te]);
      }
      function U(he) {
        return X;
        function X(z) {
          return L = T(), N = he, he.partial || (c.currentConstruct = he), he.name && c.parser.constructs.disable.null.includes(he.name) ? ne() : he.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            P ? Object.assign(Object.create(c), P) : c,
            l,
            Y,
            ne
          )(z);
        }
      }
      function Y(he) {
        return F(N, L), V;
      }
      function ne(he) {
        return L.restore(), ++te < K.length ? U(K[te]) : ee;
      }
    }
  }
  function S(F, P) {
    F.resolveAll && !i.includes(F) && i.push(F), F.resolve && Ai(c.events, P, c.events.length - P, F.resolve(c.events.slice(P), c)), F.resolveTo && (c.events = F.resolveTo(c.events, c));
  }
  function T() {
    const F = g(), P = c.previous, M = c.currentConstruct, A = c.events.length, V = Array.from(a);
    return {
      from: A,
      restore: ee
    };
    function ee() {
      r = F, c.previous = P, c.currentConstruct = M, c.events.length = A, a = V, R();
    }
  }
  function R() {
    r.line in s && r.column < 2 && (r.column = s[r.line], r.offset += s[r.line] - 1);
  }
}
function s6e(t, e) {
  const n = e.start._index, r = e.start._bufferIndex, s = e.end._index, i = e.end._bufferIndex;
  let o;
  if (n === s)
    o = [t[n].slice(r, i)];
  else {
    if (o = t.slice(n, s), r > -1) {
      const a = o[0];
      typeof a == "string" ? o[0] = a.slice(r) : o.shift();
    }
    i > 0 && o.push(t[s].slice(0, i));
  }
  return o;
}
function i6e(t, e) {
  let n = -1;
  const r = [];
  let s;
  for (; ++n < t.length; ) {
    const i = t[n];
    let o;
    if (typeof i == "string")
      o = i;
    else switch (i) {
      case -5: {
        o = "\r";
        break;
      }
      case -4: {
        o = `
`;
        break;
      }
      case -3: {
        o = `\r
`;
        break;
      }
      case -2: {
        o = e ? " " : "	";
        break;
      }
      case -1: {
        if (!e && s) continue;
        o = " ";
        break;
      }
      default:
        o = String.fromCharCode(i);
    }
    s = i === -2, r.push(o);
  }
  return r.join("");
}
function o6e(t) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      f3e([n6e, ...(t || {}).extensions || []])
    ),
    content: s(w3e),
    defined: [],
    document: s(S3e),
    flow: s(jBe),
    lazy: {},
    string: s(GBe),
    text: s(VBe)
  };
  return r;
  function s(i) {
    return o;
    function o(a) {
      return r6e(r, i, a);
    }
  }
}
function a6e(t) {
  for (; !Eq(t); )
    ;
  return t;
}
const zL = /[\0\t\n\r]/g;
function l6e() {
  let t = 1, e = "", n = !0, r;
  return s;
  function s(i, o, a) {
    const l = [];
    let c, u, h, d, f;
    for (i = e + (typeof i == "string" ? i.toString() : new TextDecoder(o || void 0).decode(i)), h = 0, e = "", n && (i.charCodeAt(0) === 65279 && h++, n = void 0); h < i.length; ) {
      if (zL.lastIndex = h, c = zL.exec(i), d = c && c.index !== void 0 ? c.index : i.length, f = i.charCodeAt(d), !c) {
        e = i.slice(h);
        break;
      }
      if (f === 10 && h === d && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), h < d && (l.push(i.slice(h, d)), t += d - h), f) {
          case 0: {
            l.push(65533), t++;
            break;
          }
          case 9: {
            for (u = Math.ceil(t / 4) * 4, l.push(-2); t++ < u; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), t = 1;
            break;
          }
          default:
            r = !0, t = 1;
        }
      h = d + 1;
    }
    return a && (r && l.push(-5), e && l.push(e), l.push(null)), l;
  }
}
const c6e = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function u6e(t) {
  return t.replace(c6e, h6e);
}
function h6e(t, e, n) {
  if (e)
    return e;
  if (n.charCodeAt(0) === 35) {
    const s = n.charCodeAt(1), i = s === 120 || s === 88;
    return bq(n.slice(i ? 2 : 1), i ? 16 : 10);
  }
  return Ck(n) || t;
}
function Lg(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? GL(t.position) : "start" in t || "end" in t ? GL(t) : "line" in t || "column" in t ? Wx(t) : "";
}
function Wx(t) {
  return VL(t && t.line) + ":" + VL(t && t.column);
}
function GL(t) {
  return Wx(t && t.start) + "-" + Wx(t && t.end);
}
function VL(t) {
  return t && typeof t == "number" ? t : 1;
}
const Aq = {}.hasOwnProperty;
function d6e(t, e, n) {
  return typeof e != "string" && (n = e, e = void 0), f6e(n)(a6e(o6e(n).document().write(l6e()(t, e, !0))));
}
function f6e(t) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: i(ie),
      autolinkProtocol: T,
      autolinkEmail: T,
      atxHeading: i(ce),
      blockQuote: i(ae),
      characterEscape: T,
      characterReference: T,
      codeFenced: i(be),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: i(be, o),
      codeText: i(de, o),
      codeTextData: T,
      data: T,
      codeFlowValue: T,
      definition: i(_e),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: i($),
      hardBreakEscape: i(re),
      hardBreakTrailing: i(re),
      htmlFlow: i(W, o),
      htmlFlowData: T,
      htmlText: i(W, o),
      htmlTextData: T,
      image: i(q),
      label: o,
      link: i(ie),
      listItem: i(xe),
      listItemValue: d,
      listOrdered: i(ye, h),
      listUnordered: i(ye),
      paragraph: i(fe),
      reference: U,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: i(ce),
      strong: i(Ce),
      thematicBreak: i(Ee)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: w,
      autolink: l(),
      autolinkEmail: ue,
      autolinkProtocol: z,
      blockQuote: l(),
      characterEscapeValue: R,
      characterReferenceMarkerHexadecimal: ne,
      characterReferenceMarkerNumeric: ne,
      characterReferenceValue: he,
      characterReference: X,
      codeFenced: l(p),
      codeFencedFence: y,
      codeFencedFenceInfo: f,
      codeFencedFenceMeta: g,
      codeFlowValue: R,
      codeIndented: l(m),
      codeText: l(V),
      codeTextData: R,
      data: R,
      definition: l(),
      definitionDestinationString: v,
      definitionLabelString: b,
      definitionTitleString: _,
      emphasis: l(),
      hardBreakEscape: l(P),
      hardBreakTrailing: l(P),
      htmlFlow: l(M),
      htmlFlowData: R,
      htmlText: l(A),
      htmlTextData: R,
      image: l(K),
      label: N,
      labelText: te,
      lineEnding: F,
      link: l(ee),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: Y,
      resourceDestinationString: L,
      resourceTitleString: j,
      resource: H,
      setextHeading: l(S),
      setextHeadingLineSequence: x,
      setextHeadingText: E,
      strong: l(),
      thematicBreak: l()
    }
  };
  Rq(e, (t || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(oe) {
    let Te = {
      type: "root",
      children: []
    };
    const ke = {
      stack: [Te],
      tokenStack: [],
      config: e,
      enter: a,
      exit: c,
      buffer: o,
      resume: u,
      data: n
    }, Ge = [];
    let G = -1;
    for (; ++G < oe.length; )
      if (oe[G][1].type === "listOrdered" || oe[G][1].type === "listUnordered")
        if (oe[G][0] === "enter")
          Ge.push(G);
        else {
          const O = Ge.pop();
          G = s(oe, O, G);
        }
    for (G = -1; ++G < oe.length; ) {
      const O = e[oe[G][0]];
      Aq.call(O, oe[G][1].type) && O[oe[G][1].type].call(Object.assign({
        sliceSerialize: oe[G][2].sliceSerialize
      }, ke), oe[G][1]);
    }
    if (ke.tokenStack.length > 0) {
      const O = ke.tokenStack[ke.tokenStack.length - 1];
      (O[1] || WL).call(ke, void 0, O[0]);
    }
    for (Te.position = {
      start: wo(oe.length > 0 ? oe[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: wo(oe.length > 0 ? oe[oe.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, G = -1; ++G < e.transforms.length; )
      Te = e.transforms[G](Te) || Te;
    return Te;
  }
  function s(oe, Te, ke) {
    let Ge = Te - 1, G = -1, O = !1, B, Z, le, ge;
    for (; ++Ge <= ke; ) {
      const we = oe[Ge];
      switch (we[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          we[0] === "enter" ? G++ : G--, ge = void 0;
          break;
        }
        case "lineEndingBlank": {
          we[0] === "enter" && (B && !ge && !G && !le && (le = Ge), ge = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          ge = void 0;
      }
      if (!G && we[0] === "enter" && we[1].type === "listItemPrefix" || G === -1 && we[0] === "exit" && (we[1].type === "listUnordered" || we[1].type === "listOrdered")) {
        if (B) {
          let Je = Ge;
          for (Z = void 0; Je--; ) {
            const ft = oe[Je];
            if (ft[1].type === "lineEnding" || ft[1].type === "lineEndingBlank") {
              if (ft[0] === "exit") continue;
              Z && (oe[Z][1].type = "lineEndingBlank", O = !0), ft[1].type = "lineEnding", Z = Je;
            } else if (!(ft[1].type === "linePrefix" || ft[1].type === "blockQuotePrefix" || ft[1].type === "blockQuotePrefixWhitespace" || ft[1].type === "blockQuoteMarker" || ft[1].type === "listItemIndent")) break;
          }
          le && (!Z || le < Z) && (B._spread = !0), B.end = Object.assign({}, Z ? oe[Z][1].start : we[1].end), oe.splice(Z || Ge, 0, ["exit", B, we[2]]), Ge++, ke++;
        }
        if (we[1].type === "listItemPrefix") {
          const Je = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, we[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          B = Je, oe.splice(Ge, 0, ["enter", Je, we[2]]), Ge++, ke++, le = void 0, ge = !0;
        }
      }
    }
    return oe[Te][1]._spread = O, ke;
  }
  function i(oe, Te) {
    return ke;
    function ke(Ge) {
      a.call(this, oe(Ge), Ge), Te && Te.call(this, Ge);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function a(oe, Te, ke) {
    this.stack[this.stack.length - 1].children.push(oe), this.stack.push(oe), this.tokenStack.push([Te, ke || void 0]), oe.position = {
      start: wo(Te.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(oe) {
    return Te;
    function Te(ke) {
      oe && oe.call(this, ke), c.call(this, ke);
    }
  }
  function c(oe, Te) {
    const ke = this.stack.pop(), Ge = this.tokenStack.pop();
    if (Ge)
      Ge[0].type !== oe.type && (Te ? Te.call(this, oe, Ge[0]) : (Ge[1] || WL).call(this, oe, Ge[0]));
    else throw new Error("Cannot close `" + oe.type + "` (" + Lg({
      start: oe.start,
      end: oe.end
    }) + "): its not open");
    ke.position.end = wo(oe.end);
  }
  function u() {
    return h3e(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function d(oe) {
    if (this.data.expectingFirstListItemValue) {
      const Te = this.stack[this.stack.length - 2];
      Te.start = Number.parseInt(this.sliceSerialize(oe), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function f() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.lang = oe;
  }
  function g() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.meta = oe;
  }
  function y() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function p() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.value = oe.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function m() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.value = oe.replace(/(\r?\n|\r)$/g, "");
  }
  function b(oe) {
    const Te = this.resume(), ke = this.stack[this.stack.length - 1];
    ke.label = Te, ke.identifier = Hc(this.sliceSerialize(oe)).toLowerCase();
  }
  function _() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.title = oe;
  }
  function v() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.url = oe;
  }
  function w(oe) {
    const Te = this.stack[this.stack.length - 1];
    if (!Te.depth) {
      const ke = this.sliceSerialize(oe).length;
      Te.depth = ke;
    }
  }
  function E() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function x(oe) {
    const Te = this.stack[this.stack.length - 1];
    Te.depth = this.sliceSerialize(oe).codePointAt(0) === 61 ? 1 : 2;
  }
  function S() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function T(oe) {
    const ke = this.stack[this.stack.length - 1].children;
    let Ge = ke[ke.length - 1];
    (!Ge || Ge.type !== "text") && (Ge = ve(), Ge.position = {
      start: wo(oe.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, ke.push(Ge)), this.stack.push(Ge);
  }
  function R(oe) {
    const Te = this.stack.pop();
    Te.value += this.sliceSerialize(oe), Te.position.end = wo(oe.end);
  }
  function F(oe) {
    const Te = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const ke = Te.children[Te.children.length - 1];
      ke.position.end = wo(oe.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(Te.type) && (T.call(this, oe), R.call(this, oe));
  }
  function P() {
    this.data.atHardBreak = !0;
  }
  function M() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.value = oe;
  }
  function A() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.value = oe;
  }
  function V() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.value = oe;
  }
  function ee() {
    const oe = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Te = this.data.referenceType || "shortcut";
      oe.type += "Reference", oe.referenceType = Te, delete oe.url, delete oe.title;
    } else
      delete oe.identifier, delete oe.label;
    this.data.referenceType = void 0;
  }
  function K() {
    const oe = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Te = this.data.referenceType || "shortcut";
      oe.type += "Reference", oe.referenceType = Te, delete oe.url, delete oe.title;
    } else
      delete oe.identifier, delete oe.label;
    this.data.referenceType = void 0;
  }
  function te(oe) {
    const Te = this.sliceSerialize(oe), ke = this.stack[this.stack.length - 2];
    ke.label = u6e(Te), ke.identifier = Hc(Te).toLowerCase();
  }
  function N() {
    const oe = this.stack[this.stack.length - 1], Te = this.resume(), ke = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, ke.type === "link") {
      const Ge = oe.children;
      ke.children = Ge;
    } else
      ke.alt = Te;
  }
  function L() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.url = oe;
  }
  function j() {
    const oe = this.resume(), Te = this.stack[this.stack.length - 1];
    Te.title = oe;
  }
  function H() {
    this.data.inReference = void 0;
  }
  function U() {
    this.data.referenceType = "collapsed";
  }
  function Y(oe) {
    const Te = this.resume(), ke = this.stack[this.stack.length - 1];
    ke.label = Te, ke.identifier = Hc(this.sliceSerialize(oe)).toLowerCase(), this.data.referenceType = "full";
  }
  function ne(oe) {
    this.data.characterReferenceType = oe.type;
  }
  function he(oe) {
    const Te = this.sliceSerialize(oe), ke = this.data.characterReferenceType;
    let Ge;
    ke ? (Ge = bq(Te, ke === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ge = Ck(Te);
    const G = this.stack[this.stack.length - 1];
    G.value += Ge;
  }
  function X(oe) {
    const Te = this.stack.pop();
    Te.position.end = wo(oe.end);
  }
  function z(oe) {
    R.call(this, oe);
    const Te = this.stack[this.stack.length - 1];
    Te.url = this.sliceSerialize(oe);
  }
  function ue(oe) {
    R.call(this, oe);
    const Te = this.stack[this.stack.length - 1];
    Te.url = "mailto:" + this.sliceSerialize(oe);
  }
  function ae() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function be() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function de() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function _e() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function $() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function ce() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function re() {
    return {
      type: "break"
    };
  }
  function W() {
    return {
      type: "html",
      value: ""
    };
  }
  function q() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function ie() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function ye(oe) {
    return {
      type: "list",
      ordered: oe.type === "listOrdered",
      start: null,
      spread: oe._spread,
      children: []
    };
  }
  function xe(oe) {
    return {
      type: "listItem",
      spread: oe._spread,
      checked: null,
      children: []
    };
  }
  function fe() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Ce() {
    return {
      type: "strong",
      children: []
    };
  }
  function ve() {
    return {
      type: "text",
      value: ""
    };
  }
  function Ee() {
    return {
      type: "thematicBreak"
    };
  }
}
function wo(t) {
  return {
    line: t.line,
    column: t.column,
    offset: t.offset
  };
}
function Rq(t, e) {
  let n = -1;
  for (; ++n < e.length; ) {
    const r = e[n];
    Array.isArray(r) ? Rq(t, r) : p6e(t, r);
  }
}
function p6e(t, e) {
  let n;
  for (n in e)
    if (Aq.call(e, n))
      switch (n) {
        case "canContainEols": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "transforms": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[n];
          r && Object.assign(t[n], r);
          break;
        }
      }
}
function WL(t, e) {
  throw t ? new Error("Cannot close `" + t.type + "` (" + Lg({
    start: t.start,
    end: t.end
  }) + "): a different token (`" + e.type + "`, " + Lg({
    start: e.start,
    end: e.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + Lg({
    start: e.start,
    end: e.end
  }) + ") is still open");
}
function m6e(t) {
  const e = this;
  e.parser = n;
  function n(r) {
    return d6e(r, {
      ...e.data("settings"),
      ...t,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("micromarkExtensions") || [],
      mdastExtensions: e.data("fromMarkdownExtensions") || []
    });
  }
}
function g6e(t, e) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: t.wrap(t.all(e), !0)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function y6e(t, e) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return t.patch(e, n), [t.applyData(e, n), { type: "text", value: `
` }];
}
function b6e(t, e) {
  const n = e.value ? e.value + `
` : "", r = {};
  e.lang && (r.className = ["language-" + e.lang]);
  let s = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return e.meta && (s.data = { meta: e.meta }), t.patch(e, s), s = t.applyData(e, s), s = { type: "element", tagName: "pre", properties: {}, children: [s] }, t.patch(e, s), s;
}
function _6e(t, e) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function v6e(t, e) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const qL = w6e(/[\dA-Za-z]/);
function w6e(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function Gu(t) {
  const e = [];
  let n = -1, r = 0, s = 0;
  for (; ++n < t.length; ) {
    const i = t.charCodeAt(n);
    let o = "";
    if (i === 37 && qL(t.charCodeAt(n + 1)) && qL(t.charCodeAt(n + 2)))
      s = 2;
    else if (i < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (o = String.fromCharCode(i));
    else if (i > 55295 && i < 57344) {
      const a = t.charCodeAt(n + 1);
      i < 56320 && a > 56319 && a < 57344 ? (o = String.fromCharCode(i, a), s = 1) : o = "";
    } else
      o = String.fromCharCode(i);
    o && (e.push(t.slice(r, n), encodeURIComponent(o)), r = n + s + 1, o = ""), s && (n += s, s = 0);
  }
  return e.join("") + t.slice(r);
}
function E6e(t, e) {
  const n = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-", r = String(e.identifier).toUpperCase(), s = Gu(r.toLowerCase()), i = t.footnoteOrder.indexOf(r);
  let o, a = t.footnoteCounts.get(r);
  a === void 0 ? (a = 0, t.footnoteOrder.push(r), o = t.footnoteOrder.length) : o = i + 1, a += 1, t.footnoteCounts.set(r, a);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + s,
      id: n + "fnref-" + s + (a > 1 ? "-" + a : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(o) }]
  };
  t.patch(e, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return t.patch(e, c), t.applyData(e, c);
}
function S6e(t, e) {
  const n = {
    type: "element",
    tagName: "h" + e.depth,
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function x6e(t, e) {
  if (t.options.allowDangerousHtml) {
    const n = { type: "raw", value: e.value };
    return t.patch(e, n), t.applyData(e, n);
  }
}
function Iq(t, e) {
  const n = e.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (e.label || e.identifier) + "]"), e.type === "imageReference")
    return [{ type: "text", value: "![" + e.alt + r }];
  const s = t.all(e), i = s[0];
  i && i.type === "text" ? i.value = "[" + i.value : s.unshift({ type: "text", value: "[" });
  const o = s[s.length - 1];
  return o && o.type === "text" ? o.value += r : s.push({ type: "text", value: r }), s;
}
function T6e(t, e) {
  const n = String(e.identifier).toUpperCase(), r = t.definitionById.get(n);
  if (!r)
    return Iq(t, e);
  const s = { src: Gu(r.url || ""), alt: e.alt };
  r.title !== null && r.title !== void 0 && (s.title = r.title);
  const i = { type: "element", tagName: "img", properties: s, children: [] };
  return t.patch(e, i), t.applyData(e, i);
}
function C6e(t, e) {
  const n = { src: Gu(e.url) };
  e.alt !== null && e.alt !== void 0 && (n.alt = e.alt), e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return t.patch(e, r), t.applyData(e, r);
}
function k6e(t, e) {
  const n = { type: "text", value: e.value.replace(/\r?\n|\r/g, " ") };
  t.patch(e, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return t.patch(e, r), t.applyData(e, r);
}
function A6e(t, e) {
  const n = String(e.identifier).toUpperCase(), r = t.definitionById.get(n);
  if (!r)
    return Iq(t, e);
  const s = { href: Gu(r.url || "") };
  r.title !== null && r.title !== void 0 && (s.title = r.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: s,
    children: t.all(e)
  };
  return t.patch(e, i), t.applyData(e, i);
}
function R6e(t, e) {
  const n = { href: Gu(e.url) };
  e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function I6e(t, e, n) {
  const r = t.all(e), s = n ? P6e(n) : Pq(e), i = {}, o = [];
  if (typeof e.checked == "boolean") {
    const u = r[0];
    let h;
    u && u.type === "element" && u.tagName === "p" ? h = u : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: e.checked, disabled: !0 },
      children: []
    }), i.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const u = r[a];
    (s || a !== 0 || u.type !== "element" || u.tagName !== "p") && o.push({ type: "text", value: `
` }), u.type === "element" && u.tagName === "p" && !s ? o.push(...u.children) : o.push(u);
  }
  const l = r[r.length - 1];
  l && (s || l.type !== "element" || l.tagName !== "p") && o.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: i, children: o };
  return t.patch(e, c), t.applyData(e, c);
}
function P6e(t) {
  let e = !1;
  if (t.type === "list") {
    e = t.spread || !1;
    const n = t.children;
    let r = -1;
    for (; !e && ++r < n.length; )
      e = Pq(n[r]);
  }
  return e;
}
function Pq(t) {
  const e = t.spread;
  return e ?? t.children.length > 1;
}
function O6e(t, e) {
  const n = {}, r = t.all(e);
  let s = -1;
  for (typeof e.start == "number" && e.start !== 1 && (n.start = e.start); ++s < r.length; ) {
    const o = r[s];
    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const i = {
    type: "element",
    tagName: e.ordered ? "ol" : "ul",
    properties: n,
    children: t.wrap(r, !0)
  };
  return t.patch(e, i), t.applyData(e, i);
}
function D6e(t, e) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function N6e(t, e) {
  const n = { type: "root", children: t.wrap(t.all(e)) };
  return t.patch(e, n), t.applyData(e, n);
}
function L6e(t, e) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const Oq = Nq("end"), Dq = Nq("start");
function Nq(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function M6e(t) {
  const e = Dq(t), n = Oq(t);
  if (e && n)
    return { start: e, end: n };
}
function B6e(t, e) {
  const n = t.all(e), r = n.shift(), s = [];
  if (r) {
    const o = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: t.wrap([r], !0)
    };
    t.patch(e.children[0], o), s.push(o);
  }
  if (n.length > 0) {
    const o = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: t.wrap(n, !0)
    }, a = Dq(e.children[1]), l = Oq(e.children[e.children.length - 1]);
    a && l && (o.position = { start: a, end: l }), s.push(o);
  }
  const i = {
    type: "element",
    tagName: "table",
    properties: {},
    children: t.wrap(s, !0)
  };
  return t.patch(e, i), t.applyData(e, i);
}
function F6e(t, e, n) {
  const r = n ? n.children : void 0, i = (r ? r.indexOf(e) : 1) === 0 ? "th" : "td", o = n && n.type === "table" ? n.align : void 0, a = o ? o.length : e.children.length;
  let l = -1;
  const c = [];
  for (; ++l < a; ) {
    const h = e.children[l], d = {}, f = o ? o[l] : void 0;
    f && (d.align = f);
    let g = { type: "element", tagName: i, properties: d, children: [] };
    h && (g.children = t.all(h), t.patch(h, g), g = t.applyData(h, g)), c.push(g);
  }
  const u = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: t.wrap(c, !0)
  };
  return t.patch(e, u), t.applyData(e, u);
}
function $6e(t, e) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const KL = 9, YL = 32;
function U6e(t) {
  const e = String(t), n = /\r?\n|\r/g;
  let r = n.exec(e), s = 0;
  const i = [];
  for (; r; )
    i.push(
      ZL(e.slice(s, r.index), s > 0, !0),
      r[0]
    ), s = r.index + r[0].length, r = n.exec(e);
  return i.push(ZL(e.slice(s), s > 0, !1)), i.join("");
}
function ZL(t, e, n) {
  let r = 0, s = t.length;
  if (e) {
    let i = t.codePointAt(r);
    for (; i === KL || i === YL; )
      r++, i = t.codePointAt(r);
  }
  if (n) {
    let i = t.codePointAt(s - 1);
    for (; i === KL || i === YL; )
      s--, i = t.codePointAt(s - 1);
  }
  return s > r ? t.slice(r, s) : "";
}
function j6e(t, e) {
  const n = { type: "text", value: U6e(String(e.value)) };
  return t.patch(e, n), t.applyData(e, n);
}
function H6e(t, e) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return t.patch(e, n), t.applyData(e, n);
}
const z6e = {
  blockquote: g6e,
  break: y6e,
  code: b6e,
  delete: _6e,
  emphasis: v6e,
  footnoteReference: E6e,
  heading: S6e,
  html: x6e,
  imageReference: T6e,
  image: C6e,
  inlineCode: k6e,
  linkReference: A6e,
  link: R6e,
  listItem: I6e,
  list: O6e,
  paragraph: D6e,
  // @ts-expect-error: root is different, but hard to type.
  root: N6e,
  strong: L6e,
  table: B6e,
  tableCell: $6e,
  tableRow: F6e,
  text: j6e,
  thematicBreak: H6e,
  toml: Wm,
  yaml: Wm,
  definition: Wm,
  footnoteDefinition: Wm
};
function Wm() {
}
function G6e(t, e) {
  const n = [{ type: "text", value: "" }];
  return e > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(e) }]
  }), n;
}
function V6e(t, e) {
  return "Back to reference " + (t + 1) + (e > 1 ? "-" + e : "");
}
function W6e(t) {
  const e = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-", n = t.options.footnoteBackContent || G6e, r = t.options.footnoteBackLabel || V6e, s = t.options.footnoteLabel || "Footnotes", i = t.options.footnoteLabelTagName || "h2", o = t.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, a = [];
  let l = -1;
  for (; ++l < t.footnoteOrder.length; ) {
    const c = t.footnoteById.get(
      t.footnoteOrder[l]
    );
    if (!c)
      continue;
    const u = t.all(c), h = String(c.identifier).toUpperCase(), d = Gu(h.toLowerCase());
    let f = 0;
    const g = [], y = t.footnoteCounts.get(h);
    for (; y !== void 0 && ++f <= y; ) {
      g.length > 0 && g.push({ type: "text", value: " " });
      let b = typeof n == "string" ? n : n(l, f);
      typeof b == "string" && (b = { type: "text", value: b }), g.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + e + "fnref-" + d + (f > 1 ? "-" + f : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, f),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(b) ? b : [b]
      });
    }
    const p = u[u.length - 1];
    if (p && p.type === "element" && p.tagName === "p") {
      const b = p.children[p.children.length - 1];
      b && b.type === "text" ? b.value += " " : p.children.push({ type: "text", value: " " }), p.children.push(...g);
    } else
      u.push(...g);
    const m = {
      type: "element",
      tagName: "li",
      properties: { id: e + "fn-" + d },
      children: t.wrap(u, !0)
    };
    t.patch(c, m), a.push(m);
  }
  if (a.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: i,
          properties: {
            ...bl(o),
            id: "footnote-label"
          },
          children: [{ type: "text", value: s }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: t.wrap(a, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const qx = {}.hasOwnProperty, q6e = {};
function K6e(t, e) {
  const n = e || q6e, r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = { ...z6e, ...n.handlers }, a = {
    all: c,
    applyData: Z6e,
    definitionById: r,
    footnoteById: s,
    footnoteCounts: i,
    footnoteOrder: [],
    handlers: o,
    one: l,
    options: n,
    patch: Y6e,
    wrap: X6e
  };
  return Fl(t, function(u) {
    if (u.type === "definition" || u.type === "footnoteDefinition") {
      const h = u.type === "definition" ? r : s, d = String(u.identifier).toUpperCase();
      h.has(d) || h.set(d, u);
    }
  }), a;
  function l(u, h) {
    const d = u.type, f = a.handlers[d];
    if (qx.call(a.handlers, d) && f)
      return f(a, u, h);
    if (a.options.passThrough && a.options.passThrough.includes(d)) {
      if ("children" in u) {
        const { children: y, ...p } = u, m = bl(p);
        return m.children = a.all(u), m;
      }
      return bl(u);
    }
    return (a.options.unknownHandler || J6e)(a, u, h);
  }
  function c(u) {
    const h = [];
    if ("children" in u) {
      const d = u.children;
      let f = -1;
      for (; ++f < d.length; ) {
        const g = a.one(d[f], u);
        if (g) {
          if (f && d[f - 1].type === "break" && (!Array.isArray(g) && g.type === "text" && (g.value = JL(g.value)), !Array.isArray(g) && g.type === "element")) {
            const y = g.children[0];
            y && y.type === "text" && (y.value = JL(y.value));
          }
          Array.isArray(g) ? h.push(...g) : h.push(g);
        }
      }
    }
    return h;
  }
}
function Y6e(t, e) {
  t.position && (e.position = M6e(t));
}
function Z6e(t, e) {
  let n = e;
  if (t && t.data) {
    const r = t.data.hName, s = t.data.hChildren, i = t.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const o = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: o };
      }
    n.type === "element" && i && Object.assign(n.properties, bl(i)), "children" in n && n.children && s !== null && s !== void 0 && (n.children = s);
  }
  return n;
}
function J6e(t, e) {
  const n = e.data || {}, r = "value" in e && !(qx.call(n, "hProperties") || qx.call(n, "hChildren")) ? { type: "text", value: e.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function X6e(t, e) {
  const n = [];
  let r = -1;
  for (e && n.push({ type: "text", value: `
` }); ++r < t.length; )
    r && n.push({ type: "text", value: `
` }), n.push(t[r]);
  return e && t.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function JL(t) {
  let e = 0, n = t.charCodeAt(e);
  for (; n === 9 || n === 32; )
    e++, n = t.charCodeAt(e);
  return t.slice(e);
}
function XL(t, e) {
  const n = K6e(t, e), r = n.one(t, void 0), s = W6e(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return s && i.children.push({ type: "text", value: `
` }, s), i;
}
function Q6e(t, e) {
  return t && "run" in t ? async function(n, r) {
    const s = (
      /** @type {HastRoot} */
      XL(n, { file: r, ...e })
    );
    await t.run(s, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      XL(n, { file: r, ...t || e })
    );
  };
}
function QL(t) {
  if (t)
    throw t;
}
var Mg = Object.prototype.hasOwnProperty, Lq = Object.prototype.toString, eM = Object.defineProperty, tM = Object.getOwnPropertyDescriptor, nM = function(e) {
  return typeof Array.isArray == "function" ? Array.isArray(e) : Lq.call(e) === "[object Array]";
}, rM = function(e) {
  if (!e || Lq.call(e) !== "[object Object]")
    return !1;
  var n = Mg.call(e, "constructor"), r = e.constructor && e.constructor.prototype && Mg.call(e.constructor.prototype, "isPrototypeOf");
  if (e.constructor && !n && !r)
    return !1;
  var s;
  for (s in e)
    ;
  return typeof s > "u" || Mg.call(e, s);
}, sM = function(e, n) {
  eM && n.name === "__proto__" ? eM(e, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : e[n.name] = n.newValue;
}, iM = function(e, n) {
  if (n === "__proto__")
    if (Mg.call(e, n)) {
      if (tM)
        return tM(e, n).value;
    } else return;
  return e[n];
}, e4e = function t() {
  var e, n, r, s, i, o, a = arguments[0], l = 1, c = arguments.length, u = !1;
  for (typeof a == "boolean" && (u = a, a = arguments[1] || {}, l = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); l < c; ++l)
    if (e = arguments[l], e != null)
      for (n in e)
        r = iM(a, n), s = iM(e, n), a !== s && (u && s && (rM(s) || (i = nM(s))) ? (i ? (i = !1, o = r && nM(r) ? r : []) : o = r && rM(r) ? r : {}, sM(a, { name: n, newValue: t(u, o, s) })) : typeof s < "u" && sM(a, { name: n, newValue: s }));
  return a;
};
const Pw = /* @__PURE__ */ Is(e4e);
function Kx(t) {
  if (typeof t != "object" || t === null)
    return !1;
  const e = Object.getPrototypeOf(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}
function t4e() {
  const t = [], e = { run: n, use: r };
  return e;
  function n(...s) {
    let i = -1;
    const o = s.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    a(null, ...s);
    function a(l, ...c) {
      const u = t[++i];
      let h = -1;
      if (l) {
        o(l);
        return;
      }
      for (; ++h < s.length; )
        (c[h] === null || c[h] === void 0) && (c[h] = s[h]);
      s = c, u ? n4e(u, a)(...c) : o(null, ...c);
    }
  }
  function r(s) {
    if (typeof s != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + s
      );
    return t.push(s), e;
  }
}
function n4e(t, e) {
  let n;
  return r;
  function r(...o) {
    const a = t.length > o.length;
    let l;
    a && o.push(s);
    try {
      l = t.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (a && n)
        throw u;
      return s(u);
    }
    a || (l && l.then && typeof l.then == "function" ? l.then(i, s) : l instanceof Error ? s(l) : i(l));
  }
  function s(o, ...a) {
    n || (n = !0, e(o, ...a));
  }
  function i(o) {
    s(null, o);
  }
}
const Js = { basename: r4e, dirname: s4e, extname: i4e, join: o4e, sep: "/" };
function r4e(t, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  wp(t);
  let n = 0, r = -1, s = t.length, i;
  if (e === void 0 || e.length === 0 || e.length > t.length) {
    for (; s--; )
      if (t.codePointAt(s) === 47) {
        if (i) {
          n = s + 1;
          break;
        }
      } else r < 0 && (i = !0, r = s + 1);
    return r < 0 ? "" : t.slice(n, r);
  }
  if (e === t)
    return "";
  let o = -1, a = e.length - 1;
  for (; s--; )
    if (t.codePointAt(s) === 47) {
      if (i) {
        n = s + 1;
        break;
      }
    } else
      o < 0 && (i = !0, o = s + 1), a > -1 && (t.codePointAt(s) === e.codePointAt(a--) ? a < 0 && (r = s) : (a = -1, r = o));
  return n === r ? r = o : r < 0 && (r = t.length), t.slice(n, r);
}
function s4e(t) {
  if (wp(t), t.length === 0)
    return ".";
  let e = -1, n = t.length, r;
  for (; --n; )
    if (t.codePointAt(n) === 47) {
      if (r) {
        e = n;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? t.codePointAt(0) === 47 ? "/" : "." : e === 1 && t.codePointAt(0) === 47 ? "//" : t.slice(0, e);
}
function i4e(t) {
  wp(t);
  let e = t.length, n = -1, r = 0, s = -1, i = 0, o;
  for (; e--; ) {
    const a = t.codePointAt(e);
    if (a === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    n < 0 && (o = !0, n = e + 1), a === 46 ? s < 0 ? s = e : i !== 1 && (i = 1) : s > -1 && (i = -1);
  }
  return s < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  i === 0 || // The (right-most) trimmed path component is exactly `..`.
  i === 1 && s === n - 1 && s === r + 1 ? "" : t.slice(s, n);
}
function o4e(...t) {
  let e = -1, n;
  for (; ++e < t.length; )
    wp(t[e]), t[e] && (n = n === void 0 ? t[e] : n + "/" + t[e]);
  return n === void 0 ? "." : a4e(n);
}
function a4e(t) {
  wp(t);
  const e = t.codePointAt(0) === 47;
  let n = l4e(t, !e);
  return n.length === 0 && !e && (n = "."), n.length > 0 && t.codePointAt(t.length - 1) === 47 && (n += "/"), e ? "/" + n : n;
}
function l4e(t, e) {
  let n = "", r = 0, s = -1, i = 0, o = -1, a, l;
  for (; ++o <= t.length; ) {
    if (o < t.length)
      a = t.codePointAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(s === o - 1 || i === 1)) if (s !== o - 1 && i === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), s = o, i = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, s = o, i = 0;
            continue;
          }
        }
        e && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + t.slice(s + 1, o) : n = t.slice(s + 1, o), r = o - s - 1;
      s = o, i = 0;
    } else a === 46 && i > -1 ? i++ : i = -1;
  }
  return n;
}
function wp(t) {
  if (typeof t != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(t)
    );
}
const c4e = { cwd: u4e };
function u4e() {
  return "/";
}
function Yx(t) {
  return !!(t !== null && typeof t == "object" && "href" in t && t.href && "protocol" in t && t.protocol && // @ts-expect-error: indexing is fine.
  t.auth === void 0);
}
function h4e(t) {
  if (typeof t == "string")
    t = new URL(t);
  else if (!Yx(t)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + t + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (t.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return d4e(t);
}
function d4e(t) {
  if (t.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = t.pathname;
  let n = -1;
  for (; ++n < e.length; )
    if (e.codePointAt(n) === 37 && e.codePointAt(n + 1) === 50) {
      const r = e.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const s = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw s.code = "ERR_INVALID_FILE_URL_PATH", s;
      }
    }
  return decodeURIComponent(e);
}
const Ow = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
let f4e = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let n;
    e ? Yx(e) ? n = { path: e } : typeof e == "string" || p4e(e) ? n = { value: e } : n = e : n = {}, this.cwd = "cwd" in n ? "" : c4e.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Ow.length; ) {
      const i = Ow[r];
      i in n && n[i] !== void 0 && n[i] !== null && (this[i] = i === "history" ? [...n[i]] : n[i]);
    }
    let s;
    for (s in n)
      Ow.includes(s) || (this[s] = n[s]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Js.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    Nw(e, "basename"), Dw(e, "basename"), this.path = Js.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Js.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    oM(this.basename, "dirname"), this.path = Js.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Js.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if (Dw(e, "extname"), oM(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Js.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    Yx(e) && (e = h4e(e)), Nw(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Js.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    Nw(e, "stem"), Dw(e, "stem"), this.path = Js.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, n, r) {
    const s = this.message(e, n, r);
    throw s.fatal = !0, s;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, n, r) {
    const s = this.message(e, n, r);
    return s.fatal = void 0, s;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, n, r) {
    const s = new Dn(
      // @ts-expect-error: the overloads are fine.
      e,
      n,
      r
    );
    return this.path && (s.name = this.path + ":" + s.name, s.file = this.path), s.fatal = !1, this.messages.push(s), s;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
};
function Dw(t, e) {
  if (t && t.includes(Js.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + Js.sep + "`"
    );
}
function Nw(t, e) {
  if (!t)
    throw new Error("`" + e + "` cannot be empty");
}
function oM(t, e) {
  if (!t)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function p4e(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
const m4e = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(t) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), s = r[t], i = function() {
      return s.apply(i, arguments);
    };
    return Object.setPrototypeOf(i, r), i;
  }
), g4e = {}.hasOwnProperty;
class qA extends m4e {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = t4e();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const e = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new qA()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      e.use(...r);
    }
    return e.data(Pw(!0, {}, this.namespace)), e;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(e, n) {
    return typeof e == "string" ? arguments.length === 2 ? (Bw("data", this.frozen), this.namespace[e] = n, this) : g4e.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (Bw("data", this.frozen), this.namespace = e, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const e = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const s = n.call(e, ...r);
      typeof s == "function" && this.transformers.use(s);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(e) {
    this.freeze();
    const n = qm(e), r = this.parser || this.Parser;
    return Lw("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(e, n) {
    const r = this;
    return this.freeze(), Lw("process", this.parser || this.Parser), Mw("process", this.compiler || this.Compiler), n ? s(void 0, n) : new Promise(s);
    function s(i, o) {
      const a = qm(e), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(a)
      );
      r.run(l, a, function(u, h, d) {
        if (u || !h || !d)
          return c(u);
        const f = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), g = r.stringify(f, d);
        _4e(g) ? d.value = g : d.result = g, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          d
        );
      });
      function c(u, h) {
        u || !h ? o(u) : i ? i(h) : n(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(e) {
    let n = !1, r;
    return this.freeze(), Lw("processSync", this.parser || this.Parser), Mw("processSync", this.compiler || this.Compiler), this.process(e, s), lM("processSync", "process", n), r;
    function s(i, o) {
      n = !0, QL(i), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(e, n, r) {
    aM(e), this.freeze();
    const s = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? i(void 0, r) : new Promise(i);
    function i(o, a) {
      const l = qm(n);
      s.run(e, l, c);
      function c(u, h, d) {
        const f = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || e
        );
        u ? a(u) : o ? o(f) : r(void 0, f, d);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(e, n) {
    let r = !1, s;
    return this.run(e, n, i), lM("runSync", "run", r), s;
    function i(o, a) {
      QL(o), s = a, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(e, n) {
    this.freeze();
    const r = qm(n), s = this.compiler || this.Compiler;
    return Mw("stringify", s), aM(e), s(e, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(e, ...n) {
    const r = this.attachers, s = this.namespace;
    if (Bw("use", this.frozen), e != null) if (typeof e == "function")
      l(e, n);
    else if (typeof e == "object")
      Array.isArray(e) ? a(e) : o(e);
    else
      throw new TypeError("Expected usable value, not `" + e + "`");
    return this;
    function i(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(u, h);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      a(c.plugins), c.settings && (s.settings = Pw(!0, s.settings, c.settings));
    }
    function a(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const h = c[u];
          i(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, u) {
      let h = -1, d = -1;
      for (; ++h < r.length; )
        if (r[h][0] === c) {
          d = h;
          break;
        }
      if (d === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [f, ...g] = u;
        const y = r[d][1];
        Kx(y) && Kx(f) && (f = Pw(!0, y, f)), r[d] = [c, f, ...g];
      }
    }
  }
}
const y4e = new qA().freeze();
function Lw(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `parser`");
}
function Mw(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `compiler`");
}
function Bw(t, e) {
  if (e)
    throw new Error(
      "Cannot call `" + t + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function aM(t) {
  if (!Kx(t) || typeof t.type != "string")
    throw new TypeError("Expected node, got `" + t + "`");
}
function lM(t, e, n) {
  if (!n)
    throw new Error(
      "`" + t + "` finished async. Use `" + e + "` instead"
    );
}
function qm(t) {
  return b4e(t) ? t : new f4e(t);
}
function b4e(t) {
  return !!(t && typeof t == "object" && "message" in t && "messages" in t);
}
function _4e(t) {
  return typeof t == "string" || v4e(t);
}
function v4e(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
const Xs = { basename: w4e, dirname: E4e, extname: S4e, join: x4e, sep: "/" };
function w4e(t, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  Ep(t);
  let n = 0, r = -1, s = t.length, i;
  if (e === void 0 || e.length === 0 || e.length > t.length) {
    for (; s--; )
      if (t.codePointAt(s) === 47) {
        if (i) {
          n = s + 1;
          break;
        }
      } else r < 0 && (i = !0, r = s + 1);
    return r < 0 ? "" : t.slice(n, r);
  }
  if (e === t)
    return "";
  let o = -1, a = e.length - 1;
  for (; s--; )
    if (t.codePointAt(s) === 47) {
      if (i) {
        n = s + 1;
        break;
      }
    } else
      o < 0 && (i = !0, o = s + 1), a > -1 && (t.codePointAt(s) === e.codePointAt(a--) ? a < 0 && (r = s) : (a = -1, r = o));
  return n === r ? r = o : r < 0 && (r = t.length), t.slice(n, r);
}
function E4e(t) {
  if (Ep(t), t.length === 0)
    return ".";
  let e = -1, n = t.length, r;
  for (; --n; )
    if (t.codePointAt(n) === 47) {
      if (r) {
        e = n;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? t.codePointAt(0) === 47 ? "/" : "." : e === 1 && t.codePointAt(0) === 47 ? "//" : t.slice(0, e);
}
function S4e(t) {
  Ep(t);
  let e = t.length, n = -1, r = 0, s = -1, i = 0, o;
  for (; e--; ) {
    const a = t.codePointAt(e);
    if (a === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    n < 0 && (o = !0, n = e + 1), a === 46 ? s < 0 ? s = e : i !== 1 && (i = 1) : s > -1 && (i = -1);
  }
  return s < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  i === 0 || // The (right-most) trimmed path component is exactly `..`.
  i === 1 && s === n - 1 && s === r + 1 ? "" : t.slice(s, n);
}
function x4e(...t) {
  let e = -1, n;
  for (; ++e < t.length; )
    Ep(t[e]), t[e] && (n = n === void 0 ? t[e] : n + "/" + t[e]);
  return n === void 0 ? "." : T4e(n);
}
function T4e(t) {
  Ep(t);
  const e = t.codePointAt(0) === 47;
  let n = C4e(t, !e);
  return n.length === 0 && !e && (n = "."), n.length > 0 && t.codePointAt(t.length - 1) === 47 && (n += "/"), e ? "/" + n : n;
}
function C4e(t, e) {
  let n = "", r = 0, s = -1, i = 0, o = -1, a, l;
  for (; ++o <= t.length; ) {
    if (o < t.length)
      a = t.codePointAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(s === o - 1 || i === 1)) if (s !== o - 1 && i === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), s = o, i = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, s = o, i = 0;
            continue;
          }
        }
        e && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + t.slice(s + 1, o) : n = t.slice(s + 1, o), r = o - s - 1;
      s = o, i = 0;
    } else a === 46 && i > -1 ? i++ : i = -1;
  }
  return n;
}
function Ep(t) {
  if (typeof t != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(t)
    );
}
const k4e = { cwd: A4e };
function A4e() {
  return "/";
}
function Zx(t) {
  return !!(t !== null && typeof t == "object" && "href" in t && t.href && "protocol" in t && t.protocol && // @ts-expect-error: indexing is fine.
  t.auth === void 0);
}
function R4e(t) {
  if (typeof t == "string")
    t = new URL(t);
  else if (!Zx(t)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + t + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (t.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return I4e(t);
}
function I4e(t) {
  if (t.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = t.pathname;
  let n = -1;
  for (; ++n < e.length; )
    if (e.codePointAt(n) === 37 && e.codePointAt(n + 1) === 50) {
      const r = e.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const s = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw s.code = "ERR_INVALID_FILE_URL_PATH", s;
      }
    }
  return decodeURIComponent(e);
}
const Fw = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class P4e {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let n;
    e ? Zx(e) ? n = { path: e } : typeof e == "string" || O4e(e) ? n = { value: e } : n = e : n = {}, this.cwd = "cwd" in n ? "" : k4e.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Fw.length; ) {
      const i = Fw[r];
      i in n && n[i] !== void 0 && n[i] !== null && (this[i] = i === "history" ? [...n[i]] : n[i]);
    }
    let s;
    for (s in n)
      Fw.includes(s) || (this[s] = n[s]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Xs.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    Uw(e, "basename"), $w(e, "basename"), this.path = Xs.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Xs.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    cM(this.basename, "dirname"), this.path = Xs.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Xs.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if ($w(e, "extname"), cM(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Xs.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    Zx(e) && (e = R4e(e)), Uw(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Xs.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    Uw(e, "stem"), $w(e, "stem"), this.path = Xs.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, n, r) {
    const s = this.message(e, n, r);
    throw s.fatal = !0, s;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, n, r) {
    const s = this.message(e, n, r);
    return s.fatal = void 0, s;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, n, r) {
    const s = new Dn(
      // @ts-expect-error: the overloads are fine.
      e,
      n,
      r
    );
    return this.path && (s.name = this.path + ":" + s.name, s.file = this.path), s.fatal = !1, this.messages.push(s), s;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
}
function $w(t, e) {
  if (t && t.includes(Xs.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + Xs.sep + "`"
    );
}
function Uw(t, e) {
  if (!t)
    throw new Error("`" + e + "` cannot be empty");
}
function cM(t, e) {
  if (!t)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function O4e(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
const D4e = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", uM = [], hM = { allowDangerousHtml: !0 }, N4e = /^(https?|ircs?|mailto|xmpp)$/i, L4e = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function M4e(t) {
  const e = t.allowedElements, n = t.allowElement, r = t.children || "", s = t.className, i = t.components, o = t.disallowedElements, a = t.rehypePlugins || uM, l = t.remarkPlugins || uM, c = t.remarkRehypeOptions ? { ...t.remarkRehypeOptions, ...hM } : hM, u = t.skipHtml, h = t.unwrapDisallowed, d = t.urlTransform || B4e, f = y4e().use(m6e).use(l).use(Q6e, c).use(a), g = new P4e();
  typeof r == "string" && (g.value = r);
  for (const b of L4e)
    Object.hasOwn(t, b.from) && ("" + b.from + (b.to ? "use `" + b.to + "` instead" : "remove it") + D4e + b.id, void 0);
  const y = f.parse(g);
  let p = f.runSync(y, g);
  return s && (p = {
    type: "element",
    tagName: "div",
    properties: { className: s },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      p.type === "root" ? p.children : [p]
    )
  }), Fl(p, m), qMe(p, {
    Fragment: k.Fragment,
    // @ts-expect-error
    // React components are allowed to return numbers,
    // but not according to the types in hast-util-to-jsx-runtime
    components: i,
    ignoreInvalidStyle: !0,
    jsx: k.jsx,
    jsxs: k.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function m(b, _, v) {
    if (b.type === "raw" && v && typeof _ == "number")
      return u ? v.children.splice(_, 1) : v.children[_] = { type: "text", value: b.value }, _;
    if (b.type === "element") {
      let w;
      for (w in Aw)
        if (Object.hasOwn(Aw, w) && Object.hasOwn(b.properties, w)) {
          const E = b.properties[w], x = Aw[w];
          (x === null || x.includes(b.tagName)) && (b.properties[w] = d(String(E || ""), w, b));
        }
    }
    if (b.type === "element") {
      let w = e ? !e.includes(b.tagName) : o ? o.includes(b.tagName) : !1;
      if (!w && n && typeof _ == "number" && (w = !n(b, _, v)), w && v && typeof _ == "number")
        return h && b.children ? v.children.splice(_, 1, ...b.children) : v.children.splice(_, 1), _;
    }
  }
}
function B4e(t) {
  const e = t.indexOf(":"), n = t.indexOf("?"), r = t.indexOf("#"), s = t.indexOf("/");
  return (
    // If there is no protocol, its relative.
    e === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    s !== -1 && e > s || n !== -1 && e > n || r !== -1 && e > r || // It is a protocol, it should be allowed.
    N4e.test(t.slice(0, e)) ? t : ""
  );
}
const Mq = [
  {
    id: "abap",
    name: "ABAP",
    import: () => import("./abap-BmBUA35e.js")
  },
  {
    id: "actionscript-3",
    name: "ActionScript",
    import: () => import("./actionscript-3-zFUbzQa9.js")
  },
  {
    id: "ada",
    name: "Ada",
    import: () => import("./ada-CBvPkFpZ.js")
  },
  {
    id: "angular-html",
    name: "Angular HTML",
    import: () => import("./angular-html-0fTdLuKf.js").then((t) => t.f)
  },
  {
    id: "angular-ts",
    name: "Angular TypeScript",
    import: () => import("./angular-ts-wkniW60G.js")
  },
  {
    id: "apache",
    name: "Apache Conf",
    import: () => import("./apache-CVNlsSDc.js")
  },
  {
    id: "apex",
    name: "Apex",
    import: () => import("./apex-DFk3KRB1.js")
  },
  {
    id: "apl",
    name: "APL",
    import: () => import("./apl-TLDHFJX6.js")
  },
  {
    id: "applescript",
    name: "AppleScript",
    import: () => import("./applescript-CYMR_y0g.js")
  },
  {
    id: "ara",
    name: "Ara",
    import: () => import("./ara-4QmU5e04.js")
  },
  {
    id: "asciidoc",
    name: "AsciiDoc",
    aliases: [
      "adoc"
    ],
    import: () => import("./asciidoc-v_1bjgUg.js")
  },
  {
    id: "asm",
    name: "Assembly",
    import: () => import("./asm-RC0Yh-NZ.js")
  },
  {
    id: "astro",
    name: "Astro",
    import: () => import("./astro-Uf8_VxKJ.js")
  },
  {
    id: "awk",
    name: "AWK",
    import: () => import("./awk-gPH8MVMW.js")
  },
  {
    id: "ballerina",
    name: "Ballerina",
    import: () => import("./ballerina-kvLnRU_e.js")
  },
  {
    id: "bat",
    name: "Batch File",
    aliases: [
      "batch"
    ],
    import: () => import("./bat-BHYy44sT.js")
  },
  {
    id: "beancount",
    name: "Beancount",
    import: () => import("./beancount-D-MADTs_.js")
  },
  {
    id: "berry",
    name: "Berry",
    aliases: [
      "be"
    ],
    import: () => import("./berry-Ci9U0o4h.js")
  },
  {
    id: "bibtex",
    name: "BibTeX",
    import: () => import("./bibtex-CX618D15.js")
  },
  {
    id: "bicep",
    name: "Bicep",
    import: () => import("./bicep-iuYiPopT.js")
  },
  {
    id: "blade",
    name: "Blade",
    import: () => import("./blade-BtR00Gx0.js")
  },
  {
    id: "bsl",
    name: "1C (Enterprise)",
    aliases: [
      "1c"
    ],
    import: () => import("./bsl-BIXPNqL4.js")
  },
  {
    id: "c",
    name: "C",
    import: () => import("./c-DASdrs7p.js")
  },
  {
    id: "cadence",
    name: "Cadence",
    aliases: [
      "cdc"
    ],
    import: () => import("./cadence-BDALQi26.js")
  },
  {
    id: "cairo",
    name: "Cairo",
    import: () => import("./cairo-tXZKA2PT.js")
  },
  {
    id: "clarity",
    name: "Clarity",
    import: () => import("./clarity-CNgV2Ths.js")
  },
  {
    id: "clojure",
    name: "Clojure",
    aliases: [
      "clj"
    ],
    import: () => import("./clojure-CsKKFGwv.js")
  },
  {
    id: "cmake",
    name: "CMake",
    import: () => import("./cmake-Dr-A3iJx.js")
  },
  {
    id: "cobol",
    name: "COBOL",
    import: () => import("./cobol-DMssKNmC.js")
  },
  {
    id: "codeowners",
    name: "CODEOWNERS",
    import: () => import("./codeowners-Bt9yU6NX.js")
  },
  {
    id: "codeql",
    name: "CodeQL",
    aliases: [
      "ql"
    ],
    import: () => import("./codeql-DBNTqJi1.js")
  },
  {
    id: "coffee",
    name: "CoffeeScript",
    aliases: [
      "coffeescript"
    ],
    import: () => import("./coffee-D_GzM8k1.js")
  },
  {
    id: "common-lisp",
    name: "Common Lisp",
    aliases: [
      "lisp"
    ],
    import: () => import("./common-lisp-r7ZEOG7T.js")
  },
  {
    id: "coq",
    name: "Coq",
    import: () => import("./coq-CB6Pv_W9.js")
  },
  {
    id: "cpp",
    name: "C++",
    aliases: [
      "c++"
    ],
    import: () => import("./cpp-CJF2i3ah.js")
  },
  {
    id: "crystal",
    name: "Crystal",
    import: () => import("./crystal-BKWnaU3g.js")
  },
  {
    id: "csharp",
    name: "C#",
    aliases: [
      "c#",
      "cs"
    ],
    import: () => import("./csharp-CYWRhZ2R.js")
  },
  {
    id: "css",
    name: "CSS",
    import: () => import("./css-D1aVdRIU.js")
  },
  {
    id: "csv",
    name: "CSV",
    import: () => import("./csv-DvCncUGQ.js")
  },
  {
    id: "cue",
    name: "CUE",
    import: () => import("./cue-BXMrmvay.js")
  },
  {
    id: "cypher",
    name: "Cypher",
    aliases: [
      "cql"
    ],
    import: () => import("./cypher-DTm5zNR1.js")
  },
  {
    id: "d",
    name: "D",
    import: () => import("./d-D6ZXmn3l.js")
  },
  {
    id: "dart",
    name: "Dart",
    import: () => import("./dart-Dz59Is3F.js")
  },
  {
    id: "dax",
    name: "DAX",
    import: () => import("./dax-DTVGzydb.js")
  },
  {
    id: "desktop",
    name: "Desktop",
    import: () => import("./desktop-Db9vb-dl.js")
  },
  {
    id: "diff",
    name: "Diff",
    import: () => import("./diff-XmNrvgM1.js")
  },
  {
    id: "docker",
    name: "Dockerfile",
    aliases: [
      "dockerfile"
    ],
    import: () => import("./docker-DWH2onkn.js")
  },
  {
    id: "dotenv",
    name: "dotEnv",
    import: () => import("./dotenv-4337wvzu.js")
  },
  {
    id: "dream-maker",
    name: "Dream Maker",
    import: () => import("./dream-maker-CvvfrJSx.js")
  },
  {
    id: "edge",
    name: "Edge",
    import: () => import("./edge-CgxR-qhM.js")
  },
  {
    id: "elixir",
    name: "Elixir",
    import: () => import("./elixir-DZkeSPwW.js")
  },
  {
    id: "elm",
    name: "Elm",
    import: () => import("./elm-BKuV1HE1.js")
  },
  {
    id: "emacs-lisp",
    name: "Emacs Lisp",
    aliases: [
      "elisp"
    ],
    import: () => import("./emacs-lisp-BAefI874.js")
  },
  {
    id: "erb",
    name: "ERB",
    import: () => import("./erb-BLwkpXUJ.js")
  },
  {
    id: "erlang",
    name: "Erlang",
    aliases: [
      "erl"
    ],
    import: () => import("./erlang-CmIiwF3I.js")
  },
  {
    id: "fennel",
    name: "Fennel",
    import: () => import("./fennel-DNqkz9pE.js")
  },
  {
    id: "fish",
    name: "Fish",
    import: () => import("./fish-DIm72t2T.js")
  },
  {
    id: "fluent",
    name: "Fluent",
    aliases: [
      "ftl"
    ],
    import: () => import("./fluent-BapTxJsC.js")
  },
  {
    id: "fortran-fixed-form",
    name: "Fortran (Fixed Form)",
    aliases: [
      "f",
      "for",
      "f77"
    ],
    import: () => import("./fortran-fixed-form-s9Hnb3av.js")
  },
  {
    id: "fortran-free-form",
    name: "Fortran (Free Form)",
    aliases: [
      "f90",
      "f95",
      "f03",
      "f08",
      "f18"
    ],
    import: () => import("./fortran-free-form-CNDsBFUj.js")
  },
  {
    id: "fsharp",
    name: "F#",
    aliases: [
      "f#",
      "fs"
    ],
    import: () => import("./fsharp-Cv0x43wb.js")
  },
  {
    id: "gdresource",
    name: "GDResource",
    import: () => import("./gdresource-CMcKXvgJ.js")
  },
  {
    id: "gdscript",
    name: "GDScript",
    import: () => import("./gdscript-D7aheHm-.js")
  },
  {
    id: "gdshader",
    name: "GDShader",
    import: () => import("./gdshader-BGJEsM2Z.js")
  },
  {
    id: "genie",
    name: "Genie",
    import: () => import("./genie-C9gPjc6J.js")
  },
  {
    id: "gherkin",
    name: "Gherkin",
    import: () => import("./gherkin-bka1Exbx.js")
  },
  {
    id: "git-commit",
    name: "Git Commit Message",
    import: () => import("./git-commit-BspYIY3P.js")
  },
  {
    id: "git-rebase",
    name: "Git Rebase Message",
    import: () => import("./git-rebase--zLBTjUa.js")
  },
  {
    id: "gleam",
    name: "Gleam",
    import: () => import("./gleam-B4k9YFGD.js")
  },
  {
    id: "glimmer-js",
    name: "Glimmer JS",
    aliases: [
      "gjs"
    ],
    import: () => import("./glimmer-js-DhY9umHJ.js")
  },
  {
    id: "glimmer-ts",
    name: "Glimmer TS",
    aliases: [
      "gts"
    ],
    import: () => import("./glimmer-ts-CCrHcYH5.js")
  },
  {
    id: "glsl",
    name: "GLSL",
    import: () => import("./glsl-XLGYNq5B.js")
  },
  {
    id: "gnuplot",
    name: "Gnuplot",
    import: () => import("./gnuplot-DnWoRZt-.js")
  },
  {
    id: "go",
    name: "Go",
    import: () => import("./go-BErP6iv1.js")
  },
  {
    id: "graphql",
    name: "GraphQL",
    aliases: [
      "gql"
    ],
    import: () => import("./graphql-DWpQF4JI.js")
  },
  {
    id: "groovy",
    name: "Groovy",
    import: () => import("./groovy-IWs5-NIO.js")
  },
  {
    id: "hack",
    name: "Hack",
    import: () => import("./hack-CQrV-ytR.js")
  },
  {
    id: "haml",
    name: "Ruby Haml",
    import: () => import("./haml-CMN0hQaL.js")
  },
  {
    id: "handlebars",
    name: "Handlebars",
    aliases: [
      "hbs"
    ],
    import: () => import("./handlebars-Cc-7fXX5.js")
  },
  {
    id: "haskell",
    name: "Haskell",
    aliases: [
      "hs"
    ],
    import: () => import("./haskell-CtlGos0K.js")
  },
  {
    id: "haxe",
    name: "Haxe",
    import: () => import("./haxe-CZZ33vZw.js")
  },
  {
    id: "hcl",
    name: "HashiCorp HCL",
    import: () => import("./hcl-6hOg9WP4.js")
  },
  {
    id: "hjson",
    name: "Hjson",
    import: () => import("./hjson-CgwED-oz.js")
  },
  {
    id: "hlsl",
    name: "HLSL",
    import: () => import("./hlsl-3-lv4gi7.js")
  },
  {
    id: "html",
    name: "HTML",
    import: () => import("./html-B0P_v3yU.js")
  },
  {
    id: "html-derivative",
    name: "HTML (Derivative)",
    import: () => import("./html-derivative-D59SHfh8.js")
  },
  {
    id: "http",
    name: "HTTP",
    import: () => import("./http-Dcjm_K1m.js")
  },
  {
    id: "hxml",
    name: "HXML",
    import: () => import("./hxml-BNKImryz.js")
  },
  {
    id: "hy",
    name: "Hy",
    import: () => import("./hy-C2xHhR6I.js")
  },
  {
    id: "imba",
    name: "Imba",
    import: () => import("./imba-Drd0AMDo.js")
  },
  {
    id: "ini",
    name: "INI",
    aliases: [
      "properties"
    ],
    import: () => import("./ini-BUcvsX-U.js")
  },
  {
    id: "java",
    name: "Java",
    import: () => import("./java-B7odJ7Ap.js")
  },
  {
    id: "javascript",
    name: "JavaScript",
    aliases: [
      "js"
    ],
    import: () => import("./javascript-fa8UlHZE.js")
  },
  {
    id: "jinja",
    name: "Jinja",
    import: () => import("./jinja-CCSYduCH.js")
  },
  {
    id: "jison",
    name: "Jison",
    import: () => import("./jison-BygvlveW.js")
  },
  {
    id: "json",
    name: "JSON",
    import: () => import("./json-71t8ZF9g.js")
  },
  {
    id: "json5",
    name: "JSON5",
    import: () => import("./json5-Z7F6rA6a.js")
  },
  {
    id: "jsonc",
    name: "JSON with Comments",
    import: () => import("./jsonc-Dphhs4m2.js")
  },
  {
    id: "jsonl",
    name: "JSON Lines",
    import: () => import("./jsonl-D9jj92Gg.js")
  },
  {
    id: "jsonnet",
    name: "Jsonnet",
    import: () => import("./jsonnet-DEQ7IUoJ.js")
  },
  {
    id: "jssm",
    name: "JSSM",
    aliases: [
      "fsl"
    ],
    import: () => import("./jssm-j74e88UX.js")
  },
  {
    id: "jsx",
    name: "JSX",
    import: () => import("./jsx-Bkesy5tT.js")
  },
  {
    id: "julia",
    name: "Julia",
    aliases: [
      "jl"
    ],
    import: () => import("./julia-CiahampL.js")
  },
  {
    id: "kotlin",
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    import: () => import("./kotlin-DCgZY7Ii.js")
  },
  {
    id: "kusto",
    name: "Kusto",
    aliases: [
      "kql"
    ],
    import: () => import("./kusto-Cw029H-v.js")
  },
  {
    id: "latex",
    name: "LaTeX",
    import: () => import("./latex-LfGCYGw5.js")
  },
  {
    id: "lean",
    name: "Lean 4",
    aliases: [
      "lean4"
    ],
    import: () => import("./lean-CYSet4vs.js")
  },
  {
    id: "less",
    name: "Less",
    import: () => import("./less-DQA4v-Nm.js")
  },
  {
    id: "liquid",
    name: "Liquid",
    import: () => import("./liquid-CvufO3kO.js")
  },
  {
    id: "log",
    name: "Log file",
    import: () => import("./log-D2eRfqDn.js")
  },
  {
    id: "logo",
    name: "Logo",
    import: () => import("./logo-QEAtGWZ9.js")
  },
  {
    id: "lua",
    name: "Lua",
    import: () => import("./lua-BVfhNLDr.js")
  },
  {
    id: "luau",
    name: "Luau",
    import: () => import("./luau-BjYGiqID.js")
  },
  {
    id: "make",
    name: "Makefile",
    aliases: [
      "makefile"
    ],
    import: () => import("./make-BjuHP00g.js")
  },
  {
    id: "markdown",
    name: "Markdown",
    aliases: [
      "md"
    ],
    import: () => import("./markdown-B6guhLWd.js")
  },
  {
    id: "marko",
    name: "Marko",
    import: () => import("./marko-CHlMS8w5.js")
  },
  {
    id: "matlab",
    name: "MATLAB",
    import: () => import("./matlab-BpQlIJiw.js")
  },
  {
    id: "mdc",
    name: "MDC",
    import: () => import("./mdc-4K6B6lHG.js")
  },
  {
    id: "mdx",
    name: "MDX",
    import: () => import("./mdx-DIoECIFU.js")
  },
  {
    id: "mermaid",
    name: "Mermaid",
    aliases: [
      "mmd"
    ],
    import: () => import("./mermaid-BZ7WHNIe.js")
  },
  {
    id: "mipsasm",
    name: "MIPS Assembly",
    aliases: [
      "mips"
    ],
    import: () => import("./mipsasm-DusDYkFc.js")
  },
  {
    id: "mojo",
    name: "Mojo",
    import: () => import("./mojo-CY9jaezJ.js")
  },
  {
    id: "move",
    name: "Move",
    import: () => import("./move-ChphFumd.js")
  },
  {
    id: "narrat",
    name: "Narrat Language",
    aliases: [
      "nar"
    ],
    import: () => import("./narrat-Dz4d7OmN.js")
  },
  {
    id: "nextflow",
    name: "Nextflow",
    aliases: [
      "nf"
    ],
    import: () => import("./nextflow-DW0Yq9a2.js")
  },
  {
    id: "nginx",
    name: "Nginx",
    import: () => import("./nginx-Can2eAjw.js")
  },
  {
    id: "nim",
    name: "Nim",
    import: () => import("./nim-B3r2RtQZ.js")
  },
  {
    id: "nix",
    name: "Nix",
    import: () => import("./nix-Cg5uV_xg.js")
  },
  {
    id: "nushell",
    name: "nushell",
    aliases: [
      "nu"
    ],
    import: () => import("./nushell-BfRnzRWn.js")
  },
  {
    id: "objective-c",
    name: "Objective-C",
    aliases: [
      "objc"
    ],
    import: () => import("./objective-c-BGg9R27G.js")
  },
  {
    id: "objective-cpp",
    name: "Objective-C++",
    import: () => import("./objective-cpp-CJ3y3V_5.js")
  },
  {
    id: "ocaml",
    name: "OCaml",
    import: () => import("./ocaml-BZLsfx_o.js")
  },
  {
    id: "pascal",
    name: "Pascal",
    import: () => import("./pascal-l2bqd7Dz.js")
  },
  {
    id: "perl",
    name: "Perl",
    import: () => import("./perl-DaMQyPwp.js")
  },
  {
    id: "php",
    name: "PHP",
    import: () => import("./php-BL3EfPBi.js")
  },
  {
    id: "plsql",
    name: "PL/SQL",
    import: () => import("./plsql-oVq_K_wH.js")
  },
  {
    id: "po",
    name: "Gettext PO",
    aliases: [
      "pot",
      "potx"
    ],
    import: () => import("./po-5jaeIyVd.js")
  },
  {
    id: "polar",
    name: "Polar",
    import: () => import("./polar-wcLp8ci7.js")
  },
  {
    id: "postcss",
    name: "PostCSS",
    import: () => import("./postcss-BZ3MNRIJ.js")
  },
  {
    id: "powerquery",
    name: "PowerQuery",
    import: () => import("./powerquery-CgRa2XRw.js")
  },
  {
    id: "powershell",
    name: "PowerShell",
    aliases: [
      "ps",
      "ps1"
    ],
    import: () => import("./powershell-Diwyv8Eh.js")
  },
  {
    id: "prisma",
    name: "Prisma",
    import: () => import("./prisma-COL_v1x4.js")
  },
  {
    id: "prolog",
    name: "Prolog",
    import: () => import("./prolog-CuvJOxqT.js")
  },
  {
    id: "proto",
    name: "Protocol Buffer 3",
    aliases: [
      "protobuf"
    ],
    import: () => import("./proto-o9HLmF90.js")
  },
  {
    id: "pug",
    name: "Pug",
    aliases: [
      "jade"
    ],
    import: () => import("./pug-HKe4Luo3.js")
  },
  {
    id: "puppet",
    name: "Puppet",
    import: () => import("./puppet-wpGOnQp5.js")
  },
  {
    id: "purescript",
    name: "PureScript",
    import: () => import("./purescript-B_1NgE2N.js")
  },
  {
    id: "python",
    name: "Python",
    aliases: [
      "py"
    ],
    import: () => import("./python-xYxLFJY-.js")
  },
  {
    id: "qml",
    name: "QML",
    import: () => import("./qml-FlMIyjU9.js")
  },
  {
    id: "qmldir",
    name: "QML Directory",
    import: () => import("./qmldir-BInDYbpo.js")
  },
  {
    id: "qss",
    name: "Qt Style Sheets",
    import: () => import("./qss-D-h4NdUG.js")
  },
  {
    id: "r",
    name: "R",
    import: () => import("./r-F-9I-ITZ.js")
  },
  {
    id: "racket",
    name: "Racket",
    import: () => import("./racket-BoD1TBFT.js")
  },
  {
    id: "raku",
    name: "Raku",
    aliases: [
      "perl6"
    ],
    import: () => import("./raku-IaYcw19m.js")
  },
  {
    id: "razor",
    name: "ASP.NET Razor",
    import: () => import("./razor-CeqqNtyB.js")
  },
  {
    id: "reg",
    name: "Windows Registry Script",
    import: () => import("./reg-CMUdAgIP.js")
  },
  {
    id: "regexp",
    name: "RegExp",
    aliases: [
      "regex"
    ],
    import: () => import("./regexp-GiFkbxS-.js")
  },
  {
    id: "rel",
    name: "Rel",
    import: () => import("./rel-BaRn3QX7.js")
  },
  {
    id: "riscv",
    name: "RISC-V",
    import: () => import("./riscv-B9V3SsvW.js")
  },
  {
    id: "rst",
    name: "reStructuredText",
    import: () => import("./rst-C3D6-dqL.js")
  },
  {
    id: "ruby",
    name: "Ruby",
    aliases: [
      "rb"
    ],
    import: () => import("./ruby-DcPLUUK3.js")
  },
  {
    id: "rust",
    name: "Rust",
    aliases: [
      "rs"
    ],
    import: () => import("./rust-Pc7DCsZD.js")
  },
  {
    id: "sas",
    name: "SAS",
    import: () => import("./sas-tDSYjXcL.js")
  },
  {
    id: "sass",
    name: "Sass",
    import: () => import("./sass-iCyS6eP9.js")
  },
  {
    id: "scala",
    name: "Scala",
    import: () => import("./scala-Cly-fENF.js")
  },
  {
    id: "scheme",
    name: "Scheme",
    import: () => import("./scheme-Zi24oEYu.js")
  },
  {
    id: "scss",
    name: "SCSS",
    import: () => import("./scss-DhHc4lxB.js")
  },
  {
    id: "sdbl",
    name: "1C (Query)",
    aliases: [
      "1c-query"
    ],
    import: () => import("./sdbl-BBamrXFL.js")
  },
  {
    id: "shaderlab",
    name: "ShaderLab",
    aliases: [
      "shader"
    ],
    import: () => import("./shaderlab-CvqEIoL0.js")
  },
  {
    id: "shellscript",
    name: "Shell",
    aliases: [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    import: () => import("./shellscript-Dn0-btNd.js")
  },
  {
    id: "shellsession",
    name: "Shell Session",
    aliases: [
      "console"
    ],
    import: () => import("./shellsession-8OLo3sB6.js")
  },
  {
    id: "smalltalk",
    name: "Smalltalk",
    import: () => import("./smalltalk-Cns31tKw.js")
  },
  {
    id: "solidity",
    name: "Solidity",
    import: () => import("./solidity-BG_k8fA_.js")
  },
  {
    id: "soy",
    name: "Closure Templates",
    aliases: [
      "closure-templates"
    ],
    import: () => import("./soy-EwHMOVPj.js")
  },
  {
    id: "sparql",
    name: "SPARQL",
    import: () => import("./sparql-DhuelBut.js")
  },
  {
    id: "splunk",
    name: "Splunk Query Language",
    aliases: [
      "spl"
    ],
    import: () => import("./splunk-CTqDjQdo.js")
  },
  {
    id: "sql",
    name: "SQL",
    import: () => import("./sql-DCkt643-.js")
  },
  {
    id: "ssh-config",
    name: "SSH Config",
    import: () => import("./ssh-config-DHHGll-v.js")
  },
  {
    id: "stata",
    name: "Stata",
    import: () => import("./stata-Dok6hMw0.js")
  },
  {
    id: "stylus",
    name: "Stylus",
    aliases: [
      "styl"
    ],
    import: () => import("./stylus-n_9f0QQ5.js")
  },
  {
    id: "svelte",
    name: "Svelte",
    import: () => import("./svelte-01qw6Rxm.js")
  },
  {
    id: "swift",
    name: "Swift",
    import: () => import("./swift-BAWqNR8A.js")
  },
  {
    id: "system-verilog",
    name: "SystemVerilog",
    import: () => import("./system-verilog-Cui-g-ut.js")
  },
  {
    id: "systemd",
    name: "Systemd Units",
    import: () => import("./systemd-CsKYQIQK.js")
  },
  {
    id: "talonscript",
    name: "TalonScript",
    aliases: [
      "talon"
    ],
    import: () => import("./talonscript-D2dGh8FO.js")
  },
  {
    id: "tasl",
    name: "Tasl",
    import: () => import("./tasl-D3W8HMV6.js")
  },
  {
    id: "tcl",
    name: "Tcl",
    import: () => import("./tcl-2y0Fuc4S.js")
  },
  {
    id: "templ",
    name: "Templ",
    import: () => import("./templ-Hmy8U0DD.js")
  },
  {
    id: "terraform",
    name: "Terraform",
    aliases: [
      "tf",
      "tfvars"
    ],
    import: () => import("./terraform-BGW6Oerf.js")
  },
  {
    id: "tex",
    name: "TeX",
    import: () => import("./tex-mHs7a43s.js")
  },
  {
    id: "toml",
    name: "TOML",
    import: () => import("./toml-CQSfOn0e.js")
  },
  {
    id: "ts-tags",
    name: "TypeScript with Tags",
    aliases: [
      "lit"
    ],
    import: () => import("./ts-tags-DYZ4SGcN.js")
  },
  {
    id: "tsv",
    name: "TSV",
    import: () => import("./tsv-BtvSkaG0.js")
  },
  {
    id: "tsx",
    name: "TSX",
    import: () => import("./tsx-DiGsgWT8.js")
  },
  {
    id: "turtle",
    name: "Turtle",
    import: () => import("./turtle-BJ2wmjPc.js")
  },
  {
    id: "twig",
    name: "Twig",
    import: () => import("./twig-BmytkGQV.js")
  },
  {
    id: "typescript",
    name: "TypeScript",
    aliases: [
      "ts"
    ],
    import: () => import("./typescript-buWNZFwO.js")
  },
  {
    id: "typespec",
    name: "TypeSpec",
    aliases: [
      "tsp"
    ],
    import: () => import("./typespec-bLbdsxJL.js")
  },
  {
    id: "typst",
    name: "Typst",
    aliases: [
      "typ"
    ],
    import: () => import("./typst-Y9_SmXTs.js")
  },
  {
    id: "v",
    name: "V",
    import: () => import("./v-wa8Orrdd.js")
  },
  {
    id: "vala",
    name: "Vala",
    import: () => import("./vala-DRdriFr_.js")
  },
  {
    id: "vb",
    name: "Visual Basic",
    aliases: [
      "cmd"
    ],
    import: () => import("./vb-E2_-jk4M.js")
  },
  {
    id: "verilog",
    name: "Verilog",
    import: () => import("./verilog-B1iBoR5_.js")
  },
  {
    id: "vhdl",
    name: "VHDL",
    import: () => import("./vhdl-CRVaAhXk.js")
  },
  {
    id: "viml",
    name: "Vim Script",
    aliases: [
      "vim",
      "vimscript"
    ],
    import: () => import("./viml-B-zWOd7Z.js")
  },
  {
    id: "vue",
    name: "Vue",
    import: () => import("./vue-Bl1uVNsA.js")
  },
  {
    id: "vue-html",
    name: "Vue HTML",
    import: () => import("./vue-html-DHr5wjBG.js")
  },
  {
    id: "vyper",
    name: "Vyper",
    aliases: [
      "vy"
    ],
    import: () => import("./vyper-DWutKXpa.js")
  },
  {
    id: "wasm",
    name: "WebAssembly",
    import: () => import("./wasm-Bv5f0gKv.js")
  },
  {
    id: "wenyan",
    name: "Wenyan",
    aliases: [
      ""
    ],
    import: () => import("./wenyan-BMYnfus1.js")
  },
  {
    id: "wgsl",
    name: "WGSL",
    import: () => import("./wgsl-DnPoPGDU.js")
  },
  {
    id: "wikitext",
    name: "Wikitext",
    aliases: [
      "mediawiki",
      "wiki"
    ],
    import: () => import("./wikitext-CntM04PE.js")
  },
  {
    id: "wolfram",
    name: "Wolfram",
    aliases: [
      "wl"
    ],
    import: () => import("./wolfram-Ws5qPlX9.js")
  },
  {
    id: "xml",
    name: "XML",
    import: () => import("./xml-ChBsf5uy.js")
  },
  {
    id: "xsl",
    name: "XSL",
    import: () => import("./xsl-BefjlXrd.js")
  },
  {
    id: "yaml",
    name: "YAML",
    aliases: [
      "yml"
    ],
    import: () => import("./yaml-Bbg74JKr.js")
  },
  {
    id: "zenscript",
    name: "ZenScript",
    import: () => import("./zenscript-C0RKE4nU.js")
  },
  {
    id: "zig",
    name: "Zig",
    import: () => import("./zig-D6SXBGNm.js")
  }
], F4e = Object.fromEntries(Mq.map((t) => [t.id, t.import])), $4e = Object.fromEntries(Mq.flatMap((t) => t.aliases?.map((e) => [e, t.import]) || [])), Bq = {
  ...F4e,
  ...$4e
}, U4e = [
  {
    id: "andromeeda",
    displayName: "Andromeeda",
    type: "dark",
    import: () => import("./andromeeda-uXNdzNpk.js")
  },
  {
    id: "aurora-x",
    displayName: "Aurora X",
    type: "dark",
    import: () => import("./aurora-x-BwoVEUWZ.js")
  },
  {
    id: "ayu-dark",
    displayName: "Ayu Dark",
    type: "dark",
    import: () => import("./ayu-dark-CxPZkpb2.js")
  },
  {
    id: "catppuccin-frappe",
    displayName: "Catppuccin Frapp",
    type: "dark",
    import: () => import("./catppuccin-frappe-BrTOiad2.js")
  },
  {
    id: "catppuccin-latte",
    displayName: "Catppuccin Latte",
    type: "light",
    import: () => import("./catppuccin-latte-D-dc_R4m.js")
  },
  {
    id: "catppuccin-macchiato",
    displayName: "Catppuccin Macchiato",
    type: "dark",
    import: () => import("./catppuccin-macchiato-DN4jOp0G.js")
  },
  {
    id: "catppuccin-mocha",
    displayName: "Catppuccin Mocha",
    type: "dark",
    import: () => import("./catppuccin-mocha-B8yCE3-3.js")
  },
  {
    id: "dark-plus",
    displayName: "Dark Plus",
    type: "dark",
    import: () => import("./dark-plus-pUHDTVV0.js")
  },
  {
    id: "dracula",
    displayName: "Dracula Theme",
    type: "dark",
    import: () => import("./dracula-BtZx2Kac.js")
  },
  {
    id: "dracula-soft",
    displayName: "Dracula Theme Soft",
    type: "dark",
    import: () => import("./dracula-soft-BKa-aqBv.js")
  },
  {
    id: "everforest-dark",
    displayName: "Everforest Dark",
    type: "dark",
    import: () => import("./everforest-dark-DMCBqXCK.js")
  },
  {
    id: "everforest-light",
    displayName: "Everforest Light",
    type: "light",
    import: () => import("./everforest-light-BbXl82Em.js")
  },
  {
    id: "github-dark",
    displayName: "GitHub Dark",
    type: "dark",
    import: () => import("./github-dark-DenFmJkN.js")
  },
  {
    id: "github-dark-default",
    displayName: "GitHub Dark Default",
    type: "dark",
    import: () => import("./github-dark-default-BJPUVz4H.js")
  },
  {
    id: "github-dark-dimmed",
    displayName: "GitHub Dark Dimmed",
    type: "dark",
    import: () => import("./github-dark-dimmed-DUshB20C.js")
  },
  {
    id: "github-dark-high-contrast",
    displayName: "GitHub Dark High Contrast",
    type: "dark",
    import: () => import("./github-dark-high-contrast-D3aGCnF8.js")
  },
  {
    id: "github-light",
    displayName: "GitHub Light",
    type: "light",
    import: () => import("./github-light-JYsPkUQd.js")
  },
  {
    id: "github-light-default",
    displayName: "GitHub Light Default",
    type: "light",
    import: () => import("./github-light-default-D99KPAby.js")
  },
  {
    id: "github-light-high-contrast",
    displayName: "GitHub Light High Contrast",
    type: "light",
    import: () => import("./github-light-high-contrast-BbmZE-Mp.js")
  },
  {
    id: "houston",
    displayName: "Houston",
    type: "dark",
    import: () => import("./houston-BDYrDoDW.js")
  },
  {
    id: "kanagawa-dragon",
    displayName: "Kanagawa Dragon",
    type: "dark",
    import: () => import("./kanagawa-dragon-CiKur4Hl.js")
  },
  {
    id: "kanagawa-lotus",
    displayName: "Kanagawa Lotus",
    type: "light",
    import: () => import("./kanagawa-lotus-BKu-smKu.js")
  },
  {
    id: "kanagawa-wave",
    displayName: "Kanagawa Wave",
    type: "dark",
    import: () => import("./kanagawa-wave-CQwozSzG.js")
  },
  {
    id: "laserwave",
    displayName: "LaserWave",
    type: "dark",
    import: () => import("./laserwave-6a00oqik.js")
  },
  {
    id: "light-plus",
    displayName: "Light Plus",
    type: "light",
    import: () => import("./light-plus-CZuVqSLX.js")
  },
  {
    id: "material-theme",
    displayName: "Material Theme",
    type: "dark",
    import: () => import("./material-theme-D6KBX41T.js")
  },
  {
    id: "material-theme-darker",
    displayName: "Material Theme Darker",
    type: "dark",
    import: () => import("./material-theme-darker-CkRroheE.js")
  },
  {
    id: "material-theme-lighter",
    displayName: "Material Theme Lighter",
    type: "light",
    import: () => import("./material-theme-lighter-BUBw43Yz.js")
  },
  {
    id: "material-theme-ocean",
    displayName: "Material Theme Ocean",
    type: "dark",
    import: () => import("./material-theme-ocean-ClGX14Ja.js")
  },
  {
    id: "material-theme-palenight",
    displayName: "Material Theme Palenight",
    type: "dark",
    import: () => import("./material-theme-palenight-C1RVm8K1.js")
  },
  {
    id: "min-dark",
    displayName: "Min Dark",
    type: "dark",
    import: () => import("./min-dark-C7ak0t6c.js")
  },
  {
    id: "min-light",
    displayName: "Min Light",
    type: "light",
    import: () => import("./min-light-CKFxVcPp.js")
  },
  {
    id: "monokai",
    displayName: "Monokai",
    type: "dark",
    import: () => import("./monokai-C1KBYcO0.js")
  },
  {
    id: "night-owl",
    displayName: "Night Owl",
    type: "dark",
    import: () => import("./night-owl-Bm2rzalh.js")
  },
  {
    id: "nord",
    displayName: "Nord",
    type: "dark",
    import: () => import("./nord-CC5OiUXg.js")
  },
  {
    id: "one-dark-pro",
    displayName: "One Dark Pro",
    type: "dark",
    import: () => import("./one-dark-pro-D7-kP8fv.js")
  },
  {
    id: "one-light",
    displayName: "One Light",
    type: "light",
    import: () => import("./one-light-D9sNaUtq.js")
  },
  {
    id: "plastic",
    displayName: "Plastic",
    type: "dark",
    import: () => import("./plastic-CSTz3KZp.js")
  },
  {
    id: "poimandres",
    displayName: "Poimandres",
    type: "dark",
    import: () => import("./poimandres-C-VADXHD.js")
  },
  {
    id: "red",
    displayName: "Red",
    type: "dark",
    import: () => import("./red-7y8PH7HH.js")
  },
  {
    id: "rose-pine",
    displayName: "Ros Pine",
    type: "dark",
    import: () => import("./rose-pine-DhT-HZE9.js")
  },
  {
    id: "rose-pine-dawn",
    displayName: "Ros Pine Dawn",
    type: "light",
    import: () => import("./rose-pine-dawn-DiCjL2i4.js")
  },
  {
    id: "rose-pine-moon",
    displayName: "Ros Pine Moon",
    type: "dark",
    import: () => import("./rose-pine-moon-BNmGHlcn.js")
  },
  {
    id: "slack-dark",
    displayName: "Slack Dark",
    type: "dark",
    import: () => import("./slack-dark-i7wN4OET.js")
  },
  {
    id: "slack-ochin",
    displayName: "Slack Ochin",
    type: "light",
    import: () => import("./slack-ochin-ndHf0LoP.js")
  },
  {
    id: "snazzy-light",
    displayName: "Snazzy Light",
    type: "light",
    import: () => import("./snazzy-light-BlSJXAu4.js")
  },
  {
    id: "solarized-dark",
    displayName: "Solarized Dark",
    type: "dark",
    import: () => import("./solarized-dark-UTmkh7lw.js")
  },
  {
    id: "solarized-light",
    displayName: "Solarized Light",
    type: "light",
    import: () => import("./solarized-light-BheCkDPT.js")
  },
  {
    id: "synthwave-84",
    displayName: "Synthwave '84",
    type: "dark",
    import: () => import("./synthwave-84-NU3C_KFZ.js")
  },
  {
    id: "tokyo-night",
    displayName: "Tokyo Night",
    type: "dark",
    import: () => import("./tokyo-night-LhP3hHhi.js")
  },
  {
    id: "vesper",
    displayName: "Vesper",
    type: "dark",
    import: () => import("./vesper-CJsaOsSM.js")
  },
  {
    id: "vitesse-black",
    displayName: "Vitesse Black",
    type: "dark",
    import: () => import("./vitesse-black-BoGvW84i.js")
  },
  {
    id: "vitesse-dark",
    displayName: "Vitesse Dark",
    type: "dark",
    import: () => import("./vitesse-dark-Cym-eLtO.js")
  },
  {
    id: "vitesse-light",
    displayName: "Vitesse Light",
    type: "light",
    import: () => import("./vitesse-light-CcmG315c.js")
  }
], j4e = Object.fromEntries(U4e.map((t) => [t.id, t.import]));
let ao = class extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
}, KA = class extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
};
function H4e() {
  return 2147483648;
}
function z4e() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const G4e = (t, e) => t + (e - t % e) % e;
async function V4e(t) {
  let e, n;
  const r = {};
  function s(f) {
    n = f, r.HEAPU8 = new Uint8Array(f), r.HEAPU32 = new Uint32Array(f);
  }
  function i(f, g, y) {
    r.HEAPU8.copyWithin(f, g, g + y);
  }
  function o(f) {
    try {
      return e.grow(f - n.byteLength + 65535 >>> 16), s(e.buffer), 1;
    } catch {
    }
  }
  function a(f) {
    const g = r.HEAPU8.length;
    f = f >>> 0;
    const y = H4e();
    if (f > y)
      return !1;
    for (let p = 1; p <= 4; p *= 2) {
      let m = g * (1 + 0.2 / p);
      m = Math.min(m, f + 100663296);
      const b = Math.min(y, G4e(Math.max(f, m), 65536));
      if (o(b))
        return !0;
    }
    return !1;
  }
  const l = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function c(f, g, y = 1024) {
    const p = g + y;
    let m = g;
    for (; f[m] && !(m >= p); )
      ++m;
    if (m - g > 16 && f.buffer && l)
      return l.decode(f.subarray(g, m));
    let b = "";
    for (; g < m; ) {
      let _ = f[g++];
      if (!(_ & 128)) {
        b += String.fromCharCode(_);
        continue;
      }
      const v = f[g++] & 63;
      if ((_ & 224) === 192) {
        b += String.fromCharCode((_ & 31) << 6 | v);
        continue;
      }
      const w = f[g++] & 63;
      if ((_ & 240) === 224 ? _ = (_ & 15) << 12 | v << 6 | w : _ = (_ & 7) << 18 | v << 12 | w << 6 | f[g++] & 63, _ < 65536)
        b += String.fromCharCode(_);
      else {
        const E = _ - 65536;
        b += String.fromCharCode(55296 | E >> 10, 56320 | E & 1023);
      }
    }
    return b;
  }
  function u(f, g) {
    return f ? c(r.HEAPU8, f, g) : "";
  }
  const h = {
    emscripten_get_now: z4e,
    emscripten_memcpy_big: i,
    emscripten_resize_heap: a,
    fd_write: () => 0
  };
  async function d() {
    const g = await t({
      env: h,
      wasi_snapshot_preview1: h
    });
    e = g.memory, s(e.buffer), Object.assign(r, g), r.UTF8ToString = u;
  }
  return await d(), r;
}
var W4e = Object.defineProperty, q4e = (t, e, n) => e in t ? W4e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, cn = (t, e, n) => (q4e(t, typeof e != "symbol" ? e + "" : e, n), n);
let bn = null;
function K4e(t) {
  throw new KA(t.UTF8ToString(t.getLastOnigError()));
}
class m_ {
  constructor(e) {
    cn(this, "utf16Length"), cn(this, "utf8Length"), cn(this, "utf16Value"), cn(this, "utf8Value"), cn(this, "utf16OffsetToUtf8"), cn(this, "utf8OffsetToUtf16");
    const n = e.length, r = m_._utf8ByteLength(e), s = r !== n, i = s ? new Uint32Array(n + 1) : null;
    s && (i[n] = r);
    const o = s ? new Uint32Array(r + 1) : null;
    s && (o[r] = n);
    const a = new Uint8Array(r);
    let l = 0;
    for (let c = 0; c < n; c++) {
      const u = e.charCodeAt(c);
      let h = u, d = !1;
      if (u >= 55296 && u <= 56319 && c + 1 < n) {
        const f = e.charCodeAt(c + 1);
        f >= 56320 && f <= 57343 && (h = (u - 55296 << 10) + 65536 | f - 56320, d = !0);
      }
      s && (i[c] = l, d && (i[c + 1] = l), h <= 127 ? o[l + 0] = c : h <= 2047 ? (o[l + 0] = c, o[l + 1] = c) : h <= 65535 ? (o[l + 0] = c, o[l + 1] = c, o[l + 2] = c) : (o[l + 0] = c, o[l + 1] = c, o[l + 2] = c, o[l + 3] = c)), h <= 127 ? a[l++] = h : h <= 2047 ? (a[l++] = 192 | (h & 1984) >>> 6, a[l++] = 128 | (h & 63) >>> 0) : h <= 65535 ? (a[l++] = 224 | (h & 61440) >>> 12, a[l++] = 128 | (h & 4032) >>> 6, a[l++] = 128 | (h & 63) >>> 0) : (a[l++] = 240 | (h & 1835008) >>> 18, a[l++] = 128 | (h & 258048) >>> 12, a[l++] = 128 | (h & 4032) >>> 6, a[l++] = 128 | (h & 63) >>> 0), d && c++;
    }
    this.utf16Length = n, this.utf8Length = r, this.utf16Value = e, this.utf8Value = a, this.utf16OffsetToUtf8 = i, this.utf8OffsetToUtf16 = o;
  }
  static _utf8ByteLength(e) {
    let n = 0;
    for (let r = 0, s = e.length; r < s; r++) {
      const i = e.charCodeAt(r);
      let o = i, a = !1;
      if (i >= 55296 && i <= 56319 && r + 1 < s) {
        const l = e.charCodeAt(r + 1);
        l >= 56320 && l <= 57343 && (o = (i - 55296 << 10) + 65536 | l - 56320, a = !0);
      }
      o <= 127 ? n += 1 : o <= 2047 ? n += 2 : o <= 65535 ? n += 3 : n += 4, a && r++;
    }
    return n;
  }
  createString(e) {
    const n = e.omalloc(this.utf8Length);
    return e.HEAPU8.set(this.utf8Value, n), n;
  }
}
const Ys = class {
  constructor(t) {
    if (cn(this, "id", ++Ys.LAST_ID), cn(this, "_onigBinding"), cn(this, "content"), cn(this, "utf16Length"), cn(this, "utf8Length"), cn(this, "utf16OffsetToUtf8"), cn(this, "utf8OffsetToUtf16"), cn(this, "ptr"), !bn)
      throw new KA("Must invoke loadWasm first.");
    this._onigBinding = bn, this.content = t;
    const e = new m_(t);
    this.utf16Length = e.utf16Length, this.utf8Length = e.utf8Length, this.utf16OffsetToUtf8 = e.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = e.utf8OffsetToUtf16, this.utf8Length < 1e4 && !Ys._sharedPtrInUse ? (Ys._sharedPtr || (Ys._sharedPtr = bn.omalloc(1e4)), Ys._sharedPtrInUse = !0, bn.HEAPU8.set(e.utf8Value, Ys._sharedPtr), this.ptr = Ys._sharedPtr) : this.ptr = e.createString(bn);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === Ys._sharedPtr ? Ys._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
let Sp = Ys;
cn(Sp, "LAST_ID", 0);
cn(Sp, "_sharedPtr", 0);
cn(Sp, "_sharedPtrInUse", !1);
class Y4e {
  constructor(e) {
    if (cn(this, "_onigBinding"), cn(this, "_ptr"), !bn)
      throw new KA("Must invoke loadWasm first.");
    const n = [], r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = new m_(e[a]);
      n[a] = c.createString(bn), r[a] = c.utf8Length;
    }
    const s = bn.omalloc(4 * e.length);
    bn.HEAPU32.set(n, s / 4);
    const i = bn.omalloc(4 * e.length);
    bn.HEAPU32.set(r, i / 4);
    const o = bn.createOnigScanner(s, i, e.length);
    for (let a = 0, l = e.length; a < l; a++)
      bn.ofree(n[a]);
    bn.ofree(i), bn.ofree(s), o === 0 && K4e(bn), this._onigBinding = bn, this._ptr = o;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(e, n, r) {
    let s = 0;
    if (typeof r == "number" && (s = r), typeof e == "string") {
      e = new Sp(e);
      const i = this._findNextMatchSync(e, n, !1, s);
      return e.dispose(), i;
    }
    return this._findNextMatchSync(e, n, !1, s);
  }
  _findNextMatchSync(e, n, r, s) {
    const i = this._onigBinding, o = i.findNextOnigScannerMatch(this._ptr, e.id, e.ptr, e.utf8Length, e.convertUtf16OffsetToUtf8(n), s);
    if (o === 0)
      return null;
    const a = i.HEAPU32;
    let l = o / 4;
    const c = a[l++], u = a[l++], h = [];
    for (let d = 0; d < u; d++) {
      const f = e.convertUtf8OffsetToUtf16(a[l++]), g = e.convertUtf8OffsetToUtf16(a[l++]);
      h[d] = {
        start: f,
        end: g,
        length: g - f
      };
    }
    return {
      index: c,
      captureIndices: h
    };
  }
}
function Z4e(t) {
  return typeof t.instantiator == "function";
}
function J4e(t) {
  return typeof t.default == "function";
}
function X4e(t) {
  return typeof t.data < "u";
}
function Q4e(t) {
  return typeof Response < "u" && t instanceof Response;
}
function e5e(t) {
  return typeof ArrayBuffer < "u" && (t instanceof ArrayBuffer || ArrayBuffer.isView(t)) || typeof Me < "u" && Me.isBuffer?.(t) || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer || typeof Uint32Array < "u" && t instanceof Uint32Array;
}
let Km;
function t5e(t) {
  if (Km)
    return Km;
  async function e() {
    bn = await V4e(async (n) => {
      let r = t;
      return r = await r, typeof r == "function" && (r = await r(n)), typeof r == "function" && (r = await r(n)), Z4e(r) ? r = await r.instantiator(n) : J4e(r) ? r = await r.default(n) : (X4e(r) && (r = r.data), Q4e(r) ? typeof WebAssembly.instantiateStreaming == "function" ? r = await n5e(r)(n) : r = await r5e(r)(n) : e5e(r) ? r = await jw(r)(n) : r instanceof WebAssembly.Module ? r = await jw(r)(n) : "default" in r && r.default instanceof WebAssembly.Module && (r = await jw(r.default)(n))), "instance" in r && (r = r.instance), "exports" in r && (r = r.exports), r;
    });
  }
  return Km = e(), Km;
}
function jw(t) {
  return (e) => WebAssembly.instantiate(t, e);
}
function n5e(t) {
  return (e) => WebAssembly.instantiateStreaming(t, e);
}
function r5e(t) {
  return async (e) => {
    const n = await t.arrayBuffer();
    return WebAssembly.instantiate(n, e);
  };
}
let s5e;
function i5e() {
  return s5e;
}
async function Fq(t) {
  return t && await t5e(t), {
    createScanner(e) {
      return new Y4e(e.map((n) => typeof n == "string" ? n : n.source));
    },
    createString(e) {
      return new Sp(e);
    }
  };
}
function o5e(t) {
  return YA(t);
}
function YA(t) {
  return Array.isArray(t) ? a5e(t) : t instanceof RegExp ? t : typeof t == "object" ? l5e(t) : t;
}
function a5e(t) {
  let e = [];
  for (let n = 0, r = t.length; n < r; n++)
    e[n] = YA(t[n]);
  return e;
}
function l5e(t) {
  let e = {};
  for (let n in t)
    e[n] = YA(t[n]);
  return e;
}
function $q(t, ...e) {
  return e.forEach((n) => {
    for (let r in n)
      t[r] = n[r];
  }), t;
}
function Uq(t) {
  const e = ~t.lastIndexOf("/") || ~t.lastIndexOf("\\");
  return e === 0 ? t : ~e === t.length - 1 ? Uq(t.substring(0, t.length - 1)) : t.substr(~e + 1);
}
var Hw = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, Ym = class {
  static hasCaptures(t) {
    return t === null ? !1 : (Hw.lastIndex = 0, Hw.test(t));
  }
  static replaceCaptures(t, e, n) {
    return t.replace(Hw, (r, s, i, o) => {
      let a = n[parseInt(s || i, 10)];
      if (a) {
        let l = e.substring(a.start, a.end);
        for (; l[0] === "."; )
          l = l.substring(1);
        switch (o) {
          case "downcase":
            return l.toLowerCase();
          case "upcase":
            return l.toUpperCase();
          default:
            return l;
        }
      } else
        return r;
    });
  }
};
function jq(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Hq(t, e) {
  if (t === null && e === null)
    return 0;
  if (!t)
    return -1;
  if (!e)
    return 1;
  let n = t.length, r = e.length;
  if (n === r) {
    for (let s = 0; s < n; s++) {
      let i = jq(t[s], e[s]);
      if (i !== 0)
        return i;
    }
    return 0;
  }
  return n - r;
}
function dM(t) {
  return !!(/^#[0-9a-f]{6}$/i.test(t) || /^#[0-9a-f]{8}$/i.test(t) || /^#[0-9a-f]{3}$/i.test(t) || /^#[0-9a-f]{4}$/i.test(t));
}
function zq(t) {
  return t.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var Gq = class {
  constructor(t) {
    this.fn = t;
  }
  cache = /* @__PURE__ */ new Map();
  get(t) {
    if (this.cache.has(t))
      return this.cache.get(t);
    const e = this.fn(t);
    return this.cache.set(t, e), e;
  }
}, Py = class {
  constructor(t, e, n) {
    this._colorMap = t, this._defaults = e, this._root = n;
  }
  static createFromRawTheme(t, e) {
    return this.createFromParsedTheme(h5e(t), e);
  }
  static createFromParsedTheme(t, e) {
    return f5e(t, e);
  }
  _cachedMatchRoot = new Gq(
    (t) => this._root.match(t)
  );
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(t) {
    if (t === null)
      return this._defaults;
    const e = t.scopeName, r = this._cachedMatchRoot.get(e).find(
      (s) => c5e(t.parent, s.parentScopes)
    );
    return r ? new Vq(
      r.fontStyle,
      r.foreground,
      r.background
    ) : null;
  }
}, zw = class Bg {
  constructor(e, n) {
    this.parent = e, this.scopeName = n;
  }
  static push(e, n) {
    for (const r of n)
      e = new Bg(e, r);
    return e;
  }
  static from(...e) {
    let n = null;
    for (let r = 0; r < e.length; r++)
      n = new Bg(n, e[r]);
    return n;
  }
  push(e) {
    return new Bg(this, e);
  }
  getSegments() {
    let e = this;
    const n = [];
    for (; e; )
      n.push(e.scopeName), e = e.parent;
    return n.reverse(), n;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(e) {
    return this === e ? !0 : this.parent === null ? !1 : this.parent.extends(e);
  }
  getExtensionIfDefined(e) {
    const n = [];
    let r = this;
    for (; r && r !== e; )
      n.push(r.scopeName), r = r.parent;
    return r === e ? n.reverse() : void 0;
  }
};
function c5e(t, e) {
  if (e.length === 0)
    return !0;
  for (let n = 0; n < e.length; n++) {
    let r = e[n], s = !1;
    if (r === ">") {
      if (n === e.length - 1)
        return !1;
      r = e[++n], s = !0;
    }
    for (; t && !u5e(t.scopeName, r); ) {
      if (s)
        return !1;
      t = t.parent;
    }
    if (!t)
      return !1;
    t = t.parent;
  }
  return !0;
}
function u5e(t, e) {
  return e === t || t.startsWith(e) && t[e.length] === ".";
}
var Vq = class {
  constructor(t, e, n) {
    this.fontStyle = t, this.foregroundId = e, this.backgroundId = n;
  }
};
function h5e(t) {
  if (!t)
    return [];
  if (!t.settings || !Array.isArray(t.settings))
    return [];
  let e = t.settings, n = [], r = 0;
  for (let s = 0, i = e.length; s < i; s++) {
    let o = e[s];
    if (!o.settings)
      continue;
    let a;
    if (typeof o.scope == "string") {
      let h = o.scope;
      h = h.replace(/^[,]+/, ""), h = h.replace(/[,]+$/, ""), a = h.split(",");
    } else Array.isArray(o.scope) ? a = o.scope : a = [""];
    let l = -1;
    if (typeof o.settings.fontStyle == "string") {
      l = 0;
      let h = o.settings.fontStyle.split(" ");
      for (let d = 0, f = h.length; d < f; d++)
        switch (h[d]) {
          case "italic":
            l = l | 1;
            break;
          case "bold":
            l = l | 2;
            break;
          case "underline":
            l = l | 4;
            break;
          case "strikethrough":
            l = l | 8;
            break;
        }
    }
    let c = null;
    typeof o.settings.foreground == "string" && dM(o.settings.foreground) && (c = o.settings.foreground);
    let u = null;
    typeof o.settings.background == "string" && dM(o.settings.background) && (u = o.settings.background);
    for (let h = 0, d = a.length; h < d; h++) {
      let g = a[h].trim().split(" "), y = g[g.length - 1], p = null;
      g.length > 1 && (p = g.slice(0, g.length - 1), p.reverse()), n[r++] = new d5e(
        y,
        p,
        s,
        l,
        c,
        u
      );
    }
  }
  return n;
}
var d5e = class {
  constructor(t, e, n, r, s, i) {
    this.scope = t, this.parentScopes = e, this.index = n, this.fontStyle = r, this.foreground = s, this.background = i;
  }
}, so = /* @__PURE__ */ ((t) => (t[t.NotSet = -1] = "NotSet", t[t.None = 0] = "None", t[t.Italic = 1] = "Italic", t[t.Bold = 2] = "Bold", t[t.Underline = 4] = "Underline", t[t.Strikethrough = 8] = "Strikethrough", t))(so || {});
function f5e(t, e) {
  t.sort((l, c) => {
    let u = jq(l.scope, c.scope);
    return u !== 0 || (u = Hq(l.parentScopes, c.parentScopes), u !== 0) ? u : l.index - c.index;
  });
  let n = 0, r = "#000000", s = "#ffffff";
  for (; t.length >= 1 && t[0].scope === ""; ) {
    let l = t.shift();
    l.fontStyle !== -1 && (n = l.fontStyle), l.foreground !== null && (r = l.foreground), l.background !== null && (s = l.background);
  }
  let i = new p5e(e), o = new Vq(n, i.getId(r), i.getId(s)), a = new g5e(new Jx(0, null, -1, 0, 0), []);
  for (let l = 0, c = t.length; l < c; l++) {
    let u = t[l];
    a.insert(0, u.scope, u.parentScopes, u.fontStyle, i.getId(u.foreground), i.getId(u.background));
  }
  return new Py(i, o, a);
}
var p5e = class {
  _isFrozen;
  _lastColorId;
  _id2color;
  _color2id;
  constructor(t) {
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(t)) {
      this._isFrozen = !0;
      for (let e = 0, n = t.length; e < n; e++)
        this._color2id[t[e]] = e, this._id2color[e] = t[e];
    } else
      this._isFrozen = !1;
  }
  getId(t) {
    if (t === null)
      return 0;
    t = t.toUpperCase();
    let e = this._color2id[t];
    if (e)
      return e;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${t}`);
    return e = ++this._lastColorId, this._color2id[t] = e, this._id2color[e] = t, e;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, m5e = Object.freeze([]), Jx = class Wq {
  scopeDepth;
  parentScopes;
  fontStyle;
  foreground;
  background;
  constructor(e, n, r, s, i) {
    this.scopeDepth = e, this.parentScopes = n || m5e, this.fontStyle = r, this.foreground = s, this.background = i;
  }
  clone() {
    return new Wq(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(e) {
    let n = [];
    for (let r = 0, s = e.length; r < s; r++)
      n[r] = e[r].clone();
    return n;
  }
  acceptOverwrite(e, n, r, s) {
    this.scopeDepth > e ? console.log("how did this happen?") : this.scopeDepth = e, n !== -1 && (this.fontStyle = n), r !== 0 && (this.foreground = r), s !== 0 && (this.background = s);
  }
}, g5e = class Xx {
  constructor(e, n = [], r = {}) {
    this._mainRule = e, this._children = r, this._rulesWithParentScopes = n;
  }
  _rulesWithParentScopes;
  static _cmpBySpecificity(e, n) {
    if (e.scopeDepth !== n.scopeDepth)
      return n.scopeDepth - e.scopeDepth;
    let r = 0, s = 0;
    for (; e.parentScopes[r] === ">" && r++, n.parentScopes[s] === ">" && s++, !(r >= e.parentScopes.length || s >= n.parentScopes.length); ) {
      const i = n.parentScopes[s].length - e.parentScopes[r].length;
      if (i !== 0)
        return i;
      r++, s++;
    }
    return n.parentScopes.length - e.parentScopes.length;
  }
  match(e) {
    if (e !== "") {
      let r = e.indexOf("."), s, i;
      if (r === -1 ? (s = e, i = "") : (s = e.substring(0, r), i = e.substring(r + 1)), this._children.hasOwnProperty(s))
        return this._children[s].match(i);
    }
    const n = this._rulesWithParentScopes.concat(this._mainRule);
    return n.sort(Xx._cmpBySpecificity), n;
  }
  insert(e, n, r, s, i, o) {
    if (n === "") {
      this._doInsertHere(e, r, s, i, o);
      return;
    }
    let a = n.indexOf("."), l, c;
    a === -1 ? (l = n, c = "") : (l = n.substring(0, a), c = n.substring(a + 1));
    let u;
    this._children.hasOwnProperty(l) ? u = this._children[l] : (u = new Xx(this._mainRule.clone(), Jx.cloneArr(this._rulesWithParentScopes)), this._children[l] = u), u.insert(e + 1, c, r, s, i, o);
  }
  _doInsertHere(e, n, r, s, i) {
    if (n === null) {
      this._mainRule.acceptOverwrite(e, r, s, i);
      return;
    }
    for (let o = 0, a = this._rulesWithParentScopes.length; o < a; o++) {
      let l = this._rulesWithParentScopes[o];
      if (Hq(l.parentScopes, n) === 0) {
        l.acceptOverwrite(e, r, s, i);
        return;
      }
    }
    r === -1 && (r = this._mainRule.fontStyle), s === 0 && (s = this._mainRule.foreground), i === 0 && (i = this._mainRule.background), this._rulesWithParentScopes.push(new Jx(e, n, r, s, i));
  }
}, yu = class Hr {
  static toBinaryStr(e) {
    return e.toString(2).padStart(32, "0");
  }
  static print(e) {
    const n = Hr.getLanguageId(e), r = Hr.getTokenType(e), s = Hr.getFontStyle(e), i = Hr.getForeground(e), o = Hr.getBackground(e);
    console.log({
      languageId: n,
      tokenType: r,
      fontStyle: s,
      foreground: i,
      background: o
    });
  }
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(e, n, r, s, i, o, a) {
    let l = Hr.getLanguageId(e), c = Hr.getTokenType(e), u = Hr.containsBalancedBrackets(e) ? 1 : 0, h = Hr.getFontStyle(e), d = Hr.getForeground(e), f = Hr.getBackground(e);
    return n !== 0 && (l = n), r !== 8 && (c = r), s !== null && (u = s ? 1 : 0), i !== -1 && (h = i), o !== 0 && (d = o), a !== 0 && (f = a), (l << 0 | c << 8 | u << 10 | h << 11 | d << 15 | f << 24) >>> 0;
  }
};
function Oy(t, e) {
  const n = [], r = y5e(t);
  let s = r.next();
  for (; s !== null; ) {
    let l = 0;
    if (s.length === 2 && s.charAt(1) === ":") {
      switch (s.charAt(0)) {
        case "R":
          l = 1;
          break;
        case "L":
          l = -1;
          break;
        default:
          console.log(`Unknown priority ${s} in scope selector`);
      }
      s = r.next();
    }
    let c = o();
    if (n.push({ matcher: c, priority: l }), s !== ",")
      break;
    s = r.next();
  }
  return n;
  function i() {
    if (s === "-") {
      s = r.next();
      const l = i();
      return (c) => !!l && !l(c);
    }
    if (s === "(") {
      s = r.next();
      const l = a();
      return s === ")" && (s = r.next()), l;
    }
    if (fM(s)) {
      const l = [];
      do
        l.push(s), s = r.next();
      while (fM(s));
      return (c) => e(l, c);
    }
    return null;
  }
  function o() {
    const l = [];
    let c = i();
    for (; c; )
      l.push(c), c = i();
    return (u) => l.every((h) => h(u));
  }
  function a() {
    const l = [];
    let c = o();
    for (; c && (l.push(c), s === "|" || s === ","); ) {
      do
        s = r.next();
      while (s === "|" || s === ",");
      c = o();
    }
    return (u) => l.some((h) => h(u));
  }
}
function fM(t) {
  return !!t && !!t.match(/[\w\.:]+/);
}
function y5e(t) {
  let e = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n = e.exec(t);
  return {
    next: () => {
      if (!n)
        return null;
      const r = n[0];
      return n = e.exec(t), r;
    }
  };
}
function qq(t) {
  typeof t.dispose == "function" && t.dispose();
}
var wf = class {
  constructor(t) {
    this.scopeName = t;
  }
  toKey() {
    return this.scopeName;
  }
}, b5e = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, _5e = class {
  _references = [];
  _seenReferenceKeys = /* @__PURE__ */ new Set();
  get references() {
    return this._references;
  }
  visitedRule = /* @__PURE__ */ new Set();
  add(t) {
    const e = t.toKey();
    this._seenReferenceKeys.has(e) || (this._seenReferenceKeys.add(e), this._references.push(t));
  }
}, v5e = class {
  constructor(t, e) {
    this.repo = t, this.initialScopeName = e, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new wf(this.initialScopeName)];
  }
  seenFullScopeRequests = /* @__PURE__ */ new Set();
  seenPartialScopeRequests = /* @__PURE__ */ new Set();
  Q;
  processQueue() {
    const t = this.Q;
    this.Q = [];
    const e = new _5e();
    for (const n of t)
      w5e(n, this.initialScopeName, this.repo, e);
    for (const n of e.references)
      if (n instanceof wf) {
        if (this.seenFullScopeRequests.has(n.scopeName))
          continue;
        this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n);
      } else {
        if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
          continue;
        this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n);
      }
  }
};
function w5e(t, e, n, r) {
  const s = n.lookup(t.scopeName);
  if (!s) {
    if (t.scopeName === e)
      throw new Error(`No grammar provided for <${e}>`);
    return;
  }
  const i = n.lookup(e);
  t instanceof wf ? Fg({ baseGrammar: i, selfGrammar: s }, r) : Qx(
    t.ruleName,
    { baseGrammar: i, selfGrammar: s, repository: s.repository },
    r
  );
  const o = n.injections(t.scopeName);
  if (o)
    for (const a of o)
      r.add(new wf(a));
}
function Qx(t, e, n) {
  if (e.repository && e.repository[t]) {
    const r = e.repository[t];
    Dy([r], e, n);
  }
}
function Fg(t, e) {
  t.selfGrammar.patterns && Array.isArray(t.selfGrammar.patterns) && Dy(
    t.selfGrammar.patterns,
    { ...t, repository: t.selfGrammar.repository },
    e
  ), t.selfGrammar.injections && Dy(
    Object.values(t.selfGrammar.injections),
    { ...t, repository: t.selfGrammar.repository },
    e
  );
}
function Dy(t, e, n) {
  for (const r of t) {
    if (n.visitedRule.has(r))
      continue;
    n.visitedRule.add(r);
    const s = r.repository ? $q({}, e.repository, r.repository) : e.repository;
    Array.isArray(r.patterns) && Dy(r.patterns, { ...e, repository: s }, n);
    const i = r.include;
    if (!i)
      continue;
    const o = Kq(i);
    switch (o.kind) {
      case 0:
        Fg({ ...e, selfGrammar: e.baseGrammar }, n);
        break;
      case 1:
        Fg(e, n);
        break;
      case 2:
        Qx(o.ruleName, { ...e, repository: s }, n);
        break;
      case 3:
      case 4:
        const a = o.scopeName === e.selfGrammar.scopeName ? e.selfGrammar : o.scopeName === e.baseGrammar.scopeName ? e.baseGrammar : void 0;
        if (a) {
          const l = { baseGrammar: e.baseGrammar, selfGrammar: a, repository: s };
          o.kind === 4 ? Qx(o.ruleName, l, n) : Fg(l, n);
        } else
          o.kind === 4 ? n.add(new b5e(o.scopeName, o.ruleName)) : n.add(new wf(o.scopeName));
        break;
    }
  }
}
var E5e = class {
  kind = 0;
}, S5e = class {
  kind = 1;
}, x5e = class {
  constructor(t) {
    this.ruleName = t;
  }
  kind = 2;
}, T5e = class {
  constructor(t) {
    this.scopeName = t;
  }
  kind = 3;
}, C5e = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  kind = 4;
};
function Kq(t) {
  if (t === "$base")
    return new E5e();
  if (t === "$self")
    return new S5e();
  const e = t.indexOf("#");
  if (e === -1)
    return new T5e(t);
  if (e === 0)
    return new x5e(t.substring(1));
  {
    const n = t.substring(0, e), r = t.substring(e + 1);
    return new C5e(n, r);
  }
}
var k5e = /\\(\d+)/, pM = /\\(\d+)/g, A5e = -1, Yq = -2;
var xp = class {
  $location;
  id;
  _nameIsCapturing;
  _name;
  _contentNameIsCapturing;
  _contentName;
  constructor(t, e, n, r) {
    this.$location = t, this.id = e, this._name = n || null, this._nameIsCapturing = Ym.hasCaptures(this._name), this._contentName = r || null, this._contentNameIsCapturing = Ym.hasCaptures(this._contentName);
  }
  get debugName() {
    const t = this.$location ? `${Uq(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${t}`;
  }
  getName(t, e) {
    return !this._nameIsCapturing || this._name === null || t === null || e === null ? this._name : Ym.replaceCaptures(this._name, t, e);
  }
  getContentName(t, e) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : Ym.replaceCaptures(this._contentName, t, e);
  }
}, R5e = class extends xp {
  retokenizeCapturedWithRuleId;
  constructor(t, e, n, r, s) {
    super(t, e, n, r), this.retokenizeCapturedWithRuleId = s;
  }
  dispose() {
  }
  collectPatterns(t, e) {
    throw new Error("Not supported!");
  }
  compile(t, e) {
    throw new Error("Not supported!");
  }
  compileAG(t, e, n, r) {
    throw new Error("Not supported!");
  }
}, I5e = class extends xp {
  _match;
  captures;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, s) {
    super(t, e, n, null), this._match = new Ef(r, this.id), this.captures = s, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(t, e) {
    e.push(this._match);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Sf(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, mM = class extends xp {
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, s) {
    super(t, e, n, r), this.patterns = s.patterns, this.hasMissingPatterns = s.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(t, e) {
    for (const n of this.patterns)
      t.getRule(n).collectPatterns(t, e);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Sf(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, eT = class extends xp {
  _begin;
  beginCaptures;
  _end;
  endHasBackReferences;
  endCaptures;
  applyEndPatternLast;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, s, i, o, a, l, c) {
    super(t, e, n, r), this._begin = new Ef(s, this.id), this.beginCaptures = i, this._end = new Ef(o || "", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = a, this.applyEndPatternLast = l || !1, this.patterns = c.patterns, this.hasMissingPatterns = c.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(t, e) {
    return this._end.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t, e).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t, e).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t, e) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Sf();
      for (const n of this.patterns)
        t.getRule(n).collectPatterns(t, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, e) : this._cachedCompiledPatterns.setSource(0, e)), this._cachedCompiledPatterns;
  }
}, Ny = class extends xp {
  _begin;
  beginCaptures;
  whileCaptures;
  _while;
  whileHasBackReferences;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  _cachedCompiledWhilePatterns;
  constructor(t, e, n, r, s, i, o, a, l) {
    super(t, e, n, r), this._begin = new Ef(s, this.id), this.beginCaptures = i, this.whileCaptures = a, this._while = new Ef(o, Yq), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = l.patterns, this.hasMissingPatterns = l.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(t, e) {
    return this._while.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Sf();
      for (const e of this.patterns)
        t.getRule(e).collectPatterns(t, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(t, e) {
    return this._getCachedCompiledWhilePatterns(t, e).compile(t);
  }
  compileWhileAG(t, e, n, r) {
    return this._getCachedCompiledWhilePatterns(t, e).compileAG(t, n, r);
  }
  _getCachedCompiledWhilePatterns(t, e) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new Sf(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, e || ""), this._cachedCompiledWhilePatterns;
  }
}, Zq = class Nn {
  static createCaptureRule(e, n, r, s, i) {
    return e.registerRule((o) => new R5e(n, o, r, s, i));
  }
  static getCompiledRuleId(e, n, r) {
    return e.id || n.registerRule((s) => {
      if (e.id = s, e.match)
        return new I5e(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.match,
          Nn._compileCaptures(e.captures, n, r)
        );
      if (typeof e.begin > "u") {
        e.repository && (r = $q({}, r, e.repository));
        let i = e.patterns;
        return typeof i > "u" && e.include && (i = [{ include: e.include }]), new mM(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.contentName,
          Nn._compilePatterns(i, n, r)
        );
      }
      return e.while ? new Ny(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        Nn._compileCaptures(e.beginCaptures || e.captures, n, r),
        e.while,
        Nn._compileCaptures(e.whileCaptures || e.captures, n, r),
        Nn._compilePatterns(e.patterns, n, r)
      ) : new eT(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        Nn._compileCaptures(e.beginCaptures || e.captures, n, r),
        e.end,
        Nn._compileCaptures(e.endCaptures || e.captures, n, r),
        e.applyEndPatternLast,
        Nn._compilePatterns(e.patterns, n, r)
      );
    }), e.id;
  }
  static _compileCaptures(e, n, r) {
    let s = [];
    if (e) {
      let i = 0;
      for (const o in e) {
        if (o === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(o, 10);
        a > i && (i = a);
      }
      for (let o = 0; o <= i; o++)
        s[o] = null;
      for (const o in e) {
        if (o === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(o, 10);
        let l = 0;
        e[o].patterns && (l = Nn.getCompiledRuleId(e[o], n, r)), s[a] = Nn.createCaptureRule(n, e[o].$vscodeTextmateLocation, e[o].name, e[o].contentName, l);
      }
    }
    return s;
  }
  static _compilePatterns(e, n, r) {
    let s = [];
    if (e)
      for (let i = 0, o = e.length; i < o; i++) {
        const a = e[i];
        let l = -1;
        if (a.include) {
          const c = Kq(a.include);
          switch (c.kind) {
            case 0:
            case 1:
              l = Nn.getCompiledRuleId(r[a.include], n, r);
              break;
            case 2:
              let u = r[c.ruleName];
              u && (l = Nn.getCompiledRuleId(u, n, r));
              break;
            case 3:
            case 4:
              const h = c.scopeName, d = c.kind === 4 ? c.ruleName : null, f = n.getExternalGrammar(h, r);
              if (f)
                if (d) {
                  let g = f.repository[d];
                  g && (l = Nn.getCompiledRuleId(g, n, f.repository));
                } else
                  l = Nn.getCompiledRuleId(f.repository.$self, n, f.repository);
              break;
          }
        } else
          l = Nn.getCompiledRuleId(a, n, r);
        if (l !== -1) {
          const c = n.getRule(l);
          let u = !1;
          if ((c instanceof mM || c instanceof eT || c instanceof Ny) && c.hasMissingPatterns && c.patterns.length === 0 && (u = !0), u)
            continue;
          s.push(l);
        }
      }
    return {
      patterns: s,
      hasMissingPatterns: (e ? e.length : 0) !== s.length
    };
  }
}, Ef = class Jq {
  source;
  ruleId;
  hasAnchor;
  hasBackReferences;
  _anchorCache;
  constructor(e, n) {
    if (e && typeof e == "string") {
      const r = e.length;
      let s = 0, i = [], o = !1;
      for (let a = 0; a < r; a++)
        if (e.charAt(a) === "\\" && a + 1 < r) {
          const c = e.charAt(a + 1);
          c === "z" ? (i.push(e.substring(s, a)), i.push("$(?!\\n)(?<!\\n)"), s = a + 2) : (c === "A" || c === "G") && (o = !0), a++;
        }
      this.hasAnchor = o, s === 0 ? this.source = e : (i.push(e.substring(s, r)), this.source = i.join(""));
    } else
      this.hasAnchor = !1, this.source = e;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = n, typeof this.source == "string" ? this.hasBackReferences = k5e.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new Jq(this.source, this.ruleId);
  }
  setSource(e) {
    this.source !== e && (this.source = e, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(e, n) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let r = n.map((s) => e.substring(s.start, s.end));
    return pM.lastIndex = 0, this.source.replace(pM, (s, i) => zq(r[parseInt(i, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let e = [], n = [], r = [], s = [], i, o, a, l;
    for (i = 0, o = this.source.length; i < o; i++)
      a = this.source.charAt(i), e[i] = a, n[i] = a, r[i] = a, s[i] = a, a === "\\" && i + 1 < o && (l = this.source.charAt(i + 1), l === "A" ? (e[i + 1] = "", n[i + 1] = "", r[i + 1] = "A", s[i + 1] = "A") : l === "G" ? (e[i + 1] = "", n[i + 1] = "G", r[i + 1] = "", s[i + 1] = "G") : (e[i + 1] = l, n[i + 1] = l, r[i + 1] = l, s[i + 1] = l), i++);
    return {
      A0_G0: e.join(""),
      A0_G1: n.join(""),
      A1_G0: r.join(""),
      A1_G1: s.join("")
    };
  }
  resolveAnchors(e, n) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : e ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, Sf = class {
  _items;
  _hasAnchors;
  _cached;
  _anchorCache;
  constructor() {
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(t) {
    this._items.push(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  unshift(t) {
    this._items.unshift(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(t, e) {
    this._items[t].source !== e && (this._disposeCaches(), this._items[t].setSource(e));
  }
  compile(t) {
    if (!this._cached) {
      let e = this._items.map((n) => n.source);
      this._cached = new gM(t, e, this._items.map((n) => n.ruleId));
    }
    return this._cached;
  }
  compileAG(t, e, n) {
    return this._hasAnchors ? e ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(t, e, n)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(t, e, n)), this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(t, e, n)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(t, e, n)), this._anchorCache.A0_G0) : this.compile(t);
  }
  _resolveAnchors(t, e, n) {
    let r = this._items.map((s) => s.resolveAnchors(e, n));
    return new gM(t, r, this._items.map((s) => s.ruleId));
  }
}, gM = class {
  constructor(t, e, n) {
    this.regExps = e, this.rules = n, this.scanner = t.createOnigScanner(e);
  }
  scanner;
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const t = [];
    for (let e = 0, n = this.rules.length; e < n; e++)
      t.push("   - " + this.rules[e] + ": " + this.regExps[e]);
    return t.join(`
`);
  }
  findNextMatchSync(t, e, n) {
    const r = this.scanner.findNextMatchSync(t, e, n);
    return r ? {
      ruleId: this.rules[r.index],
      captureIndices: r.captureIndices
    } : null;
  }
}, Gw = class {
  constructor(t, e) {
    this.languageId = t, this.tokenType = e;
  }
}, P5e = class tT {
  _defaultAttributes;
  _embeddedLanguagesMatcher;
  constructor(e, n) {
    this._defaultAttributes = new Gw(
      e,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new O5e(Object.entries(n || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(e) {
    return e === null ? tT._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(e);
  }
  static _NULL_SCOPE_METADATA = new Gw(0, 0);
  _getBasicScopeAttributes = new Gq((e) => {
    const n = this._scopeToLanguage(e), r = this._toStandardTokenType(e);
    return new Gw(n, r);
  });
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(e) {
    return this._embeddedLanguagesMatcher.match(e) || 0;
  }
  _toStandardTokenType(e) {
    const n = e.match(tT.STANDARD_TOKEN_TYPE_REGEXP);
    if (!n)
      return 8;
    switch (n[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
}, O5e = class {
  values;
  scopesRegExp;
  constructor(t) {
    if (t.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(t);
      const e = t.map(
        ([n, r]) => zq(n)
      );
      e.sort(), e.reverse(), this.scopesRegExp = new RegExp(
        `^((${e.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(t) {
    if (!this.scopesRegExp)
      return;
    const e = t.match(this.scopesRegExp);
    if (e)
      return this.values.get(e[1]);
  }
};
typeof je < "u" && je.env.VSCODE_TEXTMATE_DEBUG;
var yM = class {
  constructor(t, e) {
    this.stack = t, this.stoppedEarly = e;
  }
};
function Xq(t, e, n, r, s, i, o, a) {
  const l = e.content.length;
  let c = !1, u = -1;
  if (o) {
    const f = D5e(
      t,
      e,
      n,
      r,
      s,
      i
    );
    s = f.stack, r = f.linePos, n = f.isFirstLine, u = f.anchorPosition;
  }
  const h = Date.now();
  for (; !c; ) {
    if (a !== 0 && Date.now() - h > a)
      return new yM(s, !0);
    d();
  }
  return new yM(s, !1);
  function d() {
    const f = N5e(
      t,
      e,
      n,
      r,
      s,
      u
    );
    if (!f) {
      i.produce(s, l), c = !0;
      return;
    }
    const g = f.captureIndices, y = f.matchedRuleId, p = g && g.length > 0 ? g[0].end > r : !1;
    if (y === A5e) {
      const m = s.getRule(t);
      i.produce(s, g[0].start), s = s.withContentNameScopesList(s.nameScopesList), Mh(
        t,
        e,
        n,
        s,
        i,
        m.endCaptures,
        g
      ), i.produce(s, g[0].end);
      const b = s;
      if (s = s.parent, u = b.getAnchorPos(), !p && b.getEnterPos() === r) {
        s = b, i.produce(s, l), c = !0;
        return;
      }
    } else {
      const m = t.getRule(y);
      i.produce(s, g[0].start);
      const b = s, _ = m.getName(e.content, g), v = s.contentNameScopesList.pushAttributed(
        _,
        t
      );
      if (s = s.push(
        y,
        r,
        u,
        g[0].end === l,
        null,
        v,
        v
      ), m instanceof eT) {
        const w = m;
        Mh(
          t,
          e,
          n,
          s,
          i,
          w.beginCaptures,
          g
        ), i.produce(s, g[0].end), u = g[0].end;
        const E = w.getContentName(
          e.content,
          g
        ), x = v.pushAttributed(
          E,
          t
        );
        if (s = s.withContentNameScopesList(x), w.endHasBackReferences && (s = s.withEndRule(
          w.getEndWithResolvedBackReferences(
            e.content,
            g
          )
        )), !p && b.hasSameRuleAs(s)) {
          s = s.pop(), i.produce(s, l), c = !0;
          return;
        }
      } else if (m instanceof Ny) {
        const w = m;
        Mh(
          t,
          e,
          n,
          s,
          i,
          w.beginCaptures,
          g
        ), i.produce(s, g[0].end), u = g[0].end;
        const E = w.getContentName(
          e.content,
          g
        ), x = v.pushAttributed(
          E,
          t
        );
        if (s = s.withContentNameScopesList(x), w.whileHasBackReferences && (s = s.withEndRule(
          w.getWhileWithResolvedBackReferences(
            e.content,
            g
          )
        )), !p && b.hasSameRuleAs(s)) {
          s = s.pop(), i.produce(s, l), c = !0;
          return;
        }
      } else if (Mh(
        t,
        e,
        n,
        s,
        i,
        m.captures,
        g
      ), i.produce(s, g[0].end), s = s.pop(), !p) {
        s = s.safePop(), i.produce(s, l), c = !0;
        return;
      }
    }
    g[0].end > r && (r = g[0].end, n = !1);
  }
}
function D5e(t, e, n, r, s, i) {
  let o = s.beginRuleCapturedEOL ? 0 : -1;
  const a = [];
  for (let l = s; l; l = l.pop()) {
    const c = l.getRule(t);
    c instanceof Ny && a.push({
      rule: c,
      stack: l
    });
  }
  for (let l = a.pop(); l; l = a.pop()) {
    const { ruleScanner: c, findOptions: u } = B5e(l.rule, t, l.stack.endRule, n, r === o), h = c.findNextMatchSync(e, r, u);
    if (h) {
      if (h.ruleId !== Yq) {
        s = l.stack.pop();
        break;
      }
      h.captureIndices && h.captureIndices.length && (i.produce(l.stack, h.captureIndices[0].start), Mh(t, e, n, l.stack, i, l.rule.whileCaptures, h.captureIndices), i.produce(l.stack, h.captureIndices[0].end), o = h.captureIndices[0].end, h.captureIndices[0].end > r && (r = h.captureIndices[0].end, n = !1));
    } else {
      s = l.stack.pop();
      break;
    }
  }
  return { stack: s, linePos: r, anchorPosition: o, isFirstLine: n };
}
function N5e(t, e, n, r, s, i) {
  const o = L5e(t, e, n, r, s, i), a = t.getInjections();
  if (a.length === 0)
    return o;
  const l = M5e(a, t, e, n, r, s, i);
  if (!l)
    return o;
  if (!o)
    return l;
  const c = o.captureIndices[0].start, u = l.captureIndices[0].start;
  return u < c || l.priorityMatch && u === c ? l : o;
}
function L5e(t, e, n, r, s, i) {
  const o = s.getRule(t), { ruleScanner: a, findOptions: l } = Qq(o, t, s.endRule, n, r === i), c = a.findNextMatchSync(e, r, l);
  return c ? {
    captureIndices: c.captureIndices,
    matchedRuleId: c.ruleId
  } : null;
}
function M5e(t, e, n, r, s, i, o) {
  let a = Number.MAX_VALUE, l = null, c, u = 0;
  const h = i.contentNameScopesList.getScopeNames();
  for (let d = 0, f = t.length; d < f; d++) {
    const g = t[d];
    if (!g.matcher(h))
      continue;
    const y = e.getRule(g.ruleId), { ruleScanner: p, findOptions: m } = Qq(y, e, null, r, s === o), b = p.findNextMatchSync(n, s, m);
    if (!b)
      continue;
    const _ = b.captureIndices[0].start;
    if (!(_ >= a) && (a = _, l = b.captureIndices, c = b.ruleId, u = g.priority, a === s))
      break;
  }
  return l ? {
    priorityMatch: u === -1,
    captureIndices: l,
    matchedRuleId: c
  } : null;
}
function Qq(t, e, n, r, s) {
  return {
    ruleScanner: t.compileAG(e, n, r, s),
    findOptions: 0
    /* None */
  };
}
function B5e(t, e, n, r, s) {
  return {
    ruleScanner: t.compileWhileAG(e, n, r, s),
    findOptions: 0
    /* None */
  };
}
function Mh(t, e, n, r, s, i, o) {
  if (i.length === 0)
    return;
  const a = e.content, l = Math.min(i.length, o.length), c = [], u = o[0].end;
  for (let h = 0; h < l; h++) {
    const d = i[h];
    if (d === null)
      continue;
    const f = o[h];
    if (f.length === 0)
      continue;
    if (f.start > u)
      break;
    for (; c.length > 0 && c[c.length - 1].endPos <= f.start; )
      s.produceFromScopes(c[c.length - 1].scopes, c[c.length - 1].endPos), c.pop();
    if (c.length > 0 ? s.produceFromScopes(c[c.length - 1].scopes, f.start) : s.produce(r, f.start), d.retokenizeCapturedWithRuleId) {
      const y = d.getName(a, o), p = r.contentNameScopesList.pushAttributed(y, t), m = d.getContentName(a, o), b = p.pushAttributed(m, t), _ = r.push(d.retokenizeCapturedWithRuleId, f.start, -1, !1, null, p, b), v = t.createOnigString(a.substring(0, f.end));
      Xq(
        t,
        v,
        n && f.start === 0,
        f.start,
        _,
        s,
        !1,
        /* no time limit */
        0
      ), qq(v);
      continue;
    }
    const g = d.getName(a, o);
    if (g !== null) {
      const p = (c.length > 0 ? c[c.length - 1].scopes : r.contentNameScopesList).pushAttributed(g, t);
      c.push(new F5e(p, f.end));
    }
  }
  for (; c.length > 0; )
    s.produceFromScopes(c[c.length - 1].scopes, c[c.length - 1].endPos), c.pop();
}
var F5e = class {
  scopes;
  endPos;
  constructor(t, e) {
    this.scopes = t, this.endPos = e;
  }
};
function $5e(t, e, n, r, s, i, o, a) {
  return new j5e(
    t,
    e,
    n,
    r,
    s,
    i,
    o,
    a
  );
}
function bM(t, e, n, r, s) {
  const i = Oy(e, Ly), o = Zq.getCompiledRuleId(n, r, s.repository);
  for (const a of i)
    t.push({
      debugSelector: e,
      matcher: a.matcher,
      ruleId: o,
      grammar: s,
      priority: a.priority
    });
}
function Ly(t, e) {
  if (e.length < t.length)
    return !1;
  let n = 0;
  return t.every((r) => {
    for (let s = n; s < e.length; s++)
      if (U5e(e[s], r))
        return n = s + 1, !0;
    return !1;
  });
}
function U5e(t, e) {
  if (!t)
    return !1;
  if (t === e)
    return !0;
  const n = e.length;
  return t.length > n && t.substr(0, n) === e && t[n] === ".";
}
var j5e = class {
  constructor(t, e, n, r, s, i, o, a) {
    if (this._rootScopeName = t, this.balancedBracketSelectors = i, this._onigLib = a, this._basicScopeAttributesProvider = new P5e(
      n,
      r
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = o, this._grammar = _M(e, null), this._injections = null, this._tokenTypeMatchers = [], s)
      for (const l of Object.keys(s)) {
        const c = Oy(l, Ly);
        for (const u of c)
          this._tokenTypeMatchers.push({
            matcher: u.matcher,
            type: s[l]
          });
      }
  }
  _rootId;
  _lastRuleId;
  _ruleId2desc;
  _includedGrammars;
  _grammarRepository;
  _grammar;
  _injections;
  _basicScopeAttributesProvider;
  _tokenTypeMatchers;
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const t of this._ruleId2desc)
      t && t.dispose();
  }
  createOnigScanner(t) {
    return this._onigLib.createOnigScanner(t);
  }
  createOnigString(t) {
    return this._onigLib.createOnigString(t);
  }
  getMetadataForScope(t) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(t);
  }
  _collectInjections() {
    const t = {
      lookup: (s) => s === this._rootScopeName ? this._grammar : this.getExternalGrammar(s),
      injections: (s) => this._grammarRepository.injections(s)
    }, e = [], n = this._rootScopeName, r = t.lookup(n);
    if (r) {
      const s = r.injections;
      if (s)
        for (let o in s)
          bM(
            e,
            o,
            s[o],
            this,
            r
          );
      const i = this._grammarRepository.injections(n);
      i && i.forEach((o) => {
        const a = this.getExternalGrammar(o);
        if (a) {
          const l = a.injectionSelector;
          l && bM(
            e,
            l,
            a,
            this,
            a
          );
        }
      });
    }
    return e.sort((s, i) => s.priority - i.priority), e;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(t) {
    const e = ++this._lastRuleId, n = t(e);
    return this._ruleId2desc[e] = n, n;
  }
  getRule(t) {
    return this._ruleId2desc[t];
  }
  getExternalGrammar(t, e) {
    if (this._includedGrammars[t])
      return this._includedGrammars[t];
    if (this._grammarRepository) {
      const n = this._grammarRepository.lookup(t);
      if (n)
        return this._includedGrammars[t] = _M(
          n,
          e && e.$base
        ), this._includedGrammars[t];
    }
  }
  tokenizeLine(t, e, n = 0) {
    const r = this._tokenize(t, e, !1, n);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(t, e, n = 0) {
    const r = this._tokenize(t, e, !0, n);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(t, e, n, r) {
    this._rootId === -1 && (this._rootId = Zq.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let s;
    if (!e || e === nT.NULL) {
      s = !0;
      const c = this._basicScopeAttributesProvider.getDefaultAttributes(), u = this.themeProvider.getDefaults(), h = yu.set(
        0,
        c.languageId,
        c.tokenType,
        null,
        u.fontStyle,
        u.foregroundId,
        u.backgroundId
      ), d = this.getRule(this._rootId).getName(
        null,
        null
      );
      let f;
      d ? f = hd.createRootAndLookUpScopeName(
        d,
        h,
        this
      ) : f = hd.createRoot(
        "unknown",
        h
      ), e = new nT(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        f,
        f
      );
    } else
      s = !1, e.reset();
    t = t + `
`;
    const i = this.createOnigString(t), o = i.content.length, a = new z5e(
      n,
      t,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), l = Xq(
      this,
      i,
      s,
      0,
      e,
      a,
      !0,
      r
    );
    return qq(i), {
      lineLength: o,
      lineTokens: a,
      ruleStack: l.stack,
      stoppedEarly: l.stoppedEarly
    };
  }
};
function _M(t, e) {
  return t = o5e(t), t.repository = t.repository || {}, t.repository.$self = {
    $vscodeTextmateLocation: t.$vscodeTextmateLocation,
    patterns: t.patterns,
    name: t.scopeName
  }, t.repository.$base = e || t.repository.$self, t;
}
var hd = class Zs {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, n, r) {
    this.parent = e, this.scopePath = n, this.tokenAttributes = r;
  }
  static fromExtension(e, n) {
    let r = e, s = e?.scopePath ?? null;
    for (const i of n)
      s = zw.push(s, i.scopeNames), r = new Zs(r, s, i.encodedTokenAttributes);
    return r;
  }
  static createRoot(e, n) {
    return new Zs(null, new zw(null, e), n);
  }
  static createRootAndLookUpScopeName(e, n, r) {
    const s = r.getMetadataForScope(e), i = new zw(null, e), o = r.themeProvider.themeMatch(i), a = Zs.mergeAttributes(
      n,
      s,
      o
    );
    return new Zs(null, i, a);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(e) {
    return Zs.equals(this, e);
  }
  static equals(e, n) {
    do {
      if (e === n || !e && !n)
        return !0;
      if (!e || !n || e.scopeName !== n.scopeName || e.tokenAttributes !== n.tokenAttributes)
        return !1;
      e = e.parent, n = n.parent;
    } while (!0);
  }
  static mergeAttributes(e, n, r) {
    let s = -1, i = 0, o = 0;
    return r !== null && (s = r.fontStyle, i = r.foregroundId, o = r.backgroundId), yu.set(
      e,
      n.languageId,
      n.tokenType,
      null,
      s,
      i,
      o
    );
  }
  pushAttributed(e, n) {
    if (e === null)
      return this;
    if (e.indexOf(" ") === -1)
      return Zs._pushAttributed(this, e, n);
    const r = e.split(/ /g);
    let s = this;
    for (const i of r)
      s = Zs._pushAttributed(s, i, n);
    return s;
  }
  static _pushAttributed(e, n, r) {
    const s = r.getMetadataForScope(n), i = e.scopePath.push(n), o = r.themeProvider.themeMatch(i), a = Zs.mergeAttributes(
      e.tokenAttributes,
      s,
      o
    );
    return new Zs(e, i, a);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(e) {
    const n = [];
    let r = this;
    for (; r && r !== e; )
      n.push({
        encodedTokenAttributes: r.tokenAttributes,
        scopeNames: r.scopePath.getExtensionIfDefined(r.parent?.scopePath ?? null)
      }), r = r.parent;
    return r === e ? n.reverse() : void 0;
  }
}, nT = class Da {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, n, r, s, i, o, a, l) {
    this.parent = e, this.ruleId = n, this.beginRuleCapturedEOL = i, this.endRule = o, this.nameScopesList = a, this.contentNameScopesList = l, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = r, this._anchorPos = s;
  }
  _stackElementBrand = void 0;
  // TODO remove me
  static NULL = new Da(
    null,
    0,
    0,
    0,
    !1,
    null,
    null,
    null
  );
  /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */
  _enterPos;
  /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */
  _anchorPos;
  /**
   * The depth of the stack.
   */
  depth;
  equals(e) {
    return e === null ? !1 : Da._equals(this, e);
  }
  static _equals(e, n) {
    return e === n ? !0 : this._structuralEquals(e, n) ? hd.equals(e.contentNameScopesList, n.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(e, n) {
    do {
      if (e === n || !e && !n)
        return !0;
      if (!e || !n || e.depth !== n.depth || e.ruleId !== n.ruleId || e.endRule !== n.endRule)
        return !1;
      e = e.parent, n = n.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(e) {
    for (; e; )
      e._enterPos = -1, e._anchorPos = -1, e = e.parent;
  }
  reset() {
    Da._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(e, n, r, s, i, o, a) {
    return new Da(
      this,
      e,
      n,
      r,
      s,
      i,
      o,
      a
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(e) {
    return e.getRule(this.ruleId);
  }
  toString() {
    const e = [];
    return this._writeString(e, 0), "[" + e.join(",") + "]";
  }
  _writeString(e, n) {
    return this.parent && (n = this.parent._writeString(e, n)), e[n++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`, n;
  }
  withContentNameScopesList(e) {
    return this.contentNameScopesList === e ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      e
    );
  }
  withEndRule(e) {
    return this.endRule === e ? this : new Da(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      e,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(e) {
    let n = this;
    for (; n && n._enterPos === e._enterPos; ) {
      if (n.ruleId === e.ruleId)
        return !0;
      n = n.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
    };
  }
  static pushFrame(e, n) {
    const r = hd.fromExtension(e?.nameScopesList ?? null, n.nameScopesList);
    return new Da(
      e,
      n.ruleId,
      n.enterPos ?? -1,
      n.anchorPos ?? -1,
      n.beginRuleCapturedEOL,
      n.endRule,
      r,
      hd.fromExtension(r, n.contentNameScopesList)
    );
  }
}, H5e = class {
  balancedBracketScopes;
  unbalancedBracketScopes;
  allowAny = !1;
  constructor(t, e) {
    this.balancedBracketScopes = t.flatMap(
      (n) => n === "*" ? (this.allowAny = !0, []) : Oy(n, Ly).map((r) => r.matcher)
    ), this.unbalancedBracketScopes = e.flatMap(
      (n) => Oy(n, Ly).map((r) => r.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(t) {
    for (const e of this.unbalancedBracketScopes)
      if (e(t))
        return !1;
    for (const e of this.balancedBracketScopes)
      if (e(t))
        return !0;
    return this.allowAny;
  }
}, z5e = class {
  constructor(t, e, n, r) {
    this.balancedBracketSelectors = r, this._emitBinaryTokens = t, this._tokenTypeOverrides = n, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  _emitBinaryTokens;
  /**
   * defined only if `false`.
   */
  _lineText;
  /**
   * used only if `_emitBinaryTokens` is false.
   */
  _tokens;
  /**
   * used only if `_emitBinaryTokens` is true.
   */
  _binaryTokens;
  _lastTokenEndIndex;
  _tokenTypeOverrides;
  produce(t, e) {
    this.produceFromScopes(t.contentNameScopesList, e);
  }
  produceFromScopes(t, e) {
    if (this._lastTokenEndIndex >= e)
      return;
    if (this._emitBinaryTokens) {
      let r = t?.tokenAttributes ?? 0, s = !1;
      if (this.balancedBracketSelectors?.matchesAlways && (s = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const i = t?.getScopeNames() ?? [];
        for (const o of this._tokenTypeOverrides)
          o.matcher(i) && (r = yu.set(
            r,
            0,
            o.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (s = this.balancedBracketSelectors.match(i));
      }
      if (s && (r = yu.set(
        r,
        0,
        8,
        s,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === r) {
        this._lastTokenEndIndex = e;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(r), this._lastTokenEndIndex = e;
      return;
    }
    const n = t?.getScopeNames() ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: e,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: n
    }), this._lastTokenEndIndex = e;
  }
  getResult(t, e) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === e - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(t, e) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === e - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const n = new Uint32Array(this._binaryTokens.length);
    for (let r = 0, s = this._binaryTokens.length; r < s; r++)
      n[r] = this._binaryTokens[r];
    return n;
  }
}, G5e = class {
  constructor(t, e) {
    this._onigLib = e, this._theme = t;
  }
  _grammars = /* @__PURE__ */ new Map();
  _rawGrammars = /* @__PURE__ */ new Map();
  _injectionGrammars = /* @__PURE__ */ new Map();
  _theme;
  dispose() {
    for (const t of this._grammars.values())
      t.dispose();
  }
  setTheme(t) {
    this._theme = t;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(t, e) {
    this._rawGrammars.set(t.scopeName, t), e && this._injectionGrammars.set(t.scopeName, e);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(t) {
    return this._rawGrammars.get(t);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(t) {
    return this._injectionGrammars.get(t);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(t) {
    return this._theme.match(t);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(t, e, n, r, s) {
    if (!this._grammars.has(t)) {
      let i = this._rawGrammars.get(t);
      if (!i)
        return null;
      this._grammars.set(t, $5e(
        t,
        i,
        e,
        n,
        r,
        s,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(t);
  }
}, V5e = class {
  _options;
  _syncRegistry;
  _ensureGrammarCache;
  constructor(e) {
    this._options = e, this._syncRegistry = new G5e(
      Py.createFromRawTheme(e.theme, e.colorMap),
      e.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(e, n) {
    this._syncRegistry.setTheme(Py.createFromRawTheme(e, n));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(e, n, r) {
    return this.loadGrammarWithConfiguration(e, n, { embeddedLanguages: r });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(e, n, r) {
    return this._loadGrammar(
      e,
      n,
      r.embeddedLanguages,
      r.tokenTypes,
      new H5e(
        r.balancedBracketSelectors || [],
        r.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(e) {
    return this._loadGrammar(e, 0, null, null, null);
  }
  _loadGrammar(e, n, r, s, i) {
    const o = new v5e(this._syncRegistry, e);
    for (; o.Q.length > 0; )
      o.Q.map((a) => this._loadSingleGrammar(a.scopeName)), o.processQueue();
    return this._grammarForScopeName(
      e,
      n,
      r,
      s,
      i
    );
  }
  _loadSingleGrammar(e) {
    this._ensureGrammarCache.has(e) || (this._doLoadSingleGrammar(e), this._ensureGrammarCache.set(e, !0));
  }
  _doLoadSingleGrammar(e) {
    const n = this._options.loadGrammar(e);
    if (n) {
      const r = typeof this._options.getInjections == "function" ? this._options.getInjections(e) : void 0;
      this._syncRegistry.addGrammar(n, r);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(e, n = [], r = 0, s = null) {
    return this._syncRegistry.addGrammar(e, n), this._grammarForScopeName(e.scopeName, r, s);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(e, n = 0, r = null, s = null, i = null) {
    return this._syncRegistry.grammarForScopeName(
      e,
      n,
      r,
      s,
      i
    );
  }
}, rT = nT.NULL;
const W5e = /["&'<>`]/g, q5e = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, K5e = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), Y5e = /[|\\{}()[\]^$+*?.]/g, vM = /* @__PURE__ */ new WeakMap();
function Z5e(t, e) {
  if (t = t.replace(
    e.subset ? J5e(e.subset) : W5e,
    r
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(q5e, n).replace(K5e, r);
  function n(s, i, o) {
    return e.format(
      (s.charCodeAt(0) - 55296) * 1024 + s.charCodeAt(1) - 56320 + 65536,
      o.charCodeAt(i + 2),
      e
    );
  }
  function r(s, i, o) {
    return e.format(
      s.charCodeAt(0),
      o.charCodeAt(i + 1),
      e
    );
  }
}
function J5e(t) {
  let e = vM.get(t);
  return e || (e = X5e(t), vM.set(t, e)), e;
}
function X5e(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e.push(t[n].replace(Y5e, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
const Q5e = /[\dA-Fa-f]/;
function eFe(t, e, n) {
  const r = "&#x" + t.toString(16).toUpperCase();
  return n && e && !Q5e.test(String.fromCharCode(e)) ? r : r + ";";
}
const tFe = /\d/;
function nFe(t, e, n) {
  const r = "&#" + String(t);
  return n && e && !tFe.test(String.fromCharCode(e)) ? r : r + ";";
}
const rFe = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], Vw = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
}, sFe = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], eK = {}.hasOwnProperty, sT = {};
let Zm;
for (Zm in Vw)
  eK.call(Vw, Zm) && (sT[Vw[Zm]] = Zm);
const iFe = /[^\dA-Za-z]/;
function oFe(t, e, n, r) {
  const s = String.fromCharCode(t);
  if (eK.call(sT, s)) {
    const i = sT[s], o = "&" + i;
    return n && rFe.includes(i) && !sFe.includes(i) && (!r || e && e !== 61 && iFe.test(String.fromCharCode(e))) ? o : o + ";";
  }
  return "";
}
function aFe(t, e, n) {
  let r = eFe(t, e, n.omitOptionalSemicolons), s;
  if ((n.useNamedReferences || n.useShortestReferences) && (s = oFe(
    t,
    e,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !s) && n.useShortestReferences) {
    const i = nFe(t, e, n.omitOptionalSemicolons);
    i.length < r.length && (r = i);
  }
  return s && (!n.useShortestReferences || s.length < r.length) ? s : r;
}
function zc(t, e) {
  return Z5e(t, Object.assign({ format: aFe }, e));
}
const lFe = /^>|^->|<!--|-->|--!>|<!-$/g, cFe = [">"], uFe = ["<", ">"];
function hFe(t, e, n, r) {
  return r.settings.bogusComments ? "<?" + zc(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: cFe
    })
  ) + ">" : "<!--" + t.value.replace(lFe, s) + "-->";
  function s(i) {
    return zc(
      i,
      Object.assign({}, r.settings.characterReferences, {
        subset: uFe
      })
    );
  }
}
function dFe(t, e, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
const fFe = /[ \t\n\f\r]/g;
function ZA(t) {
  return typeof t == "object" ? t.type === "text" ? wM(t.value) : !1 : wM(t);
}
function wM(t) {
  return t.replace(fFe, "") === "";
}
const gn = nK(1), tK = nK(-1), pFe = [];
function nK(t) {
  return e;
  function e(n, r, s) {
    const i = n ? n.children : pFe;
    let o = (r || 0) + t, a = i[o];
    if (!s)
      for (; a && ZA(a); )
        o += t, a = i[o];
    return a;
  }
}
const mFe = {}.hasOwnProperty;
function rK(t) {
  return e;
  function e(n, r, s) {
    return mFe.call(t, n.tagName) && t[n.tagName](n, r, s);
  }
}
const JA = rK({
  body: yFe,
  caption: Ww,
  colgroup: Ww,
  dd: wFe,
  dt: vFe,
  head: Ww,
  html: gFe,
  li: _Fe,
  optgroup: EFe,
  option: SFe,
  p: bFe,
  rp: EM,
  rt: EM,
  tbody: TFe,
  td: SM,
  tfoot: CFe,
  th: SM,
  thead: xFe,
  tr: kFe
});
function Ww(t, e, n) {
  const r = gn(n, e, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && ZA(r.value.charAt(0)));
}
function gFe(t, e, n) {
  const r = gn(n, e);
  return !r || r.type !== "comment";
}
function yFe(t, e, n) {
  const r = gn(n, e);
  return !r || r.type !== "comment";
}
function bFe(t, e, n) {
  const r = gn(n, e);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function _Fe(t, e, n) {
  const r = gn(n, e);
  return !r || r.type === "element" && r.tagName === "li";
}
function vFe(t, e, n) {
  const r = gn(n, e);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function wFe(t, e, n) {
  const r = gn(n, e);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function EM(t, e, n) {
  const r = gn(n, e);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function EFe(t, e, n) {
  const r = gn(n, e);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function SFe(t, e, n) {
  const r = gn(n, e);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function xFe(t, e, n) {
  const r = gn(n, e);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function TFe(t, e, n) {
  const r = gn(n, e);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function CFe(t, e, n) {
  return !gn(n, e);
}
function kFe(t, e, n) {
  const r = gn(n, e);
  return !r || r.type === "element" && r.tagName === "tr";
}
function SM(t, e, n) {
  const r = gn(n, e);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const AFe = rK({
  body: PFe,
  colgroup: OFe,
  head: IFe,
  html: RFe,
  tbody: DFe
});
function RFe(t) {
  const e = gn(t, -1);
  return !e || e.type !== "comment";
}
function IFe(t) {
  const e = /* @__PURE__ */ new Set();
  for (const r of t.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (e.has(r.tagName)) return !1;
      e.add(r.tagName);
    }
  const n = t.children[0];
  return !n || n.type === "element";
}
function PFe(t) {
  const e = gn(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && ZA(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function OFe(t, e, n) {
  const r = tK(n, e), s = gn(t, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && JA(r, n.children.indexOf(r), n) ? !1 : !!(s && s.type === "element" && s.tagName === "col");
}
function DFe(t, e, n) {
  const r = tK(n, e), s = gn(t, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && JA(r, n.children.indexOf(r), n) ? !1 : !!(s && s.type === "element" && s.tagName === "tr");
}
const Jm = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function NFe(t, e, n, r) {
  const s = r.schema, i = s.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let o = s.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(t.tagName.toLowerCase());
  const a = [];
  let l;
  s.space === "html" && t.tagName === "svg" && (r.schema = Oi);
  const c = LFe(r, t.properties), u = r.all(
    s.space === "html" && t.tagName === "template" ? t.content : t
  );
  return r.schema = s, u && (o = !1), (c || !i || !AFe(t, e, n)) && (a.push("<", t.tagName, c ? " " + c : ""), o && (s.space === "svg" || r.settings.closeSelfClosing) && (l = c.charAt(c.length - 1), (!r.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(u), !o && (!i || !JA(t, e, n)) && a.push("</" + t.tagName + ">"), a.join("");
}
function LFe(t, e) {
  const n = [];
  let r = -1, s;
  if (e) {
    for (s in e)
      if (e[s] !== null && e[s] !== void 0) {
        const i = MFe(t, s, e[s]);
        i && n.push(i);
      }
  }
  for (; ++r < n.length; ) {
    const i = t.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && i !== '"' && i !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function MFe(t, e, n) {
  const r = ap(t.schema, e), s = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, i = t.settings.allowDangerousCharacters ? 0 : 1;
  let o = t.quote, a;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const l = zc(
    r.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: Jm.name[s][i]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? mk : gk)(n, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(n), t.settings.collapseEmptyAttributes && !n) ? l : (t.settings.preferUnquoted && (a = zc(
    n,
    Object.assign({}, t.settings.characterReferences, {
      attribute: !0,
      subset: Jm.unquoted[s][i]
    })
  )), a !== n && (t.settings.quoteSmart && W0(n, o) > W0(n, t.alternative) && (o = t.alternative), a = o + zc(
    n,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (o === "'" ? Jm.single : Jm.double)[s][i],
      attribute: !0
    })
  ) + o), l + (a && "=" + a));
}
const BFe = ["<", "&"];
function sK(t, e, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? t.value : zc(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: BFe
    })
  );
}
function FFe(t, e, n, r) {
  return r.settings.allowDangerousHtml ? t.value : sK(t, e, n, r);
}
function $Fe(t, e, n, r) {
  return r.all(t);
}
const UFe = bk("type", {
  invalid: jFe,
  unknown: HFe,
  handlers: { comment: hFe, doctype: dFe, element: NFe, raw: FFe, root: $Fe, text: sK }
});
function jFe(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function HFe(t) {
  const e = (
    /** @type {Nodes} */
    t
  );
  throw new Error("Cannot compile unknown node `" + e.type + "`");
}
const zFe = {}, GFe = {}, VFe = [];
function WFe(t, e) {
  const n = zFe, r = n.quote || '"', s = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: qFe,
    all: KFe,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || TH,
      characterReferences: n.characterReferences || GFe,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? Oi : Pu,
    quote: r,
    alternative: s
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function qFe(t, e, n) {
  return UFe(t, e, n, this);
}
function KFe(t) {
  const e = [], n = t && t.children || VFe;
  let r = -1;
  for (; ++r < n.length; )
    e[r] = this.one(n[r], r, t);
  return e.join("");
}
function YFe(t) {
  return Array.isArray(t) ? t : [t];
}
function g_(t, e = !1) {
  const n = t.split(/(\r?\n)/g);
  let r = 0;
  const s = [];
  for (let i = 0; i < n.length; i += 2) {
    const o = e ? n[i] + (n[i + 1] || "") : n[i];
    s.push([o, r]), r += n[i].length, r += n[i + 1]?.length || 0;
  }
  return s;
}
function XA(t) {
  return !t || ["plaintext", "txt", "text", "plain"].includes(t);
}
function QA(t) {
  return t === "ansi" || XA(t);
}
function e2(t) {
  return t === "none";
}
function iK(t) {
  return e2(t);
}
function oK(t, e) {
  if (!e)
    return t;
  t.properties ||= {}, t.properties.class ||= [], typeof t.properties.class == "string" && (t.properties.class = t.properties.class.split(/\s+/g)), Array.isArray(t.properties.class) || (t.properties.class = []);
  const n = Array.isArray(e) ? e : e.split(/\s+/g);
  for (const r of n)
    r && !t.properties.class.includes(r) && t.properties.class.push(r);
  return t;
}
function ZFe(t, e) {
  let n = 0;
  const r = [];
  for (const s of e)
    s > n && r.push({
      ...t,
      content: t.content.slice(n, s),
      offset: t.offset + n
    }), n = s;
  return n < t.content.length && r.push({
    ...t,
    content: t.content.slice(n),
    offset: t.offset + n
  }), r;
}
function JFe(t, e) {
  const n = Array.from(e instanceof Set ? e : new Set(e)).sort((r, s) => r - s);
  return n.length ? t.map((r) => r.flatMap((s) => {
    const i = n.filter((o) => s.offset < o && o < s.offset + s.content.length).map((o) => o - s.offset).sort((o, a) => o - a);
    return i.length ? ZFe(s, i) : s;
  })) : t;
}
async function aK(t) {
  return Promise.resolve(typeof t == "function" ? t() : t).then((e) => e.default || e);
}
function My(t, e) {
  const n = typeof t == "string" ? {} : { ...t.colorReplacements }, r = typeof t == "string" ? t : t.name;
  for (const [s, i] of Object.entries(e?.colorReplacements || {}))
    typeof i == "string" ? n[s] = i : s === r && Object.assign(n, i);
  return n;
}
function Ka(t, e) {
  return t && (e?.[t?.toLowerCase()] || t);
}
function lK(t) {
  const e = {};
  return t.color && (e.color = t.color), t.bgColor && (e["background-color"] = t.bgColor), t.fontStyle && (t.fontStyle & so.Italic && (e["font-style"] = "italic"), t.fontStyle & so.Bold && (e["font-weight"] = "bold"), t.fontStyle & so.Underline && (e["text-decoration"] = "underline")), e;
}
function XFe(t) {
  return typeof t == "string" ? t : Object.entries(t).map(([e, n]) => `${e}:${n}`).join(";");
}
function QFe(t) {
  const e = g_(t, !0).map(([s]) => s);
  function n(s) {
    if (s === t.length)
      return {
        line: e.length - 1,
        character: e[e.length - 1].length
      };
    let i = s, o = 0;
    for (const a of e) {
      if (i < a.length)
        break;
      i -= a.length, o++;
    }
    return { line: o, character: i };
  }
  function r(s, i) {
    let o = 0;
    for (let a = 0; a < s; a++)
      o += e[a].length;
    return o += i, o;
  }
  return {
    lines: e,
    indexToPos: n,
    posToIndex: r
  };
}
class Kn extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
}
const cK = /* @__PURE__ */ new WeakMap();
function y_(t, e) {
  cK.set(t, e);
}
function xf(t) {
  return cK.get(t);
}
class Vu {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(e, n) {
    return new Vu(
      Object.fromEntries(YFe(n).map((r) => [r, rT])),
      e
    );
  }
  constructor(...e) {
    if (e.length === 2) {
      const [n, r] = e;
      this.lang = r, this._stacks = n;
    } else {
      const [n, r, s] = e;
      this.lang = r, this._stacks = { [s]: n };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(e = this.theme) {
    return this._stacks[e];
  }
  /**
   * @deprecated use `getScopes` instead
   */
  get scopes() {
    return xM(this._stacks[this.theme]);
  }
  getScopes(e = this.theme) {
    return xM(this._stacks[e]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.scopes
    };
  }
}
function xM(t) {
  const e = [], n = /* @__PURE__ */ new Set();
  function r(s) {
    if (n.has(s))
      return;
    n.add(s);
    const i = s?.nameScopesList?.scopeName;
    i && e.push(i), s.parent && r(s.parent);
  }
  return r(t), e;
}
function e8e(t, e) {
  if (!(t instanceof Vu))
    throw new Kn("Invalid grammar state");
  return t.getInternalStack(e);
}
function t8e() {
  const t = /* @__PURE__ */ new WeakMap();
  function e(n) {
    if (!t.has(n.meta)) {
      let r = function(o) {
        if (typeof o == "number") {
          if (o < 0 || o > n.source.length)
            throw new Kn(`Invalid decoration offset: ${o}. Code length: ${n.source.length}`);
          return {
            ...s.indexToPos(o),
            offset: o
          };
        } else {
          const a = s.lines[o.line];
          if (a === void 0)
            throw new Kn(`Invalid decoration position ${JSON.stringify(o)}. Lines length: ${s.lines.length}`);
          if (o.character < 0 || o.character > a.length)
            throw new Kn(`Invalid decoration position ${JSON.stringify(o)}. Line ${o.line} length: ${a.length}`);
          return {
            ...o,
            offset: s.posToIndex(o.line, o.character)
          };
        }
      };
      const s = QFe(n.source), i = (n.options.decorations || []).map((o) => ({
        ...o,
        start: r(o.start),
        end: r(o.end)
      }));
      n8e(i), t.set(n.meta, {
        decorations: i,
        converter: s,
        source: n.source
      });
    }
    return t.get(n.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(n) {
      if (!this.options.decorations?.length)
        return;
      const s = e(this).decorations.flatMap((o) => [o.start.offset, o.end.offset]);
      return JFe(n, s);
    },
    code(n) {
      if (!this.options.decorations?.length)
        return;
      const r = e(this), s = Array.from(n.children).filter((u) => u.type === "element" && u.tagName === "span");
      if (s.length !== r.converter.lines.length)
        throw new Kn(`Number of lines in code element (${s.length}) does not match the number of lines in the source (${r.converter.lines.length}). Failed to apply decorations.`);
      function i(u, h, d, f) {
        const g = s[u];
        let y = "", p = -1, m = -1;
        if (h === 0 && (p = 0), d === 0 && (m = 0), d === Number.POSITIVE_INFINITY && (m = g.children.length), p === -1 || m === -1)
          for (let _ = 0; _ < g.children.length; _++)
            y += uK(g.children[_]), p === -1 && y.length === h && (p = _ + 1), m === -1 && y.length === d && (m = _ + 1);
        if (p === -1)
          throw new Kn(`Failed to find start index for decoration ${JSON.stringify(f.start)}`);
        if (m === -1)
          throw new Kn(`Failed to find end index for decoration ${JSON.stringify(f.end)}`);
        const b = g.children.slice(p, m);
        if (!f.alwaysWrap && b.length === g.children.length)
          a(g, f, "line");
        else if (!f.alwaysWrap && b.length === 1 && b[0].type === "element")
          a(b[0], f, "token");
        else {
          const _ = {
            type: "element",
            tagName: "span",
            properties: {},
            children: b
          };
          a(_, f, "wrapper"), g.children.splice(p, b.length, _);
        }
      }
      function o(u, h) {
        s[u] = a(s[u], h, "line");
      }
      function a(u, h, d) {
        const f = h.properties || {}, g = h.transform || ((y) => y);
        return u.tagName = h.tagName || "span", u.properties = {
          ...u.properties,
          ...f,
          class: u.properties.class
        }, h.properties?.class && oK(u, h.properties.class), u = g(u, d) || u, u;
      }
      const l = [], c = r.decorations.sort((u, h) => h.start.offset - u.start.offset);
      for (const u of c) {
        const { start: h, end: d } = u;
        if (h.line === d.line)
          i(h.line, h.character, d.character, u);
        else if (h.line < d.line) {
          i(h.line, h.character, Number.POSITIVE_INFINITY, u);
          for (let f = h.line + 1; f < d.line; f++)
            l.unshift(() => o(f, u));
          i(d.line, 0, d.character, u);
        }
      }
      l.forEach((u) => u());
    }
  };
}
function n8e(t) {
  for (let e = 0; e < t.length; e++) {
    const n = t[e];
    if (n.start.offset > n.end.offset)
      throw new Kn(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
    for (let r = e + 1; r < t.length; r++) {
      const s = t[r], i = n.start.offset < s.start.offset && s.start.offset < n.end.offset, o = n.start.offset < s.end.offset && s.end.offset < n.end.offset, a = s.start.offset < n.start.offset && n.start.offset < s.end.offset, l = s.start.offset < n.end.offset && n.end.offset < s.end.offset;
      if (i || o || a || l) {
        if (o && o || a && l)
          continue;
        throw new Kn(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(s.start)} intersect.`);
      }
    }
  }
}
function uK(t) {
  return t.type === "text" ? t.value : t.type === "element" ? t.children.map(uK).join("") : "";
}
const r8e = [
  /* @__PURE__ */ t8e()
];
function By(t) {
  return [
    ...t.transformers || [],
    ...r8e
  ];
}
var Ya = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], qw = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function s8e(t, e) {
  const n = t.indexOf("\x1B[", e);
  if (n !== -1) {
    const r = t.indexOf("m", n);
    return {
      sequence: t.substring(n + 2, r).split(";"),
      startPosition: n,
      position: r + 1
    };
  }
  return {
    position: t.length
  };
}
function TM(t, e) {
  let n = 1;
  const r = t[e + n++];
  let s;
  if (r === "2") {
    const i = [
      t[e + n++],
      t[e + n++],
      t[e + n]
    ].map((o) => Number.parseInt(o));
    i.length === 3 && !i.some((o) => Number.isNaN(o)) && (s = {
      type: "rgb",
      rgb: i
    });
  } else if (r === "5") {
    const i = Number.parseInt(t[e + n]);
    Number.isNaN(i) || (s = { type: "table", index: Number(i) });
  }
  return [n, s];
}
function i8e(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n], s = Number.parseInt(r);
    if (!Number.isNaN(s))
      if (s === 0)
        e.push({ type: "resetAll" });
      else if (s <= 9)
        qw[s] && e.push({
          type: "setDecoration",
          value: qw[s]
        });
      else if (s <= 29) {
        const i = qw[s - 20];
        i && e.push({
          type: "resetDecoration",
          value: i
        });
      } else if (s <= 37)
        e.push({
          type: "setForegroundColor",
          value: { type: "named", name: Ya[s - 30] }
        });
      else if (s === 38) {
        const [i, o] = TM(t, n);
        o && e.push({
          type: "setForegroundColor",
          value: o
        }), n += i;
      } else if (s === 39)
        e.push({
          type: "resetForegroundColor"
        });
      else if (s <= 47)
        e.push({
          type: "setBackgroundColor",
          value: { type: "named", name: Ya[s - 40] }
        });
      else if (s === 48) {
        const [i, o] = TM(t, n);
        o && e.push({
          type: "setBackgroundColor",
          value: o
        }), n += i;
      } else s === 49 ? e.push({
        type: "resetBackgroundColor"
      }) : s >= 90 && s <= 97 ? e.push({
        type: "setForegroundColor",
        value: { type: "named", name: Ya[s - 90 + 8] }
      }) : s >= 100 && s <= 107 && e.push({
        type: "setBackgroundColor",
        value: { type: "named", name: Ya[s - 100 + 8] }
      });
  }
  return e;
}
function o8e() {
  let t = null, e = null, n = /* @__PURE__ */ new Set();
  return {
    parse(r) {
      const s = [];
      let i = 0;
      do {
        const o = s8e(r, i), a = o.sequence ? r.substring(i, o.startPosition) : r.substring(i);
        if (a.length > 0 && s.push({
          value: a,
          foreground: t,
          background: e,
          decorations: new Set(n)
        }), o.sequence) {
          const l = i8e(o.sequence);
          for (const c of l)
            c.type === "resetAll" ? (t = null, e = null, n.clear()) : c.type === "resetForegroundColor" ? t = null : c.type === "resetBackgroundColor" ? e = null : c.type === "resetDecoration" && n.delete(c.value);
          for (const c of l)
            c.type === "setForegroundColor" ? t = c.value : c.type === "setBackgroundColor" ? e = c.value : c.type === "setDecoration" && n.add(c.value);
        }
        i = o.position;
      } while (i < r.length);
      return s;
    }
  };
}
var a8e = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function l8e(t = a8e) {
  function e(a) {
    return t[a];
  }
  function n(a) {
    return `#${a.map((l) => Math.max(0, Math.min(l, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let r;
  function s() {
    if (r)
      return r;
    r = [];
    for (let c = 0; c < Ya.length; c++)
      r.push(e(Ya[c]));
    let a = [0, 95, 135, 175, 215, 255];
    for (let c = 0; c < 6; c++)
      for (let u = 0; u < 6; u++)
        for (let h = 0; h < 6; h++)
          r.push(n([a[c], a[u], a[h]]));
    let l = 8;
    for (let c = 0; c < 24; c++, l += 10)
      r.push(n([l, l, l]));
    return r;
  }
  function i(a) {
    return s()[a];
  }
  function o(a) {
    switch (a.type) {
      case "named":
        return e(a.name);
      case "rgb":
        return n(a.rgb);
      case "table":
        return i(a.index);
    }
  }
  return {
    value: o
  };
}
function c8e(t, e, n) {
  const r = My(t, n), s = g_(e), i = l8e(
    Object.fromEntries(
      Ya.map((a) => [
        a,
        t.colors?.[`terminal.ansi${a[0].toUpperCase()}${a.substring(1)}`]
      ])
    )
  ), o = o8e();
  return s.map(
    (a) => o.parse(a[0]).map((l) => {
      let c, u;
      l.decorations.has("reverse") ? (c = l.background ? i.value(l.background) : t.bg, u = l.foreground ? i.value(l.foreground) : t.fg) : (c = l.foreground ? i.value(l.foreground) : t.fg, u = l.background ? i.value(l.background) : void 0), c = Ka(c, r), u = Ka(u, r), l.decorations.has("dim") && (c = u8e(c));
      let h = so.None;
      return l.decorations.has("bold") && (h |= so.Bold), l.decorations.has("italic") && (h |= so.Italic), l.decorations.has("underline") && (h |= so.Underline), {
        content: l.value,
        offset: a[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: c,
        bgColor: u,
        fontStyle: h
      };
    })
  );
}
function u8e(t) {
  const e = t.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (e)
    if (e[3]) {
      const r = Math.round(Number.parseInt(e[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${e[1]}${e[2]}${r}`;
    } else return e[2] ? `#${e[1]}${e[2]}80` : `#${Array.from(e[1]).map((r) => `${r}${r}`).join("")}80`;
  const n = t.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return n ? `var(${n[1]}-dim)` : t;
}
function t2(t, e, n = {}) {
  const {
    lang: r = "text",
    theme: s = t.getLoadedThemes()[0]
  } = n;
  if (XA(r) || e2(s))
    return g_(e).map((l) => [{ content: l[0], offset: l[1] }]);
  const { theme: i, colorMap: o } = t.setTheme(s);
  if (r === "ansi")
    return c8e(i, e, n);
  const a = t.getLanguage(r);
  if (n.grammarState) {
    if (n.grammarState.lang !== a.name)
      throw new ao(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${a.name}"`);
    if (!n.grammarState.themes.includes(i.name))
      throw new ao(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${i.name}"`);
  }
  return d8e(e, a, i, o, n);
}
function h8e(...t) {
  if (t.length === 2)
    return xf(t[1]);
  const [e, n, r = {}] = t, {
    lang: s = "text",
    theme: i = e.getLoadedThemes()[0]
  } = r;
  if (XA(s) || e2(i))
    throw new ao("Plain language does not have grammar state");
  if (s === "ansi")
    throw new ao("ANSI language does not have grammar state");
  const { theme: o, colorMap: a } = e.setTheme(i), l = e.getLanguage(s);
  return new Vu(
    Fy(n, l, o, a, r).stateStack,
    l.name,
    o.name
  );
}
function d8e(t, e, n, r, s) {
  const i = Fy(t, e, n, r, s), o = new Vu(
    Fy(t, e, n, r, s).stateStack,
    e.name,
    n.name
  );
  return y_(i.tokens, o), i.tokens;
}
function Fy(t, e, n, r, s) {
  const i = My(n, s), {
    tokenizeMaxLineLength: o = 0,
    tokenizeTimeLimit: a = 500
  } = s, l = g_(t);
  let c = s.grammarState ? e8e(s.grammarState, n.name) ?? rT : s.grammarContextCode != null ? Fy(
    s.grammarContextCode,
    e,
    n,
    r,
    {
      ...s,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : rT, u = [];
  const h = [];
  for (let d = 0, f = l.length; d < f; d++) {
    const [g, y] = l[d];
    if (g === "") {
      u = [], h.push([]);
      continue;
    }
    if (o > 0 && g.length >= o) {
      u = [], h.push([{
        content: g,
        offset: y,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let p, m, b;
    s.includeExplanation && (p = e.tokenizeLine(g, c), m = p.tokens, b = 0);
    const _ = e.tokenizeLine2(g, c, a), v = _.tokens.length / 2;
    for (let w = 0; w < v; w++) {
      const E = _.tokens[2 * w], x = w + 1 < v ? _.tokens[2 * w + 2] : g.length;
      if (E === x)
        continue;
      const S = _.tokens[2 * w + 1], T = Ka(
        r[yu.getForeground(S)],
        i
      ), R = yu.getFontStyle(S), F = {
        content: g.substring(E, x),
        offset: y + E,
        color: T,
        fontStyle: R
      };
      if (s.includeExplanation) {
        const P = [];
        if (s.includeExplanation !== "scopeName")
          for (const A of n.settings) {
            let V;
            switch (typeof A.scope) {
              case "string":
                V = A.scope.split(/,/).map((ee) => ee.trim());
                break;
              case "object":
                V = A.scope;
                break;
              default:
                continue;
            }
            P.push({
              settings: A,
              selectors: V.map((ee) => ee.split(/ /))
            });
          }
        F.explanation = [];
        let M = 0;
        for (; E + M < x; ) {
          const A = m[b], V = g.substring(
            A.startIndex,
            A.endIndex
          );
          M += V.length, F.explanation.push({
            content: V,
            scopes: s.includeExplanation === "scopeName" ? f8e(
              A.scopes
            ) : p8e(
              P,
              A.scopes
            )
          }), b += 1;
        }
      }
      u.push(F);
    }
    h.push(u), u = [], c = _.ruleStack;
  }
  return {
    tokens: h,
    stateStack: c
  };
}
function f8e(t) {
  return t.map((e) => ({ scopeName: e }));
}
function p8e(t, e) {
  const n = [];
  for (let r = 0, s = e.length; r < s; r++) {
    const i = e[r];
    n[r] = {
      scopeName: i,
      themeMatches: g8e(t, i, e.slice(0, r))
    };
  }
  return n;
}
function CM(t, e) {
  return t === e || e.substring(0, t.length) === t && e[t.length] === ".";
}
function m8e(t, e, n) {
  if (!CM(t[t.length - 1], e))
    return !1;
  let r = t.length - 2, s = n.length - 1;
  for (; r >= 0 && s >= 0; )
    CM(t[r], n[s]) && (r -= 1), s -= 1;
  return r === -1;
}
function g8e(t, e, n) {
  const r = [];
  for (const { selectors: s, settings: i } of t)
    for (const o of s)
      if (m8e(o, e, n)) {
        r.push(i);
        break;
      }
  return r;
}
function hK(t, e, n) {
  const r = Object.entries(n.themes).filter((l) => l[1]).map((l) => ({ color: l[0], theme: l[1] })), s = r.map((l) => {
    const c = t2(t, e, {
      ...n,
      theme: l.theme
    }), u = xf(c), h = typeof l.theme == "string" ? l.theme : l.theme.name;
    return {
      tokens: c,
      state: u,
      theme: h
    };
  }), i = y8e(
    ...s.map((l) => l.tokens)
  ), o = i[0].map(
    (l, c) => l.map((u, h) => {
      const d = {
        content: u.content,
        variants: {},
        offset: u.offset
      };
      return "includeExplanation" in n && n.includeExplanation && (d.explanation = u.explanation), i.forEach((f, g) => {
        const {
          content: y,
          explanation: p,
          offset: m,
          ...b
        } = f[c][h];
        d.variants[r[g].color] = b;
      }), d;
    })
  ), a = s[0].state ? new Vu(
    Object.fromEntries(s.map((l) => [l.theme, l.state?.getInternalStack(l.theme)])),
    s[0].state.lang
  ) : void 0;
  return a && y_(o, a), o;
}
function y8e(...t) {
  const e = t.map(() => []), n = t.length;
  for (let r = 0; r < t[0].length; r++) {
    const s = t.map((l) => l[r]), i = e.map(() => []);
    e.forEach((l, c) => l.push(i[c]));
    const o = s.map(() => 0), a = s.map((l) => l[0]);
    for (; a.every((l) => l); ) {
      const l = Math.min(...a.map((c) => c.content.length));
      for (let c = 0; c < n; c++) {
        const u = a[c];
        u.content.length === l ? (i[c].push(u), o[c] += 1, a[c] = s[c][o[c]]) : (i[c].push({
          ...u,
          content: u.content.slice(0, l)
        }), a[c] = {
          ...u,
          content: u.content.slice(l),
          offset: u.offset + l
        });
      }
    }
  }
  return e;
}
function $y(t, e, n) {
  let r, s, i, o, a, l;
  if ("themes" in n) {
    const {
      defaultColor: c = "light",
      cssVariablePrefix: u = "--shiki-"
    } = n, h = Object.entries(n.themes).filter((p) => p[1]).map((p) => ({ color: p[0], theme: p[1] })).sort((p, m) => p.color === c ? -1 : m.color === c ? 1 : 0);
    if (h.length === 0)
      throw new ao("`themes` option must not be empty");
    const d = hK(
      t,
      e,
      n
    );
    if (l = xf(d), c && !h.find((p) => p.color === c))
      throw new ao(`\`themes\` option must contain the defaultColor key \`${c}\``);
    const f = h.map((p) => t.getTheme(p.theme)), g = h.map((p) => p.color);
    i = d.map((p) => p.map((m) => b8e(m, g, u, c))), l && y_(i, l);
    const y = h.map((p) => My(p.theme, n));
    s = h.map((p, m) => (m === 0 && c ? "" : `${u + p.color}:`) + (Ka(f[m].fg, y[m]) || "inherit")).join(";"), r = h.map((p, m) => (m === 0 && c ? "" : `${u + p.color}-bg:`) + (Ka(f[m].bg, y[m]) || "inherit")).join(";"), o = `shiki-themes ${f.map((p) => p.name).join(" ")}`, a = c ? void 0 : [s, r].join(";");
  } else if ("theme" in n) {
    const c = My(n.theme, n);
    i = t2(
      t,
      e,
      n
    );
    const u = t.getTheme(n.theme);
    r = Ka(u.bg, c), s = Ka(u.fg, c), o = u.name, l = xf(i);
  } else
    throw new ao("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: i,
    fg: s,
    bg: r,
    themeName: o,
    rootStyle: a,
    grammarState: l
  };
}
function b8e(t, e, n, r) {
  const s = {
    content: t.content,
    explanation: t.explanation,
    offset: t.offset
  }, i = e.map((l) => lK(t.variants[l])), o = new Set(i.flatMap((l) => Object.keys(l))), a = {};
  return i.forEach((l, c) => {
    for (const u of o) {
      const h = l[u] || "inherit";
      if (c === 0 && r)
        a[u] = h;
      else {
        const d = u === "color" ? "" : u === "background-color" ? "-bg" : `-${u}`, f = n + e[c] + (u === "color" ? "" : d);
        a[f] = h;
      }
    }
  }), s.htmlStyle = a, s;
}
function Uy(t, e, n, r = {
  meta: {},
  options: n,
  codeToHast: (s, i) => Uy(t, s, i),
  codeToTokens: (s, i) => $y(t, s, i)
}) {
  let s = e;
  for (const f of By(n))
    s = f.preprocess?.call(r, s, n) || s;
  let {
    tokens: i,
    fg: o,
    bg: a,
    themeName: l,
    rootStyle: c,
    grammarState: u
  } = $y(t, s, n);
  const {
    mergeWhitespaces: h = !0
  } = n;
  h === !0 ? i = v8e(i) : h === "never" && (i = w8e(i));
  const d = {
    ...r,
    get source() {
      return s;
    }
  };
  for (const f of By(n))
    i = f.tokens?.call(d, i) || i;
  return _8e(
    i,
    {
      ...n,
      fg: o,
      bg: a,
      themeName: l,
      rootStyle: c
    },
    d,
    u
  );
}
function _8e(t, e, n, r = xf(t)) {
  const s = By(e), i = [], o = {
    type: "root",
    children: []
  }, {
    structure: a = "classic",
    tabindex: l = "0"
  } = e;
  let c = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${e.themeName || ""}`,
      style: e.rootStyle || `background-color:${e.bg};color:${e.fg}`,
      ...l !== !1 && l != null ? {
        tabindex: l.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(e.meta || {})
        ).filter(([g]) => !g.startsWith("_"))
      )
    },
    children: []
  }, u = {
    type: "element",
    tagName: "code",
    properties: {},
    children: i
  };
  const h = [], d = {
    ...n,
    structure: a,
    addClassToHast: oK,
    get source() {
      return n.source;
    },
    get tokens() {
      return t;
    },
    get options() {
      return e;
    },
    get root() {
      return o;
    },
    get pre() {
      return c;
    },
    get code() {
      return u;
    },
    get lines() {
      return h;
    }
  };
  if (t.forEach((g, y) => {
    y && (a === "inline" ? o.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : a === "classic" && i.push({ type: "text", value: `
` }));
    let p = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, m = 0;
    for (const b of g) {
      let _ = {
        type: "element",
        tagName: "span",
        properties: {
          ...b.htmlAttrs
        },
        children: [{ type: "text", value: b.content }]
      };
      b.htmlStyle;
      const v = XFe(b.htmlStyle || lK(b));
      v && (_.properties.style = v);
      for (const w of s)
        _ = w?.span?.call(d, _, y + 1, m, p, b) || _;
      a === "inline" ? o.children.push(_) : a === "classic" && p.children.push(_), m += b.content.length;
    }
    if (a === "classic") {
      for (const b of s)
        p = b?.line?.call(d, p, y + 1) || p;
      h.push(p), i.push(p);
    }
  }), a === "classic") {
    for (const g of s)
      u = g?.code?.call(d, u) || u;
    c.children.push(u);
    for (const g of s)
      c = g?.pre?.call(d, c) || c;
    o.children.push(c);
  }
  let f = o;
  for (const g of s)
    f = g?.root?.call(d, f) || f;
  return r && y_(f, r), f;
}
function v8e(t) {
  return t.map((e) => {
    const n = [];
    let r = "", s = 0;
    return e.forEach((i, o) => {
      const l = !(i.fontStyle && i.fontStyle & so.Underline);
      l && i.content.match(/^\s+$/) && e[o + 1] ? (s || (s = i.offset), r += i.content) : r ? (l ? n.push({
        ...i,
        offset: s,
        content: r + i.content
      }) : n.push(
        {
          content: r,
          offset: s
        },
        i
      ), s = 0, r = "") : n.push(i);
    }), n;
  });
}
function w8e(t) {
  return t.map((e) => e.flatMap((n) => {
    if (n.content.match(/^\s+$/))
      return n;
    const r = n.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!r)
      return n;
    const [, s, i, o] = r;
    if (!s && !o)
      return n;
    const a = [{
      ...n,
      offset: n.offset + s.length,
      content: i
    }];
    return s && a.unshift({
      content: s,
      offset: n.offset
    }), o && a.push({
      content: o,
      offset: n.offset + s.length + i.length
    }), a;
  }));
}
function E8e(t, e, n) {
  const r = {
    meta: {},
    options: n,
    codeToHast: (i, o) => Uy(t, i, o),
    codeToTokens: (i, o) => $y(t, i, o)
  };
  let s = WFe(Uy(t, e, n, r));
  for (const i of By(n))
    s = i.postprocess?.call(r, s, n) || s;
  return s;
}
const kM = { light: "#333333", dark: "#bbbbbb" }, AM = { light: "#fffffe", dark: "#1e1e1e" }, RM = "__shiki_resolved";
function n2(t) {
  if (t?.[RM])
    return t;
  const e = {
    ...t
  };
  e.tokenColors && !e.settings && (e.settings = e.tokenColors, delete e.tokenColors), e.type ||= "dark", e.colorReplacements = { ...e.colorReplacements }, e.settings ||= [];
  let { bg: n, fg: r } = e;
  if (!n || !r) {
    const a = e.settings ? e.settings.find((l) => !l.name && !l.scope) : void 0;
    a?.settings?.foreground && (r = a.settings.foreground), a?.settings?.background && (n = a.settings.background), !r && e?.colors?.["editor.foreground"] && (r = e.colors["editor.foreground"]), !n && e?.colors?.["editor.background"] && (n = e.colors["editor.background"]), r || (r = e.type === "light" ? kM.light : kM.dark), n || (n = e.type === "light" ? AM.light : AM.dark), e.fg = r, e.bg = n;
  }
  e.settings[0] && e.settings[0].settings && !e.settings[0].scope || e.settings.unshift({
    settings: {
      foreground: e.fg,
      background: e.bg
    }
  });
  let s = 0;
  const i = /* @__PURE__ */ new Map();
  function o(a) {
    if (i.has(a))
      return i.get(a);
    s += 1;
    const l = `#${s.toString(16).padStart(8, "0").toLowerCase()}`;
    return e.colorReplacements?.[`#${l}`] ? o(a) : (i.set(a, l), l);
  }
  e.settings = e.settings.map((a) => {
    const l = a.settings?.foreground && !a.settings.foreground.startsWith("#"), c = a.settings?.background && !a.settings.background.startsWith("#");
    if (!l && !c)
      return a;
    const u = {
      ...a,
      settings: {
        ...a.settings
      }
    };
    if (l) {
      const h = o(a.settings.foreground);
      e.colorReplacements[h] = a.settings.foreground, u.settings.foreground = h;
    }
    if (c) {
      const h = o(a.settings.background);
      e.colorReplacements[h] = a.settings.background, u.settings.background = h;
    }
    return u;
  });
  for (const a of Object.keys(e.colors || {}))
    if ((a === "editor.foreground" || a === "editor.background" || a.startsWith("terminal.ansi")) && !e.colors[a]?.startsWith("#")) {
      const l = o(e.colors[a]);
      e.colorReplacements[l] = e.colors[a], e.colors[a] = l;
    }
  return Object.defineProperty(e, RM, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), e;
}
async function dK(t) {
  return Array.from(new Set((await Promise.all(
    t.filter((e) => !QA(e)).map(async (e) => await aK(e).then((n) => Array.isArray(n) ? n : [n]))
  )).flat()));
}
async function fK(t) {
  return (await Promise.all(
    t.map(
      async (n) => iK(n) ? null : n2(await aK(n))
    )
  )).filter((n) => !!n);
}
class S8e extends V5e {
  constructor(e, n, r, s = {}) {
    super(e), this._resolver = e, this._themes = n, this._langs = r, this._alias = s, this._themes.map((i) => this.loadTheme(i)), this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(e) {
    return typeof e == "string" ? this._resolvedThemes.get(e) : this.loadTheme(e);
  }
  loadTheme(e) {
    const n = n2(e);
    return n.name && (this._resolvedThemes.set(n.name, n), this._loadedThemesCache = null), n;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(e) {
    let n = this._textmateThemeCache.get(e);
    n || (n = Py.createFromRawTheme(e), this._textmateThemeCache.set(e, n)), this._syncRegistry.setTheme(n);
  }
  getGrammar(e) {
    if (this._alias[e]) {
      const n = /* @__PURE__ */ new Set([e]);
      for (; this._alias[e]; ) {
        if (e = this._alias[e], n.has(e))
          throw new Kn(`Circular alias \`${Array.from(n).join(" -> ")} -> ${e}\``);
        n.add(e);
      }
    }
    return this._resolvedGrammars.get(e);
  }
  loadLanguage(e) {
    if (this.getGrammar(e.name))
      return;
    const n = new Set(
      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(e.name))
    );
    this._resolver.addLanguage(e);
    const r = {
      balancedBracketSelectors: e.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: e.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(e.scopeName, e);
    const s = this.loadGrammarWithConfiguration(e.scopeName, 1, r);
    if (s.name = e.name, this._resolvedGrammars.set(e.name, s), e.aliases && e.aliases.forEach((i) => {
      this._alias[i] = e.name;
    }), this._loadedLanguagesCache = null, n.size)
      for (const i of n)
        this._resolvedGrammars.delete(i.name), this._loadedLanguagesCache = null, this._syncRegistry?._injectionGrammars?.delete(i.scopeName), this._syncRegistry?._grammars?.delete(i.scopeName), this.loadLanguage(this._langMap.get(i.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(e) {
    for (const s of e)
      this.resolveEmbeddedLanguages(s);
    const n = Array.from(this._langGraph.entries()), r = n.filter(([s, i]) => !i);
    if (r.length) {
      const s = n.filter(([i, o]) => o && o.embeddedLangs?.some((a) => r.map(([l]) => l).includes(a))).filter((i) => !r.includes(i));
      throw new Kn(`Missing languages ${r.map(([i]) => `\`${i}\``).join(", ")}, required by ${s.map(([i]) => `\`${i}\``).join(", ")}`);
    }
    for (const [s, i] of n)
      this._resolver.addLanguage(i);
    for (const [s, i] of n)
      this.loadLanguage(i);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(e) {
    if (this._langMap.set(e.name, e), this._langGraph.set(e.name, e), e.embeddedLangs)
      for (const n of e.embeddedLangs)
        this._langGraph.set(n, this._langMap.get(n));
  }
}
class x8e {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(e, n) {
    this._onigLib = {
      createOnigScanner: (r) => e.createScanner(r),
      createOnigString: (r) => e.createString(r)
    }, n.forEach((r) => this.addLanguage(r));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(e) {
    return this._langs.get(e);
  }
  loadGrammar(e) {
    return this._scopeToLang.get(e);
  }
  addLanguage(e) {
    this._langs.set(e.name, e), e.aliases && e.aliases.forEach((n) => {
      this._langs.set(n, e);
    }), this._scopeToLang.set(e.scopeName, e), e.injectTo && e.injectTo.forEach((n) => {
      this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(e.scopeName);
    });
  }
  getInjections(e) {
    const n = e.split(".");
    let r = [];
    for (let s = 1; s <= n.length; s++) {
      const i = n.slice(0, s).join(".");
      r = [...r, ...this._injections.get(i) || []];
    }
    return r;
  }
}
let mh = 0;
function T8e(t) {
  mh += 1, t.warnings !== !1 && mh >= 10 && mh % 10 === 0 && console.warn(`[Shiki] ${mh} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let e = !1;
  if (!t.engine)
    throw new Kn("`engine` option is required for synchronous mode");
  const n = (t.langs || []).flat(1), r = (t.themes || []).flat(1).map(n2), s = new x8e(t.engine, n), i = new S8e(s, r, n, t.langAlias);
  let o;
  function a(b) {
    p();
    const _ = i.getGrammar(typeof b == "string" ? b : b.name);
    if (!_)
      throw new Kn(`Language \`${b}\` not found, you may need to load it first`);
    return _;
  }
  function l(b) {
    if (b === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    p();
    const _ = i.getTheme(b);
    if (!_)
      throw new Kn(`Theme \`${b}\` not found, you may need to load it first`);
    return _;
  }
  function c(b) {
    p();
    const _ = l(b);
    o !== b && (i.setTheme(_), o = b);
    const v = i.getColorMap();
    return {
      theme: _,
      colorMap: v
    };
  }
  function u() {
    return p(), i.getLoadedThemes();
  }
  function h() {
    return p(), i.getLoadedLanguages();
  }
  function d(...b) {
    p(), i.loadLanguages(b.flat(1));
  }
  async function f(...b) {
    return d(await dK(b));
  }
  function g(...b) {
    p();
    for (const _ of b.flat(1))
      i.loadTheme(_);
  }
  async function y(...b) {
    return p(), g(await fK(b));
  }
  function p() {
    if (e)
      throw new Kn("Shiki instance has been disposed");
  }
  function m() {
    e || (e = !0, i.dispose(), mh -= 1);
  }
  return {
    setTheme: c,
    getTheme: l,
    getLanguage: a,
    getLoadedThemes: u,
    getLoadedLanguages: h,
    loadLanguage: f,
    loadLanguageSync: d,
    loadTheme: y,
    loadThemeSync: g,
    dispose: m,
    [Symbol.dispose]: m
  };
}
async function C8e(t = {}) {
  t.loadWasm;
  const [
    e,
    n,
    r
  ] = await Promise.all([
    fK(t.themes || []),
    dK(t.langs || []),
    t.engine || Fq(t.loadWasm || i5e())
  ]);
  return T8e({
    ...t,
    themes: e,
    langs: n,
    engine: r
  });
}
async function k8e(t = {}) {
  const e = await C8e(t);
  return {
    getLastGrammarState: (...n) => h8e(e, ...n),
    codeToTokensBase: (n, r) => t2(e, n, r),
    codeToTokensWithThemes: (n, r) => hK(e, n, r),
    codeToTokens: (n, r) => $y(e, n, r),
    codeToHast: (n, r) => Uy(e, n, r),
    codeToHtml: (n, r) => E8e(e, n, r),
    ...e,
    getInternalContext: () => e
  };
}
function A8e(t, e, n) {
  let r, s, i;
  {
    const a = t;
    r = a.langs, s = a.themes, i = a.engine;
  }
  async function o(a) {
    function l(f) {
      if (typeof f == "string") {
        if (QA(f))
          return [];
        const g = r[f];
        if (!g)
          throw new ao(`Language \`${f}\` is not included in this bundle. You may want to load it from external source.`);
        return g;
      }
      return f;
    }
    function c(f) {
      if (iK(f))
        return "none";
      if (typeof f == "string") {
        const g = s[f];
        if (!g)
          throw new ao(`Theme \`${f}\` is not included in this bundle. You may want to load it from external source.`);
        return g;
      }
      return f;
    }
    const u = (a.themes ?? []).map((f) => c(f)), h = (a.langs ?? []).map((f) => l(f)), d = await k8e({
      engine: a.engine ?? i(),
      ...a,
      themes: u,
      langs: h
    });
    return {
      ...d,
      loadLanguage(...f) {
        return d.loadLanguage(...f.map(l));
      },
      loadTheme(...f) {
        return d.loadTheme(...f.map(c));
      }
    };
  }
  return o;
}
function R8e(t) {
  let e;
  async function n(r = {}) {
    if (e) {
      const s = await e;
      return await Promise.all([
        s.loadTheme(...r.themes || []),
        s.loadLanguage(...r.langs || [])
      ]), s;
    } else
      return e = t({
        ...r,
        themes: r.themes || [],
        langs: r.langs || []
      }), e;
  }
  return n;
}
function I8e(t) {
  const e = R8e(t);
  return {
    getSingletonHighlighter(n) {
      return e(n);
    },
    async codeToHtml(n, r) {
      return (await e({
        langs: [r.lang],
        themes: "theme" in r ? [r.theme] : Object.values(r.themes)
      })).codeToHtml(n, r);
    },
    async codeToHast(n, r) {
      return (await e({
        langs: [r.lang],
        themes: "theme" in r ? [r.theme] : Object.values(r.themes)
      })).codeToHast(n, r);
    },
    async codeToTokens(n, r) {
      return (await e({
        langs: [r.lang],
        themes: "theme" in r ? [r.theme] : Object.values(r.themes)
      })).codeToTokens(n, r);
    },
    async codeToTokensBase(n, r) {
      return (await e({
        langs: [r.lang],
        themes: [r.theme]
      })).codeToTokensBase(n, r);
    },
    async codeToTokensWithThemes(n, r) {
      return (await e({
        langs: [r.lang],
        themes: Object.values(r.themes).filter(Boolean)
      })).codeToTokensWithThemes(n, r);
    },
    async getLastGrammarState(n, r) {
      return (await e({
        langs: [r.lang],
        themes: [r.theme]
      })).getLastGrammarState(n, r);
    }
  };
}
const pK = /* @__PURE__ */ A8e({
  langs: Bq,
  themes: j4e,
  engine: () => Fq(import("./wasm-DQxwEHae.js"))
}), {
  codeToHtml: P8e
} = /* @__PURE__ */ I8e(
  pK
), O8e = {
  langs: ["shell"],
  themes: ["light-plus", "dark-plus"]
}, D8e = await pK(O8e), N8e = I.memo(({ messageId: t }) => {
  const e = I.useRef(!1), [n, r] = I.useState(!1), [s, i] = I.useState(!1), a = mt(We.artifacts)[t], l = mt(
    MT(a.runner.actions, (u) => Object.values(u))
  ), c = () => {
    e.current = !0, r(!n);
  };
  return I.useEffect(() => {
    if (l.length && !n && !e.current && r(!0), l.length !== 0 && a.type === "bundled") {
      const u = !l.find((h) => h.status !== "complete");
      s !== u && i(u);
    }
  }, [l]), /* @__PURE__ */ k.jsxs("div", { className: "artifact border border-bolt-elements-borderColor flex flex-col overflow-hidden rounded-lg w-full transition-border duration-150", children: [
    /* @__PURE__ */ k.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ k.jsxs(
        "button",
        {
          className: "flex items-stretch bg-bolt-elements-artifacts-background hover:bg-bolt-elements-artifacts-backgroundHover w-full overflow-hidden",
          onClick: () => {
            const u = We.showWorkbench.get();
            We.showWorkbench.set(!u);
          },
          children: [
            a.type == "bundled" && /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
              /* @__PURE__ */ k.jsx("div", { className: "p-4", children: s ? /* @__PURE__ */ k.jsx("div", { className: "i-ph:files-light", style: { fontSize: "2rem" } }) : /* @__PURE__ */ k.jsx("div", { className: "i-svg-spinners:90-ring-with-bg", style: { fontSize: "2rem" } }) }),
              /* @__PURE__ */ k.jsx("div", { className: "bg-bolt-elements-artifacts-borderColor w-[1px]" })
            ] }),
            /* @__PURE__ */ k.jsxs("div", { className: "px-5 p-3.5 w-full text-left", children: [
              /* @__PURE__ */ k.jsx("div", { className: "w-full text-bolt-elements-textPrimary font-medium leading-5 text-sm", children: a?.title }),
              /* @__PURE__ */ k.jsx("div", { className: "w-full w-full text-bolt-elements-textSecondary text-xs mt-0.5", children: "Click to open Workbench" })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ k.jsx("div", { className: "bg-bolt-elements-artifacts-borderColor w-[1px]" }),
      /* @__PURE__ */ k.jsx(cl, { children: l.length && a.type !== "bundled" && /* @__PURE__ */ k.jsx(
        hn.button,
        {
          initial: { width: 0 },
          animate: { width: "auto" },
          exit: { width: 0 },
          transition: { duration: 0.15, ease: xs },
          className: "bg-bolt-elements-artifacts-background hover:bg-bolt-elements-artifacts-backgroundHover",
          onClick: c,
          children: /* @__PURE__ */ k.jsx("div", { className: "p-4", children: /* @__PURE__ */ k.jsx("div", { className: n ? "i-ph:caret-up-bold" : "i-ph:caret-down-bold" }) })
        }
      ) })
    ] }),
    /* @__PURE__ */ k.jsx(cl, { children: a.type !== "bundled" && n && l.length > 0 && /* @__PURE__ */ k.jsxs(
      hn.div,
      {
        className: "actions",
        initial: { height: 0 },
        animate: { height: "auto" },
        exit: { height: "0px" },
        transition: { duration: 0.15 },
        children: [
          /* @__PURE__ */ k.jsx("div", { className: "bg-bolt-elements-artifacts-borderColor h-[1px]" }),
          /* @__PURE__ */ k.jsx("div", { className: "p-5 text-left bg-bolt-elements-actions-background", children: /* @__PURE__ */ k.jsx(F8e, { actions: l }) })
        ]
      }
    ) })
  ] });
});
function L8e({ classsName: t, code: e }) {
  return /* @__PURE__ */ k.jsx(
    "div",
    {
      className: qe("text-xs", t),
      dangerouslySetInnerHTML: {
        __html: D8e.codeToHtml(e, {
          lang: "shell",
          theme: "dark-plus"
        })
      }
    }
  );
}
const M8e = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0 }
};
function B8e(t) {
  We.currentView.get() !== "code" && We.currentView.set("code"), We.setSelectedFile(`${ia}/${t}`);
}
const F8e = I.memo(({ actions: t }) => /* @__PURE__ */ k.jsx(hn.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.15 }, children: /* @__PURE__ */ k.jsx("ul", { className: "list-none space-y-2.5", children: t.map((e, n) => {
  const { status: r, type: s, content: i } = e, o = n === t.length - 1;
  return /* @__PURE__ */ k.jsxs(
    hn.li,
    {
      variants: M8e,
      initial: "hidden",
      animate: "visible",
      transition: {
        duration: 0.2,
        ease: xs
      },
      children: [
        /* @__PURE__ */ k.jsxs("div", { className: "flex items-center gap-1.5 text-sm", children: [
          /* @__PURE__ */ k.jsx("div", { className: qe("text-lg", $8e(e.status)), children: r === "running" ? /* @__PURE__ */ k.jsx(k.Fragment, { children: s !== "start" ? /* @__PURE__ */ k.jsx("div", { className: "i-svg-spinners:90-ring-with-bg" }) : /* @__PURE__ */ k.jsx("div", { className: "i-ph:terminal-window-duotone" }) }) : r === "pending" ? /* @__PURE__ */ k.jsx("div", { className: "i-ph:circle-duotone" }) : r === "complete" ? /* @__PURE__ */ k.jsx("div", { className: "i-ph:check" }) : r === "failed" || r === "aborted" ? /* @__PURE__ */ k.jsx("div", { className: "i-ph:x" }) : null }),
          s === "file" ? /* @__PURE__ */ k.jsxs("div", { children: [
            "Create",
            " ",
            /* @__PURE__ */ k.jsx(
              "code",
              {
                className: "bg-bolt-elements-artifacts-inlineCode-background text-bolt-elements-artifacts-inlineCode-text px-1.5 py-1 rounded-md text-bolt-elements-item-contentAccent hover:underline cursor-pointer",
                onClick: () => B8e(e.filePath),
                children: e.filePath
              }
            )
          ] }) : s === "shell" ? /* @__PURE__ */ k.jsx("div", { className: "flex items-center w-full min-h-[28px]", children: /* @__PURE__ */ k.jsx("span", { className: "flex-1", children: "Run command" }) }) : s === "start" ? /* @__PURE__ */ k.jsx(
            "a",
            {
              onClick: (a) => {
                a.preventDefault(), We.currentView.set("preview");
              },
              className: "flex items-center w-full min-h-[28px]",
              children: /* @__PURE__ */ k.jsx("span", { className: "flex-1", children: "Start Application" })
            }
          ) : null
        ] }),
        (s === "shell" || s === "start") && /* @__PURE__ */ k.jsx(
          L8e,
          {
            classsName: qe("mt-1", {
              "mb-3.5": !o
            }),
            code: i
          }
        )
      ]
    },
    n
  );
}) }) }));
function $8e(t) {
  switch (t) {
    case "pending":
      return "text-bolt-elements-textTertiary";
    case "running":
      return "text-bolt-elements-loader-progress";
    case "complete":
      return "text-bolt-elements-icon-success";
    case "aborted":
      return "text-bolt-elements-textSecondary";
    case "failed":
      return "text-bolt-elements-icon-error";
    default:
      return;
  }
}
const U8e = "C", j8e = {
  CopyButtonContainer: U8e
}, IM = Sr("CodeBlock"), H8e = I.memo(
  ({ className: t, code: e, language: n = "plaintext", theme: r = "dark-plus", disableCopy: s = !1 }) => {
    const [i, o] = I.useState(void 0), [a, l] = I.useState(!1), c = () => {
      a || (navigator.clipboard.writeText(e), l(!0), setTimeout(() => {
        l(!1);
      }, 2e3));
    };
    return I.useEffect(() => {
      n && !QA(n) && !(n in Bq) && IM.warn(`Unsupported language '${n}'`), IM.trace(`Language = ${n}`), (async () => {
        o(await P8e(e, { lang: n, theme: r }));
      })();
    }, [e]), /* @__PURE__ */ k.jsxs("div", { className: qe("relative group text-left", t), children: [
      /* @__PURE__ */ k.jsx(
        "div",
        {
          className: qe(
            j8e.CopyButtonContainer,
            "bg-transparant absolute top-[10px] right-[10px] rounded-md z-10 text-lg flex items-center justify-center opacity-0 group-hover:opacity-100",
            {
              "rounded-l-0 opacity-100": a
            }
          ),
          children: !s && /* @__PURE__ */ k.jsx(
            "button",
            {
              className: qe(
                "flex items-center bg-accent-500 p-[6px] justify-center before:bg-white before:rounded-l-md before:text-gray-500 before:border-r before:border-gray-300 rounded-md transition-theme",
                {
                  "before:opacity-0": !a,
                  "before:opacity-100": a
                }
              ),
              title: "Copy Code",
              onClick: () => c(),
              children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:clipboard-text-duotone" })
            }
          )
        }
      ),
      /* @__PURE__ */ k.jsx("div", { dangerouslySetInnerHTML: { __html: i ?? "" } })
    ] });
  }
), z8e = "B", G8e = {
  MarkdownContent: z8e
}, V8e = ({ title: t, children: e }) => {
  const [n, r] = I.useState(!1);
  return /* @__PURE__ */ k.jsxs(
    "div",
    {
      onClick: () => r(!n),
      className: `
        bg-bolt-elements-background-depth-2
        shadow-md 
        rounded-lg 
        cursor-pointer 
        transition-all 
        duration-300
        ${n ? "max-h-96" : "max-h-13"}
        overflow-auto
        border border-bolt-elements-borderColor
      `,
      children: [
        /* @__PURE__ */ k.jsxs("div", { className: "p-4 flex items-center gap-4 rounded-lg  text-bolt-elements-textSecondary font-medium leading-5 text-sm  border border-bolt-elements-borderColor", children: [
          /* @__PURE__ */ k.jsx("div", { className: "i-ph:brain-thin text-2xl" }),
          /* @__PURE__ */ k.jsxs("div", { className: "div", children: [
            /* @__PURE__ */ k.jsxs("span", { children: [
              " ",
              t
            ] }),
            " ",
            !n && /* @__PURE__ */ k.jsx("span", { className: "text-bolt-elements-textTertiary", children: " - Click to expand" })
          ] })
        ] }),
        /* @__PURE__ */ k.jsx(
          "div",
          {
            className: `
        transition-opacity 
        duration-300
        p-4 
        rounded-lg 
        ${n ? "opacity-100" : "opacity-0"}
      `,
            children: e
          }
        )
      ]
    }
  );
}, PM = Sr("MarkdownComponent"), jy = I.memo(({ children: t, html: e = !1, limitedMarkdown: n = !1 }) => {
  PM.trace("Render");
  const r = I.useMemo(() => ({
    div: ({ className: s, children: i, node: o, ...a }) => {
      if (s?.includes("__boltArtifact__")) {
        const l = o?.properties.dataMessageId;
        return l || PM.error(`Invalid message id ${l}`), /* @__PURE__ */ k.jsx(N8e, { messageId: l });
      }
      return s?.includes("__boltThought__") ? /* @__PURE__ */ k.jsx(V8e, { title: "Thought process", children: i }) : /* @__PURE__ */ k.jsx("div", { className: s, ...a, children: i });
    },
    pre: (s) => {
      const { children: i, node: o, ...a } = s, [l] = o?.children ?? [];
      if (l && l.type === "element" && l.tagName === "code" && l.children[0].type === "text") {
        const { className: c, ...u } = l.properties, [, h = "plaintext"] = /language-(\w+)/.exec(String(c) || "") ?? [];
        return /* @__PURE__ */ k.jsx(H8e, { code: l.children[0].value, language: h, ...u });
      }
      return /* @__PURE__ */ k.jsx("pre", { ...a, children: i });
    }
  }), []);
  return /* @__PURE__ */ k.jsx(
    M4e,
    {
      allowedElements: a7,
      className: G8e.MarkdownContent,
      components: r,
      remarkPlugins: QTe(n),
      rehypePlugins: eCe(e),
      children: W8e(t)
    }
  );
}), W8e = (t) => {
  if (!t || !t.includes("__boltArtifact__"))
    return t;
  const e = t.split(`
`), n = e.findIndex((r) => r.includes("__boltArtifact__"));
  return n === -1 ? t : (n > 0 && e[n - 1]?.trim().match(/^```\w*$/) && (e[n - 1] = ""), n < e.length - 1 && e[n + 1]?.trim().match(/^```$/) && (e[n + 1] = ""), e.join(`
`));
};
var r2 = "Popover", [mK, cWe] = Ii(r2, [
  Bu
]), Tp = Bu(), [q8e, Ea] = mK(r2), gK = (t) => {
  const {
    __scopePopover: e,
    children: n,
    open: r,
    defaultOpen: s,
    onOpenChange: i,
    modal: o = !1
  } = t, a = Tp(e), l = I.useRef(null), [c, u] = I.useState(!1), [h = !1, d] = tp({
    prop: r,
    defaultProp: s,
    onChange: i
  });
  return /* @__PURE__ */ k.jsx(Hk, { ...a, children: /* @__PURE__ */ k.jsx(
    q8e,
    {
      scope: e,
      contentId: Ad(),
      triggerRef: l,
      open: h,
      onOpenChange: d,
      onOpenToggle: I.useCallback(() => d((f) => !f), [d]),
      hasCustomAnchor: c,
      onCustomAnchorAdd: I.useCallback(() => u(!0), []),
      onCustomAnchorRemove: I.useCallback(() => u(!1), []),
      modal: o,
      children: n
    }
  ) });
};
gK.displayName = r2;
var yK = "PopoverAnchor", bK = I.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, s = Ea(yK, n), i = Tp(n), { onCustomAnchorAdd: o, onCustomAnchorRemove: a } = s;
    return I.useEffect(() => (o(), () => a()), [o, a]), /* @__PURE__ */ k.jsx(Gb, { ...i, ...r, ref: e });
  }
);
bK.displayName = yK;
var _K = "PopoverTrigger", vK = I.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, s = Ea(_K, n), i = Tp(n), o = Yt(e, s.triggerRef), a = /* @__PURE__ */ k.jsx(
      Pt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": s.open,
        "aria-controls": s.contentId,
        "data-state": CK(s.open),
        ...r,
        ref: o,
        onClick: Ke(t.onClick, s.onOpenToggle)
      }
    );
    return s.hasCustomAnchor ? a : /* @__PURE__ */ k.jsx(Gb, { asChild: !0, ...i, children: a });
  }
);
vK.displayName = _K;
var s2 = "PopoverPortal", [K8e, Y8e] = mK(s2, {
  forceMount: void 0
}), wK = (t) => {
  const { __scopePopover: e, forceMount: n, children: r, container: s } = t, i = Ea(s2, e);
  return /* @__PURE__ */ k.jsx(K8e, { scope: e, forceMount: n, children: /* @__PURE__ */ k.jsx(ls, { present: n || i.open, children: /* @__PURE__ */ k.jsx(rp, { asChild: !0, container: s, children: r }) }) });
};
wK.displayName = s2;
var bu = "PopoverContent", EK = I.forwardRef(
  (t, e) => {
    const n = Y8e(bu, t.__scopePopover), { forceMount: r = n.forceMount, ...s } = t, i = Ea(bu, t.__scopePopover);
    return /* @__PURE__ */ k.jsx(ls, { present: r || i.open, children: i.modal ? /* @__PURE__ */ k.jsx(Z8e, { ...s, ref: e }) : /* @__PURE__ */ k.jsx(J8e, { ...s, ref: e }) });
  }
);
EK.displayName = bu;
var Z8e = I.forwardRef(
  (t, e) => {
    const n = Ea(bu, t.__scopePopover), r = I.useRef(null), s = Yt(e, r), i = I.useRef(!1);
    return I.useEffect(() => {
      const o = r.current;
      if (o) return _C(o);
    }, []), /* @__PURE__ */ k.jsx(db, { as: dl, allowPinchZoom: !0, children: /* @__PURE__ */ k.jsx(
      SK,
      {
        ...t,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ke(t.onCloseAutoFocus, (o) => {
          o.preventDefault(), i.current || n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: Ke(
          t.onPointerDownOutside,
          (o) => {
            const a = o.detail.originalEvent, l = a.button === 0 && a.ctrlKey === !0, c = a.button === 2 || l;
            i.current = c;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Ke(
          t.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), J8e = I.forwardRef(
  (t, e) => {
    const n = Ea(bu, t.__scopePopover), r = I.useRef(!1), s = I.useRef(!1);
    return /* @__PURE__ */ k.jsx(
      SK,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          t.onCloseAutoFocus?.(i), i.defaultPrevented || (r.current || n.triggerRef.current?.focus(), i.preventDefault()), r.current = !1, s.current = !1;
        },
        onInteractOutside: (i) => {
          t.onInteractOutside?.(i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (s.current = !0));
          const o = i.target;
          n.triggerRef.current?.contains(o) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && s.current && i.preventDefault();
        }
      }
    );
  }
), SK = I.forwardRef(
  (t, e) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: s,
      onCloseAutoFocus: i,
      disableOutsidePointerEvents: o,
      onEscapeKeyDown: a,
      onPointerDownOutside: l,
      onFocusOutside: c,
      onInteractOutside: u,
      ...h
    } = t, d = Ea(bu, n), f = Tp(n);
    return bC(), /* @__PURE__ */ k.jsx(
      ub,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: s,
        onUnmountAutoFocus: i,
        children: /* @__PURE__ */ k.jsx(
          np,
          {
            asChild: !0,
            disableOutsidePointerEvents: o,
            onInteractOutside: u,
            onEscapeKeyDown: a,
            onPointerDownOutside: l,
            onFocusOutside: c,
            onDismiss: () => d.onOpenChange(!1),
            children: /* @__PURE__ */ k.jsx(
              zk,
              {
                "data-state": CK(d.open),
                role: "dialog",
                id: d.contentId,
                ...f,
                ...h,
                ref: e,
                style: {
                  ...h.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), xK = "PopoverClose", X8e = I.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, s = Ea(xK, n);
    return /* @__PURE__ */ k.jsx(
      Pt.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: Ke(t.onClick, () => s.onOpenChange(!1))
      }
    );
  }
);
X8e.displayName = xK;
var Q8e = "PopoverArrow", TK = I.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, s = Tp(n);
    return /* @__PURE__ */ k.jsx(Gk, { ...s, ...r, ref: e });
  }
);
TK.displayName = Q8e;
function CK(t) {
  return t ? "open" : "closed";
}
var e$e = gK, t$e = bK, n$e = vK, r$e = wK, s$e = EK, i$e = TK;
const o$e = ({
  children: t,
  trigger: e,
  side: n,
  align: r
}) => /* @__PURE__ */ k.jsxs(e$e, { children: [
  /* @__PURE__ */ k.jsx(n$e, { asChild: !0, children: e }),
  /* @__PURE__ */ k.jsx(t$e, {}),
  /* @__PURE__ */ k.jsx(r$e, { children: /* @__PURE__ */ k.jsxs(
    s$e,
    {
      sideOffset: 10,
      side: n,
      align: r,
      className: "bg-bolt-elements-background-depth-2 text-bolt-elements-item-contentAccent p-2 rounded-md shadow-xl z-workbench",
      children: [
        t,
        /* @__PURE__ */ k.jsx(i$e, { className: "bg-bolt-elements-item-background-depth-2" })
      ]
    }
  ) })
] });
function a$e(t) {
  t = kK(t), We.currentView.get() !== "code" && We.currentView.set("code"), We.setSelectedFile(`${ia}/${t}`);
}
function kK(t) {
  let e = t;
  return e.startsWith(ia) && (e = t.replace(ia, "")), e.startsWith("/") && (e = e.slice(1)), e;
}
const l$e = I.memo(({ content: t, annotations: e }) => {
  const n = e?.filter(
    (o) => o && typeof o == "object" && Object.keys(o).includes("type")
  ) || [];
  let r;
  n.find((o) => o.type === "chatSummary") && (r = n.find((o) => o.type === "chatSummary")?.summary);
  let s;
  n.find((o) => o.type === "codeContext") && (s = n.find((o) => o.type === "codeContext")?.files);
  const i = n.find((o) => o.type === "usage")?.value;
  return /* @__PURE__ */ k.jsxs("div", { className: "overflow-hidden w-full", children: [
    /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsxs("div", { className: " flex gap-2 items-center text-sm text-bolt-elements-textSecondary mb-2", children: [
      (s || r) && /* @__PURE__ */ k.jsxs(o$e, { side: "right", align: "start", trigger: /* @__PURE__ */ k.jsx("div", { className: "i-ph:info" }), children: [
        r && /* @__PURE__ */ k.jsxs("div", { className: "max-w-chat", children: [
          /* @__PURE__ */ k.jsxs("div", { className: "summary max-h-96 flex flex-col", children: [
            /* @__PURE__ */ k.jsx("h2", { className: "border border-bolt-elements-borderColor rounded-md p4", children: "Summary" }),
            /* @__PURE__ */ k.jsx("div", { style: { zoom: 0.7 }, className: "overflow-y-auto m4", children: /* @__PURE__ */ k.jsx(jy, { children: r }) })
          ] }),
          s && /* @__PURE__ */ k.jsxs("div", { className: "code-context flex flex-col p4 border border-bolt-elements-borderColor rounded-md", children: [
            /* @__PURE__ */ k.jsx("h2", { children: "Context" }),
            /* @__PURE__ */ k.jsx("div", { className: "flex gap-4 mt-4 bolt", style: { zoom: 0.6 }, children: s.map((o) => {
              const a = kK(o);
              return /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsx(
                "code",
                {
                  className: "bg-bolt-elements-artifacts-inlineCode-background text-bolt-elements-artifacts-inlineCode-text px-1.5 py-1 rounded-md text-bolt-elements-item-contentAccent hover:underline cursor-pointer",
                  onClick: (l) => {
                    l.preventDefault(), l.stopPropagation(), a$e(a);
                  },
                  children: a
                }
              ) });
            }) })
          ] })
        ] }),
        /* @__PURE__ */ k.jsx("div", { className: "context" })
      ] }),
      i && /* @__PURE__ */ k.jsxs("div", { children: [
        "Tokens: ",
        i.totalTokens,
        " (prompt: ",
        i.promptTokens,
        ", completion: ",
        i.completionTokens,
        ")"
      ] })
    ] }) }),
    /* @__PURE__ */ k.jsx(jy, { html: !0, children: t })
  ] });
});
function c$e({ content: t }) {
  if (Array.isArray(t)) {
    const n = t.find((i) => i.type === "text"), r = OM(n?.text || ""), s = t.filter((i) => i.type === "image" && i.image);
    return /* @__PURE__ */ k.jsx("div", { className: "overflow-hidden pt-[4px]", children: /* @__PURE__ */ k.jsxs("div", { className: "flex flex-col gap-4", children: [
      r && /* @__PURE__ */ k.jsx(jy, { html: !0, children: r }),
      s.map((i, o) => /* @__PURE__ */ k.jsx(
        "img",
        {
          src: i.image,
          alt: `Image ${o + 1}`,
          className: "max-w-full h-auto rounded-lg",
          style: { maxHeight: "512px", objectFit: "contain" }
        },
        o
      ))
    ] }) });
  }
  const e = OM(t);
  return /* @__PURE__ */ k.jsx("div", { className: "overflow-hidden pt-[4px]", children: /* @__PURE__ */ k.jsx(jy, { html: !0, children: e }) });
}
function OM(t) {
  return t.replace(Dye, "").replace(Nye, "");
}
const u$e = Qe.forwardRef((t, e) => {
  const { id: n, isStreaming: r = !1, messages: s = [] } = t, i = _Z(), o = (l) => {
    const c = new URLSearchParams(i.search);
    c.set("rewindTo", l), window.location.search = c.toString();
  }, a = async (l) => {
    try {
      if (!Kt || !Mo.get()) {
        $e.error("Chat persistence is not available");
        return;
      }
      const c = await x_e(Kt, Mo.get(), l);
      window.location.href = `/chat/${c}`;
    } catch (c) {
      $e.error("Failed to fork chat: " + c.message);
    }
  };
  return /* @__PURE__ */ k.jsxs("div", { id: n, ref: e, className: t.className, children: [
    s.length > 0 ? s.map((l, c) => {
      const { role: u, content: h, id: d, annotations: f } = l, g = u === "user", y = c === 0, p = c === s.length - 1;
      return f?.includes("hidden") ? /* @__PURE__ */ k.jsx(I.Fragment, {}, c) : /* @__PURE__ */ k.jsxs(
        "div",
        {
          className: qe("flex gap-4 p-6 w-full rounded-[calc(0.75rem-1px)]", {
            "bg-bolt-elements-messages-background": g || !r || r && !p,
            "bg-gradient-to-b from-bolt-elements-messages-background from-30% to-transparent": r && p,
            "mt-4": !y
          }),
          children: [
            g && /* @__PURE__ */ k.jsx("div", { className: "flex items-center justify-center w-[34px] h-[34px] overflow-hidden bg-white text-gray-600 rounded-full shrink-0 self-start", children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:user-fill text-xl" }) }),
            /* @__PURE__ */ k.jsx("div", { className: "grid grid-col-1 w-full", children: g ? /* @__PURE__ */ k.jsx(c$e, { content: h }) : /* @__PURE__ */ k.jsx(l$e, { content: h, annotations: l.annotations }) }),
            !g && /* @__PURE__ */ k.jsxs("div", { className: "flex gap-2 flex-col lg:flex-row", children: [
              d && /* @__PURE__ */ k.jsx(uu, { tooltip: "Revert to this message", children: /* @__PURE__ */ k.jsx(
                "button",
                {
                  onClick: () => o(d),
                  className: qe(
                    "i-ph:arrow-u-up-left",
                    "text-xl text-bolt-elements-textSecondary hover:text-bolt-elements-textPrimary transition-colors"
                  )
                },
                "i-ph:arrow-u-up-left"
              ) }),
              /* @__PURE__ */ k.jsx(uu, { tooltip: "Fork chat from this message", children: /* @__PURE__ */ k.jsx(
                "button",
                {
                  onClick: () => a(d),
                  className: qe(
                    "i-ph:git-fork",
                    "text-xl text-bolt-elements-textSecondary hover:text-bolt-elements-textPrimary transition-colors"
                  )
                },
                "i-ph:git-fork"
              ) })
            ] })
          ]
        },
        c
      );
    }) : null,
    r && /* @__PURE__ */ k.jsx("div", { className: "text-center w-full text-bolt-elements-textSecondary i-svg-spinners:3-dots-fade text-4xl mt-4" })
  ] });
}), h$e = Nl(0.4, 0, 0.2, 1), d$e = ({ show: t, isStreaming: e, disabled: n, onClick: r }) => /* @__PURE__ */ k.jsx(cl, { children: t ? /* @__PURE__ */ k.jsx(
  hn.button,
  {
    className: "absolute flex justify-center items-center top-[18px] right-[22px] p-1 bg-accent-500 hover:brightness-94 color-white rounded-md w-[34px] h-[34px] transition-theme disabled:opacity-50 disabled:cursor-not-allowed",
    transition: { ease: h$e, duration: 0.17 },
    initial: { opacity: 0, y: 10 },
    animate: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: 10 },
    disabled: n,
    onClick: (s) => {
      s.preventDefault(), n || r?.(s);
    },
    children: /* @__PURE__ */ k.jsx("div", { className: "text-lg", children: e ? /* @__PURE__ */ k.jsx("div", { className: "i-ph:stop-circle-bold" }) : /* @__PURE__ */ k.jsx("div", { className: "i-ph:arrow-right" }) })
  }
) : null }), Kw = {}, DM = {};
function Hy() {
  const t = nt.get("apiKeys");
  let e = {};
  return t && (e = DM[t], e || (e = DM[t] = JSON.parse(t))), e;
}
const f$e = ({ provider: t, apiKey: e, setApiKey: n }) => {
  const [r, s] = I.useState(!1), [i, o] = I.useState(e), [a, l] = I.useState(!1);
  I.useEffect(() => {
    const d = Hy()[t.name] || "";
    o(d), n(d), s(!1);
  }, [t.name]);
  const c = I.useCallback(async () => {
    if (Kw[t.name] !== void 0) {
      l(Kw[t.name]);
      return;
    }
    try {
      const f = (await (await fetch(`/api/check-env-key?provider=${encodeURIComponent(t.name)}`)).json()).isSet;
      Kw[t.name] = f, l(f);
    } catch (h) {
      console.error("Failed to check environment API key:", h), l(!1);
    }
  }, [t.name]);
  I.useEffect(() => {
    c();
  }, [c]);
  const u = () => {
    n(i);
    const d = { ...Hy(), [t.name]: i };
    nt.set("apiKeys", JSON.stringify(d)), s(!1);
  };
  return /* @__PURE__ */ k.jsxs("div", { className: "flex items-center justify-between py-3 px-1", children: [
    /* @__PURE__ */ k.jsx("div", { className: "flex items-center gap-2 flex-1", children: /* @__PURE__ */ k.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ k.jsxs("span", { className: "text-sm font-medium text-bolt-elements-textSecondary", children: [
        t?.name,
        " API Key:"
      ] }),
      !r && /* @__PURE__ */ k.jsx("div", { className: "flex items-center gap-2", children: e ? /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
        /* @__PURE__ */ k.jsx("div", { className: "i-ph:check-circle-fill text-green-500 w-4 h-4" }),
        /* @__PURE__ */ k.jsx("span", { className: "text-xs text-green-500", children: "Set via UI" })
      ] }) : a ? /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
        /* @__PURE__ */ k.jsx("div", { className: "i-ph:check-circle-fill text-green-500 w-4 h-4" }),
        /* @__PURE__ */ k.jsx("span", { className: "text-xs text-green-500", children: "Set via environment variable" })
      ] }) : /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
        /* @__PURE__ */ k.jsx("div", { className: "i-ph:x-circle-fill text-red-500 w-4 h-4" }),
        /* @__PURE__ */ k.jsx("span", { className: "text-xs text-red-500", children: "Not Set (Please set via UI or ENV_VAR)" })
      ] }) })
    ] }) }),
    /* @__PURE__ */ k.jsx("div", { className: "flex items-center gap-2 shrink-0", children: r ? /* @__PURE__ */ k.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "password",
          value: i,
          placeholder: "Enter API Key",
          onChange: (h) => o(h.target.value),
          className: `w-[300px] px-3 py-1.5 text-sm rounded border border-bolt-elements-borderColor 
                        bg-bolt-elements-prompt-background text-bolt-elements-textPrimary 
                        focus:outline-none focus:ring-2 focus:ring-bolt-elements-focus`
        }
      ),
      /* @__PURE__ */ k.jsx(
        Vt,
        {
          onClick: u,
          title: "Save API Key",
          className: "bg-green-500/10 hover:bg-green-500/20 text-green-500",
          children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:check w-4 h-4" })
        }
      ),
      /* @__PURE__ */ k.jsx(
        Vt,
        {
          onClick: () => s(!1),
          title: "Cancel",
          className: "bg-red-500/10 hover:bg-red-500/20 text-red-500",
          children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:x w-4 h-4" })
        }
      )
    ] }) : /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
      /* @__PURE__ */ k.jsx(
        Vt,
        {
          onClick: () => s(!0),
          title: "Edit API Key",
          className: "bg-blue-500/10 hover:bg-blue-500/20 text-blue-500",
          children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:pencil-simple w-4 h-4" })
        }
      ),
      t?.getApiKeyLink && !e && /* @__PURE__ */ k.jsxs(
        Vt,
        {
          onClick: () => window.open(t?.getApiKeyLink),
          title: "Get API Key",
          className: "bg-purple-500/10 hover:bg-purple-500/20 text-purple-500 flex items-center gap-2",
          children: [
            /* @__PURE__ */ k.jsx("span", { className: "text-xs whitespace-nowrap", children: t?.labelForGetApiKey || "Get API Key" }),
            /* @__PURE__ */ k.jsx("div", { className: `${t?.icon || "i-ph:key"} w-4 h-4` })
          ]
        }
      )
    ] }) })
  ] });
}, p$e = "s", m$e = "t", g$e = "u", y$e = "v", b$e = "w", gh = {
  BaseChat: p$e,
  Chat: m$e,
  PromptEffectContainer: g$e,
  PromptEffectLine: y$e,
  PromptShine: b$e
}, _$e = ({ exportChat: t }) => /* @__PURE__ */ k.jsx(uu, { tooltip: "Export Chat", children: /* @__PURE__ */ k.jsx(Vt, { title: "Export Chat", onClick: () => t?.(), children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:download-simple text-xl" }) }) });
function NM(t) {
  return Array.isArray(t) ? t : [t];
}
const iT = "", LM = " ", Yw = "\\", v$e = /^\s+$/, w$e = /(?:[^\\]|^)\\$/, E$e = /^\\!/, S$e = /^\\#/, x$e = /\r?\n/g, T$e = /^\.*\/|^\.+$/, Zw = "/";
let AK = "node-ignore";
typeof Symbol < "u" && (AK = Symbol.for("node-ignore"));
const MM = AK, C$e = (t, e, n) => Object.defineProperty(t, e, { value: n }), k$e = /([0-z])-([0-z])/g, RK = () => !1, A$e = (t) => t.replace(
  k$e,
  (e, n, r) => n.charCodeAt(0) <= r.charCodeAt(0) ? e : iT
), R$e = (t) => {
  const { length: e } = t;
  return t.slice(0, e - e % 2);
}, I$e = [
  [
    // remove BOM
    // TODO:
    // Other similar zero-width characters?
    /^\uFEFF/,
    () => iT
  ],
  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a ) -> (a)
    // (a \ ) -> (a  )
    /((?:\\\\)*?)(\\?\s+)$/,
    (t, e, n) => e + (n.indexOf("\\") === 0 ? LM : iT)
  ],
  // replace (\ ) with ' '
  // (\ ) -> ' '
  // (\\ ) -> '\\ '
  // (\\\ ) -> '\\ '
  [
    /(\\+?)\s/g,
    (t, e) => {
      const { length: n } = e;
      return e.slice(0, n - n % 2) + LM;
    }
  ],
  // Escape metacharacters
  // which is written down by users but means special for regular expressions.
  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    (t) => `\\${t}`
  ],
  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => "[^/]"
  ],
  // leading slash
  [
    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => "^"
  ],
  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => "\\/"
  ],
  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,
    // '**/foo' <-> 'foo'
    () => "^(?:.*\\/)?"
  ],
  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function() {
      return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
    }
  ],
  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,
    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer
    // Check if it is not the last `'/**'`
    (t, e, n) => e + 6 < n.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
  ],
  // normal intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'
    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule,
    //    coz trailing single wildcard will be handed by [trailing wildcard]
    /(^|[^\\]+)(\\\*)+(?=.+)/g,
    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (t, e, n) => {
      const r = n.replace(/\\\*/g, "[^\\/]*");
      return e + r;
    }
  ],
  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => Yw
  ],
  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => Yw
  ],
  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.
    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (t, e, n, r, s) => e === Yw ? `\\[${n}${R$e(r)}${s}` : s === "]" && r.length % 2 === 0 ? `[${A$e(n)}${r}]` : "[]"
  ],
  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,
    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38
    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.
    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    (t) => /\/$/.test(t) ? `${t}$` : `${t}(?=$|\\/$)`
  ],
  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (t, e) => `${e ? `${e}[^/]+` : "[^/]*"}(?=$|\\/$)`
  ]
], BM = /* @__PURE__ */ Object.create(null), P$e = (t, e) => {
  let n = BM[t];
  return n || (n = I$e.reduce(
    (r, [s, i]) => r.replace(s, i.bind(t)),
    t
  ), BM[t] = n), e ? new RegExp(n, "i") : new RegExp(n);
}, i2 = (t) => typeof t == "string", O$e = (t) => t && i2(t) && !v$e.test(t) && !w$e.test(t) && t.indexOf("#") !== 0, D$e = (t) => t.split(x$e);
let N$e = class {
  constructor(e, n, r, s) {
    this.origin = e, this.pattern = n, this.negative = r, this.regex = s;
  }
};
const L$e = (t, e) => {
  const n = t;
  let r = !1;
  t.indexOf("!") === 0 && (r = !0, t = t.substr(1)), t = t.replace(E$e, "!").replace(S$e, "#");
  const s = P$e(t, e);
  return new N$e(
    n,
    t,
    r,
    s
  );
}, M$e = (t, e) => {
  throw new e(t);
}, mo = (t, e, n) => i2(t) ? t ? mo.isNotRelative(t) ? n(
  `path should be a \`path.relative()\`d string, but got "${e}"`,
  RangeError
) : !0 : n("path must not be empty", TypeError) : n(
  `path must be a string, but got \`${e}\``,
  TypeError
), IK = (t) => T$e.test(t);
mo.isNotRelative = IK;
mo.convert = (t) => t;
let B$e = class {
  constructor({
    ignorecase: e = !0,
    ignoreCase: n = e,
    allowRelativePaths: r = !1
  } = {}) {
    C$e(this, MM, !0), this._rules = [], this._ignoreCase = n, this._allowRelativePaths = r, this._initCache();
  }
  _initCache() {
    this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
  }
  _addPattern(e) {
    if (e && e[MM]) {
      this._rules = this._rules.concat(e._rules), this._added = !0;
      return;
    }
    if (O$e(e)) {
      const n = L$e(e, this._ignoreCase);
      this._added = !0, this._rules.push(n);
    }
  }
  // @param {Array<string> | string | Ignore} pattern
  add(e) {
    return this._added = !1, NM(
      i2(e) ? D$e(e) : e
    ).forEach(this._addPattern, this), this._added && this._initCache(), this;
  }
  // legacy
  addPattern(e) {
    return this.add(e);
  }
  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X
  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen
  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.
  // @returns {TestResult} true if a file is ignored
  _testOne(e, n) {
    let r = !1, s = !1;
    return this._rules.forEach((i) => {
      const { negative: o } = i;
      if (s === o && r !== s || o && !r && !s && !n)
        return;
      i.regex.test(e) && (r = !o, s = o);
    }), {
      ignored: r,
      unignored: s
    };
  }
  // @returns {TestResult}
  _test(e, n, r, s) {
    const i = e && mo.convert(e);
    return mo(
      i,
      e,
      this._allowRelativePaths ? RK : M$e
    ), this._t(i, n, r, s);
  }
  _t(e, n, r, s) {
    if (e in n)
      return n[e];
    if (s || (s = e.split(Zw)), s.pop(), !s.length)
      return n[e] = this._testOne(e, r);
    const i = this._t(
      s.join(Zw) + Zw,
      n,
      r,
      s
    );
    return n[e] = i.ignored ? i : this._testOne(e, r);
  }
  ignores(e) {
    return this._test(e, this._ignoreCache, !1).ignored;
  }
  createFilter() {
    return (e) => !this.ignores(e);
  }
  filter(e) {
    return NM(e).filter(this.createFilter());
  }
  // @returns {TestResult}
  test(e) {
    return this._test(e, this._testCache, !0);
  }
};
const zy = (t) => new B$e(t), F$e = (t) => mo(t && mo.convert(t), t, RK);
zy.isPathValid = F$e;
zy.default = zy;
var $$e = zy;
if (
  // Detect `process` so that it can run in browsers.
  typeof je < "u" && (je.env && je.env.IGNORE_TEST_WIN32 || je.platform === "win32")
) {
  const t = (n) => /^\\\\\?\\/.test(n) || /["<>|\u0000-\u001F]+/u.test(n) ? n : n.replace(/\\/g, "/");
  mo.convert = t;
  const e = /^[a-z]:\//i;
  mo.isNotRelative = (n) => e.test(n) || IK(n);
}
const o2 = /* @__PURE__ */ Is($$e), U$e = [
  "node_modules/**",
  ".git/**",
  "dist/**",
  "build/**",
  ".next/**",
  "coverage/**",
  ".cache/**",
  ".vscode/**",
  ".idea/**",
  "**/*.log",
  "**/.DS_Store",
  "**/npm-debug.log*",
  "**/yarn-debug.log*",
  "**/yarn-error.log*"
], Jw = 1e3, j$e = o2().add(U$e), dd = () => Math.random().toString(36).substring(2, 15), H$e = async (t) => {
  const n = new Uint8Array(await t.slice(0, 1024).arrayBuffer());
  for (let r = 0; r < n.length; r++) {
    const s = n[r];
    if (s === 0 || s < 32 && s !== 9 && s !== 10 && s !== 13)
      return !0;
  }
  return !1;
}, z$e = (t) => !j$e.ignores(t);
async function PK(t) {
  const e = (n) => t.some((r) => r.path.endsWith(n));
  if (e("package.json")) {
    const n = t.find((r) => r.path.endsWith("package.json"));
    if (!n)
      return { type: "", setupCommand: "", followupMessage: "" };
    try {
      const s = JSON.parse(n.content)?.scripts || {}, o = ["dev", "start", "preview"].find((a) => s[a]);
      return o ? {
        type: "Node.js",
        setupCommand: "npm install",
        startCommand: `npm run ${o}`,
        followupMessage: `Found "${o}" script in package.json. Running "npm run ${o}" after installation.`
      } : {
        type: "Node.js",
        setupCommand: "npm install",
        followupMessage: "Would you like me to inspect package.json to determine the available scripts for running this project?"
      };
    } catch (r) {
      return console.error("Error parsing package.json:", r), { type: "", setupCommand: "", followupMessage: "" };
    }
  }
  return e("index.html") ? {
    type: "Static",
    startCommand: "npx --yes serve",
    followupMessage: ""
  } : { type: "", setupCommand: "", followupMessage: "" };
}
function OK(t) {
  if (!t.setupCommand && !t.startCommand)
    return null;
  let e = "";
  return t.setupCommand && (e += `
<boltAction type="shell">${t.setupCommand}</boltAction>`), t.startCommand && (e += `
<boltAction type="start">${t.startCommand}</boltAction>
`), {
    role: "assistant",
    content: `
<boltArtifact id="project-setup" title="Project Setup">
${e}
</boltArtifact>${t.followupMessage ? `

${t.followupMessage}` : ""}`,
    id: dd(),
    createdAt: /* @__PURE__ */ new Date()
  };
}
function G$e(t) {
  const e = /(<boltArtifact[^>]*>)([\s\S]*?)(<\/boltArtifact>)/g;
  return t.replace(e, (n, r, s, i) => {
    const o = r.replace(/</g, "&lt;").replace(/>/g, "&gt;"), a = i.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return `${o}${s}${a}`;
  });
}
function V$e(t) {
  const e = /(<boltAction[^>]*>)([\s\S]*?)(<\/boltAction>)/g;
  return t.replace(e, (n, r, s, i) => {
    const o = r.replace(/</g, "&lt;").replace(/>/g, "&gt;"), a = i.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return `${o}${s}${a}`;
  });
}
function DK(t) {
  return G$e(V$e(t));
}
const W$e = async (t, e, n) => {
  const r = await Promise.all(
    t.map(async (u) => new Promise((h, d) => {
      const f = new FileReader();
      f.onload = () => {
        const g = f.result, y = u.webkitRelativePath.split("/").slice(1).join("/");
        h({
          content: g,
          path: y
        });
      }, f.onerror = d, f.readAsText(u);
    }))
  ), s = await PK(r), i = OK(s), o = e.length > 0 ? `

Skipped ${e.length} binary files:
${e.map((u) => `- ${u}`).join(`
`)}` : "", a = {
    role: "assistant",
    content: `I've imported the contents of the "${n}" folder.${o}

<boltArtifact id="imported-files" title="Imported Files" type="bundled" >
${r.map(
      (u) => `<boltAction type="file" filePath="${u.path}">
${DK(u.content)}
</boltAction>`
    ).join(`

`)}
</boltArtifact>`,
    id: dd(),
    createdAt: /* @__PURE__ */ new Date()
  }, c = [{
    role: "user",
    id: dd(),
    content: `Import the "${n}" folder`,
    createdAt: /* @__PURE__ */ new Date()
  }, a];
  return i && (c.push({
    role: "user",
    id: dd(),
    content: "Setup the codebase and Start the application"
  }), c.push(i)), c;
}, q$e = ({ className: t, importChat: e }) => {
  const [n, r] = I.useState(!1), s = async (i) => {
    const a = Array.from(i.target.files || []).filter((u) => {
      const h = u.webkitRelativePath.split("/").slice(1).join("/");
      return z$e(h);
    });
    if (a.length === 0) {
      const u = new Error("No valid files found");
      hr.logError("File import failed - no valid files", u, { folderName: "Unknown Folder" }), $e.error("No files found in the selected folder");
      return;
    }
    if (a.length > Jw) {
      const u = new Error(`Too many files: ${a.length}`);
      hr.logError("File import failed - too many files", u, {
        fileCount: a.length,
        maxFiles: Jw
      }), $e.error(
        `This folder contains ${a.length.toLocaleString()} files. This product is not yet optimized for very large projects. Please select a folder with fewer than ${Jw.toLocaleString()} files.`
      );
      return;
    }
    const l = a[0]?.webkitRelativePath.split("/")[0] || "Unknown Folder";
    r(!0);
    const c = $e.loading(`Importing ${l}...`);
    try {
      const u = await Promise.all(
        a.map(async (g) => ({
          file: g,
          isBinary: await H$e(g)
        }))
      ), h = u.filter((g) => !g.isBinary).map((g) => g.file), d = u.filter((g) => g.isBinary).map((g) => g.file.webkitRelativePath.split("/").slice(1).join("/"));
      if (h.length === 0) {
        const g = new Error("No text files found");
        hr.logError("File import failed - no text files", g, { folderName: l }), $e.error("No text files found in the selected folder");
        return;
      }
      d.length > 0 && (hr.logWarning("Skipping binary files during import", {
        folderName: l,
        binaryCount: d.length
      }), $e.info(`Skipping ${d.length} binary files`));
      const f = await W$e(h, d, l);
      e && await e(l, [...f]), hr.logSystem("Folder imported successfully", {
        folderName: l,
        textFileCount: h.length,
        binaryFileCount: d.length
      }), $e.success("Folder imported successfully");
    } catch (u) {
      hr.logError("Failed to import folder", u, { folderName: l }), console.error("Failed to import folder:", u), $e.error("Failed to import folder");
    } finally {
      r(!1), $e.dismiss(c), i.target.value = "";
    }
  };
  return /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
    /* @__PURE__ */ k.jsx(
      "input",
      {
        type: "file",
        id: "folder-import",
        className: "hidden",
        webkitdirectory: "",
        directory: "",
        onChange: s
      }
    ),
    /* @__PURE__ */ k.jsxs(
      "button",
      {
        onClick: () => {
          document.getElementById("folder-import")?.click();
        },
        className: t,
        disabled: n,
        children: [
          /* @__PURE__ */ k.jsx("div", { className: "i-ph:upload-simple" }),
          n ? "Importing..." : "Import Folder"
        ]
      }
    )
  ] });
};
function K$e(t) {
  return /* @__PURE__ */ k.jsxs("div", { className: "flex flex-col items-center justify-center w-auto", children: [
    /* @__PURE__ */ k.jsx(
      "input",
      {
        type: "file",
        id: "chat-import",
        className: "hidden",
        accept: ".json",
        onChange: async (e) => {
          const n = e.target.files?.[0];
          if (n && t) {
            try {
              const r = new FileReader();
              r.onload = async (s) => {
                try {
                  const i = s.target?.result, o = JSON.parse(i);
                  if (Array.isArray(o.messages)) {
                    await t(o.description || "Imported Chat", o.messages), $e.success("Chat imported successfully");
                    return;
                  }
                  $e.error("Invalid chat file format");
                } catch (i) {
                  i instanceof Error ? $e.error("Failed to parse chat file: " + i.message) : $e.error("Failed to parse chat file");
                }
              }, r.onerror = () => $e.error("Failed to read chat file"), r.readAsText(n);
            } catch (r) {
              $e.error(r instanceof Error ? r.message : "Failed to import chat");
            }
            e.target.value = "";
          } else
            $e.error("Something went wrong");
        }
      }
    ),
    /* @__PURE__ */ k.jsx("div", { className: "flex flex-col items-center gap-4 max-w-2xl text-center", children: /* @__PURE__ */ k.jsxs("div", { className: "flex gap-2", children: [
      /* @__PURE__ */ k.jsxs(
        "button",
        {
          onClick: () => {
            document.getElementById("chat-import")?.click();
          },
          className: "px-4 py-2 rounded-lg border border-bolt-elements-borderColor bg-bolt-elements-prompt-background text-bolt-elements-textPrimary hover:bg-bolt-elements-background-depth-3 transition-all flex items-center gap-2",
          children: [
            /* @__PURE__ */ k.jsx("div", { className: "i-ph:upload-simple" }),
            "Import Chat"
          ]
        }
      ),
      /* @__PURE__ */ k.jsx(
        q$e,
        {
          importChat: t,
          className: "px-4 py-2 rounded-lg border border-bolt-elements-borderColor bg-bolt-elements-prompt-background text-bolt-elements-textPrimary hover:bg-bolt-elements-background-depth-3 transition-all flex items-center gap-2"
        }
      )
    ] }) })
  ] });
}
var Or = function(t) {
  if (t = t || {}, this.Promise = t.Promise || Promise, this.queues = /* @__PURE__ */ Object.create(null), this.domainReentrant = t.domainReentrant || !1, this.domainReentrant) {
    if (typeof je > "u" || typeof je.domain > "u")
      throw new Error(
        "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
      );
    this.domains = /* @__PURE__ */ Object.create(null);
  }
  this.timeout = t.timeout || Or.DEFAULT_TIMEOUT, this.maxOccupationTime = t.maxOccupationTime || Or.DEFAULT_MAX_OCCUPATION_TIME, this.maxExecutionTime = t.maxExecutionTime || Or.DEFAULT_MAX_EXECUTION_TIME, t.maxPending === 1 / 0 || Number.isInteger(t.maxPending) && t.maxPending >= 0 ? this.maxPending = t.maxPending : this.maxPending = Or.DEFAULT_MAX_PENDING;
};
Or.DEFAULT_TIMEOUT = 0;
Or.DEFAULT_MAX_OCCUPATION_TIME = 0;
Or.DEFAULT_MAX_EXECUTION_TIME = 0;
Or.DEFAULT_MAX_PENDING = 1e3;
Or.prototype.acquire = function(t, e, n, r) {
  if (Array.isArray(t))
    return this._acquireBatch(t, e, n, r);
  if (typeof e != "function")
    throw new Error("You must pass a function to execute");
  var s = null, i = null, o = null;
  typeof n != "function" && (r = n, n = null, o = new this.Promise(function(b, _) {
    s = b, i = _;
  })), r = r || {};
  var a = !1, l = null, c = null, u = null, h = this, d = function(b, _, v) {
    c && (clearTimeout(c), c = null), u && (clearTimeout(u), u = null), b && (h.queues[t] && h.queues[t].length === 0 && delete h.queues[t], h.domainReentrant && delete h.domains[t]), a || (o ? _ ? i(_) : s(v) : typeof n == "function" && n(_, v), a = !0), b && h.queues[t] && h.queues[t].length > 0 && h.queues[t].shift()();
  }, f = function(b) {
    if (a)
      return d(b);
    l && (clearTimeout(l), l = null), h.domainReentrant && b && (h.domains[t] = je.domain);
    var _ = r.maxExecutionTime || h.maxExecutionTime;
    if (_ && (u = setTimeout(function() {
      h.queues[t] && d(b, new Error("Maximum execution time is exceeded " + t));
    }, _)), e.length === 1) {
      var v = !1;
      try {
        e(function(w, E) {
          v || (v = !0, d(b, w, E));
        });
      } catch (w) {
        v || (v = !0, d(b, w));
      }
    } else
      h._promiseTry(function() {
        return e();
      }).then(function(w) {
        d(b, void 0, w);
      }, function(w) {
        d(b, w);
      });
  };
  h.domainReentrant && je.domain && (f = je.domain.bind(f));
  var g = r.maxPending || h.maxPending;
  if (!h.queues[t])
    h.queues[t] = [], f(!0);
  else if (h.domainReentrant && je.domain && je.domain === h.domains[t])
    f(!1);
  else if (h.queues[t].length >= g)
    d(!1, new Error("Too many pending tasks in queue " + t));
  else {
    var y = function() {
      f(!0);
    };
    r.skipQueue ? h.queues[t].unshift(y) : h.queues[t].push(y);
    var p = r.timeout || h.timeout;
    p && (l = setTimeout(function() {
      l = null, d(!1, new Error("async-lock timed out in queue " + t));
    }, p));
  }
  var m = r.maxOccupationTime || h.maxOccupationTime;
  if (m && (c = setTimeout(function() {
    h.queues[t] && d(!1, new Error("Maximum occupation time is exceeded in queue " + t));
  }, m)), o)
    return o;
};
Or.prototype._acquireBatch = function(t, e, n, r) {
  typeof n != "function" && (r = n, n = null);
  var s = this, i = function(a, l) {
    return function(c) {
      s.acquire(a, l, c, r);
    };
  }, o = t.reduceRight(function(a, l) {
    return i(l, a);
  }, e);
  if (typeof n == "function")
    o(n);
  else
    return new this.Promise(function(a, l) {
      o.length === 1 ? o(function(c, u) {
        c ? l(c) : a(u);
      }) : a(o());
    });
};
Or.prototype.isBusy = function(t) {
  return t ? !!this.queues[t] : Object.keys(this.queues).length > 0;
};
Or.prototype._promiseTry = function(t) {
  try {
    return this.Promise.resolve(t());
  } catch (e) {
    return this.Promise.reject(e);
  }
};
var Y$e = Or, Z$e = Y$e;
const Gy = /* @__PURE__ */ Is(Z$e);
var oT = { exports: {} };
typeof Object.create == "function" ? oT.exports = function(e, n) {
  n && (e.super_ = n, e.prototype = Object.create(n.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : oT.exports = function(e, n) {
  if (n) {
    e.super_ = n;
    var r = function() {
    };
    r.prototype = n.prototype, e.prototype = new r(), e.prototype.constructor = e;
  }
};
var J$e = oT.exports, aT = { exports: {} };
const X$e = /* @__PURE__ */ EZ($re);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t, e) {
  var n = X$e, r = n.Buffer;
  function s(o, a) {
    for (var l in o)
      a[l] = o[l];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t.exports = n : (s(n, e), e.Buffer = i);
  function i(o, a, l) {
    return r(o, a, l);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(o, a, l) {
    if (typeof o == "number")
      throw new TypeError("Argument must not be a number");
    return r(o, a, l);
  }, i.alloc = function(o, a, l) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    var c = r(o);
    return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;
  }, i.allocUnsafe = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return r(o);
  }, i.allocUnsafeSlow = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(o);
  };
})(aT, aT.exports);
var NK = aT.exports, LK = NK.Buffer;
function b_(t, e) {
  this._block = LK.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
}
b_.prototype.update = function(t, e) {
  typeof t == "string" && (e = e || "utf8", t = LK.from(t, e));
  for (var n = this._block, r = this._blockSize, s = t.length, i = this._len, o = 0; o < s; ) {
    for (var a = i % r, l = Math.min(s - o, r - a), c = 0; c < l; c++)
      n[a + c] = t[o + c];
    i += l, o += l, i % r === 0 && this._update(n);
  }
  return this._len += s, this;
};
b_.prototype.digest = function(t) {
  var e = this._len % this._blockSize;
  this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var n = this._len * 8;
  if (n <= 4294967295)
    this._block.writeUInt32BE(n, this._blockSize - 4);
  else {
    var r = (n & 4294967295) >>> 0, s = (n - r) / 4294967296;
    this._block.writeUInt32BE(s, this._blockSize - 8), this._block.writeUInt32BE(r, this._blockSize - 4);
  }
  this._update(this._block);
  var i = this._hash();
  return t ? i.toString(t) : i;
};
b_.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var Q$e = b_, eUe = J$e, MK = Q$e, tUe = NK.Buffer, nUe = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], rUe = new Array(80);
function Cp() {
  this.init(), this._w = rUe, MK.call(this, 64, 56);
}
eUe(Cp, MK);
Cp.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function sUe(t) {
  return t << 1 | t >>> 31;
}
function iUe(t) {
  return t << 5 | t >>> 27;
}
function oUe(t) {
  return t << 30 | t >>> 2;
}
function aUe(t, e, n, r) {
  return t === 0 ? e & n | ~e & r : t === 2 ? e & n | e & r | n & r : e ^ n ^ r;
}
Cp.prototype._update = function(t) {
  for (var e = this._w, n = this._a | 0, r = this._b | 0, s = this._c | 0, i = this._d | 0, o = this._e | 0, a = 0; a < 16; ++a) e[a] = t.readInt32BE(a * 4);
  for (; a < 80; ++a) e[a] = sUe(e[a - 3] ^ e[a - 8] ^ e[a - 14] ^ e[a - 16]);
  for (var l = 0; l < 80; ++l) {
    var c = ~~(l / 20), u = iUe(n) + aUe(c, r, s, i) + o + e[l] + nUe[c] | 0;
    o = i, i = s, s = oUe(r), r = n, n = u;
  }
  this._a = n + this._a | 0, this._b = r + this._b | 0, this._c = s + this._c | 0, this._d = i + this._d | 0, this._e = o + this._e | 0;
};
Cp.prototype._hash = function() {
  var t = tUe.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var lUe = Cp;
const cUe = /* @__PURE__ */ Is(lUe);
var BK = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
(function(t) {
  (function(e) {
    e(typeof DO_NOT_EXPORT_CRC > "u" ? t : {});
  })(function(e) {
    e.version = "1.2.2";
    function n() {
      for (var S = 0, T = new Array(256), R = 0; R != 256; ++R)
        S = R, S = S & 1 ? -306674912 ^ S >>> 1 : S >>> 1, S = S & 1 ? -306674912 ^ S >>> 1 : S >>> 1, S = S & 1 ? -306674912 ^ S >>> 1 : S >>> 1, S = S & 1 ? -306674912 ^ S >>> 1 : S >>> 1, S = S & 1 ? -306674912 ^ S >>> 1 : S >>> 1, S = S & 1 ? -306674912 ^ S >>> 1 : S >>> 1, S = S & 1 ? -306674912 ^ S >>> 1 : S >>> 1, S = S & 1 ? -306674912 ^ S >>> 1 : S >>> 1, T[R] = S;
      return typeof Int32Array < "u" ? new Int32Array(T) : T;
    }
    var r = n();
    function s(S) {
      var T = 0, R = 0, F = 0, P = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
      for (F = 0; F != 256; ++F) P[F] = S[F];
      for (F = 0; F != 256; ++F)
        for (R = S[F], T = 256 + F; T < 4096; T += 256) R = P[T] = R >>> 8 ^ S[R & 255];
      var M = [];
      for (F = 1; F != 16; ++F) M[F - 1] = typeof Int32Array < "u" ? P.subarray(F * 256, F * 256 + 256) : P.slice(F * 256, F * 256 + 256);
      return M;
    }
    var i = s(r), o = i[0], a = i[1], l = i[2], c = i[3], u = i[4], h = i[5], d = i[6], f = i[7], g = i[8], y = i[9], p = i[10], m = i[11], b = i[12], _ = i[13], v = i[14];
    function w(S, T) {
      for (var R = T ^ -1, F = 0, P = S.length; F < P; ) R = R >>> 8 ^ r[(R ^ S.charCodeAt(F++)) & 255];
      return ~R;
    }
    function E(S, T) {
      for (var R = T ^ -1, F = S.length - 15, P = 0; P < F; ) R = v[S[P++] ^ R & 255] ^ _[S[P++] ^ R >> 8 & 255] ^ b[S[P++] ^ R >> 16 & 255] ^ m[S[P++] ^ R >>> 24] ^ p[S[P++]] ^ y[S[P++]] ^ g[S[P++]] ^ f[S[P++]] ^ d[S[P++]] ^ h[S[P++]] ^ u[S[P++]] ^ c[S[P++]] ^ l[S[P++]] ^ a[S[P++]] ^ o[S[P++]] ^ r[S[P++]];
      for (F += 15; P < F; ) R = R >>> 8 ^ r[(R ^ S[P++]) & 255];
      return ~R;
    }
    function x(S, T) {
      for (var R = T ^ -1, F = 0, P = S.length, M = 0, A = 0; F < P; )
        M = S.charCodeAt(F++), M < 128 ? R = R >>> 8 ^ r[(R ^ M) & 255] : M < 2048 ? (R = R >>> 8 ^ r[(R ^ (192 | M >> 6 & 31)) & 255], R = R >>> 8 ^ r[(R ^ (128 | M & 63)) & 255]) : M >= 55296 && M < 57344 ? (M = (M & 1023) + 64, A = S.charCodeAt(F++) & 1023, R = R >>> 8 ^ r[(R ^ (240 | M >> 8 & 7)) & 255], R = R >>> 8 ^ r[(R ^ (128 | M >> 2 & 63)) & 255], R = R >>> 8 ^ r[(R ^ (128 | A >> 6 & 15 | (M & 3) << 4)) & 255], R = R >>> 8 ^ r[(R ^ (128 | A & 63)) & 255]) : (R = R >>> 8 ^ r[(R ^ (224 | M >> 12 & 15)) & 255], R = R >>> 8 ^ r[(R ^ (128 | M >> 6 & 63)) & 255], R = R >>> 8 ^ r[(R ^ (128 | M & 63)) & 255]);
      return ~R;
    }
    e.table = r, e.bstr = w, e.buf = E, e.str = x;
  });
})(BK);
const uUe = /* @__PURE__ */ Is(BK);
var _o = {};
(function(t) {
  var e = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
  function n(i, o) {
    return Object.prototype.hasOwnProperty.call(i, o);
  }
  t.assign = function(i) {
    for (var o = Array.prototype.slice.call(arguments, 1); o.length; ) {
      var a = o.shift();
      if (a) {
        if (typeof a != "object")
          throw new TypeError(a + "must be non-object");
        for (var l in a)
          n(a, l) && (i[l] = a[l]);
      }
    }
    return i;
  }, t.shrinkBuf = function(i, o) {
    return i.length === o ? i : i.subarray ? i.subarray(0, o) : (i.length = o, i);
  };
  var r = {
    arraySet: function(i, o, a, l, c) {
      if (o.subarray && i.subarray) {
        i.set(o.subarray(a, a + l), c);
        return;
      }
      for (var u = 0; u < l; u++)
        i[c + u] = o[a + u];
    },
    // Join array of chunks to single array.
    flattenChunks: function(i) {
      var o, a, l, c, u, h;
      for (l = 0, o = 0, a = i.length; o < a; o++)
        l += i[o].length;
      for (h = new Uint8Array(l), c = 0, o = 0, a = i.length; o < a; o++)
        u = i[o], h.set(u, c), c += u.length;
      return h;
    }
  }, s = {
    arraySet: function(i, o, a, l, c) {
      for (var u = 0; u < l; u++)
        i[c + u] = o[a + u];
    },
    // Join array of chunks to single array.
    flattenChunks: function(i) {
      return [].concat.apply([], i);
    }
  };
  t.setTyped = function(i) {
    i ? (t.Buf8 = Uint8Array, t.Buf16 = Uint16Array, t.Buf32 = Int32Array, t.assign(t, r)) : (t.Buf8 = Array, t.Buf16 = Array, t.Buf32 = Array, t.assign(t, s));
  }, t.setTyped(e);
})(_o);
var kp = {}, Mi = {}, Wu = {}, hUe = _o, dUe = 4, FM = 0, $M = 1, fUe = 2;
function qu(t) {
  for (var e = t.length; --e >= 0; )
    t[e] = 0;
}
var pUe = 0, FK = 1, mUe = 2, gUe = 3, yUe = 258, a2 = 29, Ap = 256, Tf = Ap + 1 + a2, Gc = 30, l2 = 19, $K = 2 * Tf + 1, Za = 15, Xw = 16, bUe = 7, c2 = 256, UK = 16, jK = 17, HK = 18, lT = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
), $g = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
), _Ue = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
), zK = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], vUe = 512, ji = new Array((Tf + 2) * 2);
qu(ji);
var fd = new Array(Gc * 2);
qu(fd);
var Cf = new Array(vUe);
qu(Cf);
var kf = new Array(yUe - gUe + 1);
qu(kf);
var u2 = new Array(a2);
qu(u2);
var Vy = new Array(Gc);
qu(Vy);
function Qw(t, e, n, r, s) {
  this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = r, this.max_length = s, this.has_stree = t && t.length;
}
var GK, VK, WK;
function e1(t, e) {
  this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;
}
function qK(t) {
  return t < 256 ? Cf[t] : Cf[256 + (t >>> 7)];
}
function Af(t, e) {
  t.pending_buf[t.pending++] = e & 255, t.pending_buf[t.pending++] = e >>> 8 & 255;
}
function gr(t, e, n) {
  t.bi_valid > Xw - n ? (t.bi_buf |= e << t.bi_valid & 65535, Af(t, t.bi_buf), t.bi_buf = e >> Xw - t.bi_valid, t.bi_valid += n - Xw) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += n);
}
function ui(t, e, n) {
  gr(
    t,
    n[e * 2],
    n[e * 2 + 1]
    /*.Len*/
  );
}
function KK(t, e) {
  var n = 0;
  do
    n |= t & 1, t >>>= 1, n <<= 1;
  while (--e > 0);
  return n >>> 1;
}
function wUe(t) {
  t.bi_valid === 16 ? (Af(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = t.bi_buf & 255, t.bi_buf >>= 8, t.bi_valid -= 8);
}
function EUe(t, e) {
  var n = e.dyn_tree, r = e.max_code, s = e.stat_desc.static_tree, i = e.stat_desc.has_stree, o = e.stat_desc.extra_bits, a = e.stat_desc.extra_base, l = e.stat_desc.max_length, c, u, h, d, f, g, y = 0;
  for (d = 0; d <= Za; d++)
    t.bl_count[d] = 0;
  for (n[t.heap[t.heap_max] * 2 + 1] = 0, c = t.heap_max + 1; c < $K; c++)
    u = t.heap[c], d = n[n[u * 2 + 1] * 2 + 1] + 1, d > l && (d = l, y++), n[u * 2 + 1] = d, !(u > r) && (t.bl_count[d]++, f = 0, u >= a && (f = o[u - a]), g = n[u * 2], t.opt_len += g * (d + f), i && (t.static_len += g * (s[u * 2 + 1] + f)));
  if (y !== 0) {
    do {
      for (d = l - 1; t.bl_count[d] === 0; )
        d--;
      t.bl_count[d]--, t.bl_count[d + 1] += 2, t.bl_count[l]--, y -= 2;
    } while (y > 0);
    for (d = l; d !== 0; d--)
      for (u = t.bl_count[d]; u !== 0; )
        h = t.heap[--c], !(h > r) && (n[h * 2 + 1] !== d && (t.opt_len += (d - n[h * 2 + 1]) * n[h * 2], n[h * 2 + 1] = d), u--);
  }
}
function YK(t, e, n) {
  var r = new Array(Za + 1), s = 0, i, o;
  for (i = 1; i <= Za; i++)
    r[i] = s = s + n[i - 1] << 1;
  for (o = 0; o <= e; o++) {
    var a = t[o * 2 + 1];
    a !== 0 && (t[o * 2] = KK(r[a]++, a));
  }
}
function SUe() {
  var t, e, n, r, s, i = new Array(Za + 1);
  for (n = 0, r = 0; r < a2 - 1; r++)
    for (u2[r] = n, t = 0; t < 1 << lT[r]; t++)
      kf[n++] = r;
  for (kf[n - 1] = r, s = 0, r = 0; r < 16; r++)
    for (Vy[r] = s, t = 0; t < 1 << $g[r]; t++)
      Cf[s++] = r;
  for (s >>= 7; r < Gc; r++)
    for (Vy[r] = s << 7, t = 0; t < 1 << $g[r] - 7; t++)
      Cf[256 + s++] = r;
  for (e = 0; e <= Za; e++)
    i[e] = 0;
  for (t = 0; t <= 143; )
    ji[t * 2 + 1] = 8, t++, i[8]++;
  for (; t <= 255; )
    ji[t * 2 + 1] = 9, t++, i[9]++;
  for (; t <= 279; )
    ji[t * 2 + 1] = 7, t++, i[7]++;
  for (; t <= 287; )
    ji[t * 2 + 1] = 8, t++, i[8]++;
  for (YK(ji, Tf + 1, i), t = 0; t < Gc; t++)
    fd[t * 2 + 1] = 5, fd[t * 2] = KK(t, 5);
  GK = new Qw(ji, lT, Ap + 1, Tf, Za), VK = new Qw(fd, $g, 0, Gc, Za), WK = new Qw(new Array(0), _Ue, 0, l2, bUe);
}
function ZK(t) {
  var e;
  for (e = 0; e < Tf; e++)
    t.dyn_ltree[e * 2] = 0;
  for (e = 0; e < Gc; e++)
    t.dyn_dtree[e * 2] = 0;
  for (e = 0; e < l2; e++)
    t.bl_tree[e * 2] = 0;
  t.dyn_ltree[c2 * 2] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0;
}
function JK(t) {
  t.bi_valid > 8 ? Af(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;
}
function xUe(t, e, n, r) {
  JK(t), Af(t, n), Af(t, ~n), hUe.arraySet(t.pending_buf, t.window, e, n, t.pending), t.pending += n;
}
function UM(t, e, n, r) {
  var s = e * 2, i = n * 2;
  return t[s] < t[i] || t[s] === t[i] && r[e] <= r[n];
}
function t1(t, e, n) {
  for (var r = t.heap[n], s = n << 1; s <= t.heap_len && (s < t.heap_len && UM(e, t.heap[s + 1], t.heap[s], t.depth) && s++, !UM(e, r, t.heap[s], t.depth)); )
    t.heap[n] = t.heap[s], n = s, s <<= 1;
  t.heap[n] = r;
}
function jM(t, e, n) {
  var r, s, i = 0, o, a;
  if (t.last_lit !== 0)
    do
      r = t.pending_buf[t.d_buf + i * 2] << 8 | t.pending_buf[t.d_buf + i * 2 + 1], s = t.pending_buf[t.l_buf + i], i++, r === 0 ? ui(t, s, e) : (o = kf[s], ui(t, o + Ap + 1, e), a = lT[o], a !== 0 && (s -= u2[o], gr(t, s, a)), r--, o = qK(r), ui(t, o, n), a = $g[o], a !== 0 && (r -= Vy[o], gr(t, r, a)));
    while (i < t.last_lit);
  ui(t, c2, e);
}
function cT(t, e) {
  var n = e.dyn_tree, r = e.stat_desc.static_tree, s = e.stat_desc.has_stree, i = e.stat_desc.elems, o, a, l = -1, c;
  for (t.heap_len = 0, t.heap_max = $K, o = 0; o < i; o++)
    n[o * 2] !== 0 ? (t.heap[++t.heap_len] = l = o, t.depth[o] = 0) : n[o * 2 + 1] = 0;
  for (; t.heap_len < 2; )
    c = t.heap[++t.heap_len] = l < 2 ? ++l : 0, n[c * 2] = 1, t.depth[c] = 0, t.opt_len--, s && (t.static_len -= r[c * 2 + 1]);
  for (e.max_code = l, o = t.heap_len >> 1; o >= 1; o--)
    t1(t, n, o);
  c = i;
  do
    o = t.heap[
      1
      /*SMALLEST*/
    ], t.heap[
      1
      /*SMALLEST*/
    ] = t.heap[t.heap_len--], t1(
      t,
      n,
      1
      /*SMALLEST*/
    ), a = t.heap[
      1
      /*SMALLEST*/
    ], t.heap[--t.heap_max] = o, t.heap[--t.heap_max] = a, n[c * 2] = n[o * 2] + n[a * 2], t.depth[c] = (t.depth[o] >= t.depth[a] ? t.depth[o] : t.depth[a]) + 1, n[o * 2 + 1] = n[a * 2 + 1] = c, t.heap[
      1
      /*SMALLEST*/
    ] = c++, t1(
      t,
      n,
      1
      /*SMALLEST*/
    );
  while (t.heap_len >= 2);
  t.heap[--t.heap_max] = t.heap[
    1
    /*SMALLEST*/
  ], EUe(t, e), YK(n, l, t.bl_count);
}
function HM(t, e, n) {
  var r, s = -1, i, o = e[0 * 2 + 1], a = 0, l = 7, c = 4;
  for (o === 0 && (l = 138, c = 3), e[(n + 1) * 2 + 1] = 65535, r = 0; r <= n; r++)
    i = o, o = e[(r + 1) * 2 + 1], !(++a < l && i === o) && (a < c ? t.bl_tree[i * 2] += a : i !== 0 ? (i !== s && t.bl_tree[i * 2]++, t.bl_tree[UK * 2]++) : a <= 10 ? t.bl_tree[jK * 2]++ : t.bl_tree[HK * 2]++, a = 0, s = i, o === 0 ? (l = 138, c = 3) : i === o ? (l = 6, c = 3) : (l = 7, c = 4));
}
function zM(t, e, n) {
  var r, s = -1, i, o = e[0 * 2 + 1], a = 0, l = 7, c = 4;
  for (o === 0 && (l = 138, c = 3), r = 0; r <= n; r++)
    if (i = o, o = e[(r + 1) * 2 + 1], !(++a < l && i === o)) {
      if (a < c)
        do
          ui(t, i, t.bl_tree);
        while (--a !== 0);
      else i !== 0 ? (i !== s && (ui(t, i, t.bl_tree), a--), ui(t, UK, t.bl_tree), gr(t, a - 3, 2)) : a <= 10 ? (ui(t, jK, t.bl_tree), gr(t, a - 3, 3)) : (ui(t, HK, t.bl_tree), gr(t, a - 11, 7));
      a = 0, s = i, o === 0 ? (l = 138, c = 3) : i === o ? (l = 6, c = 3) : (l = 7, c = 4);
    }
}
function TUe(t) {
  var e;
  for (HM(t, t.dyn_ltree, t.l_desc.max_code), HM(t, t.dyn_dtree, t.d_desc.max_code), cT(t, t.bl_desc), e = l2 - 1; e >= 3 && t.bl_tree[zK[e] * 2 + 1] === 0; e--)
    ;
  return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
}
function CUe(t, e, n, r) {
  var s;
  for (gr(t, e - 257, 5), gr(t, n - 1, 5), gr(t, r - 4, 4), s = 0; s < r; s++)
    gr(t, t.bl_tree[zK[s] * 2 + 1], 3);
  zM(t, t.dyn_ltree, e - 1), zM(t, t.dyn_dtree, n - 1);
}
function kUe(t) {
  var e = 4093624447, n;
  for (n = 0; n <= 31; n++, e >>>= 1)
    if (e & 1 && t.dyn_ltree[n * 2] !== 0)
      return FM;
  if (t.dyn_ltree[9 * 2] !== 0 || t.dyn_ltree[10 * 2] !== 0 || t.dyn_ltree[13 * 2] !== 0)
    return $M;
  for (n = 32; n < Ap; n++)
    if (t.dyn_ltree[n * 2] !== 0)
      return $M;
  return FM;
}
var GM = !1;
function AUe(t) {
  GM || (SUe(), GM = !0), t.l_desc = new e1(t.dyn_ltree, GK), t.d_desc = new e1(t.dyn_dtree, VK), t.bl_desc = new e1(t.bl_tree, WK), t.bi_buf = 0, t.bi_valid = 0, ZK(t);
}
function XK(t, e, n, r) {
  gr(t, (pUe << 1) + (r ? 1 : 0), 3), xUe(t, e, n);
}
function RUe(t) {
  gr(t, FK << 1, 3), ui(t, c2, ji), wUe(t);
}
function IUe(t, e, n, r) {
  var s, i, o = 0;
  t.level > 0 ? (t.strm.data_type === fUe && (t.strm.data_type = kUe(t)), cT(t, t.l_desc), cT(t, t.d_desc), o = TUe(t), s = t.opt_len + 3 + 7 >>> 3, i = t.static_len + 3 + 7 >>> 3, i <= s && (s = i)) : s = i = n + 5, n + 4 <= s && e !== -1 ? XK(t, e, n, r) : t.strategy === dUe || i === s ? (gr(t, (FK << 1) + (r ? 1 : 0), 3), jM(t, ji, fd)) : (gr(t, (mUe << 1) + (r ? 1 : 0), 3), CUe(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), jM(t, t.dyn_ltree, t.dyn_dtree)), ZK(t), r && JK(t);
}
function PUe(t, e, n) {
  return t.pending_buf[t.d_buf + t.last_lit * 2] = e >>> 8 & 255, t.pending_buf[t.d_buf + t.last_lit * 2 + 1] = e & 255, t.pending_buf[t.l_buf + t.last_lit] = n & 255, t.last_lit++, e === 0 ? t.dyn_ltree[n * 2]++ : (t.matches++, e--, t.dyn_ltree[(kf[n] + Ap + 1) * 2]++, t.dyn_dtree[qK(e) * 2]++), t.last_lit === t.lit_bufsize - 1;
}
Wu._tr_init = AUe;
Wu._tr_stored_block = XK;
Wu._tr_flush_block = IUe;
Wu._tr_tally = PUe;
Wu._tr_align = RUe;
function OUe(t, e, n, r) {
  for (var s = t & 65535 | 0, i = t >>> 16 & 65535 | 0, o = 0; n !== 0; ) {
    o = n > 2e3 ? 2e3 : n, n -= o;
    do
      s = s + e[r++] | 0, i = i + s | 0;
    while (--o);
    s %= 65521, i %= 65521;
  }
  return s | i << 16 | 0;
}
var QK = OUe;
function DUe() {
  for (var t, e = [], n = 0; n < 256; n++) {
    t = n;
    for (var r = 0; r < 8; r++)
      t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
    e[n] = t;
  }
  return e;
}
var NUe = DUe();
function LUe(t, e, n, r) {
  var s = NUe, i = r + n;
  t ^= -1;
  for (var o = r; o < i; o++)
    t = t >>> 8 ^ s[(t ^ e[o]) & 255];
  return t ^ -1;
}
var eY = LUe, h2 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, Yn = _o, ts = Wu, tY = QK, Io = eY, MUe = h2, Hl = 0, BUe = 1, FUe = 3, Yo = 4, VM = 5, hi = 0, WM = 1, ns = -2, $Ue = -3, n1 = -5, UUe = -1, jUe = 1, Xm = 2, HUe = 3, zUe = 4, GUe = 0, VUe = 2, __ = 8, WUe = 9, qUe = 15, KUe = 8, YUe = 29, ZUe = 256, uT = ZUe + 1 + YUe, JUe = 30, XUe = 19, QUe = 2 * uT + 1, eje = 15, dt = 3, Go = 258, Ss = Go + dt + 1, tje = 32, v_ = 42, hT = 69, Ug = 73, jg = 91, Hg = 103, Ja = 113, Bh = 666, dn = 1, Rp = 2, Cl = 3, Ku = 4, nje = 3;
function Vo(t, e) {
  return t.msg = MUe[e], e;
}
function qM(t) {
  return (t << 1) - (t > 4 ? 9 : 0);
}
function $o(t) {
  for (var e = t.length; --e >= 0; )
    t[e] = 0;
}
function Po(t) {
  var e = t.state, n = e.pending;
  n > t.avail_out && (n = t.avail_out), n !== 0 && (Yn.arraySet(t.output, e.pending_buf, e.pending_out, n, t.next_out), t.next_out += n, e.pending_out += n, t.total_out += n, t.avail_out -= n, e.pending -= n, e.pending === 0 && (e.pending_out = 0));
}
function Rn(t, e) {
  ts._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, Po(t.strm);
}
function vt(t, e) {
  t.pending_buf[t.pending++] = e;
}
function yh(t, e) {
  t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = e & 255;
}
function rje(t, e, n, r) {
  var s = t.avail_in;
  return s > r && (s = r), s === 0 ? 0 : (t.avail_in -= s, Yn.arraySet(e, t.input, t.next_in, s, n), t.state.wrap === 1 ? t.adler = tY(t.adler, e, s, n) : t.state.wrap === 2 && (t.adler = Io(t.adler, e, s, n)), t.next_in += s, t.total_in += s, s);
}
function nY(t, e) {
  var n = t.max_chain_length, r = t.strstart, s, i, o = t.prev_length, a = t.nice_match, l = t.strstart > t.w_size - Ss ? t.strstart - (t.w_size - Ss) : 0, c = t.window, u = t.w_mask, h = t.prev, d = t.strstart + Go, f = c[r + o - 1], g = c[r + o];
  t.prev_length >= t.good_match && (n >>= 2), a > t.lookahead && (a = t.lookahead);
  do
    if (s = e, !(c[s + o] !== g || c[s + o - 1] !== f || c[s] !== c[r] || c[++s] !== c[r + 1])) {
      r += 2, s++;
      do
        ;
      while (c[++r] === c[++s] && c[++r] === c[++s] && c[++r] === c[++s] && c[++r] === c[++s] && c[++r] === c[++s] && c[++r] === c[++s] && c[++r] === c[++s] && c[++r] === c[++s] && r < d);
      if (i = Go - (d - r), r = d - Go, i > o) {
        if (t.match_start = e, o = i, i >= a)
          break;
        f = c[r + o - 1], g = c[r + o];
      }
    }
  while ((e = h[e & u]) > l && --n !== 0);
  return o <= t.lookahead ? o : t.lookahead;
}
function kl(t) {
  var e = t.w_size, n, r, s, i, o;
  do {
    if (i = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - Ss)) {
      Yn.arraySet(t.window, t.window, e, e, 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, r = t.hash_size, n = r;
      do
        s = t.head[--n], t.head[n] = s >= e ? s - e : 0;
      while (--r);
      r = e, n = r;
      do
        s = t.prev[--n], t.prev[n] = s >= e ? s - e : 0;
      while (--r);
      i += e;
    }
    if (t.strm.avail_in === 0)
      break;
    if (r = rje(t.strm, t.window, t.strstart + t.lookahead, i), t.lookahead += r, t.lookahead + t.insert >= dt)
      for (o = t.strstart - t.insert, t.ins_h = t.window[o], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[o + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[o + dt - 1]) & t.hash_mask, t.prev[o & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = o, o++, t.insert--, !(t.lookahead + t.insert < dt)); )
        ;
  } while (t.lookahead < Ss && t.strm.avail_in !== 0);
}
function sje(t, e) {
  var n = 65535;
  for (n > t.pending_buf_size - 5 && (n = t.pending_buf_size - 5); ; ) {
    if (t.lookahead <= 1) {
      if (kl(t), t.lookahead === 0 && e === Hl)
        return dn;
      if (t.lookahead === 0)
        break;
    }
    t.strstart += t.lookahead, t.lookahead = 0;
    var r = t.block_start + n;
    if ((t.strstart === 0 || t.strstart >= r) && (t.lookahead = t.strstart - r, t.strstart = r, Rn(t, !1), t.strm.avail_out === 0) || t.strstart - t.block_start >= t.w_size - Ss && (Rn(t, !1), t.strm.avail_out === 0))
      return dn;
  }
  return t.insert = 0, e === Yo ? (Rn(t, !0), t.strm.avail_out === 0 ? Cl : Ku) : (t.strstart > t.block_start && (Rn(t, !1), t.strm.avail_out === 0), dn);
}
function r1(t, e) {
  for (var n, r; ; ) {
    if (t.lookahead < Ss) {
      if (kl(t), t.lookahead < Ss && e === Hl)
        return dn;
      if (t.lookahead === 0)
        break;
    }
    if (n = 0, t.lookahead >= dt && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + dt - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), n !== 0 && t.strstart - n <= t.w_size - Ss && (t.match_length = nY(t, n)), t.match_length >= dt)
      if (r = ts._tr_tally(t, t.strstart - t.match_start, t.match_length - dt), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= dt) {
        t.match_length--;
        do
          t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + dt - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;
        while (--t.match_length !== 0);
        t.strstart++;
      } else
        t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
    else
      r = ts._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
    if (r && (Rn(t, !1), t.strm.avail_out === 0))
      return dn;
  }
  return t.insert = t.strstart < dt - 1 ? t.strstart : dt - 1, e === Yo ? (Rn(t, !0), t.strm.avail_out === 0 ? Cl : Ku) : t.last_lit && (Rn(t, !1), t.strm.avail_out === 0) ? dn : Rp;
}
function nc(t, e) {
  for (var n, r, s; ; ) {
    if (t.lookahead < Ss) {
      if (kl(t), t.lookahead < Ss && e === Hl)
        return dn;
      if (t.lookahead === 0)
        break;
    }
    if (n = 0, t.lookahead >= dt && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + dt - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = dt - 1, n !== 0 && t.prev_length < t.max_lazy_match && t.strstart - n <= t.w_size - Ss && (t.match_length = nY(t, n), t.match_length <= 5 && (t.strategy === jUe || t.match_length === dt && t.strstart - t.match_start > 4096) && (t.match_length = dt - 1)), t.prev_length >= dt && t.match_length <= t.prev_length) {
      s = t.strstart + t.lookahead - dt, r = ts._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - dt), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
      do
        ++t.strstart <= s && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + dt - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);
      while (--t.prev_length !== 0);
      if (t.match_available = 0, t.match_length = dt - 1, t.strstart++, r && (Rn(t, !1), t.strm.avail_out === 0))
        return dn;
    } else if (t.match_available) {
      if (r = ts._tr_tally(t, 0, t.window[t.strstart - 1]), r && Rn(t, !1), t.strstart++, t.lookahead--, t.strm.avail_out === 0)
        return dn;
    } else
      t.match_available = 1, t.strstart++, t.lookahead--;
  }
  return t.match_available && (r = ts._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < dt - 1 ? t.strstart : dt - 1, e === Yo ? (Rn(t, !0), t.strm.avail_out === 0 ? Cl : Ku) : t.last_lit && (Rn(t, !1), t.strm.avail_out === 0) ? dn : Rp;
}
function ije(t, e) {
  for (var n, r, s, i, o = t.window; ; ) {
    if (t.lookahead <= Go) {
      if (kl(t), t.lookahead <= Go && e === Hl)
        return dn;
      if (t.lookahead === 0)
        break;
    }
    if (t.match_length = 0, t.lookahead >= dt && t.strstart > 0 && (s = t.strstart - 1, r = o[s], r === o[++s] && r === o[++s] && r === o[++s])) {
      i = t.strstart + Go;
      do
        ;
      while (r === o[++s] && r === o[++s] && r === o[++s] && r === o[++s] && r === o[++s] && r === o[++s] && r === o[++s] && r === o[++s] && s < i);
      t.match_length = Go - (i - s), t.match_length > t.lookahead && (t.match_length = t.lookahead);
    }
    if (t.match_length >= dt ? (n = ts._tr_tally(t, 1, t.match_length - dt), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (n = ts._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), n && (Rn(t, !1), t.strm.avail_out === 0))
      return dn;
  }
  return t.insert = 0, e === Yo ? (Rn(t, !0), t.strm.avail_out === 0 ? Cl : Ku) : t.last_lit && (Rn(t, !1), t.strm.avail_out === 0) ? dn : Rp;
}
function oje(t, e) {
  for (var n; ; ) {
    if (t.lookahead === 0 && (kl(t), t.lookahead === 0)) {
      if (e === Hl)
        return dn;
      break;
    }
    if (t.match_length = 0, n = ts._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, n && (Rn(t, !1), t.strm.avail_out === 0))
      return dn;
  }
  return t.insert = 0, e === Yo ? (Rn(t, !0), t.strm.avail_out === 0 ? Cl : Ku) : t.last_lit && (Rn(t, !1), t.strm.avail_out === 0) ? dn : Rp;
}
function zs(t, e, n, r, s) {
  this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = r, this.func = s;
}
var Cc;
Cc = [
  /*      good lazy nice chain */
  new zs(0, 0, 0, 0, sje),
  /* 0 store only */
  new zs(4, 4, 8, 4, r1),
  /* 1 max speed, no lazy matches */
  new zs(4, 5, 16, 8, r1),
  /* 2 */
  new zs(4, 6, 32, 32, r1),
  /* 3 */
  new zs(4, 4, 16, 16, nc),
  /* 4 lazy matches */
  new zs(8, 16, 32, 32, nc),
  /* 5 */
  new zs(8, 16, 128, 128, nc),
  /* 6 */
  new zs(8, 32, 128, 256, nc),
  /* 7 */
  new zs(32, 128, 258, 1024, nc),
  /* 8 */
  new zs(32, 258, 258, 4096, nc)
  /* 9 max compression */
];
function aje(t) {
  t.window_size = 2 * t.w_size, $o(t.head), t.max_lazy_match = Cc[t.level].max_lazy, t.good_match = Cc[t.level].good_length, t.nice_match = Cc[t.level].nice_length, t.max_chain_length = Cc[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = dt - 1, t.match_available = 0, t.ins_h = 0;
}
function lje() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = __, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Yn.Buf16(QUe * 2), this.dyn_dtree = new Yn.Buf16((2 * JUe + 1) * 2), this.bl_tree = new Yn.Buf16((2 * XUe + 1) * 2), $o(this.dyn_ltree), $o(this.dyn_dtree), $o(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Yn.Buf16(eje + 1), this.heap = new Yn.Buf16(2 * uT + 1), $o(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Yn.Buf16(2 * uT + 1), $o(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
function rY(t) {
  var e;
  return !t || !t.state ? Vo(t, ns) : (t.total_in = t.total_out = 0, t.data_type = VUe, e = t.state, e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? v_ : Ja, t.adler = e.wrap === 2 ? 0 : 1, e.last_flush = Hl, ts._tr_init(e), hi);
}
function sY(t) {
  var e = rY(t);
  return e === hi && aje(t.state), e;
}
function cje(t, e) {
  return !t || !t.state || t.state.wrap !== 2 ? ns : (t.state.gzhead = e, hi);
}
function iY(t, e, n, r, s, i) {
  if (!t)
    return ns;
  var o = 1;
  if (e === UUe && (e = 6), r < 0 ? (o = 0, r = -r) : r > 15 && (o = 2, r -= 16), s < 1 || s > WUe || n !== __ || r < 8 || r > 15 || e < 0 || e > 9 || i < 0 || i > zUe)
    return Vo(t, ns);
  r === 8 && (r = 9);
  var a = new lje();
  return t.state = a, a.strm = t, a.wrap = o, a.gzhead = null, a.w_bits = r, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = s + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + dt - 1) / dt), a.window = new Yn.Buf8(a.w_size * 2), a.head = new Yn.Buf16(a.hash_size), a.prev = new Yn.Buf16(a.w_size), a.lit_bufsize = 1 << s + 6, a.pending_buf_size = a.lit_bufsize * 4, a.pending_buf = new Yn.Buf8(a.pending_buf_size), a.d_buf = 1 * a.lit_bufsize, a.l_buf = 3 * a.lit_bufsize, a.level = e, a.strategy = i, a.method = n, sY(t);
}
function uje(t, e) {
  return iY(t, e, __, qUe, KUe, GUe);
}
function hje(t, e) {
  var n, r, s, i;
  if (!t || !t.state || e > VM || e < 0)
    return t ? Vo(t, ns) : ns;
  if (r = t.state, !t.output || !t.input && t.avail_in !== 0 || r.status === Bh && e !== Yo)
    return Vo(t, t.avail_out === 0 ? n1 : ns);
  if (r.strm = t, n = r.last_flush, r.last_flush = e, r.status === v_)
    if (r.wrap === 2)
      t.adler = 0, vt(r, 31), vt(r, 139), vt(r, 8), r.gzhead ? (vt(
        r,
        (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)
      ), vt(r, r.gzhead.time & 255), vt(r, r.gzhead.time >> 8 & 255), vt(r, r.gzhead.time >> 16 & 255), vt(r, r.gzhead.time >> 24 & 255), vt(r, r.level === 9 ? 2 : r.strategy >= Xm || r.level < 2 ? 4 : 0), vt(r, r.gzhead.os & 255), r.gzhead.extra && r.gzhead.extra.length && (vt(r, r.gzhead.extra.length & 255), vt(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (t.adler = Io(t.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = hT) : (vt(r, 0), vt(r, 0), vt(r, 0), vt(r, 0), vt(r, 0), vt(r, r.level === 9 ? 2 : r.strategy >= Xm || r.level < 2 ? 4 : 0), vt(r, nje), r.status = Ja);
    else {
      var o = __ + (r.w_bits - 8 << 4) << 8, a = -1;
      r.strategy >= Xm || r.level < 2 ? a = 0 : r.level < 6 ? a = 1 : r.level === 6 ? a = 2 : a = 3, o |= a << 6, r.strstart !== 0 && (o |= tje), o += 31 - o % 31, r.status = Ja, yh(r, o), r.strstart !== 0 && (yh(r, t.adler >>> 16), yh(r, t.adler & 65535)), t.adler = 1;
    }
  if (r.status === hT)
    if (r.gzhead.extra) {
      for (s = r.pending; r.gzindex < (r.gzhead.extra.length & 65535) && !(r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > s && (t.adler = Io(t.adler, r.pending_buf, r.pending - s, s)), Po(t), s = r.pending, r.pending === r.pending_buf_size)); )
        vt(r, r.gzhead.extra[r.gzindex] & 255), r.gzindex++;
      r.gzhead.hcrc && r.pending > s && (t.adler = Io(t.adler, r.pending_buf, r.pending - s, s)), r.gzindex === r.gzhead.extra.length && (r.gzindex = 0, r.status = Ug);
    } else
      r.status = Ug;
  if (r.status === Ug)
    if (r.gzhead.name) {
      s = r.pending;
      do {
        if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > s && (t.adler = Io(t.adler, r.pending_buf, r.pending - s, s)), Po(t), s = r.pending, r.pending === r.pending_buf_size)) {
          i = 1;
          break;
        }
        r.gzindex < r.gzhead.name.length ? i = r.gzhead.name.charCodeAt(r.gzindex++) & 255 : i = 0, vt(r, i);
      } while (i !== 0);
      r.gzhead.hcrc && r.pending > s && (t.adler = Io(t.adler, r.pending_buf, r.pending - s, s)), i === 0 && (r.gzindex = 0, r.status = jg);
    } else
      r.status = jg;
  if (r.status === jg)
    if (r.gzhead.comment) {
      s = r.pending;
      do {
        if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > s && (t.adler = Io(t.adler, r.pending_buf, r.pending - s, s)), Po(t), s = r.pending, r.pending === r.pending_buf_size)) {
          i = 1;
          break;
        }
        r.gzindex < r.gzhead.comment.length ? i = r.gzhead.comment.charCodeAt(r.gzindex++) & 255 : i = 0, vt(r, i);
      } while (i !== 0);
      r.gzhead.hcrc && r.pending > s && (t.adler = Io(t.adler, r.pending_buf, r.pending - s, s)), i === 0 && (r.status = Hg);
    } else
      r.status = Hg;
  if (r.status === Hg && (r.gzhead.hcrc ? (r.pending + 2 > r.pending_buf_size && Po(t), r.pending + 2 <= r.pending_buf_size && (vt(r, t.adler & 255), vt(r, t.adler >> 8 & 255), t.adler = 0, r.status = Ja)) : r.status = Ja), r.pending !== 0) {
    if (Po(t), t.avail_out === 0)
      return r.last_flush = -1, hi;
  } else if (t.avail_in === 0 && qM(e) <= qM(n) && e !== Yo)
    return Vo(t, n1);
  if (r.status === Bh && t.avail_in !== 0)
    return Vo(t, n1);
  if (t.avail_in !== 0 || r.lookahead !== 0 || e !== Hl && r.status !== Bh) {
    var l = r.strategy === Xm ? oje(r, e) : r.strategy === HUe ? ije(r, e) : Cc[r.level].func(r, e);
    if ((l === Cl || l === Ku) && (r.status = Bh), l === dn || l === Cl)
      return t.avail_out === 0 && (r.last_flush = -1), hi;
    if (l === Rp && (e === BUe ? ts._tr_align(r) : e !== VM && (ts._tr_stored_block(r, 0, 0, !1), e === FUe && ($o(r.head), r.lookahead === 0 && (r.strstart = 0, r.block_start = 0, r.insert = 0))), Po(t), t.avail_out === 0))
      return r.last_flush = -1, hi;
  }
  return e !== Yo ? hi : r.wrap <= 0 ? WM : (r.wrap === 2 ? (vt(r, t.adler & 255), vt(r, t.adler >> 8 & 255), vt(r, t.adler >> 16 & 255), vt(r, t.adler >> 24 & 255), vt(r, t.total_in & 255), vt(r, t.total_in >> 8 & 255), vt(r, t.total_in >> 16 & 255), vt(r, t.total_in >> 24 & 255)) : (yh(r, t.adler >>> 16), yh(r, t.adler & 65535)), Po(t), r.wrap > 0 && (r.wrap = -r.wrap), r.pending !== 0 ? hi : WM);
}
function dje(t) {
  var e;
  return !t || !t.state ? ns : (e = t.state.status, e !== v_ && e !== hT && e !== Ug && e !== jg && e !== Hg && e !== Ja && e !== Bh ? Vo(t, ns) : (t.state = null, e === Ja ? Vo(t, $Ue) : hi));
}
function fje(t, e) {
  var n = e.length, r, s, i, o, a, l, c, u;
  if (!t || !t.state || (r = t.state, o = r.wrap, o === 2 || o === 1 && r.status !== v_ || r.lookahead))
    return ns;
  for (o === 1 && (t.adler = tY(t.adler, e, n, 0)), r.wrap = 0, n >= r.w_size && (o === 0 && ($o(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), u = new Yn.Buf8(r.w_size), Yn.arraySet(u, e, n - r.w_size, r.w_size, 0), e = u, n = r.w_size), a = t.avail_in, l = t.next_in, c = t.input, t.avail_in = n, t.next_in = 0, t.input = e, kl(r); r.lookahead >= dt; ) {
    s = r.strstart, i = r.lookahead - (dt - 1);
    do
      r.ins_h = (r.ins_h << r.hash_shift ^ r.window[s + dt - 1]) & r.hash_mask, r.prev[s & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = s, s++;
    while (--i);
    r.strstart = s, r.lookahead = dt - 1, kl(r);
  }
  return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = dt - 1, r.match_available = 0, t.next_in = l, t.input = c, t.avail_in = a, r.wrap = o, hi;
}
Mi.deflateInit = uje;
Mi.deflateInit2 = iY;
Mi.deflateReset = sY;
Mi.deflateResetKeep = rY;
Mi.deflateSetHeader = cje;
Mi.deflate = hje;
Mi.deflateEnd = dje;
Mi.deflateSetDictionary = fje;
Mi.deflateInfo = "pako deflate (from Nodeca project)";
var zl = {}, w_ = _o, oY = !0, aY = !0;
try {
  String.fromCharCode.apply(null, [0]);
} catch {
  oY = !1;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  aY = !1;
}
var Rf = new w_.Buf8(256);
for (var Eo = 0; Eo < 256; Eo++)
  Rf[Eo] = Eo >= 252 ? 6 : Eo >= 248 ? 5 : Eo >= 240 ? 4 : Eo >= 224 ? 3 : Eo >= 192 ? 2 : 1;
Rf[254] = Rf[254] = 1;
zl.string2buf = function(t) {
  var e, n, r, s, i, o = t.length, a = 0;
  for (s = 0; s < o; s++)
    n = t.charCodeAt(s), (n & 64512) === 55296 && s + 1 < o && (r = t.charCodeAt(s + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), s++)), a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
  for (e = new w_.Buf8(a), i = 0, s = 0; i < a; s++)
    n = t.charCodeAt(s), (n & 64512) === 55296 && s + 1 < o && (r = t.charCodeAt(s + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), s++)), n < 128 ? e[i++] = n : n < 2048 ? (e[i++] = 192 | n >>> 6, e[i++] = 128 | n & 63) : n < 65536 ? (e[i++] = 224 | n >>> 12, e[i++] = 128 | n >>> 6 & 63, e[i++] = 128 | n & 63) : (e[i++] = 240 | n >>> 18, e[i++] = 128 | n >>> 12 & 63, e[i++] = 128 | n >>> 6 & 63, e[i++] = 128 | n & 63);
  return e;
};
function lY(t, e) {
  if (e < 65534 && (t.subarray && aY || !t.subarray && oY))
    return String.fromCharCode.apply(null, w_.shrinkBuf(t, e));
  for (var n = "", r = 0; r < e; r++)
    n += String.fromCharCode(t[r]);
  return n;
}
zl.buf2binstring = function(t) {
  return lY(t, t.length);
};
zl.binstring2buf = function(t) {
  for (var e = new w_.Buf8(t.length), n = 0, r = e.length; n < r; n++)
    e[n] = t.charCodeAt(n);
  return e;
};
zl.buf2string = function(t, e) {
  var n, r, s, i, o = e || t.length, a = new Array(o * 2);
  for (r = 0, n = 0; n < o; ) {
    if (s = t[n++], s < 128) {
      a[r++] = s;
      continue;
    }
    if (i = Rf[s], i > 4) {
      a[r++] = 65533, n += i - 1;
      continue;
    }
    for (s &= i === 2 ? 31 : i === 3 ? 15 : 7; i > 1 && n < o; )
      s = s << 6 | t[n++] & 63, i--;
    if (i > 1) {
      a[r++] = 65533;
      continue;
    }
    s < 65536 ? a[r++] = s : (s -= 65536, a[r++] = 55296 | s >> 10 & 1023, a[r++] = 56320 | s & 1023);
  }
  return lY(a, r);
};
zl.utf8border = function(t, e) {
  var n;
  for (e = e || t.length, e > t.length && (e = t.length), n = e - 1; n >= 0 && (t[n] & 192) === 128; )
    n--;
  return n < 0 || n === 0 ? e : n + Rf[t[n]] > e ? n : e;
};
function pje() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var cY = pje, pd = Mi, md = _o, dT = zl, fT = h2, mje = cY, uY = Object.prototype.toString, gje = 0, s1 = 4, Vc = 0, KM = 1, YM = 2, yje = -1, bje = 0, _je = 8;
function Al(t) {
  if (!(this instanceof Al)) return new Al(t);
  this.options = md.assign({
    level: yje,
    method: _je,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: bje,
    to: ""
  }, t || {});
  var e = this.options;
  e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new mje(), this.strm.avail_out = 0;
  var n = pd.deflateInit2(
    this.strm,
    e.level,
    e.method,
    e.windowBits,
    e.memLevel,
    e.strategy
  );
  if (n !== Vc)
    throw new Error(fT[n]);
  if (e.header && pd.deflateSetHeader(this.strm, e.header), e.dictionary) {
    var r;
    if (typeof e.dictionary == "string" ? r = dT.string2buf(e.dictionary) : uY.call(e.dictionary) === "[object ArrayBuffer]" ? r = new Uint8Array(e.dictionary) : r = e.dictionary, n = pd.deflateSetDictionary(this.strm, r), n !== Vc)
      throw new Error(fT[n]);
    this._dict_set = !0;
  }
}
Al.prototype.push = function(t, e) {
  var n = this.strm, r = this.options.chunkSize, s, i;
  if (this.ended)
    return !1;
  i = e === ~~e ? e : e === !0 ? s1 : gje, typeof t == "string" ? n.input = dT.string2buf(t) : uY.call(t) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;
  do {
    if (n.avail_out === 0 && (n.output = new md.Buf8(r), n.next_out = 0, n.avail_out = r), s = pd.deflate(n, i), s !== KM && s !== Vc)
      return this.onEnd(s), this.ended = !0, !1;
    (n.avail_out === 0 || n.avail_in === 0 && (i === s1 || i === YM)) && (this.options.to === "string" ? this.onData(dT.buf2binstring(md.shrinkBuf(n.output, n.next_out))) : this.onData(md.shrinkBuf(n.output, n.next_out)));
  } while ((n.avail_in > 0 || n.avail_out === 0) && s !== KM);
  return i === s1 ? (s = pd.deflateEnd(this.strm), this.onEnd(s), this.ended = !0, s === Vc) : (i === YM && (this.onEnd(Vc), n.avail_out = 0), !0);
};
Al.prototype.onData = function(t) {
  this.chunks.push(t);
};
Al.prototype.onEnd = function(t) {
  t === Vc && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = md.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
function d2(t, e) {
  var n = new Al(e);
  if (n.push(t, !0), n.err)
    throw n.msg || fT[n.err];
  return n.result;
}
function vje(t, e) {
  return e = e || {}, e.raw = !0, d2(t, e);
}
function wje(t, e) {
  return e = e || {}, e.gzip = !0, d2(t, e);
}
kp.Deflate = Al;
kp.deflate = d2;
kp.deflateRaw = vje;
kp.gzip = wje;
var Ip = {}, Ns = {}, Qm = 30, Eje = 12, Sje = function(e, n) {
  var r, s, i, o, a, l, c, u, h, d, f, g, y, p, m, b, _, v, w, E, x, S, T, R, F;
  r = e.state, s = e.next_in, R = e.input, i = s + (e.avail_in - 5), o = e.next_out, F = e.output, a = o - (n - e.avail_out), l = o + (e.avail_out - 257), c = r.dmax, u = r.wsize, h = r.whave, d = r.wnext, f = r.window, g = r.hold, y = r.bits, p = r.lencode, m = r.distcode, b = (1 << r.lenbits) - 1, _ = (1 << r.distbits) - 1;
  e:
    do {
      y < 15 && (g += R[s++] << y, y += 8, g += R[s++] << y, y += 8), v = p[g & b];
      t:
        for (; ; ) {
          if (w = v >>> 24, g >>>= w, y -= w, w = v >>> 16 & 255, w === 0)
            F[o++] = v & 65535;
          else if (w & 16) {
            E = v & 65535, w &= 15, w && (y < w && (g += R[s++] << y, y += 8), E += g & (1 << w) - 1, g >>>= w, y -= w), y < 15 && (g += R[s++] << y, y += 8, g += R[s++] << y, y += 8), v = m[g & _];
            n:
              for (; ; ) {
                if (w = v >>> 24, g >>>= w, y -= w, w = v >>> 16 & 255, w & 16) {
                  if (x = v & 65535, w &= 15, y < w && (g += R[s++] << y, y += 8, y < w && (g += R[s++] << y, y += 8)), x += g & (1 << w) - 1, x > c) {
                    e.msg = "invalid distance too far back", r.mode = Qm;
                    break e;
                  }
                  if (g >>>= w, y -= w, w = o - a, x > w) {
                    if (w = x - w, w > h && r.sane) {
                      e.msg = "invalid distance too far back", r.mode = Qm;
                      break e;
                    }
                    if (S = 0, T = f, d === 0) {
                      if (S += u - w, w < E) {
                        E -= w;
                        do
                          F[o++] = f[S++];
                        while (--w);
                        S = o - x, T = F;
                      }
                    } else if (d < w) {
                      if (S += u + d - w, w -= d, w < E) {
                        E -= w;
                        do
                          F[o++] = f[S++];
                        while (--w);
                        if (S = 0, d < E) {
                          w = d, E -= w;
                          do
                            F[o++] = f[S++];
                          while (--w);
                          S = o - x, T = F;
                        }
                      }
                    } else if (S += d - w, w < E) {
                      E -= w;
                      do
                        F[o++] = f[S++];
                      while (--w);
                      S = o - x, T = F;
                    }
                    for (; E > 2; )
                      F[o++] = T[S++], F[o++] = T[S++], F[o++] = T[S++], E -= 3;
                    E && (F[o++] = T[S++], E > 1 && (F[o++] = T[S++]));
                  } else {
                    S = o - x;
                    do
                      F[o++] = F[S++], F[o++] = F[S++], F[o++] = F[S++], E -= 3;
                    while (E > 2);
                    E && (F[o++] = F[S++], E > 1 && (F[o++] = F[S++]));
                  }
                } else if (w & 64) {
                  e.msg = "invalid distance code", r.mode = Qm;
                  break e;
                } else {
                  v = m[(v & 65535) + (g & (1 << w) - 1)];
                  continue n;
                }
                break;
              }
          } else if (w & 64)
            if (w & 32) {
              r.mode = Eje;
              break e;
            } else {
              e.msg = "invalid literal/length code", r.mode = Qm;
              break e;
            }
          else {
            v = p[(v & 65535) + (g & (1 << w) - 1)];
            continue t;
          }
          break;
        }
    } while (s < i && o < l);
  E = y >> 3, s -= E, y -= E << 3, g &= (1 << y) - 1, e.next_in = s, e.next_out = o, e.avail_in = s < i ? 5 + (i - s) : 5 - (s - i), e.avail_out = o < l ? 257 + (l - o) : 257 - (o - l), r.hold = g, r.bits = y;
}, ZM = _o, rc = 15, JM = 852, XM = 592, QM = 0, i1 = 1, e3 = 2, xje = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
], Tje = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
], Cje = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
], kje = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
], Aje = function(e, n, r, s, i, o, a, l) {
  var c = l.bits, u = 0, h = 0, d = 0, f = 0, g = 0, y = 0, p = 0, m = 0, b = 0, _ = 0, v, w, E, x, S, T = null, R = 0, F, P = new ZM.Buf16(rc + 1), M = new ZM.Buf16(rc + 1), A = null, V = 0, ee, K, te;
  for (u = 0; u <= rc; u++)
    P[u] = 0;
  for (h = 0; h < s; h++)
    P[n[r + h]]++;
  for (g = c, f = rc; f >= 1 && P[f] === 0; f--)
    ;
  if (g > f && (g = f), f === 0)
    return i[o++] = 1 << 24 | 64 << 16 | 0, i[o++] = 1 << 24 | 64 << 16 | 0, l.bits = 1, 0;
  for (d = 1; d < f && P[d] === 0; d++)
    ;
  for (g < d && (g = d), m = 1, u = 1; u <= rc; u++)
    if (m <<= 1, m -= P[u], m < 0)
      return -1;
  if (m > 0 && (e === QM || f !== 1))
    return -1;
  for (M[1] = 0, u = 1; u < rc; u++)
    M[u + 1] = M[u] + P[u];
  for (h = 0; h < s; h++)
    n[r + h] !== 0 && (a[M[n[r + h]]++] = h);
  if (e === QM ? (T = A = a, F = 19) : e === i1 ? (T = xje, R -= 257, A = Tje, V -= 257, F = 256) : (T = Cje, A = kje, F = -1), _ = 0, h = 0, u = d, S = o, y = g, p = 0, E = -1, b = 1 << g, x = b - 1, e === i1 && b > JM || e === e3 && b > XM)
    return 1;
  for (; ; ) {
    ee = u - p, a[h] < F ? (K = 0, te = a[h]) : a[h] > F ? (K = A[V + a[h]], te = T[R + a[h]]) : (K = 96, te = 0), v = 1 << u - p, w = 1 << y, d = w;
    do
      w -= v, i[S + (_ >> p) + w] = ee << 24 | K << 16 | te | 0;
    while (w !== 0);
    for (v = 1 << u - 1; _ & v; )
      v >>= 1;
    if (v !== 0 ? (_ &= v - 1, _ += v) : _ = 0, h++, --P[u] === 0) {
      if (u === f)
        break;
      u = n[r + a[h]];
    }
    if (u > g && (_ & x) !== E) {
      for (p === 0 && (p = g), S += d, y = u - p, m = 1 << y; y + p < f && (m -= P[y + p], !(m <= 0)); )
        y++, m <<= 1;
      if (b += 1 << y, e === i1 && b > JM || e === e3 && b > XM)
        return 1;
      E = _ & x, i[E] = g << 24 | y << 16 | S - o | 0;
    }
  }
  return _ !== 0 && (i[S + _] = u - p << 24 | 64 << 16 | 0), l.bits = g, 0;
}, Dr = _o, pT = QK, Gs = eY, Rje = Sje, gd = Aje, Ije = 0, hY = 1, dY = 2, t3 = 4, Pje = 5, eg = 6, Rl = 0, Oje = 1, Dje = 2, as = -2, fY = -3, pY = -4, Nje = -5, n3 = 8, mY = 1, r3 = 2, s3 = 3, i3 = 4, o3 = 5, a3 = 6, l3 = 7, c3 = 8, u3 = 9, h3 = 10, Wy = 11, Bi = 12, o1 = 13, d3 = 14, a1 = 15, f3 = 16, p3 = 17, m3 = 18, g3 = 19, tg = 20, ng = 21, y3 = 22, b3 = 23, _3 = 24, v3 = 25, w3 = 26, l1 = 27, E3 = 28, S3 = 29, Ft = 30, gY = 31, Lje = 32, Mje = 852, Bje = 592, Fje = 15, $je = Fje;
function x3(t) {
  return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((t & 65280) << 8) + ((t & 255) << 24);
}
function Uje() {
  this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Dr.Buf16(320), this.work = new Dr.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
function yY(t) {
  var e;
  return !t || !t.state ? as : (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = e.wrap & 1), e.mode = mY, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Dr.Buf32(Mje), e.distcode = e.distdyn = new Dr.Buf32(Bje), e.sane = 1, e.back = -1, Rl);
}
function bY(t) {
  var e;
  return !t || !t.state ? as : (e = t.state, e.wsize = 0, e.whave = 0, e.wnext = 0, yY(t));
}
function _Y(t, e) {
  var n, r;
  return !t || !t.state || (r = t.state, e < 0 ? (n = 0, e = -e) : (n = (e >> 4) + 1, e < 48 && (e &= 15)), e && (e < 8 || e > 15)) ? as : (r.window !== null && r.wbits !== e && (r.window = null), r.wrap = n, r.wbits = e, bY(t));
}
function vY(t, e) {
  var n, r;
  return t ? (r = new Uje(), t.state = r, r.window = null, n = _Y(t, e), n !== Rl && (t.state = null), n) : as;
}
function jje(t) {
  return vY(t, $je);
}
var T3 = !0, c1, u1;
function Hje(t) {
  if (T3) {
    var e;
    for (c1 = new Dr.Buf32(512), u1 = new Dr.Buf32(32), e = 0; e < 144; )
      t.lens[e++] = 8;
    for (; e < 256; )
      t.lens[e++] = 9;
    for (; e < 280; )
      t.lens[e++] = 7;
    for (; e < 288; )
      t.lens[e++] = 8;
    for (gd(hY, t.lens, 0, 288, c1, 0, t.work, { bits: 9 }), e = 0; e < 32; )
      t.lens[e++] = 5;
    gd(dY, t.lens, 0, 32, u1, 0, t.work, { bits: 5 }), T3 = !1;
  }
  t.lencode = c1, t.lenbits = 9, t.distcode = u1, t.distbits = 5;
}
function wY(t, e, n, r) {
  var s, i = t.state;
  return i.window === null && (i.wsize = 1 << i.wbits, i.wnext = 0, i.whave = 0, i.window = new Dr.Buf8(i.wsize)), r >= i.wsize ? (Dr.arraySet(i.window, e, n - i.wsize, i.wsize, 0), i.wnext = 0, i.whave = i.wsize) : (s = i.wsize - i.wnext, s > r && (s = r), Dr.arraySet(i.window, e, n - r, s, i.wnext), r -= s, r ? (Dr.arraySet(i.window, e, n - r, r, 0), i.wnext = r, i.whave = i.wsize) : (i.wnext += s, i.wnext === i.wsize && (i.wnext = 0), i.whave < i.wsize && (i.whave += s))), 0;
}
function zje(t, e) {
  var n, r, s, i, o, a, l, c, u, h, d, f, g, y, p = 0, m, b, _, v, w, E, x, S, T = new Dr.Buf8(4), R, F, P = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!t || !t.state || !t.output || !t.input && t.avail_in !== 0)
    return as;
  n = t.state, n.mode === Bi && (n.mode = o1), o = t.next_out, s = t.output, l = t.avail_out, i = t.next_in, r = t.input, a = t.avail_in, c = n.hold, u = n.bits, h = a, d = l, S = Rl;
  e:
    for (; ; )
      switch (n.mode) {
        case mY:
          if (n.wrap === 0) {
            n.mode = o1;
            break;
          }
          for (; u < 16; ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          if (n.wrap & 2 && c === 35615) {
            n.check = 0, T[0] = c & 255, T[1] = c >>> 8 & 255, n.check = Gs(n.check, T, 2, 0), c = 0, u = 0, n.mode = r3;
            break;
          }
          if (n.flags = 0, n.head && (n.head.done = !1), !(n.wrap & 1) || /* check if zlib header allowed */
          (((c & 255) << 8) + (c >> 8)) % 31) {
            t.msg = "incorrect header check", n.mode = Ft;
            break;
          }
          if ((c & 15) !== n3) {
            t.msg = "unknown compression method", n.mode = Ft;
            break;
          }
          if (c >>>= 4, u -= 4, x = (c & 15) + 8, n.wbits === 0)
            n.wbits = x;
          else if (x > n.wbits) {
            t.msg = "invalid window size", n.mode = Ft;
            break;
          }
          n.dmax = 1 << x, t.adler = n.check = 1, n.mode = c & 512 ? h3 : Bi, c = 0, u = 0;
          break;
        case r3:
          for (; u < 16; ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          if (n.flags = c, (n.flags & 255) !== n3) {
            t.msg = "unknown compression method", n.mode = Ft;
            break;
          }
          if (n.flags & 57344) {
            t.msg = "unknown header flags set", n.mode = Ft;
            break;
          }
          n.head && (n.head.text = c >> 8 & 1), n.flags & 512 && (T[0] = c & 255, T[1] = c >>> 8 & 255, n.check = Gs(n.check, T, 2, 0)), c = 0, u = 0, n.mode = s3;
        case s3:
          for (; u < 32; ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          n.head && (n.head.time = c), n.flags & 512 && (T[0] = c & 255, T[1] = c >>> 8 & 255, T[2] = c >>> 16 & 255, T[3] = c >>> 24 & 255, n.check = Gs(n.check, T, 4, 0)), c = 0, u = 0, n.mode = i3;
        case i3:
          for (; u < 16; ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          n.head && (n.head.xflags = c & 255, n.head.os = c >> 8), n.flags & 512 && (T[0] = c & 255, T[1] = c >>> 8 & 255, n.check = Gs(n.check, T, 2, 0)), c = 0, u = 0, n.mode = o3;
        case o3:
          if (n.flags & 1024) {
            for (; u < 16; ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            n.length = c, n.head && (n.head.extra_len = c), n.flags & 512 && (T[0] = c & 255, T[1] = c >>> 8 & 255, n.check = Gs(n.check, T, 2, 0)), c = 0, u = 0;
          } else n.head && (n.head.extra = null);
          n.mode = a3;
        case a3:
          if (n.flags & 1024 && (f = n.length, f > a && (f = a), f && (n.head && (x = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Array(n.head.extra_len)), Dr.arraySet(
            n.head.extra,
            r,
            i,
            // extra field is limited to 65536 bytes
            // - no need for additional size check
            f,
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            x
          )), n.flags & 512 && (n.check = Gs(n.check, r, f, i)), a -= f, i += f, n.length -= f), n.length))
            break e;
          n.length = 0, n.mode = l3;
        case l3:
          if (n.flags & 2048) {
            if (a === 0)
              break e;
            f = 0;
            do
              x = r[i + f++], n.head && x && n.length < 65536 && (n.head.name += String.fromCharCode(x));
            while (x && f < a);
            if (n.flags & 512 && (n.check = Gs(n.check, r, f, i)), a -= f, i += f, x)
              break e;
          } else n.head && (n.head.name = null);
          n.length = 0, n.mode = c3;
        case c3:
          if (n.flags & 4096) {
            if (a === 0)
              break e;
            f = 0;
            do
              x = r[i + f++], n.head && x && n.length < 65536 && (n.head.comment += String.fromCharCode(x));
            while (x && f < a);
            if (n.flags & 512 && (n.check = Gs(n.check, r, f, i)), a -= f, i += f, x)
              break e;
          } else n.head && (n.head.comment = null);
          n.mode = u3;
        case u3:
          if (n.flags & 512) {
            for (; u < 16; ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            if (c !== (n.check & 65535)) {
              t.msg = "header crc mismatch", n.mode = Ft;
              break;
            }
            c = 0, u = 0;
          }
          n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), t.adler = n.check = 0, n.mode = Bi;
          break;
        case h3:
          for (; u < 32; ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          t.adler = n.check = x3(c), c = 0, u = 0, n.mode = Wy;
        case Wy:
          if (n.havedict === 0)
            return t.next_out = o, t.avail_out = l, t.next_in = i, t.avail_in = a, n.hold = c, n.bits = u, Dje;
          t.adler = n.check = 1, n.mode = Bi;
        case Bi:
          if (e === Pje || e === eg)
            break e;
        case o1:
          if (n.last) {
            c >>>= u & 7, u -= u & 7, n.mode = l1;
            break;
          }
          for (; u < 3; ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          switch (n.last = c & 1, c >>>= 1, u -= 1, c & 3) {
            case 0:
              n.mode = d3;
              break;
            case 1:
              if (Hje(n), n.mode = tg, e === eg) {
                c >>>= 2, u -= 2;
                break e;
              }
              break;
            case 2:
              n.mode = p3;
              break;
            case 3:
              t.msg = "invalid block type", n.mode = Ft;
          }
          c >>>= 2, u -= 2;
          break;
        case d3:
          for (c >>>= u & 7, u -= u & 7; u < 32; ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          if ((c & 65535) !== (c >>> 16 ^ 65535)) {
            t.msg = "invalid stored block lengths", n.mode = Ft;
            break;
          }
          if (n.length = c & 65535, c = 0, u = 0, n.mode = a1, e === eg)
            break e;
        case a1:
          n.mode = f3;
        case f3:
          if (f = n.length, f) {
            if (f > a && (f = a), f > l && (f = l), f === 0)
              break e;
            Dr.arraySet(s, r, i, f, o), a -= f, i += f, l -= f, o += f, n.length -= f;
            break;
          }
          n.mode = Bi;
          break;
        case p3:
          for (; u < 14; ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          if (n.nlen = (c & 31) + 257, c >>>= 5, u -= 5, n.ndist = (c & 31) + 1, c >>>= 5, u -= 5, n.ncode = (c & 15) + 4, c >>>= 4, u -= 4, n.nlen > 286 || n.ndist > 30) {
            t.msg = "too many length or distance symbols", n.mode = Ft;
            break;
          }
          n.have = 0, n.mode = m3;
        case m3:
          for (; n.have < n.ncode; ) {
            for (; u < 3; ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            n.lens[P[n.have++]] = c & 7, c >>>= 3, u -= 3;
          }
          for (; n.have < 19; )
            n.lens[P[n.have++]] = 0;
          if (n.lencode = n.lendyn, n.lenbits = 7, R = { bits: n.lenbits }, S = gd(Ije, n.lens, 0, 19, n.lencode, 0, n.work, R), n.lenbits = R.bits, S) {
            t.msg = "invalid code lengths set", n.mode = Ft;
            break;
          }
          n.have = 0, n.mode = g3;
        case g3:
          for (; n.have < n.nlen + n.ndist; ) {
            for (; p = n.lencode[c & (1 << n.lenbits) - 1], m = p >>> 24, b = p >>> 16 & 255, _ = p & 65535, !(m <= u); ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            if (_ < 16)
              c >>>= m, u -= m, n.lens[n.have++] = _;
            else {
              if (_ === 16) {
                for (F = m + 2; u < F; ) {
                  if (a === 0)
                    break e;
                  a--, c += r[i++] << u, u += 8;
                }
                if (c >>>= m, u -= m, n.have === 0) {
                  t.msg = "invalid bit length repeat", n.mode = Ft;
                  break;
                }
                x = n.lens[n.have - 1], f = 3 + (c & 3), c >>>= 2, u -= 2;
              } else if (_ === 17) {
                for (F = m + 3; u < F; ) {
                  if (a === 0)
                    break e;
                  a--, c += r[i++] << u, u += 8;
                }
                c >>>= m, u -= m, x = 0, f = 3 + (c & 7), c >>>= 3, u -= 3;
              } else {
                for (F = m + 7; u < F; ) {
                  if (a === 0)
                    break e;
                  a--, c += r[i++] << u, u += 8;
                }
                c >>>= m, u -= m, x = 0, f = 11 + (c & 127), c >>>= 7, u -= 7;
              }
              if (n.have + f > n.nlen + n.ndist) {
                t.msg = "invalid bit length repeat", n.mode = Ft;
                break;
              }
              for (; f--; )
                n.lens[n.have++] = x;
            }
          }
          if (n.mode === Ft)
            break;
          if (n.lens[256] === 0) {
            t.msg = "invalid code -- missing end-of-block", n.mode = Ft;
            break;
          }
          if (n.lenbits = 9, R = { bits: n.lenbits }, S = gd(hY, n.lens, 0, n.nlen, n.lencode, 0, n.work, R), n.lenbits = R.bits, S) {
            t.msg = "invalid literal/lengths set", n.mode = Ft;
            break;
          }
          if (n.distbits = 6, n.distcode = n.distdyn, R = { bits: n.distbits }, S = gd(dY, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, R), n.distbits = R.bits, S) {
            t.msg = "invalid distances set", n.mode = Ft;
            break;
          }
          if (n.mode = tg, e === eg)
            break e;
        case tg:
          n.mode = ng;
        case ng:
          if (a >= 6 && l >= 258) {
            t.next_out = o, t.avail_out = l, t.next_in = i, t.avail_in = a, n.hold = c, n.bits = u, Rje(t, d), o = t.next_out, s = t.output, l = t.avail_out, i = t.next_in, r = t.input, a = t.avail_in, c = n.hold, u = n.bits, n.mode === Bi && (n.back = -1);
            break;
          }
          for (n.back = 0; p = n.lencode[c & (1 << n.lenbits) - 1], m = p >>> 24, b = p >>> 16 & 255, _ = p & 65535, !(m <= u); ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          if (b && !(b & 240)) {
            for (v = m, w = b, E = _; p = n.lencode[E + ((c & (1 << v + w) - 1) >> v)], m = p >>> 24, b = p >>> 16 & 255, _ = p & 65535, !(v + m <= u); ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            c >>>= v, u -= v, n.back += v;
          }
          if (c >>>= m, u -= m, n.back += m, n.length = _, b === 0) {
            n.mode = w3;
            break;
          }
          if (b & 32) {
            n.back = -1, n.mode = Bi;
            break;
          }
          if (b & 64) {
            t.msg = "invalid literal/length code", n.mode = Ft;
            break;
          }
          n.extra = b & 15, n.mode = y3;
        case y3:
          if (n.extra) {
            for (F = n.extra; u < F; ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            n.length += c & (1 << n.extra) - 1, c >>>= n.extra, u -= n.extra, n.back += n.extra;
          }
          n.was = n.length, n.mode = b3;
        case b3:
          for (; p = n.distcode[c & (1 << n.distbits) - 1], m = p >>> 24, b = p >>> 16 & 255, _ = p & 65535, !(m <= u); ) {
            if (a === 0)
              break e;
            a--, c += r[i++] << u, u += 8;
          }
          if (!(b & 240)) {
            for (v = m, w = b, E = _; p = n.distcode[E + ((c & (1 << v + w) - 1) >> v)], m = p >>> 24, b = p >>> 16 & 255, _ = p & 65535, !(v + m <= u); ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            c >>>= v, u -= v, n.back += v;
          }
          if (c >>>= m, u -= m, n.back += m, b & 64) {
            t.msg = "invalid distance code", n.mode = Ft;
            break;
          }
          n.offset = _, n.extra = b & 15, n.mode = _3;
        case _3:
          if (n.extra) {
            for (F = n.extra; u < F; ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            n.offset += c & (1 << n.extra) - 1, c >>>= n.extra, u -= n.extra, n.back += n.extra;
          }
          if (n.offset > n.dmax) {
            t.msg = "invalid distance too far back", n.mode = Ft;
            break;
          }
          n.mode = v3;
        case v3:
          if (l === 0)
            break e;
          if (f = d - l, n.offset > f) {
            if (f = n.offset - f, f > n.whave && n.sane) {
              t.msg = "invalid distance too far back", n.mode = Ft;
              break;
            }
            f > n.wnext ? (f -= n.wnext, g = n.wsize - f) : g = n.wnext - f, f > n.length && (f = n.length), y = n.window;
          } else
            y = s, g = o - n.offset, f = n.length;
          f > l && (f = l), l -= f, n.length -= f;
          do
            s[o++] = y[g++];
          while (--f);
          n.length === 0 && (n.mode = ng);
          break;
        case w3:
          if (l === 0)
            break e;
          s[o++] = n.length, l--, n.mode = ng;
          break;
        case l1:
          if (n.wrap) {
            for (; u < 32; ) {
              if (a === 0)
                break e;
              a--, c |= r[i++] << u, u += 8;
            }
            if (d -= l, t.total_out += d, n.total += d, d && (t.adler = n.check = /*UPDATE(state.check, put - _out, _out);*/
            n.flags ? Gs(n.check, s, d, o - d) : pT(n.check, s, d, o - d)), d = l, (n.flags ? c : x3(c)) !== n.check) {
              t.msg = "incorrect data check", n.mode = Ft;
              break;
            }
            c = 0, u = 0;
          }
          n.mode = E3;
        case E3:
          if (n.wrap && n.flags) {
            for (; u < 32; ) {
              if (a === 0)
                break e;
              a--, c += r[i++] << u, u += 8;
            }
            if (c !== (n.total & 4294967295)) {
              t.msg = "incorrect length check", n.mode = Ft;
              break;
            }
            c = 0, u = 0;
          }
          n.mode = S3;
        case S3:
          S = Oje;
          break e;
        case Ft:
          S = fY;
          break e;
        case gY:
          return pY;
        case Lje:
        default:
          return as;
      }
  return t.next_out = o, t.avail_out = l, t.next_in = i, t.avail_in = a, n.hold = c, n.bits = u, (n.wsize || d !== t.avail_out && n.mode < Ft && (n.mode < l1 || e !== t3)) && wY(t, t.output, t.next_out, d - t.avail_out), h -= t.avail_in, d -= t.avail_out, t.total_in += h, t.total_out += d, n.total += d, n.wrap && d && (t.adler = n.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
  n.flags ? Gs(n.check, s, d, t.next_out - d) : pT(n.check, s, d, t.next_out - d)), t.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === Bi ? 128 : 0) + (n.mode === tg || n.mode === a1 ? 256 : 0), (h === 0 && d === 0 || e === t3) && S === Rl && (S = Nje), S;
}
function Gje(t) {
  if (!t || !t.state)
    return as;
  var e = t.state;
  return e.window && (e.window = null), t.state = null, Rl;
}
function Vje(t, e) {
  var n;
  return !t || !t.state || (n = t.state, !(n.wrap & 2)) ? as : (n.head = e, e.done = !1, Rl);
}
function Wje(t, e) {
  var n = e.length, r, s, i;
  return !t || !t.state || (r = t.state, r.wrap !== 0 && r.mode !== Wy) ? as : r.mode === Wy && (s = 1, s = pT(s, e, n, 0), s !== r.check) ? fY : (i = wY(t, e, n, n), i ? (r.mode = gY, pY) : (r.havedict = 1, Rl));
}
Ns.inflateReset = bY;
Ns.inflateReset2 = _Y;
Ns.inflateResetKeep = yY;
Ns.inflateInit = jje;
Ns.inflateInit2 = vY;
Ns.inflate = zje;
Ns.inflateEnd = Gje;
Ns.inflateGetHeader = Vje;
Ns.inflateSetDictionary = Wje;
Ns.inflateInfo = "pako inflate (from Nodeca project)";
var EY = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
function qje() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var Kje = qje, Wc = Ns, yd = _o, zg = zl, Jt = EY, mT = h2, Yje = cY, Zje = Kje, SY = Object.prototype.toString;
function Il(t) {
  if (!(this instanceof Il)) return new Il(t);
  this.options = yd.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, t || {});
  var e = this.options;
  e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(t && t.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15 || (e.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Yje(), this.strm.avail_out = 0;
  var n = Wc.inflateInit2(
    this.strm,
    e.windowBits
  );
  if (n !== Jt.Z_OK)
    throw new Error(mT[n]);
  if (this.header = new Zje(), Wc.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = zg.string2buf(e.dictionary) : SY.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (n = Wc.inflateSetDictionary(this.strm, e.dictionary), n !== Jt.Z_OK)))
    throw new Error(mT[n]);
}
Il.prototype.push = function(t, e) {
  var n = this.strm, r = this.options.chunkSize, s = this.options.dictionary, i, o, a, l, c, u = !1;
  if (this.ended)
    return !1;
  o = e === ~~e ? e : e === !0 ? Jt.Z_FINISH : Jt.Z_NO_FLUSH, typeof t == "string" ? n.input = zg.binstring2buf(t) : SY.call(t) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;
  do {
    if (n.avail_out === 0 && (n.output = new yd.Buf8(r), n.next_out = 0, n.avail_out = r), i = Wc.inflate(n, Jt.Z_NO_FLUSH), i === Jt.Z_NEED_DICT && s && (i = Wc.inflateSetDictionary(this.strm, s)), i === Jt.Z_BUF_ERROR && u === !0 && (i = Jt.Z_OK, u = !1), i !== Jt.Z_STREAM_END && i !== Jt.Z_OK)
      return this.onEnd(i), this.ended = !0, !1;
    n.next_out && (n.avail_out === 0 || i === Jt.Z_STREAM_END || n.avail_in === 0 && (o === Jt.Z_FINISH || o === Jt.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (a = zg.utf8border(n.output, n.next_out), l = n.next_out - a, c = zg.buf2string(n.output, a), n.next_out = l, n.avail_out = r - l, l && yd.arraySet(n.output, n.output, a, l, 0), this.onData(c)) : this.onData(yd.shrinkBuf(n.output, n.next_out))), n.avail_in === 0 && n.avail_out === 0 && (u = !0);
  } while ((n.avail_in > 0 || n.avail_out === 0) && i !== Jt.Z_STREAM_END);
  return i === Jt.Z_STREAM_END && (o = Jt.Z_FINISH), o === Jt.Z_FINISH ? (i = Wc.inflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === Jt.Z_OK) : (o === Jt.Z_SYNC_FLUSH && (this.onEnd(Jt.Z_OK), n.avail_out = 0), !0);
};
Il.prototype.onData = function(t) {
  this.chunks.push(t);
};
Il.prototype.onEnd = function(t) {
  t === Jt.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = yd.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
function f2(t, e) {
  var n = new Il(e);
  if (n.push(t, !0), n.err)
    throw n.msg || mT[n.err];
  return n.result;
}
function Jje(t, e) {
  return e = e || {}, e.raw = !0, f2(t, e);
}
Ip.Inflate = Il;
Ip.inflate = f2;
Ip.inflateRaw = Jje;
Ip.ungzip = f2;
var Xje = _o.assign, Qje = kp, eHe = Ip, tHe = EY, xY = {};
Xje(xY, Qje, eHe, tHe);
var nHe = xY;
const TY = /* @__PURE__ */ Is(nHe), C3 = (t, e) => function(...n) {
  const r = e.promiseModule;
  return new r((s, i) => {
    e.multiArgs ? n.push((...o) => {
      e.errorFirst ? o[0] ? i(o) : (o.shift(), s(o)) : s(o);
    }) : e.errorFirst ? n.push((o, a) => {
      o ? i(o) : s(a);
    }) : n.push(s), t.apply(this, n);
  });
};
var rHe = (t, e) => {
  e = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise
  }, e);
  const n = typeof t;
  if (!(t !== null && (n === "object" || n === "function")))
    throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${t === null ? "null" : n}\``);
  const r = (i) => {
    const o = (a) => typeof a == "string" ? i === a : a.test(i);
    return e.include ? e.include.some(o) : !e.exclude.some(o);
  };
  let s;
  n === "function" ? s = function(...i) {
    return e.excludeMain ? t(...i) : C3(t, e).apply(this, i);
  } : s = Object.create(Object.getPrototypeOf(t));
  for (const i in t) {
    const o = t[i];
    s[i] = typeof o == "function" && r(i) ? C3(o, e) : o;
  }
  return s;
};
const h1 = /* @__PURE__ */ Is(rHe);
function k3(t) {
  return Array.isArray(t) ? t : [t];
}
const gT = "", A3 = " ", d1 = "\\", sHe = /^\s+$/, iHe = /(?:[^\\]|^)\\$/, oHe = /^\\!/, aHe = /^\\#/, lHe = /\r?\n/g, cHe = /^\.*\/|^\.+$/, f1 = "/";
let CY = "node-ignore";
typeof Symbol < "u" && (CY = Symbol.for("node-ignore"));
const R3 = CY, uHe = (t, e, n) => Object.defineProperty(t, e, { value: n }), hHe = /([0-z])-([0-z])/g, kY = () => !1, dHe = (t) => t.replace(
  hHe,
  (e, n, r) => n.charCodeAt(0) <= r.charCodeAt(0) ? e : gT
), fHe = (t) => {
  const { length: e } = t;
  return t.slice(0, e - e % 2);
}, pHe = [
  [
    // remove BOM
    // TODO:
    // Other similar zero-width characters?
    /^\uFEFF/,
    () => gT
  ],
  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a ) -> (a)
    // (a \ ) -> (a  )
    /((?:\\\\)*?)(\\?\s+)$/,
    (t, e, n) => e + (n.indexOf("\\") === 0 ? A3 : gT)
  ],
  // replace (\ ) with ' '
  // (\ ) -> ' '
  // (\\ ) -> '\\ '
  // (\\\ ) -> '\\ '
  [
    /(\\+?)\s/g,
    (t, e) => {
      const { length: n } = e;
      return e.slice(0, n - n % 2) + A3;
    }
  ],
  // Escape metacharacters
  // which is written down by users but means special for regular expressions.
  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    (t) => `\\${t}`
  ],
  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => "[^/]"
  ],
  // leading slash
  [
    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => "^"
  ],
  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => "\\/"
  ],
  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,
    // '**/foo' <-> 'foo'
    () => "^(?:.*\\/)?"
  ],
  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function() {
      return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
    }
  ],
  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,
    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer
    // Check if it is not the last `'/**'`
    (t, e, n) => e + 6 < n.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
  ],
  // normal intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'
    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule,
    //    coz trailing single wildcard will be handed by [trailing wildcard]
    /(^|[^\\]+)(\\\*)+(?=.+)/g,
    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (t, e, n) => {
      const r = n.replace(/\\\*/g, "[^\\/]*");
      return e + r;
    }
  ],
  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => d1
  ],
  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => d1
  ],
  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.
    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (t, e, n, r, s) => e === d1 ? `\\[${n}${fHe(r)}${s}` : s === "]" && r.length % 2 === 0 ? `[${dHe(n)}${r}]` : "[]"
  ],
  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,
    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38
    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.
    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    (t) => /\/$/.test(t) ? `${t}$` : `${t}(?=$|\\/$)`
  ],
  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (t, e) => `${e ? `${e}[^/]+` : "[^/]*"}(?=$|\\/$)`
  ]
], I3 = /* @__PURE__ */ Object.create(null), mHe = (t, e) => {
  let n = I3[t];
  return n || (n = pHe.reduce(
    (r, [s, i]) => r.replace(s, i.bind(t)),
    t
  ), I3[t] = n), e ? new RegExp(n, "i") : new RegExp(n);
}, p2 = (t) => typeof t == "string", gHe = (t) => t && p2(t) && !sHe.test(t) && !iHe.test(t) && t.indexOf("#") !== 0, yHe = (t) => t.split(lHe);
class bHe {
  constructor(e, n, r, s) {
    this.origin = e, this.pattern = n, this.negative = r, this.regex = s;
  }
}
const _He = (t, e) => {
  const n = t;
  let r = !1;
  t.indexOf("!") === 0 && (r = !0, t = t.substr(1)), t = t.replace(oHe, "!").replace(aHe, "#");
  const s = mHe(t, e);
  return new bHe(
    n,
    t,
    r,
    s
  );
}, vHe = (t, e) => {
  throw new e(t);
}, go = (t, e, n) => p2(t) ? t ? go.isNotRelative(t) ? n(
  `path should be a \`path.relative()\`d string, but got "${e}"`,
  RangeError
) : !0 : n("path must not be empty", TypeError) : n(
  `path must be a string, but got \`${e}\``,
  TypeError
), AY = (t) => cHe.test(t);
go.isNotRelative = AY;
go.convert = (t) => t;
class wHe {
  constructor({
    ignorecase: e = !0,
    ignoreCase: n = e,
    allowRelativePaths: r = !1
  } = {}) {
    uHe(this, R3, !0), this._rules = [], this._ignoreCase = n, this._allowRelativePaths = r, this._initCache();
  }
  _initCache() {
    this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
  }
  _addPattern(e) {
    if (e && e[R3]) {
      this._rules = this._rules.concat(e._rules), this._added = !0;
      return;
    }
    if (gHe(e)) {
      const n = _He(e, this._ignoreCase);
      this._added = !0, this._rules.push(n);
    }
  }
  // @param {Array<string> | string | Ignore} pattern
  add(e) {
    return this._added = !1, k3(
      p2(e) ? yHe(e) : e
    ).forEach(this._addPattern, this), this._added && this._initCache(), this;
  }
  // legacy
  addPattern(e) {
    return this.add(e);
  }
  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X
  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen
  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.
  // @returns {TestResult} true if a file is ignored
  _testOne(e, n) {
    let r = !1, s = !1;
    return this._rules.forEach((i) => {
      const { negative: o } = i;
      if (s === o && r !== s || o && !r && !s && !n)
        return;
      i.regex.test(e) && (r = !o, s = o);
    }), {
      ignored: r,
      unignored: s
    };
  }
  // @returns {TestResult}
  _test(e, n, r, s) {
    const i = e && go.convert(e);
    return go(
      i,
      e,
      this._allowRelativePaths ? kY : vHe
    ), this._t(i, n, r, s);
  }
  _t(e, n, r, s) {
    if (e in n)
      return n[e];
    if (s || (s = e.split(f1)), s.pop(), !s.length)
      return n[e] = this._testOne(e, r);
    const i = this._t(
      s.join(f1) + f1,
      n,
      r,
      s
    );
    return n[e] = i.ignored ? i : this._testOne(e, r);
  }
  ignores(e) {
    return this._test(e, this._ignoreCache, !1).ignored;
  }
  createFilter() {
    return (e) => !this.ignores(e);
  }
  filter(e) {
    return k3(e).filter(this.createFilter());
  }
  // @returns {TestResult}
  test(e) {
    return this._test(e, this._testCache, !0);
  }
}
const yT = (t) => new wHe(t), EHe = (t) => go(t && go.convert(t), t, kY);
yT.isPathValid = EHe;
yT.default = yT;
if (
  // Detect `process` so that it can run in browsers.
  typeof je < "u" && (je.env && je.env.IGNORE_TEST_WIN32 || je.platform === "win32")
) {
  const t = (n) => /^\\\\\?\\/.test(n) || /["<>|\u0000-\u001F]+/u.test(n) ? n : n.replace(/\\/g, "/");
  go.convert = t;
  const e = /^[a-z]:\//i;
  go.isNotRelative = (n) => e.test(n) || AY(n);
}
function SHe(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Vs(t, e, n) {
  return e = e instanceof RegExp ? e : new RegExp(SHe(e), "g"), t.replace(e, n);
}
var xHe = {
  clean: function(e) {
    if (typeof e != "string")
      throw new Error("Expected a string, received: " + e);
    return e = Vs(e, "./", "/"), e = Vs(e, "..", "."), e = Vs(e, " ", "-"), e = Vs(e, /^[~^:?*\\\-]/g, ""), e = Vs(e, /[~^:?*\\]/g, "-"), e = Vs(e, /[~^:?*\\\-]$/g, ""), e = Vs(e, "@{", "-"), e = Vs(e, /\.$/g, ""), e = Vs(e, /\/$/g, ""), e = Vs(e, /\.lock$/g, ""), e;
  }
}, THe = xHe;
const P3 = /* @__PURE__ */ Is(THe);
class bt extends Error {
  constructor(e) {
    super(e), this.caller = "";
  }
  toJSON() {
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack
    };
  }
  fromJSON(e) {
    const n = new bt(e.message);
    return n.code = e.code, n.data = e.data, n.caller = e.caller, n.stack = e.stack, n;
  }
  get isIsomorphicGitError() {
    return !0;
  }
}
class E_ extends bt {
  /**
   * @param {Array<string>} filepaths
   */
  constructor(e) {
    super(
      `Modifying the index is not possible because you have unmerged files: ${e.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`
    ), this.code = this.name = E_.code, this.data = { filepaths: e };
  }
}
E_.code = "UnmergedPathsError";
class st extends bt {
  /**
   * @param {string} message
   */
  constructor(e) {
    super(
      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${e}`
    ), this.code = this.name = st.code, this.data = { message: e };
  }
}
st.code = "InternalError";
class Pp extends bt {
  /**
   * @param {string} filepath
   */
  constructor(e) {
    super(`The filepath "${e}" contains unsafe character sequences`), this.code = this.name = Pp.code, this.data = { filepath: e };
  }
}
Pp.code = "UnsafeFilepathError";
class di {
  constructor(e) {
    this.buffer = e, this._start = 0;
  }
  eof() {
    return this._start >= this.buffer.length;
  }
  tell() {
    return this._start;
  }
  seek(e) {
    this._start = e;
  }
  slice(e) {
    const n = this.buffer.slice(this._start, this._start + e);
    return this._start += e, n;
  }
  toString(e, n) {
    const r = this.buffer.toString(e, this._start, this._start + n);
    return this._start += n, r;
  }
  write(e, n, r) {
    const s = this.buffer.write(e, this._start, n, r);
    return this._start += n, s;
  }
  copy(e, n, r) {
    const s = e.copy(this.buffer, this._start, n, r);
    return this._start += s, s;
  }
  readUInt8() {
    const e = this.buffer.readUInt8(this._start);
    return this._start += 1, e;
  }
  writeUInt8(e) {
    const n = this.buffer.writeUInt8(e, this._start);
    return this._start += 1, n;
  }
  readUInt16BE() {
    const e = this.buffer.readUInt16BE(this._start);
    return this._start += 2, e;
  }
  writeUInt16BE(e) {
    const n = this.buffer.writeUInt16BE(e, this._start);
    return this._start += 2, n;
  }
  readUInt32BE() {
    const e = this.buffer.readUInt32BE(this._start);
    return this._start += 4, e;
  }
  writeUInt32BE(e) {
    const n = this.buffer.writeUInt32BE(e, this._start);
    return this._start += 4, n;
  }
}
function S_(t, e) {
  return -(t < e) || +(t > e);
}
function RY(t, e) {
  return S_(t.path, e.path);
}
function IY(t) {
  let e = t > 0 ? t >> 12 : 0;
  e !== 4 && e !== 8 && e !== 10 && e !== 14 && (e = 8);
  let n = t & 511;
  return n & 73 ? n = 493 : n = 420, e !== 8 && (n = 0), (e << 12) + n;
}
const Ws = 2 ** 32;
function O3(t, e, n, r) {
  if (t !== void 0 && e !== void 0)
    return [t, e];
  n === void 0 && (n = r.valueOf());
  const s = Math.floor(n / 1e3), i = (n - s * 1e3) * 1e6;
  return [s, i];
}
function _u(t) {
  const [e, n] = O3(
    t.ctimeSeconds,
    t.ctimeNanoseconds,
    t.ctimeMs,
    t.ctime
  ), [r, s] = O3(
    t.mtimeSeconds,
    t.mtimeNanoseconds,
    t.mtimeMs,
    t.mtime
  );
  return {
    ctimeSeconds: e % Ws,
    ctimeNanoseconds: n % Ws,
    mtimeSeconds: r % Ws,
    mtimeNanoseconds: s % Ws,
    dev: t.dev % Ws,
    ino: t.ino % Ws,
    mode: IY(t.mode % Ws),
    uid: t.uid % Ws,
    gid: t.gid % Ws,
    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
    size: t.size > -1 ? t.size % Ws : 0
  };
}
function CHe(t) {
  let e = "";
  for (const n of new Uint8Array(t))
    n < 16 && (e += "0"), e += n.toString(16);
  return e;
}
let p1 = null;
async function vu(t) {
  return p1 === null && (p1 = await AHe()), p1 ? PY(t) : kHe(t);
}
function kHe(t) {
  return new cUe().update(t).digest("hex");
}
async function PY(t) {
  const e = await crypto.subtle.digest("SHA-1", t);
  return CHe(e);
}
async function AHe() {
  try {
    if (await PY(new Uint8Array([])) === "da39a3ee5e6b4b0d3255bfef95601890afd80709") return !0;
  } catch {
  }
  return !1;
}
function RHe(t) {
  return {
    assumeValid: !!(t & 32768),
    extended: !!(t & 16384),
    stage: (t & 12288) >> 12,
    nameLength: t & 4095
  };
}
function IHe(t) {
  const e = t.flags;
  return e.extended = !1, e.nameLength = Math.min(Me.from(t.path).length, 4095), (e.assumeValid ? 32768 : 0) + (e.extended ? 16384 : 0) + ((e.stage & 3) << 12) + (e.nameLength & 4095);
}
class $a {
  /*::
   _entries: Map<string, CacheEntry>
   _dirty: boolean // Used to determine if index needs to be saved to filesystem
   */
  constructor(e, n) {
    this._dirty = !1, this._unmergedPaths = n || /* @__PURE__ */ new Set(), this._entries = e || /* @__PURE__ */ new Map();
  }
  _addEntry(e) {
    if (e.flags.stage === 0)
      e.stages = [e], this._entries.set(e.path, e), this._unmergedPaths.delete(e.path);
    else {
      let n = this._entries.get(e.path);
      n || (this._entries.set(e.path, e), n = e), n.stages[e.flags.stage] = e, this._unmergedPaths.add(e.path);
    }
  }
  static async from(e) {
    if (Me.isBuffer(e))
      return $a.fromBuffer(e);
    if (e === null)
      return new $a(null);
    throw new st("invalid type passed to GitIndex.from");
  }
  static async fromBuffer(e) {
    if (e.length === 0)
      throw new st("Index file is empty (.git/index)");
    const n = new $a(), r = new di(e), s = r.toString("utf8", 4);
    if (s !== "DIRC")
      throw new st(`Invalid dircache magic file number: ${s}`);
    const i = await vu(e.slice(0, -20)), o = e.slice(-20).toString("hex");
    if (o !== i)
      throw new st(
        `Invalid checksum in GitIndex buffer: expected ${o} but saw ${i}`
      );
    const a = r.readUInt32BE();
    if (a !== 2)
      throw new st(`Unsupported dircache version: ${a}`);
    const l = r.readUInt32BE();
    let c = 0;
    for (; !r.eof() && c < l; ) {
      const u = {};
      u.ctimeSeconds = r.readUInt32BE(), u.ctimeNanoseconds = r.readUInt32BE(), u.mtimeSeconds = r.readUInt32BE(), u.mtimeNanoseconds = r.readUInt32BE(), u.dev = r.readUInt32BE(), u.ino = r.readUInt32BE(), u.mode = r.readUInt32BE(), u.uid = r.readUInt32BE(), u.gid = r.readUInt32BE(), u.size = r.readUInt32BE(), u.oid = r.slice(20).toString("hex");
      const h = r.readUInt16BE();
      u.flags = RHe(h);
      const d = e.indexOf(0, r.tell() + 1) - r.tell();
      if (d < 1)
        throw new st(`Got a path length of: ${d}`);
      if (u.path = r.toString("utf8", d), u.path.includes("..\\") || u.path.includes("../"))
        throw new Pp(u.path);
      let f = 8 - (r.tell() - 12) % 8;
      for (f === 0 && (f = 8); f--; ) {
        const g = r.readUInt8();
        if (g !== 0)
          throw new st(
            `Expected 1-8 null characters but got '${g}' after ${u.path}`
          );
        if (r.eof())
          throw new st("Unexpected end of file");
      }
      u.stages = [], n._addEntry(u), c++;
    }
    return n;
  }
  get unmergedPaths() {
    return [...this._unmergedPaths];
  }
  get entries() {
    return [...this._entries.values()].sort(RY);
  }
  get entriesMap() {
    return this._entries;
  }
  get entriesFlat() {
    return [...this.entries].flatMap((e) => e.stages.length > 1 ? e.stages.filter((n) => n) : e);
  }
  *[Symbol.iterator]() {
    for (const e of this.entries)
      yield e;
  }
  insert({ filepath: e, stats: n, oid: r, stage: s = 0 }) {
    n || (n = {
      ctimeSeconds: 0,
      ctimeNanoseconds: 0,
      mtimeSeconds: 0,
      mtimeNanoseconds: 0,
      dev: 0,
      ino: 0,
      mode: 0,
      uid: 0,
      gid: 0,
      size: 0
    }), n = _u(n);
    const i = Me.from(e), o = {
      ctimeSeconds: n.ctimeSeconds,
      ctimeNanoseconds: n.ctimeNanoseconds,
      mtimeSeconds: n.mtimeSeconds,
      mtimeNanoseconds: n.mtimeNanoseconds,
      dev: n.dev,
      ino: n.ino,
      // We provide a fallback value for `mode` here because not all fs
      // implementations assign it, but we use it in GitTree.
      // '100644' is for a "regular non-executable file"
      mode: n.mode || 33188,
      uid: n.uid,
      gid: n.gid,
      size: n.size,
      path: e,
      oid: r,
      flags: {
        assumeValid: !1,
        extended: !1,
        stage: s,
        nameLength: i.length < 4095 ? i.length : 4095
      },
      stages: []
    };
    this._addEntry(o), this._dirty = !0;
  }
  delete({ filepath: e }) {
    if (this._entries.has(e))
      this._entries.delete(e);
    else
      for (const n of this._entries.keys())
        n.startsWith(e + "/") && this._entries.delete(n);
    this._unmergedPaths.has(e) && this._unmergedPaths.delete(e), this._dirty = !0;
  }
  clear() {
    this._entries.clear(), this._dirty = !0;
  }
  has({ filepath: e }) {
    return this._entries.has(e);
  }
  render() {
    return this.entries.map((e) => `${e.mode.toString(8)} ${e.oid}    ${e.path}`).join(`
`);
  }
  static async _entryToBuffer(e) {
    const n = Me.from(e.path), r = Math.ceil((62 + n.length + 1) / 8) * 8, s = Me.alloc(r), i = new di(s), o = _u(e);
    return i.writeUInt32BE(o.ctimeSeconds), i.writeUInt32BE(o.ctimeNanoseconds), i.writeUInt32BE(o.mtimeSeconds), i.writeUInt32BE(o.mtimeNanoseconds), i.writeUInt32BE(o.dev), i.writeUInt32BE(o.ino), i.writeUInt32BE(o.mode), i.writeUInt32BE(o.uid), i.writeUInt32BE(o.gid), i.writeUInt32BE(o.size), i.write(e.oid, 20, "hex"), i.writeUInt16BE(IHe(e)), i.write(e.path, n.length, "utf8"), s;
  }
  async toObject() {
    const e = Me.alloc(12), n = new di(e);
    n.write("DIRC", 4, "utf8"), n.writeUInt32BE(2), n.writeUInt32BE(this.entriesFlat.length);
    let r = [];
    for (const a of this.entries)
      if (r.push($a._entryToBuffer(a)), a.stages.length > 1)
        for (const l of a.stages)
          l && l !== a && r.push($a._entryToBuffer(l));
    r = await Promise.all(r);
    const s = Me.concat(r), i = Me.concat([e, s]), o = await vu(i);
    return Me.concat([i, Me.from(o, "hex")]);
  }
}
function bT(t, e, n = !0, r = !0) {
  const s = _u(t), i = _u(e);
  return n && s.mode !== i.mode || s.mtimeSeconds !== i.mtimeSeconds || s.ctimeSeconds !== i.ctimeSeconds || s.uid !== i.uid || s.gid !== i.gid || r && s.ino !== i.ino || s.size !== i.size;
}
let m1 = null;
const sc = Symbol("IndexCache");
function PHe() {
  return {
    map: /* @__PURE__ */ new Map(),
    stats: /* @__PURE__ */ new Map()
  };
}
async function OHe(t, e, n) {
  const r = await t.lstat(e), s = await t.read(e), i = await $a.from(s);
  n.map.set(e, i), n.stats.set(e, r);
}
async function DHe(t, e, n) {
  const r = n.stats.get(e);
  if (r === void 0) return !0;
  const s = await t.lstat(e);
  return r === null || s === null ? !1 : bT(r, s);
}
class bd {
  /**
   *
   * @param {object} opts
   * @param {import('../models/FileSystem.js').FileSystem} opts.fs
   * @param {string} opts.gitdir
   * @param {object} opts.cache
   * @param {bool} opts.allowUnmerged
   * @param {function(GitIndex): any} closure
   */
  static async acquire({ fs: e, gitdir: n, cache: r, allowUnmerged: s = !0 }, i) {
    r[sc] || (r[sc] = PHe());
    const o = `${n}/index`;
    m1 === null && (m1 = new Gy({ maxPending: 1 / 0 }));
    let a, l = [];
    return await m1.acquire(o, async () => {
      await DHe(e, o, r[sc]) && await OHe(e, o, r[sc]);
      const c = r[sc].map.get(o);
      if (l = c.unmergedPaths, l.length && !s)
        throw new E_(l);
      if (a = await i(c), c._dirty) {
        const u = await c.toObject();
        await e.write(o, u), r[sc].stats.set(o, await e.lstat(o)), c._dirty = !1;
      }
    }), a;
  }
}
function D3(t) {
  const e = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
  return e > -1 && (t = t.slice(e + 1)), t;
}
function qy(t) {
  const e = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
  return e === -1 ? "." : e === 0 ? "/" : t.slice(0, e);
}
function NHe(t) {
  const e = /* @__PURE__ */ new Map(), n = function(s) {
    if (!e.has(s)) {
      const i = {
        type: "tree",
        fullpath: s,
        basename: D3(s),
        metadata: {},
        children: []
      };
      e.set(s, i), i.parent = n(qy(s)), i.parent && i.parent !== i && i.parent.children.push(i);
    }
    return e.get(s);
  }, r = function(s, i) {
    if (!e.has(s)) {
      const o = {
        type: "blob",
        fullpath: s,
        basename: D3(s),
        metadata: i,
        // This recursively generates any missing parent folders.
        parent: n(qy(s)),
        children: []
      };
      o.parent && o.parent.children.push(o), e.set(s, o);
    }
    return e.get(s);
  };
  n(".");
  for (const s of t)
    r(s.path, s);
  return e;
}
function LHe(t) {
  switch (t) {
    case 16384:
      return "tree";
    case 33188:
      return "blob";
    case 33261:
      return "blob";
    case 40960:
      return "blob";
    case 57344:
      return "commit";
  }
  throw new st(`Unexpected GitTree entry mode: ${t.toString(8)}`);
}
class MHe {
  constructor({ fs: e, gitdir: n, cache: r }) {
    this.treePromise = bd.acquire(
      { fs: e, gitdir: n, cache: r },
      async function(i) {
        return NHe(i.entries);
      }
    );
    const s = this;
    this.ConstructEntry = class {
      constructor(o) {
        this._fullpath = o, this._type = !1, this._mode = !1, this._stat = !1, this._oid = !1;
      }
      async type() {
        return s.type(this);
      }
      async mode() {
        return s.mode(this);
      }
      async stat() {
        return s.stat(this);
      }
      async content() {
        return s.content(this);
      }
      async oid() {
        return s.oid(this);
      }
    };
  }
  async readdir(e) {
    const n = e._fullpath, s = (await this.treePromise).get(n);
    if (!s || s.type === "blob") return null;
    if (s.type !== "tree")
      throw new Error(`ENOTDIR: not a directory, scandir '${n}'`);
    const i = s.children.map((o) => o.fullpath);
    return i.sort(S_), i;
  }
  async type(e) {
    return e._type === !1 && await e.stat(), e._type;
  }
  async mode(e) {
    return e._mode === !1 && await e.stat(), e._mode;
  }
  async stat(e) {
    if (e._stat === !1) {
      const r = (await this.treePromise).get(e._fullpath);
      if (!r)
        throw new Error(
          `ENOENT: no such file or directory, lstat '${e._fullpath}'`
        );
      const s = r.type === "tree" ? {} : _u(r.metadata);
      e._type = r.type === "tree" ? "tree" : LHe(s.mode), e._mode = s.mode, r.type === "tree" ? e._stat = void 0 : e._stat = s;
    }
    return e._stat;
  }
  async content(e) {
  }
  async oid(e) {
    if (e._oid === !1) {
      const r = (await this.treePromise).get(e._fullpath);
      e._oid = r.metadata.oid;
    }
    return e._oid;
  }
}
const x_ = Symbol("GitWalkSymbol");
function BHe() {
  const t = /* @__PURE__ */ Object.create(null);
  return Object.defineProperty(t, x_, {
    value: function({ fs: e, gitdir: n, cache: r }) {
      return new MHe({ fs: e, gitdir: n, cache: r });
    }
  }), Object.freeze(t), t;
}
class yi extends bt {
  /**
   * @param {string} what
   */
  constructor(e) {
    super(`Could not find ${e}.`), this.code = this.name = yi.code, this.data = { what: e };
  }
}
yi.code = "NotFoundError";
class Op extends bt {
  /**
   * @param {string} oid
   * @param {'blob'|'commit'|'tag'|'tree'} actual
   * @param {'blob'|'commit'|'tag'|'tree'} expected
   * @param {string} [filepath]
   */
  constructor(e, n, r, s) {
    super(
      `Object ${e} ${s ? `at ${s}` : ""}was anticipated to be a ${r} but it is a ${n}.`
    ), this.code = this.name = Op.code, this.data = { oid: e, actual: n, expected: r, filepath: s };
  }
}
Op.code = "ObjectTypeError";
class Pl extends bt {
  /**
   * @param {string} value
   */
  constructor(e) {
    super(`Expected a 40-char hex object id but saw "${e}".`), this.code = this.name = Pl.code, this.data = { value: e };
  }
}
Pl.code = "InvalidOidError";
class T_ extends bt {
  /**
   * @param {string} remote
   */
  constructor(e) {
    super(`Could not find a fetch refspec for remote "${e}". Make sure the config file has an entry like the following:
[remote "${e}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`), this.code = this.name = T_.code, this.data = { remote: e };
  }
}
T_.code = "NoRefspecError";
class Ky {
  constructor(e) {
    if (this.refs = /* @__PURE__ */ new Map(), this.parsedConfig = [], e) {
      let n = null;
      this.parsedConfig = e.trim().split(`
`).map((r) => {
        if (/^\s*#/.test(r))
          return { line: r, comment: !0 };
        const s = r.indexOf(" ");
        if (r.startsWith("^")) {
          const i = r.slice(1);
          return this.refs.set(n + "^{}", i), { line: r, ref: n, peeled: i };
        } else {
          const i = r.slice(0, s);
          return n = r.slice(s + 1), this.refs.set(n, i), { line: r, ref: n, oid: i };
        }
      });
    }
    return this;
  }
  static from(e) {
    return new Ky(e);
  }
  delete(e) {
    this.parsedConfig = this.parsedConfig.filter((n) => n.ref !== e), this.refs.delete(e);
  }
  toString() {
    return this.parsedConfig.map(({ line: e }) => e).join(`
`) + `
`;
  }
}
class Yy {
  constructor({ remotePath: e, localPath: n, force: r, matchPrefix: s }) {
    Object.assign(this, {
      remotePath: e,
      localPath: n,
      force: r,
      matchPrefix: s
    });
  }
  static from(e) {
    const [
      n,
      r,
      s,
      i,
      o
    ] = e.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1), a = n === "+", l = s === "*";
    if (l !== (o === "*"))
      throw new st("Invalid refspec");
    return new Yy({
      remotePath: r,
      localPath: i,
      force: a,
      matchPrefix: l
    });
  }
  translate(e) {
    if (this.matchPrefix) {
      if (e.startsWith(this.remotePath))
        return this.localPath + e.replace(this.remotePath, "");
    } else if (e === this.remotePath) return this.localPath;
    return null;
  }
  reverseTranslate(e) {
    if (this.matchPrefix) {
      if (e.startsWith(this.localPath))
        return this.remotePath + e.replace(this.localPath, "");
    } else if (e === this.localPath) return this.remotePath;
    return null;
  }
}
class m2 {
  constructor(e = []) {
    this.rules = e;
  }
  static from(e) {
    const n = [];
    for (const r of e)
      n.push(Yy.from(r));
    return new m2(n);
  }
  add(e) {
    const n = Yy.from(e);
    this.rules.push(n);
  }
  translate(e) {
    const n = [];
    for (const r of this.rules)
      for (const s of e) {
        const i = r.translate(s);
        i && n.push([s, i]);
      }
    return n;
  }
  translateOne(e) {
    let n = null;
    for (const r of this.rules) {
      const s = r.translate(e);
      s && (n = s);
    }
    return n;
  }
  localNamespaces() {
    return this.rules.filter((e) => e.matchPrefix).map((e) => e.localPath.replace(/\/$/, ""));
  }
}
function FHe(t, e) {
  const n = t.replace(/\^\{\}$/, ""), r = e.replace(/\^\{\}$/, ""), s = -(n < r) || +(n > r);
  return s === 0 ? t.endsWith("^{}") ? 1 : -1 : s;
}
const $He = (t) => {
  t = t.toLowerCase();
  let e = parseInt(t);
  return t.endsWith("k") && (e *= 1024), t.endsWith("m") && (e *= 1024 * 1024), t.endsWith("g") && (e *= 1024 * 1024 * 1024), e;
}, bh = (t) => {
  if (t = t.trim().toLowerCase(), t === "true" || t === "yes" || t === "on") return !0;
  if (t === "false" || t === "no" || t === "off") return !1;
  throw Error(
    `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${t}`
  );
}, N3 = {
  core: {
    filemode: bh,
    bare: bh,
    logallrefupdates: bh,
    symlinks: bh,
    ignorecase: bh,
    bigFileThreshold: $He
  }
}, UHe = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/, jHe = /^[A-Za-z0-9-.]+$/, HHe = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/, zHe = /^[A-Za-z][A-Za-z-]*$/, GHe = /^(.*?)( *[#;].*)$/, VHe = (t) => {
  const e = UHe.exec(t);
  if (e != null) {
    const [n, r] = e.slice(1);
    return [n, r];
  }
  return null;
}, WHe = (t) => {
  const e = HHe.exec(t);
  if (e != null) {
    const [n, r = "true"] = e.slice(1), s = qHe(r), i = KHe(s);
    return [n, i];
  }
  return null;
}, qHe = (t) => {
  const e = GHe.exec(t);
  if (e == null)
    return t;
  const [n, r] = e.slice(1);
  return L3(n) && L3(r) ? `${n}${r}` : n;
}, L3 = (t) => (t.match(/(?:^|[^\\])"/g) || []).length % 2 !== 0, KHe = (t) => t.split("").reduce((e, n, r, s) => {
  const i = n === '"' && s[r - 1] !== "\\", o = n === "\\" && s[r + 1] === '"';
  return i || o ? e : e + n;
}, ""), M3 = (t) => t != null ? t.toLowerCase() : null, _T = (t, e, n) => [M3(t), e, M3(n)].filter((r) => r != null).join("."), B3 = (t) => {
  const e = t.split("."), n = e.shift(), r = e.pop(), s = e.length ? e.join(".") : void 0;
  return {
    section: n,
    subsection: s,
    name: r,
    path: _T(n, s, r),
    sectionPath: _T(n, s, null)
  };
}, YHe = (t, e) => t.reduce((n, r, s) => e(r) ? s : n, -1);
class g2 {
  constructor(e) {
    let n = null, r = null;
    this.parsedConfig = e ? e.split(`
`).map((s) => {
      let i = null, o = null;
      const a = s.trim(), l = VHe(a), c = l != null;
      if (c)
        [n, r] = l;
      else {
        const h = WHe(a);
        h != null && ([i, o] = h);
      }
      const u = _T(n, r, i);
      return { line: s, isSection: c, section: n, subsection: r, name: i, value: o, path: u };
    }) : [];
  }
  static from(e) {
    return new g2(e);
  }
  async get(e, n = !1) {
    const r = B3(e).path, s = this.parsedConfig.filter((i) => i.path === r).map(({ section: i, name: o, value: a }) => {
      const l = N3[i] && N3[i][o];
      return l ? l(a) : a;
    });
    return n ? s : s.pop();
  }
  async getall(e) {
    return this.get(e, !0);
  }
  async getSubsections(e) {
    return this.parsedConfig.filter((n) => n.section === e && n.isSection).map((n) => n.subsection);
  }
  async deleteSection(e, n) {
    this.parsedConfig = this.parsedConfig.filter(
      (r) => !(r.section === e && r.subsection === n)
    );
  }
  async append(e, n) {
    return this.set(e, n, !0);
  }
  async set(e, n, r = !1) {
    const {
      section: s,
      subsection: i,
      name: o,
      path: a,
      sectionPath: l
    } = B3(e), c = YHe(
      this.parsedConfig,
      (u) => u.path === a
    );
    if (n == null)
      c !== -1 && this.parsedConfig.splice(c, 1);
    else if (c !== -1) {
      const u = this.parsedConfig[c], h = Object.assign({}, u, {
        name: o,
        value: n,
        modified: !0
      });
      r ? this.parsedConfig.splice(c + 1, 0, h) : this.parsedConfig[c] = h;
    } else {
      const u = this.parsedConfig.findIndex(
        (d) => d.path === l
      ), h = {
        section: s,
        subsection: i,
        name: o,
        value: n,
        modified: !0,
        path: a
      };
      if (jHe.test(s) && zHe.test(o))
        if (u >= 0)
          this.parsedConfig.splice(u + 1, 0, h);
        else {
          const d = {
            section: s,
            subsection: i,
            modified: !0,
            path: l
          };
          this.parsedConfig.push(d, h);
        }
    }
  }
  toString() {
    return this.parsedConfig.map(({ line: e, section: n, subsection: r, name: s, value: i, modified: o = !1 }) => o ? s != null && i != null ? typeof i == "string" && /[#;]/.test(i) ? `	${s} = "${i}"` : `	${s} = ${i}` : r != null ? `[${n} "${r}"]` : `[${n}]` : e).join(`
`);
  }
}
class Ri {
  static async get({ fs: e, gitdir: n }) {
    const r = await e.read(`${n}/config`, { encoding: "utf8" });
    return g2.from(r);
  }
  static async save({ fs: e, gitdir: n, config: r }) {
    await e.write(`${n}/config`, r.toString(), {
      encoding: "utf8"
    });
  }
}
const rg = (t) => [
  `${t}`,
  `refs/${t}`,
  `refs/tags/${t}`,
  `refs/heads/${t}`,
  `refs/remotes/${t}`,
  `refs/remotes/${t}/HEAD`
], ZHe = ["config", "description", "index", "shallow", "commondir"];
let g1;
async function So(t, e) {
  return g1 === void 0 && (g1 = new Gy()), g1.acquire(t, e);
}
class ht {
  static async updateRemoteRefs({
    fs: e,
    gitdir: n,
    remote: r,
    refs: s,
    symrefs: i,
    tags: o,
    refspecs: a = void 0,
    prune: l = !1,
    pruneTags: c = !1
  }) {
    for (const p of s.values())
      if (!p.match(/[0-9a-f]{40}/))
        throw new Pl(p);
    const u = await Ri.get({ fs: e, gitdir: n });
    if (!a) {
      if (a = await u.getall(`remote.${r}.fetch`), a.length === 0)
        throw new T_(r);
      a.unshift(`+HEAD:refs/remotes/${r}/HEAD`);
    }
    const h = m2.from(a), d = /* @__PURE__ */ new Map();
    if (c) {
      const p = await ht.listRefs({
        fs: e,
        gitdir: n,
        filepath: "refs/tags"
      });
      await ht.deleteRefs({
        fs: e,
        gitdir: n,
        refs: p.map((m) => `refs/tags/${m}`)
      });
    }
    if (o) {
      for (const p of s.keys())
        if (p.startsWith("refs/tags") && !p.endsWith("^{}") && !await ht.exists({ fs: e, gitdir: n, ref: p })) {
          const m = s.get(p);
          d.set(p, m);
        }
    }
    const f = h.translate([...s.keys()]);
    for (const [p, m] of f) {
      const b = s.get(p);
      d.set(m, b);
    }
    const g = h.translate([...i.keys()]);
    for (const [p, m] of g) {
      const b = i.get(p), _ = h.translateOne(b);
      _ && d.set(m, `ref: ${_}`);
    }
    const y = [];
    if (l) {
      for (const p of h.localNamespaces()) {
        const m = (await ht.listRefs({
          fs: e,
          gitdir: n,
          filepath: p
        })).map((b) => `${p}/${b}`);
        for (const b of m)
          d.has(b) || y.push(b);
      }
      y.length > 0 && await ht.deleteRefs({ fs: e, gitdir: n, refs: y });
    }
    for (const [p, m] of d)
      await So(
        p,
        async () => e.write(rn.join(n, p), `${m.trim()}
`, "utf8")
      );
    return { pruned: y };
  }
  // TODO: make this less crude?
  static async writeRef({ fs: e, gitdir: n, ref: r, value: s }) {
    if (!s.match(/[0-9a-f]{40}/))
      throw new Pl(s);
    await So(
      r,
      async () => e.write(rn.join(n, r), `${s.trim()}
`, "utf8")
    );
  }
  static async writeSymbolicRef({ fs: e, gitdir: n, ref: r, value: s }) {
    await So(
      r,
      async () => e.write(rn.join(n, r), `ref: ${s.trim()}
`, "utf8")
    );
  }
  static async deleteRef({ fs: e, gitdir: n, ref: r }) {
    return ht.deleteRefs({ fs: e, gitdir: n, refs: [r] });
  }
  static async deleteRefs({ fs: e, gitdir: n, refs: r }) {
    await Promise.all(r.map((a) => e.rm(rn.join(n, a))));
    let s = await So(
      "packed-refs",
      async () => e.read(`${n}/packed-refs`, { encoding: "utf8" })
    );
    const i = Ky.from(s), o = i.refs.size;
    for (const a of r)
      i.refs.has(a) && i.delete(a);
    i.refs.size < o && (s = i.toString(), await So(
      "packed-refs",
      async () => e.write(`${n}/packed-refs`, s, { encoding: "utf8" })
    ));
  }
  /**
   * @param {object} args
   * @param {import('../models/FileSystem.js').FileSystem} args.fs
   * @param {string} args.gitdir
   * @param {string} args.ref
   * @param {number} [args.depth]
   * @returns {Promise<string>}
   */
  static async resolve({ fs: e, gitdir: n, ref: r, depth: s = void 0 }) {
    if (s !== void 0 && (s--, s === -1))
      return r;
    if (r.startsWith("ref: "))
      return r = r.slice(5), ht.resolve({ fs: e, gitdir: n, ref: r, depth: s });
    if (r.length === 40 && /[0-9a-f]{40}/.test(r))
      return r;
    const i = await ht.packedRefs({ fs: e, gitdir: n }), o = rg(r).filter((a) => !ZHe.includes(a));
    for (const a of o) {
      const l = await So(
        a,
        async () => await e.read(`${n}/${a}`, { encoding: "utf8" }) || i.get(a)
      );
      if (l)
        return ht.resolve({ fs: e, gitdir: n, ref: l.trim(), depth: s });
    }
    throw new yi(r);
  }
  static async exists({ fs: e, gitdir: n, ref: r }) {
    try {
      return await ht.expand({ fs: e, gitdir: n, ref: r }), !0;
    } catch {
      return !1;
    }
  }
  static async expand({ fs: e, gitdir: n, ref: r }) {
    if (r.length === 40 && /[0-9a-f]{40}/.test(r))
      return r;
    const s = await ht.packedRefs({ fs: e, gitdir: n }), i = rg(r);
    for (const o of i)
      if (await So(
        o,
        async () => e.exists(`${n}/${o}`)
      ) || s.has(o)) return o;
    throw new yi(r);
  }
  static async expandAgainstMap({ ref: e, map: n }) {
    const r = rg(e);
    for (const s of r)
      if (await n.has(s)) return s;
    throw new yi(e);
  }
  static resolveAgainstMap({ ref: e, fullref: n = e, depth: r = void 0, map: s }) {
    if (r !== void 0 && (r--, r === -1))
      return { fullref: n, oid: e };
    if (e.startsWith("ref: "))
      return e = e.slice(5), ht.resolveAgainstMap({ ref: e, fullref: n, depth: r, map: s });
    if (e.length === 40 && /[0-9a-f]{40}/.test(e))
      return { fullref: n, oid: e };
    const i = rg(e);
    for (const o of i) {
      const a = s.get(o);
      if (a)
        return ht.resolveAgainstMap({
          ref: a.trim(),
          fullref: o,
          depth: r,
          map: s
        });
    }
    throw new yi(e);
  }
  static async packedRefs({ fs: e, gitdir: n }) {
    const r = await So(
      "packed-refs",
      async () => e.read(`${n}/packed-refs`, { encoding: "utf8" })
    );
    return Ky.from(r).refs;
  }
  // List all the refs that match the `filepath` prefix
  static async listRefs({ fs: e, gitdir: n, filepath: r }) {
    const s = ht.packedRefs({ fs: e, gitdir: n });
    let i = null;
    try {
      i = await e.readdirDeep(`${n}/${r}`), i = i.map((o) => o.replace(`${n}/${r}/`, ""));
    } catch {
      i = [];
    }
    for (let o of (await s).keys())
      o.startsWith(r) && (o = o.replace(r + "/", ""), i.includes(o) || i.push(o));
    return i.sort(FHe), i;
  }
  static async listBranches({ fs: e, gitdir: n, remote: r }) {
    return r ? ht.listRefs({
      fs: e,
      gitdir: n,
      filepath: `refs/remotes/${r}`
    }) : ht.listRefs({ fs: e, gitdir: n, filepath: "refs/heads" });
  }
  static async listTags({ fs: e, gitdir: n }) {
    return (await ht.listRefs({
      fs: e,
      gitdir: n,
      filepath: "refs/tags"
    })).filter((s) => !s.endsWith("^{}"));
  }
}
function JHe(t, e) {
  return S_(F3(t), F3(e));
}
function F3(t) {
  return t.mode === "040000" ? t.path + "/" : t.path;
}
function OY(t) {
  switch (t) {
    case "040000":
      return "tree";
    case "100644":
      return "blob";
    case "100755":
      return "blob";
    case "120000":
      return "blob";
    case "160000":
      return "commit";
  }
  throw new st(`Unexpected GitTree entry mode: ${t}`);
}
function XHe(t) {
  const e = [];
  let n = 0;
  for (; n < t.length; ) {
    const r = t.indexOf(32, n);
    if (r === -1)
      throw new st(
        `GitTree: Error parsing buffer at byte location ${n}: Could not find the next space character.`
      );
    const s = t.indexOf(0, n);
    if (s === -1)
      throw new st(
        `GitTree: Error parsing buffer at byte location ${n}: Could not find the next null character.`
      );
    let i = t.slice(n, r).toString("utf8");
    i === "40000" && (i = "040000");
    const o = OY(i), a = t.slice(r + 1, s).toString("utf8");
    if (a.includes("\\") || a.includes("/"))
      throw new Pp(a);
    const l = t.slice(s + 1, s + 21).toString("hex");
    n = s + 21, e.push({ mode: i, path: a, oid: l, type: o });
  }
  return e;
}
function QHe(t) {
  if (typeof t == "number" && (t = t.toString(8)), t.match(/^0?4.*/)) return "040000";
  if (t.match(/^1006.*/)) return "100644";
  if (t.match(/^1007.*/)) return "100755";
  if (t.match(/^120.*/)) return "120000";
  if (t.match(/^160.*/)) return "160000";
  throw new st(`Could not understand file mode: ${t}`);
}
function e9e(t) {
  return !t.oid && t.sha && (t.oid = t.sha), t.mode = QHe(t.mode), t.type || (t.type = OY(t.mode)), t;
}
class If {
  constructor(e) {
    if (Me.isBuffer(e))
      this._entries = XHe(e);
    else if (Array.isArray(e))
      this._entries = e.map(e9e);
    else
      throw new st("invalid type passed to GitTree constructor");
    this._entries.sort(RY);
  }
  static from(e) {
    return new If(e);
  }
  render() {
    return this._entries.map((e) => `${e.mode} ${e.type} ${e.oid}    ${e.path}`).join(`
`);
  }
  toObject() {
    const e = [...this._entries];
    return e.sort(JHe), Me.concat(
      e.map((n) => {
        const r = Me.from(n.mode.replace(/^0/, "")), s = Me.from(" "), i = Me.from(n.path, "utf8"), o = Me.from([0]), a = Me.from(n.oid, "hex");
        return Me.concat([r, s, i, o, a]);
      })
    );
  }
  /**
   * @returns {TreeEntry[]}
   */
  entries() {
    return this._entries;
  }
  *[Symbol.iterator]() {
    for (const e of this._entries)
      yield e;
  }
}
class y2 {
  static wrap({ type: e, object: n }) {
    return Me.concat([
      Me.from(`${e} ${n.byteLength.toString()}\0`),
      Me.from(n)
    ]);
  }
  static unwrap(e) {
    const n = e.indexOf(32), r = e.indexOf(0), s = e.slice(0, n).toString("utf8"), i = e.slice(n + 1, r).toString("utf8"), o = e.length - (r + 1);
    if (parseInt(i) !== o)
      throw new st(
        `Length mismatch: expected ${i} bytes but got ${o} instead.`
      );
    return {
      type: s,
      object: Me.from(e.slice(r + 1))
    };
  }
}
async function t9e({ fs: t, gitdir: e, oid: n }) {
  const r = `objects/${n.slice(0, 2)}/${n.slice(2)}`, s = await t.read(`${e}/${r}`);
  return s ? { object: s, format: "deflated", source: r } : null;
}
function n9e(t, e) {
  const n = new di(t), r = $3(n);
  if (r !== e.byteLength)
    throw new st(
      `applyDelta expected source buffer to be ${r} bytes but the provided buffer was ${e.length} bytes`
    );
  const s = $3(n);
  let i;
  const o = j3(n, e);
  if (o.byteLength === s)
    i = o;
  else {
    i = Me.alloc(s);
    const a = new di(i);
    for (a.copy(o); !n.eof(); )
      a.copy(j3(n, e));
    const l = a.tell();
    if (s !== l)
      throw new st(
        `applyDelta expected target buffer to be ${s} bytes but the resulting buffer was ${l} bytes`
      );
  }
  return i;
}
function $3(t) {
  let e = 0, n = 0, r = null;
  do
    r = t.readUInt8(), e |= (r & 127) << n, n += 7;
  while (r & 128);
  return e;
}
function U3(t, e, n) {
  let r = 0, s = 0;
  for (; n--; )
    e & 1 && (r |= t.readUInt8() << s), e >>= 1, s += 8;
  return r;
}
function j3(t, e) {
  const n = t.readUInt8(), r = 128, s = 15, i = 112;
  if (n & r) {
    const o = U3(t, n & s, 4);
    let a = U3(t, (n & i) >> 4, 3);
    return a === 0 && (a = 65536), e.slice(o, o + a);
  } else
    return t.slice(n);
}
function r9e(t) {
  let e = [t];
  return {
    next() {
      return Promise.resolve({ done: e.length === 0, value: e.pop() });
    },
    return() {
      return e = [], {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function DY(t) {
  return t[Symbol.asyncIterator] ? t[Symbol.asyncIterator]() : t[Symbol.iterator] ? t[Symbol.iterator]() : t.next ? t : r9e(t);
}
class NY {
  constructor(e) {
    if (typeof Me > "u")
      throw new Error("Missing Buffer dependency");
    this.stream = DY(e), this.buffer = null, this.cursor = 0, this.undoCursor = 0, this.started = !1, this._ended = !1, this._discardedBytes = 0;
  }
  eof() {
    return this._ended && this.cursor === this.buffer.length;
  }
  tell() {
    return this._discardedBytes + this.cursor;
  }
  async byte() {
    if (!this.eof() && (this.started || await this._init(), !(this.cursor === this.buffer.length && (await this._loadnext(), this._ended))))
      return this._moveCursor(1), this.buffer[this.undoCursor];
  }
  async chunk() {
    if (!this.eof() && (this.started || await this._init(), !(this.cursor === this.buffer.length && (await this._loadnext(), this._ended))))
      return this._moveCursor(this.buffer.length), this.buffer.slice(this.undoCursor, this.cursor);
  }
  async read(e) {
    if (!this.eof())
      return this.started || await this._init(), this.cursor + e > this.buffer.length && (this._trim(), await this._accumulate(e)), this._moveCursor(e), this.buffer.slice(this.undoCursor, this.cursor);
  }
  async skip(e) {
    this.eof() || (this.started || await this._init(), this.cursor + e > this.buffer.length && (this._trim(), await this._accumulate(e)), this._moveCursor(e));
  }
  async undo() {
    this.cursor = this.undoCursor;
  }
  async _next() {
    this.started = !0;
    let { done: e, value: n } = await this.stream.next();
    return e && (this._ended = !0, !n) ? Me.alloc(0) : (n && (n = Me.from(n)), n);
  }
  _trim() {
    this.buffer = this.buffer.slice(this.undoCursor), this.cursor -= this.undoCursor, this._discardedBytes += this.undoCursor, this.undoCursor = 0;
  }
  _moveCursor(e) {
    this.undoCursor = this.cursor, this.cursor += e, this.cursor > this.buffer.length && (this.cursor = this.buffer.length);
  }
  async _accumulate(e) {
    if (this._ended) return;
    const n = [this.buffer];
    for (; this.cursor + e > s9e(n); ) {
      const r = await this._next();
      if (this._ended) break;
      n.push(r);
    }
    this.buffer = Me.concat(n);
  }
  async _loadnext() {
    this._discardedBytes += this.buffer.length, this.undoCursor = 0, this.cursor = 0, this.buffer = await this._next();
  }
  async _init() {
    this.buffer = await this._next();
  }
}
function s9e(t) {
  return t.reduce((e, n) => e + n.length, 0);
}
async function i9e(t, e) {
  const n = new NY(t);
  let r = await n.read(4);
  if (r = r.toString("utf8"), r !== "PACK")
    throw new st(`Invalid PACK header '${r}'`);
  let s = await n.read(4);
  if (s = s.readUInt32BE(0), s !== 2)
    throw new st(`Invalid packfile version: ${s}`);
  let i = await n.read(4);
  if (i = i.readUInt32BE(0), !(i < 1))
    for (; !n.eof() && i--; ) {
      const o = n.tell(), { type: a, length: l, ofs: c, reference: u } = await o9e(n), h = new TY.Inflate();
      for (; !h.result; ) {
        const d = await n.chunk();
        if (!d) break;
        if (h.push(d, !1), h.err)
          throw new st(`Pako error: ${h.msg}`);
        if (h.result) {
          if (h.result.length !== l)
            throw new st(
              "Inflated object size is different from that stated in packfile."
            );
          await n.undo(), await n.read(d.length - h.strm.avail_in);
          const f = n.tell();
          await e({
            data: h.result,
            type: a,
            num: i,
            offset: o,
            end: f,
            reference: u,
            ofs: c
          });
        }
      }
    }
}
async function o9e(t) {
  let e = await t.byte();
  const n = e >> 4 & 7;
  let r = e & 15;
  if (e & 128) {
    let o = 4;
    do
      e = await t.byte(), r |= (e & 127) << o, o += 7;
    while (e & 128);
  }
  let s, i;
  if (n === 6) {
    let o = 0;
    s = 0;
    const a = [];
    do
      e = await t.byte(), s |= (e & 127) << o, o += 7, a.push(e);
    while (e & 128);
    i = Me.from(a);
  }
  return n === 7 && (i = await t.read(20)), { type: n, length: r, ofs: s, reference: i };
}
async function LY(t) {
  return TY.inflate(t);
}
function a9e(t) {
  const e = [];
  let n = 0, r = 0;
  do {
    n = t.readUInt8();
    const s = n & 127;
    e.push(s), r = n & 128;
  } while (r);
  return e.reduce((s, i) => s + 1 << 7 | i, -1);
}
function l9e(t, e) {
  let n = e, r = 4, s = null;
  do
    s = t.readUInt8(), n |= (s & 127) << r, r += 7;
  while (s & 128);
  return n;
}
class Pf {
  constructor(e) {
    Object.assign(this, e), this.offsetCache = {};
  }
  static async fromIdx({ idx: e, getExternalRefDelta: n }) {
    const r = new di(e);
    if (r.slice(4).toString("hex") !== "ff744f63")
      return;
    const i = r.readUInt32BE();
    if (i !== 2)
      throw new st(
        `Unable to read version ${i} packfile IDX. (Only version 2 supported)`
      );
    if (e.byteLength > 2048 * 1024 * 1024)
      throw new st(
        "To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size."
      );
    r.seek(r.tell() + 4 * 255);
    const o = r.readUInt32BE(), a = [];
    for (let u = 0; u < o; u++) {
      const h = r.slice(20).toString("hex");
      a[u] = h;
    }
    r.seek(r.tell() + 4 * o);
    const l = /* @__PURE__ */ new Map();
    for (let u = 0; u < o; u++)
      l.set(a[u], r.readUInt32BE());
    const c = r.slice(20).toString("hex");
    return new Pf({
      hashes: a,
      crcs: {},
      offsets: l,
      packfileSha: c,
      getExternalRefDelta: n
    });
  }
  static async fromPack({ pack: e, getExternalRefDelta: n, onProgress: r }) {
    const s = {
      1: "commit",
      2: "tree",
      3: "blob",
      4: "tag",
      6: "ofs-delta",
      7: "ref-delta"
    }, i = {}, o = e.slice(-20).toString("hex"), a = [], l = {}, c = /* @__PURE__ */ new Map();
    let u = null, h = null;
    await i9e([e], async ({ data: p, type: m, reference: b, offset: _, num: v }) => {
      u === null && (u = v);
      const w = Math.floor(
        (u - v) * 100 / u
      );
      w !== h && r && await r({
        phase: "Receiving objects",
        loaded: u - v,
        total: u
      }), h = w, m = s[m], ["commit", "tree", "blob", "tag"].includes(m) ? i[_] = {
        type: m,
        offset: _
      } : m === "ofs-delta" ? i[_] = {
        type: m,
        offset: _
      } : m === "ref-delta" && (i[_] = {
        type: m,
        offset: _
      });
    });
    const d = Object.keys(i).map(Number);
    for (const [p, m] of d.entries()) {
      const b = p + 1 === d.length ? e.byteLength - 20 : d[p + 1], _ = i[m], v = uUe.buf(e.slice(m, b)) >>> 0;
      _.end = b, _.crc = v;
    }
    const f = new Pf({
      pack: Promise.resolve(e),
      packfileSha: o,
      crcs: l,
      hashes: a,
      offsets: c,
      getExternalRefDelta: n
    });
    h = null;
    let g = 0;
    const y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let p in i) {
      p = Number(p);
      const m = Math.floor(g * 100 / u);
      m !== h && r && await r({
        phase: "Resolving deltas",
        loaded: g,
        total: u
      }), g++, h = m;
      const b = i[p];
      if (!b.oid)
        try {
          f.readDepth = 0, f.externalReadDepth = 0;
          const { type: _, object: v } = await f.readSlice({ start: p });
          y[f.readDepth] += 1;
          const w = await vu(y2.wrap({ type: _, object: v }));
          b.oid = w, a.push(w), c.set(w, p), l[w] = b.crc;
        } catch {
          continue;
        }
    }
    return a.sort(), f;
  }
  async toBuffer() {
    const e = [], n = (c, u) => {
      e.push(Me.from(c, u));
    };
    n("ff744f63", "hex"), n("00000002", "hex");
    const r = new di(Me.alloc(256 * 4));
    for (let c = 0; c < 256; c++) {
      let u = 0;
      for (const h of this.hashes)
        parseInt(h.slice(0, 2), 16) <= c && u++;
      r.writeUInt32BE(u);
    }
    e.push(r.buffer);
    for (const c of this.hashes)
      n(c, "hex");
    const s = new di(Me.alloc(this.hashes.length * 4));
    for (const c of this.hashes)
      s.writeUInt32BE(this.crcs[c]);
    e.push(s.buffer);
    const i = new di(Me.alloc(this.hashes.length * 4));
    for (const c of this.hashes)
      i.writeUInt32BE(this.offsets.get(c));
    e.push(i.buffer), n(this.packfileSha, "hex");
    const o = Me.concat(e), a = await vu(o), l = Me.alloc(20);
    return l.write(a, "hex"), Me.concat([o, l]);
  }
  async load({ pack: e }) {
    this.pack = e;
  }
  async unload() {
    this.pack = null;
  }
  async read({ oid: e }) {
    if (!this.offsets.get(e)) {
      if (this.getExternalRefDelta)
        return this.externalReadDepth++, this.getExternalRefDelta(e);
      throw new st(`Could not read object ${e} from packfile`);
    }
    const n = this.offsets.get(e);
    return this.readSlice({ start: n });
  }
  async readSlice({ start: e }) {
    if (this.offsetCache[e])
      return Object.assign({}, this.offsetCache[e]);
    this.readDepth++;
    const n = {
      16: "commit",
      32: "tree",
      48: "blob",
      64: "tag",
      96: "ofs_delta",
      112: "ref_delta"
    };
    if (!this.pack)
      throw new st(
        "Tried to read from a GitPackIndex with no packfile loaded into memory"
      );
    const r = (await this.pack).slice(e), s = new di(r), i = s.readUInt8(), o = i & 112;
    let a = n[o];
    if (a === void 0)
      throw new st("Unrecognized type: 0b" + o.toString(2));
    const l = i & 15;
    let c = l;
    i & 128 && (c = l9e(s, l));
    let h = null, d = null;
    if (a === "ofs_delta") {
      const g = a9e(s), y = e - g;
      ({ object: h, type: a } = await this.readSlice({ start: y }));
    }
    if (a === "ref_delta") {
      const g = s.slice(20).toString("hex");
      ({ object: h, type: a } = await this.read({ oid: g }));
    }
    const f = r.slice(s.tell());
    if (d = Me.from(await LY(f)), d.byteLength !== c)
      throw new st(
        `Packfile told us object would have length ${c} but it had length ${d.byteLength}`
      );
    return h && (d = Me.from(n9e(d, h))), this.readDepth > 3 && (this.offsetCache[e] = { type: a, object: d }), { type: a, format: "content", object: d };
  }
}
const sg = Symbol("PackfileCache");
async function c9e({
  fs: t,
  filename: e,
  getExternalRefDelta: n,
  emitter: r,
  emitterPrefix: s
}) {
  const i = await t.read(e);
  return Pf.fromIdx({ idx: i, getExternalRefDelta: n });
}
function MY({
  fs: t,
  cache: e,
  filename: n,
  getExternalRefDelta: r,
  emitter: s,
  emitterPrefix: i
}) {
  e[sg] || (e[sg] = /* @__PURE__ */ new Map());
  let o = e[sg].get(n);
  return o || (o = c9e({
    fs: t,
    filename: n,
    getExternalRefDelta: r,
    emitter: s,
    emitterPrefix: i
  }), e[sg].set(n, o)), o;
}
async function u9e({
  fs: t,
  cache: e,
  gitdir: n,
  oid: r,
  format: s = "content",
  getExternalRefDelta: i
}) {
  let o = await t.readdir(rn.join(n, "objects/pack"));
  o = o.filter((a) => a.endsWith(".idx"));
  for (const a of o) {
    const l = `${n}/objects/pack/${a}`, c = await MY({
      fs: t,
      cache: e,
      filename: l,
      getExternalRefDelta: i
    });
    if (c.error) throw new st(c.error);
    if (c.offsets.has(r)) {
      if (!c.pack) {
        const h = l.replace(/idx$/, "pack");
        c.pack = t.read(h);
      }
      const u = await c.read({ oid: r, getExternalRefDelta: i });
      return u.format = "content", u.source = `objects/pack/${a.replace(/idx$/, "pack")}`, u;
    }
  }
  return null;
}
async function pa({
  fs: t,
  cache: e,
  gitdir: n,
  oid: r,
  format: s = "content"
}) {
  const i = (u) => pa({ fs: t, cache: e, gitdir: n, oid: u });
  let o;
  if (r === "4b825dc642cb6eb9a060e54bf8d69288fbee4904" && (o = { format: "wrapped", object: Me.from("tree 0\0") }), o || (o = await t9e({ fs: t, gitdir: n, oid: r })), !o) {
    if (o = await u9e({
      fs: t,
      cache: e,
      gitdir: n,
      oid: r,
      getExternalRefDelta: i
    }), !o)
      throw new yi(r);
    return o;
  }
  if (s === "deflated" || (o.format === "deflated" && (o.object = Me.from(await LY(o.object)), o.format = "wrapped"), s === "wrapped"))
    return o;
  const a = await vu(o.object);
  if (a !== r)
    throw new st(
      `SHA check failed! Expected ${r}, computed ${a}`
    );
  const { object: l, type: c } = y2.unwrap(o.object);
  if (o.type = c, o.object = l, o.format = "content", s === "content")
    return o;
  throw new st(`invalid requested format "${s}"`);
}
class C_ extends bt {
  /**
   * @param {'note'|'remote'|'tag'|'branch'} noun
   * @param {string} where
   * @param {boolean} canForce
   */
  constructor(e, n, r = !0) {
    super(
      `Failed to create ${e} at ${n} because it already exists.${r ? ` (Hint: use 'force: true' parameter to overwrite existing ${e}.)` : ""}`
    ), this.code = this.name = C_.code, this.data = { noun: e, where: n, canForce: r };
  }
}
C_.code = "AlreadyExistsError";
class b2 extends bt {
  /**
   * @param {'oids'|'refs'} nouns
   * @param {string} short
   * @param {string[]} matches
   */
  constructor(e, n, r) {
    super(
      `Found multiple ${e} matching "${n}" (${r.join(
        ", "
      )}). Use a longer abbreviation length to disambiguate them.`
    ), this.code = this.name = b2.code, this.data = { nouns: e, short: n, matches: r };
  }
}
b2.code = "AmbiguousError";
class k_ extends bt {
  /**
   * @param {string[]} filepaths
   */
  constructor(e) {
    super(
      `Your local changes to the following files would be overwritten by checkout: ${e.join(
        ", "
      )}`
    ), this.code = this.name = k_.code, this.data = { filepaths: e };
  }
}
k_.code = "CheckoutConflictError";
class A_ extends bt {
  /**
   * @param {string} ref
   * @param {string} oid
   */
  constructor(e, n) {
    super(
      `Failed to checkout "${e}" because commit ${n} is not available locally. Do a git fetch to make the branch available locally.`
    ), this.code = this.name = A_.code, this.data = { ref: e, oid: n };
  }
}
A_.code = "CommitNotFetchedError";
class R_ extends bt {
  constructor() {
    super("Empty response from git server."), this.code = this.name = R_.code, this.data = {};
  }
}
R_.code = "EmptyServerResponseError";
class _2 extends bt {
  constructor() {
    super("A simple fast-forward merge was not possible."), this.code = this.name = _2.code, this.data = {};
  }
}
_2.code = "FastForwardError";
class v2 extends bt {
  /**
   * @param {string} prettyDetails
   * @param {PushResult} result
   */
  constructor(e, n) {
    super(`One or more branches were not updated: ${e}`), this.code = this.name = v2.code, this.data = { prettyDetails: e, result: n };
  }
}
v2.code = "GitPushError";
class Of extends bt {
  /**
   * @param {number} statusCode
   * @param {string} statusMessage
   * @param {string} response
   */
  constructor(e, n, r) {
    super(`HTTP Error: ${e} ${n}`), this.code = this.name = Of.code, this.data = { statusCode: e, statusMessage: n, response: r };
  }
}
Of.code = "HttpError";
class w2 extends bt {
  /**
   * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]
   */
  constructor(e) {
    let n = "invalid filepath";
    e === "leading-slash" || e === "trailing-slash" ? n = '"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.' : e === "directory" && (n = '"filepath" should not be a directory.'), super(n), this.code = this.name = w2.code, this.data = { reason: e };
  }
}
w2.code = "InvalidFilepathError";
class I_ extends bt {
  /**
   * @param {string} ref
   * @param {string} suggestion
   * @param {boolean} canForce
   */
  constructor(e, n) {
    super(
      `"${e}" would be an invalid git reference. (Hint: a valid alternative would be "${n}".)`
    ), this.code = this.name = I_.code, this.data = { ref: e, suggestion: n };
  }
}
I_.code = "InvalidRefNameError";
class E2 extends bt {
  /**
   * @param {number} depth
   */
  constructor(e) {
    super(`Maximum search depth of ${e} exceeded.`), this.code = this.name = E2.code, this.data = { depth: e };
  }
}
E2.code = "MaxDepthError";
class S2 extends bt {
  constructor() {
    super("Merges with conflicts are not supported yet."), this.code = this.name = S2.code, this.data = {};
  }
}
S2.code = "MergeNotSupportedError";
class x2 extends bt {
  /**
   * @param {Array<string>} filepaths
   * @param {Array<string>} bothModified
   * @param {Array<string>} deleteByUs
   * @param {Array<string>} deleteByTheirs
   */
  constructor(e, n, r, s) {
    super(
      `Automatic merge failed with one or more merge conflicts in the following files: ${e.toString()}. Fix conflicts then commit the result.`
    ), this.code = this.name = x2.code, this.data = { filepaths: e, bothModified: n, deleteByUs: r, deleteByTheirs: s };
  }
}
x2.code = "MergeConflictError";
class T2 extends bt {
  /**
   * @param {'author'|'committer'|'tagger'} role
   */
  constructor(e) {
    super(
      `No name was provided for ${e} in the argument or in the .git/config file.`
    ), this.code = this.name = T2.code, this.data = { role: e };
  }
}
T2.code = "MissingNameError";
class Dp extends bt {
  /**
   * @param {string} parameter
   */
  constructor(e) {
    super(
      `The function requires a "${e}" parameter but none was provided.`
    ), this.code = this.name = Dp.code, this.data = { parameter: e };
  }
}
Dp.code = "MissingParameterError";
class C2 extends bt {
  /**
   * @param {Error[]} errors
   * @param {string} message
   */
  constructor(e) {
    super(
      'There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'
    ), this.code = this.name = C2.code, this.data = { errors: e }, this.errors = e;
  }
}
C2.code = "MultipleGitError";
class Np extends bt {
  /**
   * @param {string} expected
   * @param {string} actual
   */
  constructor(e, n) {
    super(`Expected "${e}" but received "${n}".`), this.code = this.name = Np.code, this.data = { expected: e, actual: n };
  }
}
Np.code = "ParseError";
class k2 extends bt {
  /**
   * @param {'not-fast-forward'|'tag-exists'} reason
   */
  constructor(e) {
    let n = "";
    e === "not-fast-forward" ? n = " because it was not a simple fast-forward" : e === "tag-exists" && (n = " because tag already exists"), super(`Push rejected${n}. Use "force: true" to override.`), this.code = this.name = k2.code, this.data = { reason: e };
  }
}
k2.code = "PushRejectedError";
class Xa extends bt {
  /**
   * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
   * @param {'depth'|'since'|'exclude'|'relative'} parameter
   */
  constructor(e, n) {
    super(
      `Remote does not support the "${e}" so the "${n}" parameter cannot be used.`
    ), this.code = this.name = Xa.code, this.data = { capability: e, parameter: n };
  }
}
Xa.code = "RemoteCapabilityError";
class P_ extends bt {
  /**
   * @param {string} preview
   * @param {string} response
   */
  constructor(e, n) {
    super(
      `Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${e}`
    ), this.code = this.name = P_.code, this.data = { preview: e, response: n };
  }
}
P_.code = "SmartHttpError";
class O_ extends bt {
  /**
   * @param {string} url
   * @param {string} transport
   * @param {string} [suggestion]
   */
  constructor(e, n, r) {
    super(
      `Git remote "${e}" uses an unrecognized transport protocol: "${n}"`
    ), this.code = this.name = O_.code, this.data = { url: e, transport: n, suggestion: r };
  }
}
O_.code = "UnknownTransportError";
class D_ extends bt {
  /**
   * @param {string} url
   */
  constructor(e) {
    super(`Cannot parse remote URL: "${e}"`), this.code = this.name = D_.code, this.data = { url: e };
  }
}
D_.code = "UrlParseError";
class N_ extends bt {
  constructor() {
    super("The operation was canceled."), this.code = this.name = N_.code, this.data = {};
  }
}
N_.code = "UserCanceledError";
class A2 extends bt {
  /**
   * @param {Array<string>} filepaths
   */
  constructor(e) {
    super(
      `Could not merge index: Entry for '${e}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`
    ), this.code = this.name = A2.code, this.data = { filepath: e };
  }
}
A2.code = "IndexResetError";
class R2 extends bt {
  /**
   * @param {string} ref
   */
  constructor(e) {
    super(
      `"${e}" does not point to any commit. You're maybe working on a repository with no commits yet. `
    ), this.code = this.name = R2.code, this.data = { ref: e };
  }
}
R2.code = "NoCommitError";
function vT({ name: t, email: e, timestamp: n, timezoneOffset: r }) {
  return r = h9e(r), `${t} <${e}> ${n} ${r}`;
}
function h9e(t) {
  const e = d9e(f9e(t));
  t = Math.abs(t);
  const n = Math.floor(t / 60);
  t -= n * 60;
  let r = String(n), s = String(t);
  return r.length < 2 && (r = "0" + r), s.length < 2 && (s = "0" + s), (e === -1 ? "-" : "+") + r + s;
}
function d9e(t) {
  return Math.sign(t) || (Object.is(t, -0) ? -1 : 1);
}
function f9e(t) {
  return t === 0 ? t : -t;
}
function Hi(t) {
  return t = t.replace(/\r/g, ""), t = t.replace(/^\n+/, ""), t = t.replace(/\n+$/, "") + `
`, t;
}
function Zy(t) {
  const [, e, n, r, s] = t.match(
    /^(.*) <(.*)> (.*) (.*)$/
  );
  return {
    name: e,
    email: n,
    timestamp: Number(r),
    timezoneOffset: p9e(s)
  };
}
function p9e(t) {
  let [, e, n, r] = t.match(/(\+|-)(\d\d)(\d\d)/);
  return r = (e === "+" ? 1 : -1) * (Number(n) * 60 + Number(r)), m9e(r);
}
function m9e(t) {
  return t === 0 ? t : -t;
}
class _d {
  constructor(e) {
    if (typeof e == "string")
      this._tag = e;
    else if (Me.isBuffer(e))
      this._tag = e.toString("utf8");
    else if (typeof e == "object")
      this._tag = _d.render(e);
    else
      throw new st(
        "invalid type passed to GitAnnotatedTag constructor"
      );
  }
  static from(e) {
    return new _d(e);
  }
  static render(e) {
    return `object ${e.object}
type ${e.type}
tag ${e.tag}
tagger ${vT(e.tagger)}

${e.message}
${e.gpgsig ? e.gpgsig : ""}`;
  }
  justHeaders() {
    return this._tag.slice(0, this._tag.indexOf(`

`));
  }
  message() {
    const e = this.withoutSignature();
    return e.slice(e.indexOf(`

`) + 2);
  }
  parse() {
    return Object.assign(this.headers(), {
      message: this.message(),
      gpgsig: this.gpgsig()
    });
  }
  render() {
    return this._tag;
  }
  headers() {
    const e = this.justHeaders().split(`
`), n = [];
    for (const s of e)
      s[0] === " " ? n[n.length - 1] += `
` + s.slice(1) : n.push(s);
    const r = {};
    for (const s of n) {
      const i = s.slice(0, s.indexOf(" ")), o = s.slice(s.indexOf(" ") + 1);
      Array.isArray(r[i]) ? r[i].push(o) : r[i] = o;
    }
    return r.tagger && (r.tagger = Zy(r.tagger)), r.committer && (r.committer = Zy(r.committer)), r;
  }
  withoutSignature() {
    const e = Hi(this._tag);
    return e.indexOf(`
-----BEGIN PGP SIGNATURE-----`) === -1 ? e : e.slice(0, e.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`));
  }
  gpgsig() {
    if (this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`) === -1) return;
    const e = this._tag.slice(
      this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._tag.indexOf("-----END PGP SIGNATURE-----") + 27
    );
    return Hi(e);
  }
  payload() {
    return this.withoutSignature() + `
`;
  }
  toObject() {
    return Me.from(this._tag, "utf8");
  }
  static async sign(e, n, r) {
    const s = e.payload();
    let { signature: i } = await n({ payload: s, secretKey: r });
    i = Hi(i);
    const o = s + i;
    return _d.from(o);
  }
}
function y1(t) {
  return t.trim().split(`
`).map((e) => " " + e).join(`
`) + `
`;
}
function g9e(t) {
  return t.split(`
`).map((e) => e.replace(/^ /, "")).join(`
`);
}
class cr {
  constructor(e) {
    if (typeof e == "string")
      this._commit = e;
    else if (Me.isBuffer(e))
      this._commit = e.toString("utf8");
    else if (typeof e == "object")
      this._commit = cr.render(e);
    else
      throw new st("invalid type passed to GitCommit constructor");
  }
  static fromPayloadSignature({ payload: e, signature: n }) {
    const r = cr.justHeaders(e), s = cr.justMessage(e), i = Hi(
      r + `
gpgsig` + y1(n) + `
` + s
    );
    return new cr(i);
  }
  static from(e) {
    return new cr(e);
  }
  toObject() {
    return Me.from(this._commit, "utf8");
  }
  // Todo: allow setting the headers and message
  headers() {
    return this.parseHeaders();
  }
  // Todo: allow setting the headers and message
  message() {
    return cr.justMessage(this._commit);
  }
  parse() {
    return Object.assign({ message: this.message() }, this.headers());
  }
  static justMessage(e) {
    return Hi(e.slice(e.indexOf(`

`) + 2));
  }
  static justHeaders(e) {
    return e.slice(0, e.indexOf(`

`));
  }
  parseHeaders() {
    const e = cr.justHeaders(this._commit).split(`
`), n = [];
    for (const s of e)
      s[0] === " " ? n[n.length - 1] += `
` + s.slice(1) : n.push(s);
    const r = {
      parent: []
    };
    for (const s of n) {
      const i = s.slice(0, s.indexOf(" ")), o = s.slice(s.indexOf(" ") + 1);
      Array.isArray(r[i]) ? r[i].push(o) : r[i] = o;
    }
    return r.author && (r.author = Zy(r.author)), r.committer && (r.committer = Zy(r.committer)), r;
  }
  static renderHeaders(e) {
    let n = "";
    if (e.tree ? n += `tree ${e.tree}
` : n += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`, e.parent) {
      if (e.parent.length === void 0)
        throw new st("commit 'parent' property should be an array");
      for (const i of e.parent)
        n += `parent ${i}
`;
    }
    const r = e.author;
    n += `author ${vT(r)}
`;
    const s = e.committer || e.author;
    return n += `committer ${vT(s)}
`, e.gpgsig && (n += "gpgsig" + y1(e.gpgsig)), n;
  }
  static render(e) {
    return cr.renderHeaders(e) + `
` + Hi(e.message);
  }
  render() {
    return this._commit;
  }
  withoutSignature() {
    const e = Hi(this._commit);
    if (e.indexOf(`
gpgsig`) === -1) return e;
    const n = e.slice(0, e.indexOf(`
gpgsig`)), r = e.slice(
      e.indexOf(`-----END PGP SIGNATURE-----
`) + 28
    );
    return Hi(n + `
` + r);
  }
  isolateSignature() {
    const e = this._commit.slice(
      this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._commit.indexOf("-----END PGP SIGNATURE-----") + 27
    );
    return g9e(e);
  }
  static async sign(e, n, r) {
    const s = e.withoutSignature(), i = cr.justMessage(e._commit);
    let { signature: o } = await n({ payload: s, secretKey: r });
    o = Hi(o);
    const l = cr.justHeaders(e._commit) + `
gpgsig` + y1(o) + `
` + i;
    return cr.from(l);
  }
}
async function wT({ fs: t, cache: e, gitdir: n, oid: r }) {
  if (r === "4b825dc642cb6eb9a060e54bf8d69288fbee4904")
    return { tree: If.from([]), oid: r };
  const { type: s, object: i } = await pa({ fs: t, cache: e, gitdir: n, oid: r });
  if (s === "tag")
    return r = _d.from(i).parse().object, wT({ fs: t, cache: e, gitdir: n, oid: r });
  if (s === "commit")
    return r = cr.from(i).parse().tree, wT({ fs: t, cache: e, gitdir: n, oid: r });
  if (s !== "tree")
    throw new Op(r, s, "tree");
  return { tree: If.from(i), oid: r };
}
class y9e {
  constructor({ fs: e, gitdir: n, ref: r, cache: s }) {
    this.fs = e, this.cache = s, this.gitdir = n, this.mapPromise = (async () => {
      const o = /* @__PURE__ */ new Map();
      let a;
      try {
        a = await ht.resolve({ fs: e, gitdir: n, ref: r });
      } catch (c) {
        c instanceof yi && (a = "4b825dc642cb6eb9a060e54bf8d69288fbee4904");
      }
      const l = await wT({ fs: e, cache: this.cache, gitdir: n, oid: a });
      return l.type = "tree", l.mode = "40000", o.set(".", l), o;
    })();
    const i = this;
    this.ConstructEntry = class {
      constructor(a) {
        this._fullpath = a, this._type = !1, this._mode = !1, this._stat = !1, this._content = !1, this._oid = !1;
      }
      async type() {
        return i.type(this);
      }
      async mode() {
        return i.mode(this);
      }
      async stat() {
        return i.stat(this);
      }
      async content() {
        return i.content(this);
      }
      async oid() {
        return i.oid(this);
      }
    };
  }
  async readdir(e) {
    const n = e._fullpath, { fs: r, cache: s, gitdir: i } = this, o = await this.mapPromise, a = o.get(n);
    if (!a) throw new Error(`No obj for ${n}`);
    const l = a.oid;
    if (!l) throw new Error(`No oid for obj ${JSON.stringify(a)}`);
    if (a.type !== "tree")
      return null;
    const { type: c, object: u } = await pa({ fs: r, cache: s, gitdir: i, oid: l });
    if (c !== a.type)
      throw new Op(l, c, a.type);
    const h = If.from(u);
    for (const d of h)
      o.set(rn.join(n, d.path), d);
    return h.entries().map((d) => rn.join(n, d.path));
  }
  async type(e) {
    if (e._type === !1) {
      const n = await this.mapPromise, { type: r } = n.get(e._fullpath);
      e._type = r;
    }
    return e._type;
  }
  async mode(e) {
    if (e._mode === !1) {
      const n = await this.mapPromise, { mode: r } = n.get(e._fullpath);
      e._mode = IY(parseInt(r, 8));
    }
    return e._mode;
  }
  async stat(e) {
  }
  async content(e) {
    if (e._content === !1) {
      const n = await this.mapPromise, { fs: r, cache: s, gitdir: i } = this, a = n.get(e._fullpath).oid, { type: l, object: c } = await pa({ fs: r, cache: s, gitdir: i, oid: a });
      l !== "blob" ? e._content = void 0 : e._content = new Uint8Array(c);
    }
    return e._content;
  }
  async oid(e) {
    if (e._oid === !1) {
      const r = (await this.mapPromise).get(e._fullpath);
      e._oid = r.oid;
    }
    return e._oid;
  }
}
function b9e({ ref: t = "HEAD" } = {}) {
  const e = /* @__PURE__ */ Object.create(null);
  return Object.defineProperty(e, x_, {
    value: function({ fs: n, gitdir: r, cache: s }) {
      return new y9e({ fs: n, gitdir: r, ref: t, cache: s });
    }
  }), Object.freeze(e), e;
}
class _9e {
  constructor({ fs: e, dir: n, gitdir: r, cache: s }) {
    this.fs = e, this.cache = s, this.dir = n, this.gitdir = r;
    const i = this;
    this.ConstructEntry = class {
      constructor(a) {
        this._fullpath = a, this._type = !1, this._mode = !1, this._stat = !1, this._content = !1, this._oid = !1;
      }
      async type() {
        return i.type(this);
      }
      async mode() {
        return i.mode(this);
      }
      async stat() {
        return i.stat(this);
      }
      async content() {
        return i.content(this);
      }
      async oid() {
        return i.oid(this);
      }
    };
  }
  async readdir(e) {
    const n = e._fullpath, { fs: r, dir: s } = this, i = await r.readdir(rn.join(s, n));
    return i === null ? null : i.map((o) => rn.join(n, o));
  }
  async type(e) {
    return e._type === !1 && await e.stat(), e._type;
  }
  async mode(e) {
    return e._mode === !1 && await e.stat(), e._mode;
  }
  async stat(e) {
    if (e._stat === !1) {
      const { fs: n, dir: r } = this;
      let s = await n.lstat(`${r}/${e._fullpath}`);
      if (!s)
        throw new Error(
          `ENOENT: no such file or directory, lstat '${e._fullpath}'`
        );
      let i = s.isDirectory() ? "tree" : "blob";
      i === "blob" && !s.isFile() && !s.isSymbolicLink() && (i = "special"), e._type = i, s = _u(s), e._mode = s.mode, s.size === -1 && e._actualSize && (s.size = e._actualSize), e._stat = s;
    }
    return e._stat;
  }
  async content(e) {
    if (e._content === !1) {
      const { fs: n, dir: r, gitdir: s } = this;
      if (await e.type() === "tree")
        e._content = void 0;
      else {
        const o = await (await Ri.get({ fs: n, gitdir: s })).get("core.autocrlf"), a = await n.read(`${r}/${e._fullpath}`, { autocrlf: o });
        e._actualSize = a.length, e._stat && e._stat.size === -1 && (e._stat.size = e._actualSize), e._content = new Uint8Array(a);
      }
    }
    return e._content;
  }
  async oid(e) {
    if (e._oid === !1) {
      const { fs: n, gitdir: r, cache: s } = this;
      let i;
      await bd.acquire({ fs: n, gitdir: r, cache: s }, async function(o) {
        const a = o.entriesMap.get(e._fullpath), l = await e.stat(), u = await (await Ri.get({ fs: n, gitdir: r })).get("core.filemode"), h = typeof je < "u" ? je.platform !== "win32" : !0;
        !a || bT(l, a, u, h) ? await e.content() === void 0 ? i = void 0 : (i = await vu(
          y2.wrap({ type: "blob", object: await e.content() })
        ), a && i === a.oid && (!u || l.mode === a.mode) && bT(l, a, u, h) && o.insert({
          filepath: e._fullpath,
          stats: l,
          oid: i
        })) : i = a.oid;
      }), e._oid = i;
    }
    return e._oid;
  }
}
function v9e() {
  const t = /* @__PURE__ */ Object.create(null);
  return Object.defineProperty(t, x_, {
    value: function({ fs: e, dir: n, gitdir: r, cache: s }) {
      return new _9e({ fs: e, dir: n, gitdir: r, cache: s });
    }
  }), Object.freeze(t), t;
}
function w9e(t, e) {
  const n = e - t;
  return Array.from({ length: n }, (r, s) => t + s);
}
const BY = typeof Array.prototype.flat > "u" ? (t) => t.reduce((e, n) => e.concat(n), []) : (t) => t.flat();
class E9e {
  constructor() {
    this.value = null;
  }
  consider(e) {
    e != null && (this.value === null ? this.value = e : e < this.value && (this.value = e));
  }
  reset() {
    this.value = null;
  }
}
function* S9e(t) {
  const e = new E9e();
  let n;
  const r = [], s = t.length;
  for (let i = 0; i < s; i++)
    r[i] = t[i].next().value, r[i] !== void 0 && e.consider(r[i]);
  if (e.value !== null)
    for (; ; ) {
      const i = [];
      n = e.value, e.reset();
      for (let o = 0; o < s; o++)
        r[o] !== void 0 && r[o] === n ? (i[o] = r[o], r[o] = t[o].next().value) : i[o] = null, r[o] !== void 0 && e.consider(r[o]);
      if (yield i, e.value === null) return;
    }
}
async function x9e({
  fs: t,
  cache: e,
  dir: n,
  gitdir: r,
  trees: s,
  // @ts-ignore
  map: i = async (l, c) => c,
  // The default reducer is a flatmap that filters out undefineds.
  reduce: o = async (l, c) => {
    const u = BY(c);
    return l !== void 0 && u.unshift(l), u;
  },
  // The default iterate function walks all children concurrently
  iterate: a = (l, c) => Promise.all([...c].map(l))
}) {
  const l = s.map(
    (f) => f[x_]({ fs: t, dir: n, gitdir: r, cache: e })
  ), c = new Array(l.length).fill("."), u = w9e(0, l.length), h = async (f) => {
    u.map((p) => {
      f[p] = f[p] && new l[p].ConstructEntry(f[p]);
    });
    const y = (await Promise.all(
      u.map((p) => f[p] ? l[p].readdir(f[p]) : [])
    )).map((p) => p === null ? [] : p).map((p) => p[Symbol.iterator]());
    return {
      entries: f,
      children: S9e(y)
    };
  }, d = async (f) => {
    const { entries: g, children: y } = await h(f), p = g.find((b) => b && b._fullpath)._fullpath, m = await i(p, g);
    if (m !== null) {
      let b = await a(d, y);
      return b = b.filter((_) => _ !== void 0), o(m, b);
    }
  };
  return d(c);
}
async function ET(t, e) {
  const n = await t.readdir(e);
  n == null ? await t.rm(e) : n.length ? await Promise.all(
    n.map((r) => {
      const s = rn.join(e, r);
      return t.lstat(s).then((i) => {
        if (i)
          return i.isDirectory() ? ET(t, s) : t.rm(s);
      });
    })
  ).then(() => t.rmdir(e)) : await t.rmdir(e);
}
function T9e(t) {
  return C9e(t) && H3(t.then) && H3(t.catch);
}
function C9e(t) {
  return t && typeof t == "object";
}
function H3(t) {
  return typeof t == "function";
}
function z3(t) {
  return T9e(((n) => {
    try {
      return n.readFile().catch((r) => r);
    } catch (r) {
      return r;
    }
  })(t));
}
const G3 = [
  "readFile",
  "writeFile",
  "mkdir",
  "rmdir",
  "unlink",
  "stat",
  "lstat",
  "readdir",
  "readlink",
  "symlink"
];
function V3(t, e) {
  if (z3(e))
    for (const n of G3)
      t[`_${n}`] = e[n].bind(e);
  else
    for (const n of G3)
      t[`_${n}`] = h1(e[n].bind(e));
  z3(e) ? e.rm ? t._rm = e.rm.bind(e) : e.rmdir.length > 1 ? t._rm = e.rmdir.bind(e) : t._rm = ET.bind(null, t) : e.rm ? t._rm = h1(e.rm.bind(e)) : e.rmdir.length > 2 ? t._rm = h1(e.rmdir.bind(e)) : t._rm = ET.bind(null, t);
}
class k9e {
  constructor(e) {
    if (typeof e._original_unwrapped_fs < "u") return e;
    const n = Object.getOwnPropertyDescriptor(e, "promises");
    n && n.enumerable ? V3(this, e.promises) : V3(this, e), this._original_unwrapped_fs = e;
  }
  /**
   * Return true if a file exists, false if it doesn't exist.
   * Rethrows errors that aren't related to file existence.
   */
  async exists(e, n = {}) {
    try {
      return await this._stat(e), !0;
    } catch (r) {
      if (r.code === "ENOENT" || r.code === "ENOTDIR" || (r.code || "").includes("ENS"))
        return !1;
      throw console.log('Unhandled error in "FileSystem.exists()" function', r), r;
    }
  }
  /**
   * Return the contents of a file if it exists, otherwise returns null.
   *
   * @param {string} filepath
   * @param {object} [options]
   *
   * @returns {Promise<Buffer|string|null>}
   */
  async read(e, n = {}) {
    try {
      let r = await this._readFile(e, n);
      if (n.autocrlf === "true")
        try {
          r = new TextDecoder("utf8", { fatal: !0 }).decode(r), r = r.replace(/\r\n/g, `
`), r = new TextEncoder().encode(r);
        } catch {
        }
      return typeof r != "string" && (r = Me.from(r)), r;
    } catch {
      return null;
    }
  }
  /**
   * Write a file (creating missing directories if need be) without throwing errors.
   *
   * @param {string} filepath
   * @param {Buffer|Uint8Array|string} contents
   * @param {object|string} [options]
   */
  async write(e, n, r = {}) {
    try {
      await this._writeFile(e, n, r);
      return;
    } catch {
      await this.mkdir(qy(e)), await this._writeFile(e, n, r);
    }
  }
  /**
   * Make a directory (or series of nested directories) without throwing an error if it already exists.
   */
  async mkdir(e, n = !1) {
    try {
      await this._mkdir(e);
      return;
    } catch (r) {
      if (r === null || r.code === "EEXIST") return;
      if (n) throw r;
      if (r.code === "ENOENT") {
        const s = qy(e);
        if (s === "." || s === "/" || s === e) throw r;
        await this.mkdir(s), await this.mkdir(e, !0);
      }
    }
  }
  /**
   * Delete a file without throwing an error if it is already deleted.
   */
  async rm(e) {
    try {
      await this._unlink(e);
    } catch (n) {
      if (n.code !== "ENOENT") throw n;
    }
  }
  /**
   * Delete a directory without throwing an error if it is already deleted.
   */
  async rmdir(e, n) {
    try {
      n && n.recursive ? await this._rm(e, n) : await this._rmdir(e);
    } catch (r) {
      if (r.code !== "ENOENT") throw r;
    }
  }
  /**
   * Read a directory without throwing an error is the directory doesn't exist
   */
  async readdir(e) {
    try {
      const n = await this._readdir(e);
      return n.sort(S_), n;
    } catch (n) {
      return n.code === "ENOTDIR" ? null : [];
    }
  }
  /**
   * Return a flast list of all the files nested inside a directory
   *
   * Based on an elegant concurrent recursive solution from SO
   * https://stackoverflow.com/a/45130990/2168416
   */
  async readdirDeep(e) {
    const n = await this._readdir(e);
    return (await Promise.all(
      n.map(async (s) => {
        const i = e + "/" + s;
        return (await this._stat(i)).isDirectory() ? this.readdirDeep(i) : i;
      })
    )).reduce((s, i) => s.concat(i), []);
  }
  /**
   * Return the Stats of a file/symlink if it exists, otherwise returns null.
   * Rethrows errors that aren't related to file existence.
   */
  async lstat(e) {
    try {
      return await this._lstat(e);
    } catch (n) {
      if (n.code === "ENOENT" || (n.code || "").includes("ENS"))
        return null;
      throw n;
    }
  }
  /**
   * Reads the contents of a symlink if it exists, otherwise returns null.
   * Rethrows errors that aren't related to file existence.
   */
  async readlink(e, n = { encoding: "buffer" }) {
    try {
      const r = await this._readlink(e, n);
      return Me.isBuffer(r) ? r : Me.from(r);
    } catch (r) {
      if (r.code === "ENOENT" || (r.code || "").includes("ENS"))
        return null;
      throw r;
    }
  }
  /**
   * Write the contents of buffer to a symlink.
   */
  async writelink(e, n) {
    return this._symlink(n.toString("utf8"), e);
  }
}
function _h(t, e) {
  if (e === void 0)
    throw new Dp(t);
}
async function A9e({ fs: t, gitdir: e, remote: n, url: r, force: s }) {
  if (n !== P3.clean(n))
    throw new I_(n, P3.clean(n));
  const i = await Ri.get({ fs: t, gitdir: e });
  if ((await i.getSubsections("remote")).includes(n) && r !== await i.get(`remote.${n}.url`))
    throw new C_("remote", n);
  await i.set(`remote.${n}.url`, r), await i.set(
    `remote.${n}.fetch`,
    `+refs/heads/*:refs/remotes/${n}/*`
  ), await Ri.save({ fs: t, gitdir: e, config: i });
}
const R9e = (t, e) => t === "." || e == null || e.length === 0 || e === "." ? !0 : e.length >= t.length ? e.startsWith(t) : t.startsWith(e);
async function I9e({
  fs: t,
  cache: e,
  onProgress: n,
  onPostCheckout: r,
  dir: s,
  gitdir: i,
  remote: o,
  ref: a,
  filepaths: l,
  noCheckout: c,
  noUpdateHead: u,
  dryRun: h,
  force: d,
  track: f = !0
}) {
  let g;
  if (r)
    try {
      g = await ht.resolve({ fs: t, gitdir: i, ref: "HEAD" });
    } catch {
      g = "0000000000000000000000000000000000000000";
    }
  let y;
  try {
    y = await ht.resolve({ fs: t, gitdir: i, ref: a });
  } catch (p) {
    if (a === "HEAD") throw p;
    const m = `${o}/${a}`;
    if (y = await ht.resolve({
      fs: t,
      gitdir: i,
      ref: m
    }), f) {
      const b = await Ri.get({ fs: t, gitdir: i });
      await b.set(`branch.${a}.remote`, o), await b.set(`branch.${a}.merge`, `refs/heads/${a}`), await Ri.save({ fs: t, gitdir: i, config: b });
    }
    await ht.writeRef({
      fs: t,
      gitdir: i,
      ref: `refs/heads/${a}`,
      value: y
    });
  }
  if (!c) {
    let p;
    try {
      p = await P9e({
        fs: t,
        cache: e,
        onProgress: n,
        dir: s,
        gitdir: i,
        ref: a,
        force: d,
        filepaths: l
      });
    } catch (w) {
      throw w instanceof yi && w.data.what === y ? new A_(a, y) : w;
    }
    const m = p.filter(([w]) => w === "conflict").map(([w, E]) => E);
    if (m.length > 0)
      throw new k_(m);
    const b = p.filter(([w]) => w === "error").map(([w, E]) => E);
    if (b.length > 0)
      throw new st(b.join(", "));
    if (h) {
      r && await r({
        previousHead: g,
        newHead: y,
        type: l != null && l.length > 0 ? "file" : "branch"
      });
      return;
    }
    let _ = 0;
    const v = p.length;
    await bd.acquire({ fs: t, gitdir: i, cache: e }, async function(w) {
      await Promise.all(
        p.filter(
          ([E]) => E === "delete" || E === "delete-index"
        ).map(async function([E, x]) {
          const S = `${s}/${x}`;
          E === "delete" && await t.rm(S), w.delete({ filepath: x }), n && await n({
            phase: "Updating workdir",
            loaded: ++_,
            total: v
          });
        })
      );
    }), await bd.acquire({ fs: t, gitdir: i, cache: e }, async function(w) {
      for (const [E, x] of p)
        if (E === "rmdir" || E === "rmdir-index") {
          const S = `${s}/${x}`;
          try {
            E === "rmdir-index" && w.delete({ filepath: x }), await t.rmdir(S), n && await n({
              phase: "Updating workdir",
              loaded: ++_,
              total: v
            });
          } catch (T) {
            if (T.code === "ENOTEMPTY")
              console.log(
                `Did not delete ${x} because directory is not empty`
              );
            else
              throw T;
          }
        }
    }), await Promise.all(
      p.filter(([w]) => w === "mkdir" || w === "mkdir-index").map(async function([w, E]) {
        const x = `${s}/${E}`;
        await t.mkdir(x), n && await n({
          phase: "Updating workdir",
          loaded: ++_,
          total: v
        });
      })
    ), await bd.acquire({ fs: t, gitdir: i, cache: e }, async function(w) {
      await Promise.all(
        p.filter(
          ([E]) => E === "create" || E === "create-index" || E === "update" || E === "mkdir-index"
        ).map(async function([E, x, S, T, R]) {
          const F = `${s}/${x}`;
          try {
            if (E !== "create-index" && E !== "mkdir-index") {
              const { object: M } = await pa({ fs: t, cache: e, gitdir: i, oid: S });
              if (R && await t.rm(F), T === 33188)
                await t.write(F, M);
              else if (T === 33261)
                await t.write(F, M, { mode: 511 });
              else if (T === 40960)
                await t.writelink(F, M);
              else
                throw new st(
                  `Invalid mode 0o${T.toString(8)} detected in blob ${S}`
                );
            }
            const P = await t.lstat(F);
            T === 33261 && (P.mode = 493), E === "mkdir-index" && (P.mode = 57344), w.insert({
              filepath: x,
              stats: P,
              oid: S
            }), n && await n({
              phase: "Updating workdir",
              loaded: ++_,
              total: v
            });
          } catch (P) {
            console.log(P);
          }
        })
      );
    }), r && await r({
      previousHead: g,
      newHead: y,
      type: l != null && l.length > 0 ? "file" : "branch"
    });
  }
  if (!u) {
    const p = await ht.expand({ fs: t, gitdir: i, ref: a });
    p.startsWith("refs/heads") ? await ht.writeSymbolicRef({
      fs: t,
      gitdir: i,
      ref: "HEAD",
      value: p
    }) : await ht.writeRef({ fs: t, gitdir: i, ref: "HEAD", value: y });
  }
}
async function P9e({
  fs: t,
  cache: e,
  onProgress: n,
  dir: r,
  gitdir: s,
  ref: i,
  force: o,
  filepaths: a
}) {
  let l = 0;
  return x9e({
    fs: t,
    cache: e,
    dir: r,
    gitdir: s,
    trees: [b9e({ ref: i }), v9e(), BHe()],
    map: async function(c, [u, h, d]) {
      if (c === ".") return;
      if (a && !a.some((g) => R9e(c, g)))
        return null;
      switch (n && await n({ phase: "Analyzing workdir", loaded: ++l }), [!!d, !!u, !!h].map(Number).join("")) {
        case "000":
          return;
        case "001":
          return o && a && a.includes(c) ? ["delete", c] : void 0;
        case "010":
          switch (await u.type()) {
            case "tree":
              return ["mkdir", c];
            case "blob":
              return [
                "create",
                c,
                await u.oid(),
                await u.mode()
              ];
            case "commit":
              return [
                "mkdir-index",
                c,
                await u.oid(),
                await u.mode()
              ];
            default:
              return [
                "error",
                `new entry Unhandled type ${await u.type()}`
              ];
          }
        case "011":
          switch (`${await u.type()}-${await h.type()}`) {
            case "tree-tree":
              return;
            case "tree-blob":
            case "blob-tree":
              return ["conflict", c];
            case "blob-blob":
              return await u.oid() !== await h.oid() ? o ? [
                "update",
                c,
                await u.oid(),
                await u.mode(),
                await u.mode() !== await h.mode()
              ] : ["conflict", c] : await u.mode() !== await h.mode() ? o ? [
                "update",
                c,
                await u.oid(),
                await u.mode(),
                !0
              ] : ["conflict", c] : [
                "create-index",
                c,
                await u.oid(),
                await u.mode()
              ];
            case "commit-tree":
              return;
            case "commit-blob":
              return ["conflict", c];
            default:
              return ["error", `new entry Unhandled type ${u.type}`];
          }
        case "100":
          return ["delete-index", c];
        case "101":
          switch (await d.type()) {
            case "tree":
              return ["rmdir", c];
            case "blob":
              return await d.oid() !== await h.oid() ? o ? ["delete", c] : ["conflict", c] : ["delete", c];
            case "commit":
              return ["rmdir-index", c];
            default:
              return [
                "error",
                `delete entry Unhandled type ${await d.type()}`
              ];
          }
        case "110":
        case "111":
          switch (`${await d.type()}-${await u.type()}`) {
            case "tree-tree":
              return;
            case "blob-blob": {
              if (await d.oid() === await u.oid() && await d.mode() === await u.mode() && !o)
                return;
              if (h) {
                if (await h.oid() !== await d.oid() && await h.oid() !== await u.oid())
                  return o ? [
                    "update",
                    c,
                    await u.oid(),
                    await u.mode(),
                    await u.mode() !== await h.mode()
                  ] : ["conflict", c];
              } else if (o)
                return [
                  "update",
                  c,
                  await u.oid(),
                  await u.mode(),
                  await u.mode() !== await d.mode()
                ];
              return await u.mode() !== await d.mode() ? [
                "update",
                c,
                await u.oid(),
                await u.mode(),
                !0
              ] : await u.oid() !== await d.oid() ? [
                "update",
                c,
                await u.oid(),
                await u.mode(),
                !1
              ] : void 0;
            }
            case "tree-blob":
              return ["update-dir-to-blob", c, await u.oid()];
            case "blob-tree":
              return ["update-blob-to-tree", c];
            case "commit-commit":
              return [
                "mkdir-index",
                c,
                await u.oid(),
                await u.mode()
              ];
            default:
              return [
                "error",
                `update entry Unhandled type ${await d.type()}-${await u.type()}`
              ];
          }
      }
    },
    // Modify the default flat mapping
    reduce: async function(c, u) {
      return u = BY(u), c ? c && c[0] === "rmdir" ? (u.push(c), u) : (u.unshift(c), u) : u;
    }
  });
}
const O9e = new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");
function FY(t) {
  const e = O9e.exec(t);
  return e ? e[1] === "remotes/" && t.endsWith("/HEAD") ? e[2].slice(0, -5) : e[2] : t;
}
async function D9e({
  fs: t,
  gitdir: e,
  fullname: n = !1,
  test: r = !1
}) {
  const s = await ht.resolve({
    fs: t,
    gitdir: e,
    ref: "HEAD",
    depth: 2
  });
  if (r)
    try {
      await ht.resolve({ fs: t, gitdir: e, ref: s });
    } catch {
      return;
    }
  if (s.startsWith("refs/"))
    return n ? s : FY(s);
}
function N9e(t) {
  return t = t.replace(/^git@([^:]+):/, "https://$1/"), t = t.replace(/^ssh:\/\//, "https://"), t;
}
function $Y({ username: t = "", password: e = "" }) {
  return `Basic ${Me.from(`${t}:${e}`).toString("base64")}`;
}
async function L_(t, e) {
  const n = DY(t);
  for (; ; ) {
    const { value: r, done: s } = await n.next();
    if (r && await e(r), s) break;
  }
  n.return && n.return();
}
async function ST(t) {
  let e = 0;
  const n = [];
  await L_(t, (i) => {
    n.push(i), e += i.byteLength;
  });
  const r = new Uint8Array(e);
  let s = 0;
  for (const i of n)
    r.set(i, s), s += i.byteLength;
  return r;
}
function W3(t) {
  let e = t.match(/^https?:\/\/([^/]+)@/);
  if (e == null) return { url: t, auth: {} };
  e = e[1];
  const [n, r] = e.split(":");
  return t = t.replace(`${e}@`, ""), { url: t, auth: { username: n, password: r } };
}
function L9e(t, e) {
  const n = e.toString(16);
  return "0".repeat(t - n.length) + n;
}
class Qs {
  static flush() {
    return Me.from("0000", "utf8");
  }
  static delim() {
    return Me.from("0001", "utf8");
  }
  static encode(e) {
    typeof e == "string" && (e = Me.from(e));
    const n = e.length + 4, r = L9e(4, n);
    return Me.concat([Me.from(r, "utf8"), e]);
  }
  static streamReader(e) {
    const n = new NY(e);
    return async function() {
      try {
        let s = await n.read(4);
        if (s == null) return !0;
        if (s = parseInt(s.toString("utf8"), 16), s === 0 || s === 1) return null;
        const i = await n.read(s - 4);
        return i ?? !0;
      } catch (s) {
        return e.error = s, !0;
      }
    };
  }
}
async function q3(t) {
  const e = {};
  let n;
  for (; n = await t(), n !== !0; ) {
    if (n === null) continue;
    n = n.toString("utf8").replace(/\n$/, "");
    const r = n.indexOf("=");
    if (r > -1) {
      const s = n.slice(0, r), i = n.slice(r + 1);
      e[s] = i;
    } else
      e[n] = !0;
  }
  return { protocolVersion: 2, capabilities2: e };
}
async function K3(t, { service: e }) {
  const n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = Qs.streamReader(t);
  let o = await i();
  for (; o === null; ) o = await i();
  if (o === !0) throw new R_();
  if (o.includes("version 2"))
    return q3(i);
  if (o.toString("utf8").replace(/\n$/, "") !== `# service=${e}`)
    throw new Np(`# service=${e}\\n`, o.toString("utf8"));
  let a = await i();
  for (; a === null; ) a = await i();
  if (a === !0) return { capabilities: n, refs: r, symrefs: s };
  if (a = a.toString("utf8"), a.includes("version 2"))
    return q3(i);
  const [l, c] = b1(a, "\0", "\\x00");
  if (c.split(" ").map((u) => n.add(u)), l !== "0000000000000000000000000000000000000000 capabilities^{}") {
    const [u, h] = b1(l, " ", " ");
    for (r.set(h, u); ; ) {
      const d = await i();
      if (d === !0) break;
      if (d !== null) {
        const [f, g] = b1(d.toString("utf8"), " ", " ");
        r.set(g, f);
      }
    }
  }
  for (const u of n)
    if (u.startsWith("symref=")) {
      const h = u.match(/symref=([^:]+):(.*)/);
      h.length === 3 && s.set(h[1], h[2]);
    }
  return { protocolVersion: 1, capabilities: n, refs: r, symrefs: s };
}
function b1(t, e, n) {
  const r = t.trim().split(e);
  if (r.length !== 2)
    throw new Np(
      `Two strings separated by '${n}'`,
      t.toString("utf8")
    );
  return r;
}
const Y3 = (t, e) => t.endsWith("?") ? `${t}${e}` : `${t}/${e.replace(/^https?:\/\//, "")}`, Z3 = (t, e) => {
  (e.username || e.password) && (t.Authorization = $Y(e)), e.headers && Object.assign(t, e.headers);
}, _1 = async (t) => {
  try {
    const e = Me.from(await ST(t.body)), n = e.toString("utf8");
    return { preview: n.length < 256 ? n : n.slice(0, 256) + "...", response: n, data: e };
  } catch {
    return {};
  }
};
class J3 {
  static async capabilities() {
    return ["discover", "connect"];
  }
  /**
   * @param {Object} args
   * @param {HttpClient} args.http
   * @param {ProgressCallback} [args.onProgress]
   * @param {AuthCallback} [args.onAuth]
   * @param {AuthFailureCallback} [args.onAuthFailure]
   * @param {AuthSuccessCallback} [args.onAuthSuccess]
   * @param {string} [args.corsProxy]
   * @param {string} args.service
   * @param {string} args.url
   * @param {Object<string, string>} args.headers
   * @param {1 | 2} args.protocolVersion - Git Protocol Version
   */
  static async discover({
    http: e,
    onProgress: n,
    onAuth: r,
    onAuthSuccess: s,
    onAuthFailure: i,
    corsProxy: o,
    service: a,
    url: l,
    headers: c,
    protocolVersion: u
  }) {
    let { url: h, auth: d } = W3(l);
    const f = o ? Y3(o, h) : h;
    (d.username || d.password) && (c.Authorization = $Y(d)), u === 2 && (c["Git-Protocol"] = "version=2");
    let g, y, p = !1;
    do
      if (g = await e.request({
        onProgress: n,
        method: "GET",
        url: `${f}/info/refs?service=${a}`,
        headers: c
      }), y = !1, g.statusCode === 401 || g.statusCode === 203) {
        const m = p ? i : r;
        if (m) {
          if (d = await m(h, {
            ...d,
            headers: { ...c }
          }), d && d.cancel)
            throw new N_();
          d && (Z3(c, d), p = !0, y = !0);
        }
      } else g.statusCode === 200 && p && s && await s(h, d);
    while (y);
    if (g.statusCode !== 200) {
      const { response: m } = await _1(g);
      throw new Of(g.statusCode, g.statusMessage, m);
    }
    if (g.headers["content-type"] === `application/x-${a}-advertisement`) {
      const m = await K3(g.body, { service: a });
      return m.auth = d, m;
    } else {
      const { preview: m, response: b, data: _ } = await _1(g);
      try {
        const v = await K3([_], { service: a });
        return v.auth = d, v;
      } catch {
        throw new P_(m, b);
      }
    }
  }
  /**
   * @param {Object} args
   * @param {HttpClient} args.http
   * @param {ProgressCallback} [args.onProgress]
   * @param {string} [args.corsProxy]
   * @param {string} args.service
   * @param {string} args.url
   * @param {Object<string, string>} [args.headers]
   * @param {any} args.body
   * @param {any} args.auth
   */
  static async connect({
    http: e,
    onProgress: n,
    corsProxy: r,
    service: s,
    url: i,
    auth: o,
    body: a,
    headers: l
  }) {
    const c = W3(i);
    c && (i = c.url), r && (i = Y3(r, i)), l["content-type"] = `application/x-${s}-request`, l.accept = `application/x-${s}-result`, Z3(l, o);
    const u = await e.request({
      onProgress: n,
      method: "POST",
      url: `${i}/${s}`,
      body: a,
      headers: l
    });
    if (u.statusCode !== 200) {
      const { response: h } = _1(u);
      throw new Of(u.statusCode, u.statusMessage, h);
    }
    return u;
  }
}
function M9e({ url: t }) {
  if (t.startsWith("git@"))
    return {
      transport: "ssh",
      address: t
    };
  const e = t.match(/(\w+)(:\/\/|::)(.*)/);
  if (e !== null) {
    if (e[2] === "://")
      return {
        transport: e[1],
        address: e[0]
      };
    if (e[2] === "::")
      return {
        transport: e[1],
        address: e[3]
      };
  }
}
class B9e {
  static getRemoteHelperFor({ url: e }) {
    const n = /* @__PURE__ */ new Map();
    n.set("http", J3), n.set("https", J3);
    const r = M9e({ url: e });
    if (!r)
      throw new D_(e);
    if (n.has(r.transport))
      return n.get(r.transport);
    throw new O_(
      e,
      r.transport,
      r.transport === "ssh" ? N9e(e) : void 0
    );
  }
}
let Ra = null;
class X3 {
  static async read({ fs: e, gitdir: n }) {
    Ra === null && (Ra = new Gy());
    const r = rn.join(n, "shallow"), s = /* @__PURE__ */ new Set();
    return await Ra.acquire(r, async function() {
      const i = await e.read(r, { encoding: "utf8" });
      if (i === null || i.trim() === "") return s;
      i.trim().split(`
`).map((o) => s.add(o));
    }), s;
  }
  static async write({ fs: e, gitdir: n, oids: r }) {
    Ra === null && (Ra = new Gy());
    const s = rn.join(n, "shallow");
    if (r.size > 0) {
      const i = [...r].join(`
`) + `
`;
      await Ra.acquire(s, async function() {
        await e.write(s, i, {
          encoding: "utf8"
        });
      });
    } else
      await Ra.acquire(s, async function() {
        await e.rm(s);
      });
  }
}
async function F9e({ fs: t, gitdir: e, oid: n }) {
  const r = `objects/${n.slice(0, 2)}/${n.slice(2)}`;
  return t.exists(`${e}/${r}`);
}
async function $9e({
  fs: t,
  cache: e,
  gitdir: n,
  oid: r,
  getExternalRefDelta: s
}) {
  let i = await t.readdir(rn.join(n, "objects/pack"));
  i = i.filter((o) => o.endsWith(".idx"));
  for (const o of i) {
    const a = `${n}/objects/pack/${o}`, l = await MY({
      fs: t,
      cache: e,
      filename: a,
      getExternalRefDelta: s
    });
    if (l.error) throw new st(l.error);
    if (l.offsets.has(r))
      return !0;
  }
  return !1;
}
async function Q3({
  fs: t,
  cache: e,
  gitdir: n,
  oid: r,
  format: s = "content"
}) {
  const i = (a) => pa({ fs: t, cache: e, gitdir: n, oid: a });
  let o = await F9e({ fs: t, gitdir: n, oid: r });
  return o || (o = await $9e({
    fs: t,
    cache: e,
    gitdir: n,
    oid: r,
    getExternalRefDelta: i
  })), o;
}
function U9e(t) {
  const s = "5041434b" + "00000002" + "00000000";
  return t.slice(0, 12).toString("hex") === s;
}
function j9e(t, e) {
  const n = t.map((r) => r.split("=", 1)[0]);
  return e.filter((r) => {
    const s = r.split("=", 1)[0];
    return n.includes(s);
  });
}
const H9e = {
  agent: "git/isomorphic-git@1.29.0"
};
class Gg {
  constructor() {
    this._queue = [];
  }
  write(e) {
    if (this._ended)
      throw Error("You cannot write to a FIFO that has already been ended!");
    if (this._waiting) {
      const n = this._waiting;
      this._waiting = null, n({ value: e });
    } else
      this._queue.push(e);
  }
  end() {
    if (this._ended = !0, this._waiting) {
      const e = this._waiting;
      this._waiting = null, e({ done: !0 });
    }
  }
  destroy(e) {
    this.error = e, this.end();
  }
  async next() {
    if (this._queue.length > 0)
      return { value: this._queue.shift() };
    if (this._ended)
      return { done: !0 };
    if (this._waiting)
      throw Error(
        "You cannot call read until the previous call to read has returned!"
      );
    return new Promise((e) => {
      this._waiting = e;
    });
  }
}
function z9e(t) {
  const e = t.indexOf("\r"), n = t.indexOf(`
`);
  return e === -1 && n === -1 ? -1 : e === -1 ? n + 1 : n === -1 ? e + 1 : n === e + 1 ? n + 1 : Math.min(e, n) + 1;
}
function G9e(t) {
  const e = new Gg();
  let n = "";
  return (async () => (await L_(t, (r) => {
    for (r = r.toString("utf8"), n += r; ; ) {
      const s = z9e(n);
      if (s === -1) break;
      e.write(n.slice(0, s)), n = n.slice(s);
    }
  }), n.length > 0 && e.write(n), e.end()))(), e;
}
class V9e {
  static demux(e) {
    const n = Qs.streamReader(e), r = new Gg(), s = new Gg(), i = new Gg(), o = async function() {
      const a = await n();
      if (a === null) return o();
      if (a === !0) {
        r.end(), i.end(), e.error ? s.destroy(e.error) : s.end();
        return;
      }
      switch (a[0]) {
        case 1: {
          s.write(a.slice(1));
          break;
        }
        case 2: {
          i.write(a.slice(1));
          break;
        }
        case 3: {
          const l = a.slice(1);
          i.write(l), r.end(), i.end(), s.destroy(new Error(l.toString("utf8")));
          return;
        }
        default:
          r.write(a);
      }
      o();
    };
    return o(), {
      packetlines: r,
      packfile: s,
      progress: i
    };
  }
  // static mux ({
  //   protocol, // 'side-band' or 'side-band-64k'
  //   packetlines,
  //   packfile,
  //   progress,
  //   error
  // }) {
  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
  //   let output = new PassThrough()
  //   packetlines.on('data', data => {
  //     if (data === null) {
  //       output.write(GitPktLine.flush())
  //     } else {
  //       output.write(GitPktLine.encode(data))
  //     }
  //   })
  //   let packfileWasEmpty = true
  //   let packfileEnded = false
  //   let progressEnded = false
  //   let errorEnded = false
  //   let goodbye = Buffer.concat([
  //     GitPktLine.encode(Buffer.from('010A', 'hex')),
  //     GitPktLine.flush()
  //   ])
  //   packfile
  //     .on('data', data => {
  //       packfileWasEmpty = false
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       packfileEnded = true
  //       if (!packfileWasEmpty) output.write(goodbye)
  //       if (progressEnded && errorEnded) output.end()
  //     })
  //   progress
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       progressEnded = true
  //       if (packfileEnded && errorEnded) output.end()
  //     })
  //   error
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       errorEnded = true
  //       if (progressEnded && packfileEnded) output.end()
  //     })
  //   return output
  // }
}
async function W9e(t) {
  const { packetlines: e, packfile: n, progress: r } = V9e.demux(t), s = [], i = [], o = [];
  let a = !1, l = !1;
  return new Promise((c, u) => {
    L_(e, (h) => {
      const d = h.toString("utf8").trim();
      if (d.startsWith("shallow")) {
        const f = d.slice(-41).trim();
        f.length !== 40 && u(new Pl(f)), s.push(f);
      } else if (d.startsWith("unshallow")) {
        const f = d.slice(-41).trim();
        f.length !== 40 && u(new Pl(f)), i.push(f);
      } else if (d.startsWith("ACK")) {
        const [, f, g] = d.split(" ");
        o.push({ oid: f, status: g }), g || (l = !0);
      } else d.startsWith("NAK") ? (a = !0, l = !0) : (l = !0, a = !0);
      l && (t.error ? u(t.error) : c({ shallows: s, unshallows: i, acks: o, nak: a, packfile: n, progress: r }));
    }).finally(() => {
      l || (t.error ? u(t.error) : c({ shallows: s, unshallows: i, acks: o, nak: a, packfile: n, progress: r }));
    });
  });
}
function q9e({
  capabilities: t = [],
  wants: e = [],
  haves: n = [],
  shallows: r = [],
  depth: s = null,
  since: i = null,
  exclude: o = []
}) {
  const a = [];
  e = [...new Set(e)];
  let l = ` ${t.join(" ")}`;
  for (const c of e)
    a.push(Qs.encode(`want ${c}${l}
`)), l = "";
  for (const c of r)
    a.push(Qs.encode(`shallow ${c}
`));
  s !== null && a.push(Qs.encode(`deepen ${s}
`)), i !== null && a.push(
    Qs.encode(`deepen-since ${Math.floor(i.valueOf() / 1e3)}
`)
  );
  for (const c of o)
    a.push(Qs.encode(`deepen-not ${c}
`));
  a.push(Qs.flush());
  for (const c of n)
    a.push(Qs.encode(`have ${c}
`));
  return a.push(Qs.encode(`done
`)), a;
}
async function K9e({
  fs: t,
  cache: e,
  http: n,
  onProgress: r,
  onMessage: s,
  onAuth: i,
  onAuthSuccess: o,
  onAuthFailure: a,
  gitdir: l,
  ref: c,
  remoteRef: u,
  remote: h,
  url: d,
  corsProxy: f,
  depth: g = null,
  since: y = null,
  exclude: p = [],
  relative: m = !1,
  tags: b = !1,
  singleBranch: _ = !1,
  headers: v = {},
  prune: w = !1,
  pruneTags: E = !1
}) {
  const x = c || await D9e({ fs: t, gitdir: l, test: !0 }), S = await Ri.get({ fs: t, gitdir: l }), T = h || x && await S.get(`branch.${x}.remote`) || "origin", R = d || await S.get(`remote.${T}.url`);
  if (typeof R > "u")
    throw new Dp("remote OR url");
  const F = u || x && await S.get(`branch.${x}.merge`) || c || "HEAD";
  f === void 0 && (f = await S.get("http.corsProxy"));
  const P = B9e.getRemoteHelperFor({ url: R }), M = await P.discover({
    http: n,
    onAuth: i,
    onAuthSuccess: o,
    onAuthFailure: a,
    corsProxy: f,
    service: "git-upload-pack",
    url: R,
    headers: v,
    protocolVersion: 1
  }), A = M.auth, V = M.refs;
  if (V.size === 0)
    return {
      defaultBranch: null,
      fetchHead: null,
      fetchHeadDescription: null
    };
  if (g !== null && !M.capabilities.has("shallow"))
    throw new Xa("shallow", "depth");
  if (y !== null && !M.capabilities.has("deepen-since"))
    throw new Xa("deepen-since", "since");
  if (p.length > 0 && !M.capabilities.has("deepen-not"))
    throw new Xa("deepen-not", "exclude");
  if (m === !0 && !M.capabilities.has("deepen-relative"))
    throw new Xa("deepen-relative", "relative");
  const { oid: ee, fullref: K } = ht.resolveAgainstMap({
    ref: F,
    map: V
  });
  for (const de of V.keys())
    de === K || de === "HEAD" || de.startsWith("refs/heads/") || b && de.startsWith("refs/tags/") || V.delete(de);
  const te = j9e(
    [...M.capabilities],
    [
      "multi_ack_detailed",
      "no-done",
      "side-band-64k",
      // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
      // which is necessary for compatibility with git. It was the cause of mysterious
      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
      // canonical git it turns out is NOT.
      "ofs-delta",
      `agent=${H9e.agent}`
    ]
  );
  m && te.push("deepen-relative");
  const N = _ ? [ee] : V.values(), L = _ ? [x] : await ht.listRefs({
    fs: t,
    gitdir: l,
    filepath: "refs"
  });
  let j = [];
  for (let de of L)
    try {
      de = await ht.expand({ fs: t, gitdir: l, ref: de });
      const _e = await ht.resolve({ fs: t, gitdir: l, ref: de });
      await Q3({ fs: t, cache: e, gitdir: l, oid: _e }) && j.push(_e);
    } catch {
    }
  j = [...new Set(j)];
  const H = await X3.read({ fs: t, gitdir: l }), U = M.capabilities.has("shallow") ? [...H] : [], Y = q9e({
    capabilities: te,
    wants: N,
    haves: j,
    shallows: U,
    depth: g,
    since: y,
    exclude: p
  }), ne = Me.from(await ST(Y)), he = await P.connect({
    http: n,
    onProgress: r,
    corsProxy: f,
    service: "git-upload-pack",
    url: R,
    auth: A,
    body: [ne],
    headers: v
  }), X = await W9e(he.body);
  he.headers && (X.headers = he.headers);
  for (const de of X.shallows)
    if (!H.has(de))
      try {
        const { object: _e } = await pa({ fs: t, cache: e, gitdir: l, oid: de }), $ = new cr(_e), ce = await Promise.all(
          $.headers().parent.map((W) => Q3({ fs: t, cache: e, gitdir: l, oid: W }))
        );
        ce.length === 0 || ce.every((W) => W) || H.add(de);
      } catch {
        H.add(de);
      }
  for (const de of X.unshallows)
    H.delete(de);
  if (await X3.write({ fs: t, gitdir: l, oids: H }), _) {
    const de = /* @__PURE__ */ new Map([[K, ee]]), _e = /* @__PURE__ */ new Map();
    let $ = 10, ce = K;
    for (; $--; ) {
      const q = M.symrefs.get(ce);
      if (q === void 0) break;
      _e.set(ce, q), ce = q;
    }
    const re = V.get(ce);
    re && de.set(ce, re);
    const { pruned: W } = await ht.updateRemoteRefs({
      fs: t,
      gitdir: l,
      remote: T,
      refs: de,
      symrefs: _e,
      tags: b,
      prune: w
    });
    w && (X.pruned = W);
  } else {
    const { pruned: de } = await ht.updateRemoteRefs({
      fs: t,
      gitdir: l,
      remote: T,
      refs: V,
      symrefs: M.symrefs,
      tags: b,
      prune: w,
      pruneTags: E
    });
    w && (X.pruned = de);
  }
  if (X.HEAD = M.symrefs.get("HEAD"), X.HEAD === void 0) {
    const { oid: de } = ht.resolveAgainstMap({
      ref: "HEAD",
      map: V
    });
    for (const [_e, $] of V.entries())
      if (_e !== "HEAD" && $ === de) {
        X.HEAD = _e;
        break;
      }
  }
  const z = K.startsWith("refs/tags") ? "tag" : "branch";
  if (X.FETCH_HEAD = {
    oid: ee,
    description: `${z} '${FY(K)}' of ${R}`
  }, r || s) {
    const de = G9e(X.progress);
    L_(de, async (_e) => {
      if (s && await s(_e), r) {
        const $ = _e.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
        $ && await r({
          phase: $[1].trim(),
          loaded: parseInt($[2], 10),
          total: parseInt($[3], 10)
        });
      }
    });
  }
  const ue = Me.from(await ST(X.packfile));
  if (he.body.error) throw he.body.error;
  const ae = ue.slice(-20).toString("hex"), be = {
    defaultBranch: X.HEAD,
    fetchHead: X.FETCH_HEAD.oid,
    fetchHeadDescription: X.FETCH_HEAD.description
  };
  if (X.headers && (be.headers = X.headers), w && (be.pruned = X.pruned), ae !== "" && !U9e(ue)) {
    be.packfile = `objects/pack/pack-${ae}.pack`;
    const de = rn.join(l, be.packfile);
    await t.write(de, ue);
    const _e = (ce) => pa({ fs: t, cache: e, gitdir: l, oid: ce }), $ = await Pf.fromPack({
      pack: ue,
      getExternalRefDelta: _e,
      onProgress: r
    });
    await t.write(de.replace(/\.pack$/, ".idx"), await $.toBuffer());
  }
  return be;
}
async function Y9e({
  fs: t,
  bare: e = !1,
  dir: n,
  gitdir: r = e ? n : rn.join(n, ".git"),
  defaultBranch: s = "master"
}) {
  if (await t.exists(r + "/config")) return;
  let i = [
    "hooks",
    "info",
    "objects/info",
    "objects/pack",
    "refs/heads",
    "refs/tags"
  ];
  i = i.map((o) => r + "/" + o);
  for (const o of i)
    await t.mkdir(o);
  await t.write(
    r + "/config",
    `[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${e}
` + (e ? "" : `	logallrefupdates = true
`) + `	symlinks = false
	ignorecase = true
`
  ), await t.write(r + "/HEAD", `ref: refs/heads/${s}
`);
}
async function Z9e({
  fs: t,
  cache: e,
  http: n,
  onProgress: r,
  onMessage: s,
  onAuth: i,
  onAuthSuccess: o,
  onAuthFailure: a,
  onPostCheckout: l,
  dir: c,
  gitdir: u,
  url: h,
  corsProxy: d,
  ref: f,
  remote: g,
  depth: y,
  since: p,
  exclude: m,
  relative: b,
  singleBranch: _,
  noCheckout: v,
  noTags: w,
  headers: E
}) {
  try {
    if (await Y9e({ fs: t, gitdir: u }), await A9e({ fs: t, gitdir: u, remote: g, url: h, force: !1 }), d) {
      const T = await Ri.get({ fs: t, gitdir: u });
      await T.set("http.corsProxy", d), await Ri.save({ fs: t, gitdir: u, config: T });
    }
    const { defaultBranch: x, fetchHead: S } = await K9e({
      fs: t,
      cache: e,
      http: n,
      onProgress: r,
      onMessage: s,
      onAuth: i,
      onAuthSuccess: o,
      onAuthFailure: a,
      gitdir: u,
      ref: f,
      remote: g,
      corsProxy: d,
      depth: y,
      since: p,
      exclude: m,
      relative: b,
      singleBranch: _,
      headers: E,
      tags: !w
    });
    if (S === null) return;
    f = f || x, f = f.replace("refs/heads/", ""), await I9e({
      fs: t,
      cache: e,
      onProgress: r,
      onPostCheckout: l,
      dir: c,
      gitdir: u,
      ref: f,
      remote: g,
      noCheckout: v
    });
  } catch (x) {
    throw await t.rmdir(u, { recursive: !0, maxRetries: 10 }).catch(() => {
    }), x;
  }
}
async function J9e({
  fs: t,
  http: e,
  onProgress: n,
  onMessage: r,
  onAuth: s,
  onAuthSuccess: i,
  onAuthFailure: o,
  onPostCheckout: a,
  dir: l,
  gitdir: c = rn.join(l, ".git"),
  url: u,
  corsProxy: h = void 0,
  ref: d = void 0,
  remote: f = "origin",
  depth: g = void 0,
  since: y = void 0,
  exclude: p = [],
  relative: m = !1,
  singleBranch: b = !1,
  noCheckout: _ = !1,
  noTags: v = !1,
  headers: w = {},
  cache: E = {}
}) {
  try {
    return _h("fs", t), _h("http", e), _h("gitdir", c), _ || _h("dir", l), _h("url", u), await Z9e({
      fs: new k9e(t),
      cache: E,
      http: e,
      onProgress: n,
      onMessage: r,
      onAuth: s,
      onAuthSuccess: i,
      onAuthFailure: o,
      onPostCheckout: a,
      dir: l,
      gitdir: c,
      url: u,
      corsProxy: h,
      ref: d,
      remote: f,
      depth: g,
      since: y,
      exclude: p,
      relative: m,
      singleBranch: b,
      noCheckout: _,
      noTags: v,
      headers: w
    });
  } catch (x) {
    throw x.caller = "git.clone", x;
  }
}
var X9e = {
  clone: J9e
};
function Q9e(t) {
  let e = [t];
  return {
    next() {
      return Promise.resolve({ done: e.length === 0, value: e.pop() });
    },
    return() {
      return e = [], {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function e7e(t) {
  return t[Symbol.asyncIterator] ? t[Symbol.asyncIterator]() : t[Symbol.iterator] ? t[Symbol.iterator]() : t.next ? t : Q9e(t);
}
async function t7e(t, e) {
  const n = e7e(t);
  for (; ; ) {
    const { value: r, done: s } = await n.next();
    if (r && await e(r), s) break;
  }
  n.return && n.return();
}
async function n7e(t) {
  let e = 0;
  const n = [];
  await t7e(t, (i) => {
    n.push(i), e += i.byteLength;
  });
  const r = new Uint8Array(e);
  let s = 0;
  for (const i of n)
    r.set(i, s), s += i.byteLength;
  return r;
}
function r7e(t) {
  if (t[Symbol.asyncIterator]) return t;
  const e = t.getReader();
  return {
    next() {
      return e.read();
    },
    return() {
      return e.releaseLock(), {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function s7e({
  onProgress: t,
  url: e,
  method: n = "GET",
  headers: r = {},
  body: s
}) {
  s && (s = await n7e(s));
  const i = await fetch(e, { method: n, headers: r, body: s }), o = i.body && i.body.getReader ? r7e(i.body) : [new Uint8Array(await i.arrayBuffer())];
  r = {};
  for (const [a, l] of i.headers.entries())
    r[a] = l;
  return {
    url: i.url,
    method: i.method,
    statusCode: i.status,
    statusMessage: i.statusText,
    body: o,
    headers: r
  };
}
var i7e = { request: s7e };
const eB = (t) => {
  const e = t.split("/")[2], n = nt.get(`git:${e}`);
  if (!n)
    return null;
  try {
    const { username: r, password: s } = JSON.parse(n || "{}");
    return { username: r, password: s };
  } catch (r) {
    return console.log(`Failed to parse Git Cookie ${r}`), null;
  }
}, o7e = (t, e) => {
  const n = t.split("/")[2];
  nt.set(`git:${n}`, JSON.stringify(e));
};
function a7e() {
  const [t, e] = I.useState(!1), [n, r] = I.useState(), [s, i] = I.useState(), o = I.useRef({});
  I.useEffect(() => {
    La.then((l) => {
      o.current = {}, r(l), i(UY(l, o)), e(!0);
    });
  }, []);
  const a = I.useCallback(
    async (l) => {
      if (!n || !s || !t)
        throw "Webcontainer not initialized";
      o.current = {};
      const c = {
        "User-Agent": "bolt.diy"
      }, u = eB(l);
      u && (c.Authorization = `Basic ${Me.from(`${u.username}:${u.password}`).toString("base64")}`);
      try {
        await X9e.clone({
          fs: s,
          http: i7e,
          dir: n.workdir,
          url: l,
          depth: 1,
          singleBranch: !0,
          corsProxy: "/api/git-proxy",
          headers: c,
          onAuth: (d) => {
            let f = eB(d);
            return f || (confirm("This repo is password protected. Ready to enter a username & password?") ? (f = {
              username: prompt("Enter username"),
              password: prompt("Enter password")
            }, f) : { cancel: !0 });
          },
          onAuthFailure: (d, f) => {
            throw $e.error(`Error Authenticating with ${d.split("/")[2]}`), `Error Authenticating with ${d.split("/")[2]}`;
          },
          onAuthSuccess: (d, f) => {
            o7e(d, f);
          }
        });
        const h = {};
        for (const [d, f] of Object.entries(o.current))
          h[d] = f;
        return { workdir: n.workdir, data: h };
      } catch (h) {
        throw console.error("Git clone error:", h), h;
      }
    },
    [n, s, t]
  );
  return { ready: t, gitClone: a };
}
const UY = (t, e) => ({
  promises: {
    readFile: async (n, r) => {
      const s = r?.encoding, i = qs.relative(t.workdir, n);
      try {
        return await t.fs.readFile(i, s);
      } catch (o) {
        throw o;
      }
    },
    writeFile: async (n, r, s) => {
      const i = s.encoding, o = qs.relative(t.workdir, n);
      e.current && (e.current[o] = { data: r, encoding: i });
      try {
        return await t.fs.writeFile(o, r, { ...s, encoding: i });
      } catch (a) {
        throw a;
      }
    },
    mkdir: async (n, r) => {
      const s = qs.relative(t.workdir, n);
      try {
        return await t.fs.mkdir(s, { ...r, recursive: !0 });
      } catch (i) {
        throw i;
      }
    },
    readdir: async (n, r) => {
      const s = qs.relative(t.workdir, n);
      try {
        return await t.fs.readdir(s, r);
      } catch (i) {
        throw i;
      }
    },
    rm: async (n, r) => {
      const s = qs.relative(t.workdir, n);
      try {
        return await t.fs.rm(s, { ...r || {} });
      } catch (i) {
        throw i;
      }
    },
    rmdir: async (n, r) => {
      const s = qs.relative(t.workdir, n);
      try {
        return await t.fs.rm(s, { recursive: !0, ...r });
      } catch (i) {
        throw i;
      }
    },
    unlink: async (n) => {
      const r = qs.relative(t.workdir, n);
      try {
        return await t.fs.rm(r, { recursive: !1 });
      } catch (s) {
        throw s;
      }
    },
    stat: async (n) => {
      try {
        const r = qs.relative(t.workdir, n), s = await t.fs.readdir(qs.dirname(r), { withFileTypes: !0 }), i = qs.basename(r), o = s.find((a) => a.name == i);
        if (!o)
          throw new Error(`ENOENT: no such file or directory, stat '${n}'`);
        return {
          isFile: () => o.isFile(),
          isDirectory: () => o.isDirectory(),
          isSymbolicLink: () => !1,
          size: 1,
          mode: 438,
          // Default permissions
          mtimeMs: Date.now(),
          uid: 1e3,
          gid: 1e3
        };
      } catch (r) {
        console.log(r?.message);
        const s = new Error(`ENOENT: no such file or directory, stat '${n}'`);
        throw s.code = "ENOENT", s.errno = -2, s.syscall = "stat", s.path = n, s;
      }
    },
    lstat: async (n) => await UY(t, e).promises.stat(n),
    readlink: async (n) => {
      throw new Error(`EINVAL: invalid argument, readlink '${n}'`);
    },
    symlink: async (n, r) => {
      throw new Error(`EPERM: operation not permitted, symlink '${n}' -> '${r}'`);
    },
    chmod: async (n, r) => await Promise.resolve()
  }
}), qs = {
  dirname: (t) => !t || !t.includes("/") ? "." : (t = t.replace(/\/+$/, ""), t.split("/").slice(0, -1).join("/") || "/"),
  basename: (t, e) => {
    t = t.replace(/\/+$/, "");
    const n = t.split("/").pop() || "";
    return e && n.endsWith(e) ? n.slice(0, -e.length) : n;
  },
  relative: (t, e) => {
    if (!t || !e)
      return ".";
    const n = (u) => u.replace(/\/+$/, "").split("/").filter(Boolean), r = n(t), s = n(e);
    let i = 0;
    const o = Math.min(r.length, s.length);
    for (let u = 0; u < o && r[u] === s[u]; u++)
      i++;
    const a = r.length - i, l = s.slice(i), c = [...Array(a).fill(".."), ...l];
    return c.length === 0 ? "." : c.join("/");
  }
}, l7e = ({
  message: t = "Loading...",
  progress: e,
  progressText: n
}) => /* @__PURE__ */ k.jsx("div", { className: "fixed inset-0 flex items-center justify-center bg-black/80 z-50 backdrop-blur-sm", children: /* @__PURE__ */ k.jsxs("div", { className: "relative flex flex-col items-center gap-4 p-8 rounded-lg bg-bolt-elements-background-depth-2 shadow-lg", children: [
  /* @__PURE__ */ k.jsx(
    "div",
    {
      className: "i-svg-spinners:90-ring-with-bg text-bolt-elements-loader-progress",
      style: { fontSize: "2rem" }
    }
  ),
  /* @__PURE__ */ k.jsx("p", { className: "text-lg text-bolt-elements-textTertiary", children: t }),
  e !== void 0 && /* @__PURE__ */ k.jsxs("div", { className: "w-64 flex flex-col gap-2", children: [
    /* @__PURE__ */ k.jsx("div", { className: "w-full h-2 bg-bolt-elements-background-depth-1 rounded-full overflow-hidden", children: /* @__PURE__ */ k.jsx(
      "div",
      {
        className: "h-full bg-bolt-elements-loader-progress transition-all duration-300 ease-out rounded-full",
        style: { width: `${Math.min(100, Math.max(0, e))}%` }
      }
    ) }),
    n && /* @__PURE__ */ k.jsx("p", { className: "text-sm text-bolt-elements-textTertiary text-center", children: n })
  ] })
] }) }), c7e = [
  "node_modules/**",
  ".git/**",
  ".github/**",
  ".vscode/**",
  "**/*.jpg",
  "**/*.jpeg",
  "**/*.png",
  "dist/**",
  "build/**",
  ".next/**",
  "coverage/**",
  ".cache/**",
  ".vscode/**",
  ".idea/**",
  "**/*.log",
  "**/.DS_Store",
  "**/npm-debug.log*",
  "**/yarn-debug.log*",
  "**/yarn-error.log*",
  "**/*lock.json",
  "**/*lock.yaml"
], u7e = o2().add(c7e);
function h7e({ importChat: t }) {
  const { ready: e, gitClone: n } = a7e(), [r, s] = I.useState(!1), i = async (o) => {
    if (!e)
      return;
    const a = prompt("Enter the Git url");
    if (a) {
      s(!0);
      try {
        const { workdir: l, data: c } = await n(a);
        if (t) {
          const u = Object.keys(c).filter((m) => !u7e.ignores(m));
          console.log(u);
          const h = new TextDecoder("utf-8"), d = u.map((m) => {
            const { data: b, encoding: _ } = c[m];
            return {
              path: m,
              content: _ === "utf8" ? b : b instanceof Uint8Array ? h.decode(b) : ""
            };
          }).filter((m) => m.content), f = await PK(d), g = OK(f), p = [{
            role: "assistant",
            content: `Cloning the repo ${a} into ${l}
<boltArtifact id="imported-files" title="Git Cloned Files" type="bundled">
${d.map(
              (m) => `<boltAction type="file" filePath="${m.path}">
${DK(m.content)}
</boltAction>`
            ).join(`
`)}
</boltArtifact>`,
            id: dd(),
            createdAt: /* @__PURE__ */ new Date()
          }];
          g && p.push(g), await t(`Git Project:${a.split("/").slice(-1)[0]}`, p, { gitUrl: a });
        }
      } catch (l) {
        console.error("Error during import:", l), $e.error("Failed to import repository");
      } finally {
        s(!1);
      }
    }
  };
  return /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
    /* @__PURE__ */ k.jsxs(
      "button",
      {
        onClick: i,
        title: "Clone a Git Repo",
        className: "px-4 py-2 rounded-lg border border-bolt-elements-borderColor bg-bolt-elements-prompt-background text-bolt-elements-textPrimary hover:bg-bolt-elements-background-depth-3 transition-all flex items-center gap-2",
        children: [
          /* @__PURE__ */ k.jsx("span", { className: "i-ph:git-branch" }),
          "Clone a Git Repo"
        ]
      }
    ),
    r && /* @__PURE__ */ k.jsx(l7e, { message: "Please wait while we clone the repository..." })
  ] });
}
const d7e = ({ files: t, imageDataList: e, onRemove: n }) => !t || t.length === 0 ? null : /* @__PURE__ */ k.jsx("div", { className: "flex flex-row overflow-x-auto -mt-2", children: t.map((r, s) => /* @__PURE__ */ k.jsx("div", { className: "mr-2 relative", children: e[s] && /* @__PURE__ */ k.jsxs("div", { className: "relative pt-4 pr-4", children: [
  /* @__PURE__ */ k.jsx("img", { src: e[s], alt: r.name, className: "max-h-20" }),
  /* @__PURE__ */ k.jsx(
    "button",
    {
      onClick: () => n(s),
      className: "absolute top-1 right-1 z-10 bg-black rounded-full w-5 h-5 shadow-md hover:bg-gray-900 transition-colors flex items-center justify-center",
      children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:x w-3 h-3 text-gray-200" })
    }
  )
] }) }, r.name + r.size)) }), f7e = ({
  model: t,
  setModel: e,
  provider: n,
  setProvider: r,
  modelList: s,
  providerList: i,
  modelLoading: o
}) => (I.useEffect(() => {
  if (i.length != 0 && n && !i.map((a) => a.name).includes(n.name)) {
    const a = i[0];
    r?.(a);
    const l = s.find((c) => c.provider === a.name);
    l && e?.(l.name);
  }
}, [i, n, r, s, e]), i.length === 0 ? /* @__PURE__ */ k.jsx("div", { className: "mb-2 p-4 rounded-lg border border-bolt-elements-borderColor bg-bolt-elements-prompt-background text-bolt-elements-textPrimary", children: /* @__PURE__ */ k.jsx("p", { className: "text-center", children: "No providers are currently enabled. Please enable at least one provider in the settings to start using the chat." }) }) : /* @__PURE__ */ k.jsxs("div", { className: "mb-2 flex gap-2 flex-col sm:flex-row", children: [
  /* @__PURE__ */ k.jsx(
    "select",
    {
      value: n?.name ?? "",
      onChange: (a) => {
        const l = i.find((u) => u.name === a.target.value);
        l && r && r(l);
        const c = [...s].find((u) => u.provider === a.target.value);
        c && e && e(c.name);
      },
      className: "flex-1 p-2 rounded-lg border border-bolt-elements-borderColor bg-bolt-elements-prompt-background text-bolt-elements-textPrimary focus:outline-none focus:ring-2 focus:ring-bolt-elements-focus transition-all",
      children: i.map((a) => /* @__PURE__ */ k.jsx("option", { value: a.name, children: a.name }, a.name))
    }
  ),
  /* @__PURE__ */ k.jsx(
    "select",
    {
      value: t,
      onChange: (a) => e?.(a.target.value),
      className: "flex-1 p-2 rounded-lg border border-bolt-elements-borderColor bg-bolt-elements-prompt-background text-bolt-elements-textPrimary focus:outline-none focus:ring-2 focus:ring-bolt-elements-focus transition-all lg:max-w-[70%]",
      disabled: o === "all" || o === n?.name,
      children: o == "all" || o == n?.name ? /* @__PURE__ */ k.jsx("option", { value: "", children: "Loading..." }, 0) : [...s].filter((a) => a.provider == n?.name && a.name).map((a, l) => /* @__PURE__ */ k.jsx("option", { value: a.name, children: a.label }, l))
    },
    n?.name
  )
] })), p7e = ({
  isListening: t,
  onStart: e,
  onStop: n,
  disabled: r
}) => /* @__PURE__ */ k.jsx(
  Vt,
  {
    title: t ? "Stop listening" : "Start speech recognition",
    disabled: r,
    className: qe("transition-all", {
      "text-bolt-elements-item-contentAccent": t
    }),
    onClick: t ? n : e,
    children: t ? /* @__PURE__ */ k.jsx("div", { className: "i-ph:microphone-slash text-xl" }) : /* @__PURE__ */ k.jsx("div", { className: "i-ph:microphone text-xl" })
  }
), m7e = ({
  setUploadedFiles: t,
  setImageDataList: e,
  uploadedFiles: n,
  imageDataList: r
}) => (I.useEffect(() => (t && e && (window.__BOLT_SET_UPLOADED_FILES__ = t, window.__BOLT_SET_IMAGE_DATA_LIST__ = e, window.__BOLT_UPLOADED_FILES__ = n, window.__BOLT_IMAGE_DATA_LIST__ = r), () => {
  delete window.__BOLT_SET_UPLOADED_FILES__, delete window.__BOLT_SET_IMAGE_DATA_LIST__, delete window.__BOLT_UPLOADED_FILES__, delete window.__BOLT_IMAGE_DATA_LIST__;
}), [t, e, n, r]), null), g7e = () => /* @__PURE__ */ k.jsx("div", { className: "flex flex-col items-center gap-4", children: /* @__PURE__ */ k.jsx("span", { className: "text-sm text-gray-500", children: "Par bolt.diy et DeepSeeks." }) });
function y7e({ alert: t, clearAlert: e, postMessage: n }) {
  const { description: r, content: s, source: i } = t, o = i === "preview", a = o ? "Preview Error" : "Terminal Error", l = o ? "We encountered an error while running the preview. Would you like Bolt to analyze and help resolve this issue?" : "We encountered an error while running terminal commands. Would you like Bolt to analyze and help resolve this issue?";
  return /* @__PURE__ */ k.jsx(cl, { children: /* @__PURE__ */ k.jsx(
    hn.div,
    {
      initial: { opacity: 0, y: -20 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: -20 },
      transition: { duration: 0.3 },
      className: "rounded-lg border border-bolt-elements-borderColor bg-bolt-elements-background-depth-2 p-4",
      children: /* @__PURE__ */ k.jsxs("div", { className: "flex items-start", children: [
        /* @__PURE__ */ k.jsx(
          hn.div,
          {
            className: "flex-shrink-0",
            initial: { scale: 0 },
            animate: { scale: 1 },
            transition: { delay: 0.2 },
            children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:warning-duotone text-xl text-bolt-elements-button-danger-text" })
          }
        ),
        /* @__PURE__ */ k.jsxs("div", { className: "ml-3 flex-1", children: [
          /* @__PURE__ */ k.jsx(
            hn.h3,
            {
              initial: { opacity: 0 },
              animate: { opacity: 1 },
              transition: { delay: 0.1 },
              className: "text-sm font-medium text-bolt-elements-textPrimary",
              children: a
            }
          ),
          /* @__PURE__ */ k.jsxs(
            hn.div,
            {
              initial: { opacity: 0 },
              animate: { opacity: 1 },
              transition: { delay: 0.2 },
              className: "mt-2 text-sm text-bolt-elements-textSecondary",
              children: [
                /* @__PURE__ */ k.jsx("p", { children: l }),
                r && /* @__PURE__ */ k.jsxs("div", { className: "text-xs text-bolt-elements-textSecondary p-2 bg-bolt-elements-background-depth-3 rounded mt-4 mb-4", children: [
                  "Error: ",
                  r
                ] })
              ]
            }
          ),
          /* @__PURE__ */ k.jsx(
            hn.div,
            {
              className: "mt-4",
              initial: { opacity: 0, y: 10 },
              animate: { opacity: 1, y: 0 },
              transition: { delay: 0.3 },
              children: /* @__PURE__ */ k.jsxs("div", { className: qe(" flex gap-2"), children: [
                /* @__PURE__ */ k.jsxs(
                  "button",
                  {
                    onClick: () => n(
                      `*Fix this ${o ? "preview" : "terminal"} error* 
\`\`\`${o ? "js" : "sh"}
${s}
\`\`\`
`
                    ),
                    className: qe(
                      "px-2 py-1.5 rounded-md text-sm font-medium",
                      "bg-bolt-elements-button-primary-background",
                      "hover:bg-bolt-elements-button-primary-backgroundHover",
                      "focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-bolt-elements-button-danger-background",
                      "text-bolt-elements-button-primary-text",
                      "flex items-center gap-1.5"
                    ),
                    children: [
                      /* @__PURE__ */ k.jsx("div", { className: "i-ph:chat-circle-duotone" }),
                      "Ask Bolt"
                    ]
                  }
                ),
                /* @__PURE__ */ k.jsx(
                  "button",
                  {
                    onClick: e,
                    className: qe(
                      "px-2 py-1.5 rounded-md text-sm font-medium",
                      "bg-bolt-elements-button-secondary-background",
                      "hover:bg-bolt-elements-button-secondary-backgroundHover",
                      "focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-bolt-elements-button-secondary-background",
                      "text-bolt-elements-button-secondary-text"
                    ),
                    children: "Dismiss"
                  }
                )
              ] })
            }
          )
        ] })
      ] })
    }
  ) });
}
function b7e({ data: t }) {
  const [e, n] = Qe.useState([]), [r, s] = I.useState(!1);
  return Qe.useEffect(() => {
    if (!t || t.length == 0) {
      n([]);
      return;
    }
    const i = /* @__PURE__ */ new Map();
    t.forEach((a) => {
      const l = i.get(a.label);
      l && l.status === "complete" || i.set(a.label, a);
    });
    const o = Array.from(i.values());
    o.sort((a, l) => a.order - l.order), n(o);
  }, [t]), e.length === 0 ? /* @__PURE__ */ k.jsx(k.Fragment, {}) : /* @__PURE__ */ k.jsx(cl, { children: /* @__PURE__ */ k.jsx(
    "div",
    {
      className: qe(
        "bg-bolt-elements-background-depth-2",
        "border border-bolt-elements-borderColor",
        "shadow-lg rounded-lg  relative w-full max-w-chat mx-auto z-prompt",
        "p-1"
      ),
      style: { transform: "translateY(1rem)" },
      children: /* @__PURE__ */ k.jsxs(
        "div",
        {
          className: qe(
            "bg-bolt-elements-item-backgroundAccent",
            "p-1 rounded-lg text-bolt-elements-item-contentAccent",
            "flex "
          ),
          children: [
            /* @__PURE__ */ k.jsx("div", { className: "flex-1", children: /* @__PURE__ */ k.jsx(cl, { children: r ? /* @__PURE__ */ k.jsx(
              hn.div,
              {
                className: "actions",
                initial: { height: 0 },
                animate: { height: "auto" },
                exit: { height: "0px" },
                transition: { duration: 0.15 },
                children: e.map((i, o) => /* @__PURE__ */ k.jsx(tB, { progress: i }, o))
              }
            ) : /* @__PURE__ */ k.jsx(tB, { progress: e.slice(-1)[0] }) }) }),
            /* @__PURE__ */ k.jsx(
              hn.button,
              {
                initial: { width: 0 },
                animate: { width: "auto" },
                exit: { width: 0 },
                transition: { duration: 0.15, ease: xs },
                className: " p-1 rounded-lg bg-bolt-elements-item-backgroundAccent hover:bg-bolt-elements-artifacts-backgroundHover",
                onClick: () => s((i) => !i),
                children: /* @__PURE__ */ k.jsx("div", { className: r ? "i-ph:caret-up-bold" : "i-ph:caret-down-bold" })
              }
            )
          ]
        }
      )
    }
  ) });
}
const tB = ({ progress: t }) => /* @__PURE__ */ k.jsxs(
  hn.div,
  {
    className: qe("flex text-sm gap-3"),
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
    transition: { duration: 0.15 },
    children: [
      /* @__PURE__ */ k.jsx("div", { className: "flex items-center gap-1.5 ", children: /* @__PURE__ */ k.jsx("div", { children: t.status === "in-progress" ? /* @__PURE__ */ k.jsx("div", { className: "i-svg-spinners:90-ring-with-bg" }) : t.status === "complete" ? /* @__PURE__ */ k.jsx("div", { className: "i-ph:check" }) : null }) }),
      t.message
    ]
  }
), _7e = 76, v7e = Qe.forwardRef(
  ({
    textareaRef: t,
    messageRef: e,
    scrollRef: n,
    showChat: r = !0,
    chatStarted: s = !1,
    isStreaming: i = !1,
    model: o,
    setModel: a,
    provider: l,
    setProvider: c,
    providerList: u,
    input: h = "",
    enhancingPrompt: d,
    handleInputChange: f,
    // promptEnhanced,
    enhancePrompt: g,
    sendMessage: y,
    handleStop: p,
    importChat: m,
    exportChat: b,
    uploadedFiles: _ = [],
    setUploadedFiles: v,
    imageDataList: w = [],
    setImageDataList: E,
    messages: x,
    actionAlert: S,
    clearAlert: T,
    data: R
  }, F) => {
    const P = s ? 400 : 200, [M, A] = I.useState(Hy()), [V, ee] = I.useState([]), [K, te] = I.useState(!1), [N, L] = I.useState(!1), [j, H] = I.useState(null), [U, Y] = I.useState(""), [ne, he] = I.useState("all"), [X, z] = I.useState([]);
    I.useEffect(() => {
      if (R) {
        const re = R.filter(
          (W) => typeof W == "object" && W.type === "progress"
        );
        z(re);
      }
    }, [R]), I.useEffect(() => {
      console.log(U);
    }, [U]), I.useEffect(() => {
      if (typeof window < "u" && ("SpeechRecognition" in window || "webkitSpeechRecognition" in window)) {
        const re = window.SpeechRecognition || window.webkitSpeechRecognition, W = new re();
        W.continuous = !0, W.interimResults = !0, W.onresult = (q) => {
          const ie = Array.from(q.results).map((ye) => ye[0]).map((ye) => ye.transcript).join("");
          Y(ie), f && f({
            target: { value: ie }
          });
        }, W.onerror = (q) => {
          console.error("Speech recognition error:", q.error), L(!1);
        }, H(W);
      }
    }, []), I.useEffect(() => {
      if (typeof window < "u") {
        let re = {};
        try {
          re = Hy(), A(re);
        } catch (W) {
          console.error("Error loading API keys from cookies:", W), nt.remove("apiKeys");
        }
        he("all"), fetch("/api/models").then((W) => W.json()).then((W) => {
          ee(W.modelList);
        }).catch((W) => {
          console.error("Error fetching model list:", W);
        }).finally(() => {
          he(void 0);
        });
      }
    }, [u, l]);
    const ue = async (re, W) => {
      const q = { ...M, [re]: W };
      A(q), nt.set("apiKeys", JSON.stringify(q)), he(re);
      let ie = [];
      try {
        ie = (await (await fetch(`/api/models/${encodeURIComponent(re)}`)).json()).modelList;
      } catch (ye) {
        console.error("Error loading dynamic models for:", re, ye);
      }
      ee((ye) => [...ye.filter((fe) => fe.provider !== re), ...ie]), he(void 0);
    }, ae = () => {
      j && (j.start(), L(!0));
    }, be = () => {
      j && (j.stop(), L(!1));
    }, de = (re, W) => {
      y && (y(re, W), j && (j.abort(), Y(""), L(!1), f && f({
        target: { value: "" }
      })));
    }, _e = () => {
      const re = document.createElement("input");
      re.type = "file", re.accept = "image/*", re.onchange = async (W) => {
        const q = W.target.files?.[0];
        if (q) {
          const ie = new FileReader();
          ie.onload = (ye) => {
            const xe = ye.target?.result;
            v?.([..._, q]), E?.([...w, xe]);
          }, ie.readAsDataURL(q);
        }
      }, re.click();
    }, $ = async (re) => {
      const W = re.clipboardData?.items;
      if (W) {
        for (const q of W)
          if (q.type.startsWith("image/")) {
            re.preventDefault();
            const ie = q.getAsFile();
            if (ie) {
              const ye = new FileReader();
              ye.onload = (xe) => {
                const fe = xe.target?.result;
                v?.([..._, ie]), E?.([...w, fe]);
              }, ye.readAsDataURL(ie);
            }
            break;
          }
      }
    }, ce = /* @__PURE__ */ k.jsx(
      "div",
      {
        ref: F,
        className: qe(gh.BaseChat, "relative flex h-full w-full overflow-hidden"),
        "data-chat-visible": r,
        children: /* @__PURE__ */ k.jsxs("div", { ref: n, className: "flex flex-col lg:flex-row overflow-y-auto w-full h-full", children: [
          /* @__PURE__ */ k.jsxs("div", { className: qe(gh.Chat, "flex flex-col flex-grow lg:min-w-[var(--chat-min-width)] h-full"), children: [
            !s && /* @__PURE__ */ k.jsxs("div", { id: "intro", className: "mt-[16vh] max-w-chat mx-auto text-center px-4 lg:px-0", children: [
              /* @__PURE__ */ k.jsx("h1", { className: "text-3xl lg:text-6xl font-bold text-bolt-elements-textPrimary mb-4 animate-fade-in", children: "Crez votre application" }),
              /* @__PURE__ */ k.jsx("p", { className: "text-md lg:text-xl mb-8 text-bolt-elements-textSecondary animate-fade-in animation-delay-200", children: "Crez votre site avec juste une desciption ." })
            ] }),
            /* @__PURE__ */ k.jsxs(
              "div",
              {
                className: qe("pt-6 px-2 sm:px-6", {
                  "h-full flex flex-col": s
                }),
                ref: n,
                children: [
                  /* @__PURE__ */ k.jsx(Oo, { children: () => s ? /* @__PURE__ */ k.jsx(
                    u$e,
                    {
                      ref: e,
                      className: "flex flex-col w-full flex-1 max-w-chat pb-6 mx-auto z-1",
                      messages: x,
                      isStreaming: i
                    }
                  ) : null }),
                  /* @__PURE__ */ k.jsxs(
                    "div",
                    {
                      className: qe("flex flex-col gap-4 w-full max-w-chat mx-auto z-prompt mb-6", {
                        "sticky bottom-2": s
                      }),
                      children: [
                        /* @__PURE__ */ k.jsx("div", { className: "bg-bolt-elements-background-depth-2", children: S && /* @__PURE__ */ k.jsx(
                          y7e,
                          {
                            alert: S,
                            clearAlert: () => T?.(),
                            postMessage: (re) => {
                              y?.({}, re), T?.();
                            }
                          }
                        ) }),
                        X && /* @__PURE__ */ k.jsx(b7e, { data: X }),
                        /* @__PURE__ */ k.jsxs(
                          "div",
                          {
                            className: qe(
                              "bg-bolt-elements-background-depth-2 p-3 rounded-lg border border-bolt-elements-borderColor relative w-full max-w-chat mx-auto z-prompt"
                              /*
                               * {
                               *   'sticky bottom-2': chatStarted,
                               * },
                               */
                            ),
                            children: [
                              /* @__PURE__ */ k.jsxs("svg", { className: qe(gh.PromptEffectContainer), children: [
                                /* @__PURE__ */ k.jsxs("defs", { children: [
                                  /* @__PURE__ */ k.jsxs(
                                    "linearGradient",
                                    {
                                      id: "line-gradient",
                                      x1: "20%",
                                      y1: "0%",
                                      x2: "-14%",
                                      y2: "10%",
                                      gradientUnits: "userSpaceOnUse",
                                      gradientTransform: "rotate(-45)",
                                      children: [
                                        /* @__PURE__ */ k.jsx("stop", { offset: "0%", stopColor: "#b44aff", stopOpacity: "0%" }),
                                        /* @__PURE__ */ k.jsx("stop", { offset: "40%", stopColor: "#b44aff", stopOpacity: "80%" }),
                                        /* @__PURE__ */ k.jsx("stop", { offset: "50%", stopColor: "#b44aff", stopOpacity: "80%" }),
                                        /* @__PURE__ */ k.jsx("stop", { offset: "100%", stopColor: "#b44aff", stopOpacity: "0%" })
                                      ]
                                    }
                                  ),
                                  /* @__PURE__ */ k.jsxs("linearGradient", { id: "shine-gradient", children: [
                                    /* @__PURE__ */ k.jsx("stop", { offset: "0%", stopColor: "white", stopOpacity: "0%" }),
                                    /* @__PURE__ */ k.jsx("stop", { offset: "40%", stopColor: "#ffffff", stopOpacity: "80%" }),
                                    /* @__PURE__ */ k.jsx("stop", { offset: "50%", stopColor: "#ffffff", stopOpacity: "80%" }),
                                    /* @__PURE__ */ k.jsx("stop", { offset: "100%", stopColor: "white", stopOpacity: "0%" })
                                  ] })
                                ] }),
                                /* @__PURE__ */ k.jsx("rect", { className: qe(gh.PromptEffectLine), pathLength: "100", strokeLinecap: "round" }),
                                /* @__PURE__ */ k.jsx("rect", { className: qe(gh.PromptShine), x: "48", y: "24", width: "70", height: "1" })
                              ] }),
                              /* @__PURE__ */ k.jsx("div", { children: /* @__PURE__ */ k.jsx(Oo, { children: () => /* @__PURE__ */ k.jsxs("div", { className: "hidden", children: [
                                /* @__PURE__ */ k.jsx(
                                  f7e,
                                  {
                                    model: o,
                                    setModel: a,
                                    modelList: V,
                                    provider: l,
                                    setProvider: c,
                                    providerList: u || Rb,
                                    apiKeys: M,
                                    modelLoading: ne
                                  },
                                  l?.name + ":" + V.length
                                ),
                                (u || []).length > 0 && l && /* @__PURE__ */ k.jsx(
                                  f$e,
                                  {
                                    provider: l,
                                    apiKey: M[l.name] || "",
                                    setApiKey: (re) => {
                                      ue(l.name, re);
                                    }
                                  }
                                )
                              ] }) }) }),
                              /* @__PURE__ */ k.jsx(
                                d7e,
                                {
                                  files: _,
                                  imageDataList: w,
                                  onRemove: (re) => {
                                    v?.(_.filter((W, q) => q !== re)), E?.(w.filter((W, q) => q !== re));
                                  }
                                }
                              ),
                              /* @__PURE__ */ k.jsx(Oo, { children: () => /* @__PURE__ */ k.jsx(
                                m7e,
                                {
                                  setUploadedFiles: v,
                                  setImageDataList: E,
                                  uploadedFiles: _,
                                  imageDataList: w
                                }
                              ) }),
                              /* @__PURE__ */ k.jsxs(
                                "div",
                                {
                                  className: qe(
                                    "relative shadow-xs border border-bolt-elements-borderColor backdrop-blur rounded-lg"
                                  ),
                                  children: [
                                    /* @__PURE__ */ k.jsx(
                                      "textarea",
                                      {
                                        ref: t,
                                        className: qe(
                                          "w-full pl-4 pt-4 pr-16 outline-none resize-none text-bolt-elements-textPrimary placeholder-bolt-elements-textTertiary bg-transparent text-sm",
                                          "transition-all duration-200",
                                          "hover:border-bolt-elements-focus"
                                        ),
                                        onDragEnter: (re) => {
                                          re.preventDefault(), re.currentTarget.style.border = "2px solid #1488fc";
                                        },
                                        onDragOver: (re) => {
                                          re.preventDefault(), re.currentTarget.style.border = "2px solid #1488fc";
                                        },
                                        onDragLeave: (re) => {
                                          re.preventDefault(), re.currentTarget.style.border = "1px solid var(--bolt-elements-borderColor)";
                                        },
                                        onDrop: (re) => {
                                          re.preventDefault(), re.currentTarget.style.border = "1px solid var(--bolt-elements-borderColor)", Array.from(re.dataTransfer.files).forEach((q) => {
                                            if (q.type.startsWith("image/")) {
                                              const ie = new FileReader();
                                              ie.onload = (ye) => {
                                                const xe = ye.target?.result;
                                                v?.([..._, q]), E?.([...w, xe]);
                                              }, ie.readAsDataURL(q);
                                            }
                                          });
                                        },
                                        onKeyDown: (re) => {
                                          if (re.key === "Enter") {
                                            if (re.shiftKey)
                                              return;
                                            if (re.preventDefault(), i) {
                                              p?.();
                                              return;
                                            }
                                            if (re.nativeEvent.isComposing)
                                              return;
                                            de?.(re);
                                          }
                                        },
                                        value: h,
                                        onChange: (re) => {
                                          f?.(re);
                                        },
                                        onPaste: $,
                                        style: {
                                          minHeight: _7e,
                                          maxHeight: P
                                        },
                                        placeholder: "Comment on peut vous aider aujourd'hui ?",
                                        translate: "no"
                                      }
                                    ),
                                    /* @__PURE__ */ k.jsx(Oo, { children: () => /* @__PURE__ */ k.jsx(
                                      d$e,
                                      {
                                        show: h.length > 0 || i || _.length > 0,
                                        isStreaming: i,
                                        disabled: !u || u.length === 0,
                                        onClick: (re) => {
                                          if (i) {
                                            p?.();
                                            return;
                                          }
                                          (h.length > 0 || _.length > 0) && de?.(re);
                                        }
                                      }
                                    ) }),
                                    /* @__PURE__ */ k.jsxs("div", { className: "flex justify-between items-center text-sm p-4 pt-2", children: [
                                      /* @__PURE__ */ k.jsxs("div", { className: "flex gap-1 items-center", children: [
                                        /* @__PURE__ */ k.jsx(Vt, { title: "Upload file", className: "transition-all", onClick: () => _e(), children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:paperclip text-xl" }) }),
                                        /* @__PURE__ */ k.jsx(
                                          Vt,
                                          {
                                            title: "Enhance prompt",
                                            disabled: h.length === 0 || d,
                                            className: qe("transition-all", d ? "opacity-100" : ""),
                                            onClick: () => {
                                              g?.(), $e.success("Prompt enhanced!");
                                            },
                                            children: d ? /* @__PURE__ */ k.jsx("div", { className: "i-svg-spinners:90-ring-with-bg text-bolt-elements-loader-progress text-xl animate-spin" }) : /* @__PURE__ */ k.jsx("div", { className: "i-bolt:stars text-xl" })
                                          }
                                        ),
                                        /* @__PURE__ */ k.jsx(
                                          p7e,
                                          {
                                            isListening: N,
                                            onStart: ae,
                                            onStop: be,
                                            disabled: i
                                          }
                                        ),
                                        s && /* @__PURE__ */ k.jsx(Oo, { children: () => /* @__PURE__ */ k.jsx(_$e, { exportChat: b }) }),
                                        /* @__PURE__ */ k.jsxs(
                                          Vt,
                                          {
                                            title: "Model Settings",
                                            className: qe("transition-all flex items-center gap-1", {
                                              "bg-bolt-elements-item-backgroundAccent text-bolt-elements-item-contentAccent": K,
                                              "bg-bolt-elements-item-backgroundDefault text-bolt-elements-item-contentDefault": !K
                                            }),
                                            onClick: () => te(!K),
                                            disabled: !u || u.length === 0,
                                            children: [
                                              /* @__PURE__ */ k.jsx("div", { className: `i-ph:caret-${K ? "right" : "down"} text-lg` }),
                                              K ? /* @__PURE__ */ k.jsx("span", { className: "text-xs", children: o }) : /* @__PURE__ */ k.jsx("span", {})
                                            ]
                                          }
                                        )
                                      ] }),
                                      h.length > 3 ? /* @__PURE__ */ k.jsxs("div", { className: "text-xs text-bolt-elements-textTertiary", children: [
                                        "Use ",
                                        /* @__PURE__ */ k.jsx("kbd", { className: "kdb px-1.5 py-0.5 rounded bg-bolt-elements-background-depth-2", children: "Shift" }),
                                        " ",
                                        "+ ",
                                        /* @__PURE__ */ k.jsx("kbd", { className: "kdb px-1.5 py-0.5 rounded bg-bolt-elements-background-depth-2", children: "Return" }),
                                        " ",
                                        "a new line"
                                      ] }) : null
                                    ] })
                                  ]
                                }
                              )
                            ]
                          }
                        )
                      ]
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ k.jsxs("div", { className: "flex flex-col justify-center gap-5", children: [
              !s && /* @__PURE__ */ k.jsxs("div", { className: "flex justify-center gap-2", children: [
                K$e(m),
                /* @__PURE__ */ k.jsx(h7e, { importChat: m })
              ] }),
              !s && /* @__PURE__ */ k.jsx(g7e, {})
            ] })
          ] }),
          /* @__PURE__ */ k.jsx(Oo, { children: () => /* @__PURE__ */ k.jsx(bMe, { chatStarted: s, isStreaming: i }) })
        ] })
      }
    );
    return /* @__PURE__ */ k.jsx(Ske, { delayDuration: 200, children: ce });
  }
);
var jY = "vercel.ai.error", w7e = Symbol.for(jY), HY, E7e = class zY extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: e,
    message: n,
    cause: r
  }) {
    super(n), this[HY] = !0, this.name = e, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(e) {
    return zY.hasMarker(e, jY);
  }
  static hasMarker(e, n) {
    const r = Symbol.for(n);
    return e != null && typeof e == "object" && r in e && typeof e[r] == "boolean" && e[r] === !0;
  }
};
HY = w7e;
var wu = E7e;
function GY(t) {
  return t == null ? "unknown error" : typeof t == "string" ? t : t instanceof Error ? t.message : JSON.stringify(t);
}
var VY = "AI_InvalidArgumentError", WY = `vercel.ai.error.${VY}`, S7e = Symbol.for(WY), qY, x7e = class extends wu {
  constructor({
    message: t,
    cause: e,
    argument: n
  }) {
    super({ name: VY, message: t, cause: e }), this[qY] = !0, this.argument = n;
  }
  static isInstance(t) {
    return wu.hasMarker(t, WY);
  }
};
qY = S7e;
var KY = "AI_JSONParseError", YY = `vercel.ai.error.${KY}`, T7e = Symbol.for(YY), ZY, nB = class extends wu {
  constructor({ text: t, cause: e }) {
    super({
      name: KY,
      message: `JSON parsing failed: Text: ${t}.
Error message: ${GY(e)}`,
      cause: e
    }), this[ZY] = !0, this.text = t;
  }
  static isInstance(t) {
    return wu.hasMarker(t, YY);
  }
};
ZY = T7e;
var JY = "AI_TypeValidationError", XY = `vercel.ai.error.${JY}`, C7e = Symbol.for(XY), QY, k7e = class xT extends wu {
  constructor({ value: e, cause: n }) {
    super({
      name: JY,
      message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${GY(n)}`,
      cause: n
    }), this[QY] = !0, this.value = e;
  }
  static isInstance(e) {
    return wu.hasMarker(e, XY);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: e,
    cause: n
  }) {
    return xT.isInstance(n) && n.value === e ? n : new xT({ value: e, cause: n });
  }
};
QY = C7e;
var rB = k7e, A7e = ({
  prefix: t,
  size: e = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const s = Cu(n, e);
  if (t == null)
    return s;
  if (n.includes(r))
    throw new x7e({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return (i) => `${t}${r}${s(i)}`;
}, eZ = A7e(), Jy = Symbol.for("vercel.ai.validator");
function R7e(t) {
  return { [Jy]: !0, validate: t };
}
function I7e(t) {
  return typeof t == "object" && t !== null && Jy in t && t[Jy] === !0 && "validate" in t;
}
function P7e(t) {
  return I7e(t) ? t : O7e(t);
}
function O7e(t) {
  return R7e((e) => {
    const n = t.safeParse(e);
    return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
  });
}
function D7e({
  value: t,
  schema: e
}) {
  const n = P7e(e);
  try {
    if (n.validate == null)
      return { success: !0, value: t };
    const r = n.validate(t);
    return r.success ? r : {
      success: !1,
      error: rB.wrap({ value: t, cause: r.error })
    };
  } catch (r) {
    return {
      success: !1,
      error: rB.wrap({ value: t, cause: r })
    };
  }
}
function sB({
  text: t,
  schema: e
}) {
  try {
    const n = ln.parse(t);
    if (e == null)
      return { success: !0, value: n, rawValue: n };
    const r = D7e({ value: n, schema: e });
    return r.success ? { ...r, rawValue: n } : r;
  } catch (n) {
    return {
      success: !1,
      error: nB.isInstance(n) ? n : new nB({ text: t, cause: n })
    };
  }
}
const N7e = Symbol("Let zodToJsonSchema decide on which parser to use"), iB = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, L7e = (t) => typeof t == "string" ? {
  ...iB,
  name: t
} : {
  ...iB,
  ...t
}, M7e = (t) => {
  const e = L7e(t), n = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
  return {
    ...e,
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(Object.entries(e.definitions).map(([r, s]) => [
      s._def,
      {
        def: s._def,
        path: [...e.basePath, e.definitionPath, r],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function tZ(t, e, n, r) {
  r?.errorMessages && n && (t.errorMessage = {
    ...t.errorMessage,
    [e]: n
  });
}
function kt(t, e, n, r, s) {
  t[e] = n, tZ(t, e, r, s);
}
function B7e() {
  return {};
}
function F7e(t, e) {
  const n = {
    type: "array"
  };
  return t.type?._def && t.type?._def?.typeName !== Ne.ZodAny && (n.items = St(t.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), t.minLength && kt(n, "minItems", t.minLength.value, t.minLength.message, e), t.maxLength && kt(n, "maxItems", t.maxLength.value, t.maxLength.message, e), t.exactLength && (kt(n, "minItems", t.exactLength.value, t.exactLength.message, e), kt(n, "maxItems", t.exactLength.value, t.exactLength.message, e)), n;
}
function $7e(t, e) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks)
    return n;
  for (const r of t.checks)
    switch (r.kind) {
      case "min":
        e.target === "jsonSchema7" ? r.inclusive ? kt(n, "minimum", r.value, r.message, e) : kt(n, "exclusiveMinimum", r.value, r.message, e) : (r.inclusive || (n.exclusiveMinimum = !0), kt(n, "minimum", r.value, r.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? r.inclusive ? kt(n, "maximum", r.value, r.message, e) : kt(n, "exclusiveMaximum", r.value, r.message, e) : (r.inclusive || (n.exclusiveMaximum = !0), kt(n, "maximum", r.value, r.message, e));
        break;
      case "multipleOf":
        kt(n, "multipleOf", r.value, r.message, e);
        break;
    }
  return n;
}
function U7e() {
  return {
    type: "boolean"
  };
}
function nZ(t, e) {
  return St(t.type._def, e);
}
const j7e = (t, e) => St(t.innerType._def, e);
function rZ(t, e, n) {
  const r = n ?? e.dateStrategy;
  if (Array.isArray(r))
    return {
      anyOf: r.map((s, i) => rZ(t, e, s))
    };
  switch (r) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return H7e(t, e);
  }
}
const H7e = (t, e) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3")
    return n;
  for (const r of t.checks)
    switch (r.kind) {
      case "min":
        kt(
          n,
          "minimum",
          r.value,
          // This is in milliseconds
          r.message,
          e
        );
        break;
      case "max":
        kt(
          n,
          "maximum",
          r.value,
          // This is in milliseconds
          r.message,
          e
        );
        break;
    }
  return n;
};
function z7e(t, e) {
  return {
    ...St(t.innerType._def, e),
    default: t.defaultValue()
  };
}
function G7e(t, e) {
  return e.effectStrategy === "input" ? St(t.schema._def, e) : {};
}
function V7e(t) {
  return {
    type: "string",
    enum: Array.from(t.values)
  };
}
const W7e = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function q7e(t, e) {
  const n = [
    St(t.left._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"]
    }),
    St(t.right._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i);
  let r = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const s = [];
  return n.forEach((i) => {
    if (W7e(i))
      s.push(...i.allOf), i.unevaluatedProperties === void 0 && (r = void 0);
    else {
      let o = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: a, ...l } = i;
        o = l;
      } else
        r = void 0;
      s.push(o);
    }
  }), s.length ? {
    allOf: s,
    ...r
  } : void 0;
}
function K7e(t, e) {
  const n = typeof t.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(t.value) ? "array" : "object"
  } : e.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [t.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: t.value
  };
}
let v1;
const hs = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (v1 === void 0 && (v1 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), v1),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function sZ(t, e) {
  const n = {
    type: "string"
  };
  if (t.checks)
    for (const r of t.checks)
      switch (r.kind) {
        case "min":
          kt(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, r.message, e);
          break;
        case "max":
          kt(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value, r.message, e);
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              ds(n, "email", r.message, e);
              break;
            case "format:idn-email":
              ds(n, "idn-email", r.message, e);
              break;
            case "pattern:zod":
              Wn(n, hs.email, r.message, e);
              break;
          }
          break;
        case "url":
          ds(n, "uri", r.message, e);
          break;
        case "uuid":
          ds(n, "uuid", r.message, e);
          break;
        case "regex":
          Wn(n, r.regex, r.message, e);
          break;
        case "cuid":
          Wn(n, hs.cuid, r.message, e);
          break;
        case "cuid2":
          Wn(n, hs.cuid2, r.message, e);
          break;
        case "startsWith":
          Wn(n, RegExp(`^${w1(r.value, e)}`), r.message, e);
          break;
        case "endsWith":
          Wn(n, RegExp(`${w1(r.value, e)}$`), r.message, e);
          break;
        case "datetime":
          ds(n, "date-time", r.message, e);
          break;
        case "date":
          ds(n, "date", r.message, e);
          break;
        case "time":
          ds(n, "time", r.message, e);
          break;
        case "duration":
          ds(n, "duration", r.message, e);
          break;
        case "length":
          kt(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, r.message, e), kt(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value, r.message, e);
          break;
        case "includes": {
          Wn(n, RegExp(w1(r.value, e)), r.message, e);
          break;
        }
        case "ip": {
          r.version !== "v6" && ds(n, "ipv4", r.message, e), r.version !== "v4" && ds(n, "ipv6", r.message, e);
          break;
        }
        case "base64url":
          Wn(n, hs.base64url, r.message, e);
          break;
        case "jwt":
          Wn(n, hs.jwt, r.message, e);
          break;
        case "cidr": {
          r.version !== "v6" && Wn(n, hs.ipv4Cidr, r.message, e), r.version !== "v4" && Wn(n, hs.ipv6Cidr, r.message, e);
          break;
        }
        case "emoji":
          Wn(n, hs.emoji(), r.message, e);
          break;
        case "ulid": {
          Wn(n, hs.ulid, r.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              ds(n, "binary", r.message, e);
              break;
            }
            case "contentEncoding:base64": {
              kt(n, "contentEncoding", "base64", r.message, e);
              break;
            }
            case "pattern:zod": {
              Wn(n, hs.base64, r.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          Wn(n, hs.nanoid, r.message, e);
      }
  return n;
}
function w1(t, e) {
  return e.patternStrategy === "escape" ? Z7e(t) : t;
}
const Y7e = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function Z7e(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    Y7e.has(t[n]) || (e += "\\"), e += t[n];
  return e;
}
function ds(t, e, n, r) {
  t.format || t.anyOf?.some((s) => s.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && r.errorMessages && {
      errorMessage: { format: t.errorMessage.format }
    }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: e,
    ...n && r.errorMessages && { errorMessage: { format: n } }
  })) : kt(t, "format", e, n, r);
}
function Wn(t, e, n, r) {
  t.pattern || t.allOf?.some((s) => s.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && r.errorMessages && {
      errorMessage: { pattern: t.errorMessage.pattern }
    }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: oB(e, r),
    ...n && r.errorMessages && { errorMessage: { pattern: n } }
  })) : kt(t, "pattern", oB(e, r), n, r);
}
function oB(t, e) {
  if (!e.applyRegexFlags || !t.flags)
    return t.source;
  const n = {
    i: t.flags.includes("i"),
    m: t.flags.includes("m"),
    s: t.flags.includes("s")
    // `.` matches newlines
  }, r = n.i ? t.source.toLowerCase() : t.source;
  let s = "", i = !1, o = !1, a = !1;
  for (let l = 0; l < r.length; l++) {
    if (i) {
      s += r[l], i = !1;
      continue;
    }
    if (n.i) {
      if (o) {
        if (r[l].match(/[a-z]/)) {
          a ? (s += r[l], s += `${r[l - 2]}-${r[l]}`.toUpperCase(), a = !1) : r[l + 1] === "-" && r[l + 2]?.match(/[a-z]/) ? (s += r[l], a = !0) : s += `${r[l]}${r[l].toUpperCase()}`;
          continue;
        }
      } else if (r[l].match(/[a-z]/)) {
        s += `[${r[l]}${r[l].toUpperCase()}]`;
        continue;
      }
    }
    if (n.m) {
      if (r[l] === "^") {
        s += `(^|(?<=[\r
]))`;
        continue;
      } else if (r[l] === "$") {
        s += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (n.s && r[l] === ".") {
      s += o ? `${r[l]}\r
` : `[${r[l]}\r
]`;
      continue;
    }
    s += r[l], r[l] === "\\" ? i = !0 : o && r[l] === "]" ? o = !1 : !o && r[l] === "[" && (o = !0);
  }
  try {
    new RegExp(s);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), t.source;
  }
  return s;
}
function iZ(t, e) {
  if (e.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), e.target === "openApi3" && t.keyType?._def.typeName === Ne.ZodEnum)
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce((r, s) => ({
        ...r,
        [s]: St(t.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "properties", s]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const n = {
    type: "object",
    additionalProperties: St(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (e.target === "openApi3")
    return n;
  if (t.keyType?._def.typeName === Ne.ZodString && t.keyType._def.checks?.length) {
    const { type: r, ...s } = sZ(t.keyType._def, e);
    return {
      ...n,
      propertyNames: s
    };
  } else {
    if (t.keyType?._def.typeName === Ne.ZodEnum)
      return {
        ...n,
        propertyNames: {
          enum: t.keyType._def.values
        }
      };
    if (t.keyType?._def.typeName === Ne.ZodBranded && t.keyType._def.type._def.typeName === Ne.ZodString && t.keyType._def.type._def.checks?.length) {
      const { type: r, ...s } = nZ(t.keyType._def, e);
      return {
        ...n,
        propertyNames: s
      };
    }
  }
  return n;
}
function J7e(t, e) {
  if (e.mapStrategy === "record")
    return iZ(t, e);
  const n = St(t.keyType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "0"]
  }) || {}, r = St(t.valueType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function X7e(t) {
  const e = t.values, r = Object.keys(t.values).filter((i) => typeof e[e[i]] != "number").map((i) => e[i]), s = Array.from(new Set(r.map((i) => typeof i)));
  return {
    type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function Q7e() {
  return {
    not: {}
  };
}
function eze(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const Xy = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function tze(t, e) {
  if (e.target === "openApi3")
    return aB(t, e);
  const n = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (n.every((r) => r._def.typeName in Xy && (!r._def.checks || !r._def.checks.length))) {
    const r = n.reduce((s, i) => {
      const o = Xy[i._def.typeName];
      return o && !s.includes(o) ? [...s, o] : s;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (n.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = n.reduce((s, i) => {
      const o = typeof i._def.value;
      switch (o) {
        case "string":
        case "number":
        case "boolean":
          return [...s, o];
        case "bigint":
          return [...s, "integer"];
        case "object":
          if (i._def.value === null)
            return [...s, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return s;
      }
    }, []);
    if (r.length === n.length) {
      const s = r.filter((i, o, a) => a.indexOf(i) === o);
      return {
        type: s.length > 1 ? s : s[0],
        enum: n.reduce((i, o) => i.includes(o._def.value) ? i : [...i, o._def.value], [])
      };
    }
  } else if (n.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce((r, s) => [
        ...r,
        ...s._def.values.filter((i) => !r.includes(i))
      ], [])
    };
  return aB(t, e);
}
const aB = (t, e) => {
  const n = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((r, s) => St(r._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", `${s}`]
  })).filter((r) => !!r && (!e.strictUnions || typeof r == "object" && Object.keys(r).length > 0));
  return n.length ? { anyOf: n } : void 0;
};
function nze(t, e) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return e.target === "openApi3" ? {
      type: Xy[t.innerType._def.typeName],
      nullable: !0
    } : {
      type: [
        Xy[t.innerType._def.typeName],
        "null"
      ]
    };
  if (e.target === "openApi3") {
    const r = St(t.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return r && "$ref" in r ? { allOf: [r], nullable: !0 } : r && { ...r, nullable: !0 };
  }
  const n = St(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function rze(t, e) {
  const n = {
    type: "number"
  };
  if (!t.checks)
    return n;
  for (const r of t.checks)
    switch (r.kind) {
      case "int":
        n.type = "integer", tZ(n, "type", r.message, e);
        break;
      case "min":
        e.target === "jsonSchema7" ? r.inclusive ? kt(n, "minimum", r.value, r.message, e) : kt(n, "exclusiveMinimum", r.value, r.message, e) : (r.inclusive || (n.exclusiveMinimum = !0), kt(n, "minimum", r.value, r.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? r.inclusive ? kt(n, "maximum", r.value, r.message, e) : kt(n, "exclusiveMaximum", r.value, r.message, e) : (r.inclusive || (n.exclusiveMaximum = !0), kt(n, "maximum", r.value, r.message, e));
        break;
      case "multipleOf":
        kt(n, "multipleOf", r.value, r.message, e);
        break;
    }
  return n;
}
function sze(t, e) {
  return e.removeAdditionalStrategy === "strict" ? t.catchall._def.typeName === "ZodNever" ? t.unknownKeys !== "strict" : St(t.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0 : t.catchall._def.typeName === "ZodNever" ? t.unknownKeys === "passthrough" : St(t.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0;
}
function ize(t, e) {
  const n = e.target === "openAi", r = {
    type: "object",
    ...Object.entries(t.shape()).reduce((s, [i, o]) => {
      if (o === void 0 || o._def === void 0)
        return s;
      let a = o.isOptional();
      a && n && (o instanceof ws && (o = o._def.innerType), o.isNullable() || (o = o.nullable()), a = !1);
      const l = St(o._def, {
        ...e,
        currentPath: [...e.currentPath, "properties", i],
        propertyPath: [...e.currentPath, "properties", i]
      });
      return l === void 0 ? s : {
        properties: { ...s.properties, [i]: l },
        required: a ? s.required : [...s.required, i]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: sze(t, e)
  };
  return r.required.length || delete r.required, r;
}
const oze = (t, e) => {
  if (e.currentPath.toString() === e.propertyPath?.toString())
    return St(t.innerType._def, e);
  const n = St(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"]
  });
  return n ? {
    anyOf: [
      {
        not: {}
      },
      n
    ]
  } : {};
}, aze = (t, e) => {
  if (e.pipeStrategy === "input")
    return St(t.in._def, e);
  if (e.pipeStrategy === "output")
    return St(t.out._def, e);
  const n = St(t.in._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", "0"]
  }), r = St(t.out._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, r].filter((s) => s !== void 0)
  };
};
function lze(t, e) {
  return St(t.type._def, e);
}
function cze(t, e) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: St(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return t.minSize && kt(r, "minItems", t.minSize.value, t.minSize.message, e), t.maxSize && kt(r, "maxItems", t.maxSize.value, t.maxSize.message, e), r;
}
function uze(t, e) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((n, r) => St(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${r}`]
    })).reduce((n, r) => r === void 0 ? n : [...n, r], []),
    additionalItems: St(t.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((n, r) => St(n._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${r}`]
    })).reduce((n, r) => r === void 0 ? n : [...n, r], [])
  };
}
function hze() {
  return {
    not: {}
  };
}
function dze() {
  return {};
}
const fze = (t, e) => St(t.innerType._def, e);
function St(t, e, n = !1) {
  const r = e.seen.get(t);
  if (e.override) {
    const o = e.override?.(t, e, r, n);
    if (o !== N7e)
      return o;
  }
  if (r && !n) {
    const o = pze(r, e);
    if (o !== void 0)
      return o;
  }
  const s = { def: t, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(t, s);
  const i = gze(t, t.typeName, e);
  return i && yze(t, e, i), s.jsonSchema = i, i;
}
const pze = (t, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    case "relative":
      return { $ref: mze(e.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < e.currentPath.length && t.path.every((n, r) => e.currentPath[r] === n) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), {}) : e.$refStrategy === "seen" ? {} : void 0;
  }
}, mze = (t, e) => {
  let n = 0;
  for (; n < t.length && n < e.length && t[n] === e[n]; n++)
    ;
  return [(t.length - n).toString(), ...e.slice(n)].join("/");
}, gze = (t, e, n) => {
  switch (e) {
    case Ne.ZodString:
      return sZ(t, n);
    case Ne.ZodNumber:
      return rze(t, n);
    case Ne.ZodObject:
      return ize(t, n);
    case Ne.ZodBigInt:
      return $7e(t, n);
    case Ne.ZodBoolean:
      return U7e();
    case Ne.ZodDate:
      return rZ(t, n);
    case Ne.ZodUndefined:
      return hze();
    case Ne.ZodNull:
      return eze(n);
    case Ne.ZodArray:
      return F7e(t, n);
    case Ne.ZodUnion:
    case Ne.ZodDiscriminatedUnion:
      return tze(t, n);
    case Ne.ZodIntersection:
      return q7e(t, n);
    case Ne.ZodTuple:
      return uze(t, n);
    case Ne.ZodRecord:
      return iZ(t, n);
    case Ne.ZodLiteral:
      return K7e(t, n);
    case Ne.ZodEnum:
      return V7e(t);
    case Ne.ZodNativeEnum:
      return X7e(t);
    case Ne.ZodNullable:
      return nze(t, n);
    case Ne.ZodOptional:
      return oze(t, n);
    case Ne.ZodMap:
      return J7e(t, n);
    case Ne.ZodSet:
      return cze(t, n);
    case Ne.ZodLazy:
      return St(t.getter()._def, n);
    case Ne.ZodPromise:
      return lze(t, n);
    case Ne.ZodNaN:
    case Ne.ZodNever:
      return Q7e();
    case Ne.ZodEffects:
      return G7e(t, n);
    case Ne.ZodAny:
      return B7e();
    case Ne.ZodUnknown:
      return dze();
    case Ne.ZodDefault:
      return z7e(t, n);
    case Ne.ZodBranded:
      return nZ(t, n);
    case Ne.ZodReadonly:
      return fze(t, n);
    case Ne.ZodCatch:
      return j7e(t, n);
    case Ne.ZodPipeline:
      return aze(t, n);
    case Ne.ZodFunction:
    case Ne.ZodVoid:
    case Ne.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
}, yze = (t, e, n) => (t.description && (n.description = t.description, e.markdownDescription && (n.markdownDescription = t.description)), n), bze = (t, e) => {
  const n = M7e(e), r = typeof e == "object" && e.definitions ? Object.entries(e.definitions).reduce((l, [c, u]) => ({
    ...l,
    [c]: St(u._def, {
      ...n,
      currentPath: [...n.basePath, n.definitionPath, c]
    }, !0) ?? {}
  }), {}) : void 0, s = typeof e == "string" ? e : e?.nameStrategy === "title" ? void 0 : e?.name, i = St(t._def, s === void 0 ? n : {
    ...n,
    currentPath: [...n.basePath, n.definitionPath, s]
  }, !1) ?? {}, o = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
  o !== void 0 && (i.title = o);
  const a = s === void 0 ? r ? {
    ...i,
    [n.definitionPath]: r
  } : i : {
    $ref: [
      ...n.$refStrategy === "relative" ? [] : n.basePath,
      n.definitionPath,
      s
    ].join("/"),
    [n.definitionPath]: {
      ...r,
      [s]: i
    }
  };
  return n.target === "jsonSchema7" ? a.$schema = "http://json-schema.org/draft-07/schema#" : (n.target === "jsonSchema2019-09" || n.target === "openAi") && (a.$schema = "https://json-schema.org/draft/2019-09/schema#"), n.target === "openAi" && ("anyOf" in a || "oneOf" in a || "allOf" in a || "type" in a && Array.isArray(a.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), a;
};
var Df = {
  code: "0",
  name: "text",
  parse: (t) => {
    if (typeof t != "string")
      throw new Error('"text" parts expect a string value.');
    return { type: "text", value: t };
  }
}, Nf = {
  code: "3",
  name: "error",
  parse: (t) => {
    if (typeof t != "string")
      throw new Error('"error" parts expect a string value.');
    return { type: "error", value: t };
  }
}, Lf = {
  code: "4",
  name: "assistant_message",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("id" in t) || !("role" in t) || !("content" in t) || typeof t.id != "string" || typeof t.role != "string" || t.role !== "assistant" || !Array.isArray(t.content) || !t.content.every(
      (e) => e != null && typeof e == "object" && "type" in e && e.type === "text" && "text" in e && e.text != null && typeof e.text == "object" && "value" in e.text && typeof e.text.value == "string"
    ))
      throw new Error(
        '"assistant_message" parts expect an object with an "id", "role", and "content" property.'
      );
    return {
      type: "assistant_message",
      value: t
    };
  }
}, Mf = {
  code: "5",
  name: "assistant_control_data",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("threadId" in t) || !("messageId" in t) || typeof t.threadId != "string" || typeof t.messageId != "string")
      throw new Error(
        '"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.'
      );
    return {
      type: "assistant_control_data",
      value: {
        threadId: t.threadId,
        messageId: t.messageId
      }
    };
  }
}, Bf = {
  code: "6",
  name: "data_message",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("role" in t) || !("data" in t) || typeof t.role != "string" || t.role !== "data")
      throw new Error(
        '"data_message" parts expect an object with a "role" and "data" property.'
      );
    return {
      type: "data_message",
      value: t
    };
  }
}, _ze = [
  Df,
  Nf,
  Lf,
  Mf,
  Bf
];
Df.code + "", Nf.code + "", Lf.code + "", Mf.code + "", Bf.code + "";
Df.name + "", Df.code, Nf.name + "", Nf.code, Lf.name + "", Lf.code, Mf.name + "", Mf.code, Bf.name + "", Bf.code;
_ze.map((t) => t.code);
function vze(t) {
  const e = ["ROOT"];
  let n = -1, r = null;
  function s(l, c, u) {
    switch (l) {
      case '"': {
        n = c, e.pop(), e.push(u), e.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        n = c, r = c, e.pop(), e.push(u), e.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        e.pop(), e.push(u), e.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        n = c, e.pop(), e.push(u), e.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        n = c, e.pop(), e.push(u), e.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        n = c, e.pop(), e.push(u), e.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function i(l, c) {
    switch (l) {
      case ",": {
        e.pop(), e.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        n = c, e.pop();
        break;
      }
    }
  }
  function o(l, c) {
    switch (l) {
      case ",": {
        e.pop(), e.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        n = c, e.pop();
        break;
      }
    }
  }
  for (let l = 0; l < t.length; l++) {
    const c = t[l];
    switch (e[e.length - 1]) {
      case "ROOT":
        s(c, l, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (c) {
          case '"': {
            e.pop(), e.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            n = l, e.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (c) {
          case '"': {
            e.pop(), e.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (c) {
          case '"': {
            e.pop(), e.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (c) {
          case ":": {
            e.pop(), e.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        s(c, l, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        i(c, l);
        break;
      }
      case "INSIDE_STRING": {
        switch (c) {
          case '"': {
            e.pop(), n = l;
            break;
          }
          case "\\": {
            e.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            n = l;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (c) {
          case "]": {
            n = l, e.pop();
            break;
          }
          default: {
            n = l, s(c, l, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (c) {
          case ",": {
            e.pop(), e.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            n = l, e.pop();
            break;
          }
          default: {
            n = l;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        s(c, l, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        e.pop(), n = l;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (c) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            n = l;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            e.pop(), e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l), e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && i(c, l);
            break;
          }
          case "}": {
            e.pop(), e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && i(c, l);
            break;
          }
          case "]": {
            e.pop(), e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l);
            break;
          }
          default: {
            e.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const h = t.substring(r, l + 1);
        !"false".startsWith(h) && !"true".startsWith(h) && !"null".startsWith(h) ? (e.pop(), e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? i(c, l) : e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l)) : n = l;
        break;
      }
    }
  }
  let a = t.slice(0, n + 1);
  for (let l = e.length - 1; l >= 0; l--)
    switch (e[l]) {
      case "INSIDE_STRING": {
        a += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        a += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        a += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const u = t.substring(r, t.length);
        "true".startsWith(u) ? a += "true".slice(u.length) : "false".startsWith(u) ? a += "false".slice(u.length) : "null".startsWith(u) && (a += "null".slice(u.length));
      }
    }
  return a;
}
function wze(t) {
  if (t === void 0)
    return { value: void 0, state: "undefined-input" };
  let e = sB({ text: t });
  return e.success ? { value: e.value, state: "successful-parse" } : (e = sB({ text: vze(t) }), e.success ? { value: e.value, state: "repaired-parse" } : { value: void 0, state: "failed-parse" });
}
var Ff = {
  code: "0",
  name: "text",
  parse: (t) => {
    if (typeof t != "string")
      throw new Error('"text" parts expect a string value.');
    return { type: "text", value: t };
  }
}, $f = {
  code: "2",
  name: "data",
  parse: (t) => {
    if (!Array.isArray(t))
      throw new Error('"data" parts expect an array value.');
    return { type: "data", value: t };
  }
}, Uf = {
  code: "3",
  name: "error",
  parse: (t) => {
    if (typeof t != "string")
      throw new Error('"error" parts expect a string value.');
    return { type: "error", value: t };
  }
}, jf = {
  code: "8",
  name: "message_annotations",
  parse: (t) => {
    if (!Array.isArray(t))
      throw new Error('"message_annotations" parts expect an array value.');
    return { type: "message_annotations", value: t };
  }
}, Hf = {
  code: "9",
  name: "tool_call",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("toolCallId" in t) || typeof t.toolCallId != "string" || !("toolName" in t) || typeof t.toolName != "string" || !("args" in t) || typeof t.args != "object")
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    return {
      type: "tool_call",
      value: t
    };
  }
}, zf = {
  code: "a",
  name: "tool_result",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("toolCallId" in t) || typeof t.toolCallId != "string" || !("result" in t))
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    return {
      type: "tool_result",
      value: t
    };
  }
}, Gf = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("toolCallId" in t) || typeof t.toolCallId != "string" || !("toolName" in t) || typeof t.toolName != "string")
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    return {
      type: "tool_call_streaming_start",
      value: t
    };
  }
}, Vf = {
  code: "c",
  name: "tool_call_delta",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("toolCallId" in t) || typeof t.toolCallId != "string" || !("argsTextDelta" in t) || typeof t.argsTextDelta != "string")
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    return {
      type: "tool_call_delta",
      value: t
    };
  }
}, Wf = {
  code: "d",
  name: "finish_message",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("finishReason" in t) || typeof t.finishReason != "string")
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    const e = {
      finishReason: t.finishReason
    };
    return "usage" in t && t.usage != null && typeof t.usage == "object" && "promptTokens" in t.usage && "completionTokens" in t.usage && (e.usage = {
      promptTokens: typeof t.usage.promptTokens == "number" ? t.usage.promptTokens : Number.NaN,
      completionTokens: typeof t.usage.completionTokens == "number" ? t.usage.completionTokens : Number.NaN
    }), {
      type: "finish_message",
      value: e
    };
  }
}, qf = {
  code: "e",
  name: "finish_step",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("finishReason" in t) || typeof t.finishReason != "string")
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    const e = {
      finishReason: t.finishReason,
      isContinued: !1
    };
    return "usage" in t && t.usage != null && typeof t.usage == "object" && "promptTokens" in t.usage && "completionTokens" in t.usage && (e.usage = {
      promptTokens: typeof t.usage.promptTokens == "number" ? t.usage.promptTokens : Number.NaN,
      completionTokens: typeof t.usage.completionTokens == "number" ? t.usage.completionTokens : Number.NaN
    }), "isContinued" in t && typeof t.isContinued == "boolean" && (e.isContinued = t.isContinued), {
      type: "finish_step",
      value: e
    };
  }
}, Kf = {
  code: "f",
  name: "start_step",
  parse: (t) => {
    if (t == null || typeof t != "object" || !("messageId" in t) || typeof t.messageId != "string")
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    return {
      type: "start_step",
      value: {
        messageId: t.messageId
      }
    };
  }
}, Yf = {
  code: "g",
  name: "reasoning",
  parse: (t) => {
    if (typeof t != "string")
      throw new Error('"reasoning" parts expect a string value.');
    return { type: "reasoning", value: t };
  }
}, oZ = [
  Ff,
  $f,
  Uf,
  jf,
  Hf,
  zf,
  Gf,
  Vf,
  Wf,
  qf,
  Kf,
  Yf
], Eze = {
  [Ff.code]: Ff,
  [$f.code]: $f,
  [Uf.code]: Uf,
  [jf.code]: jf,
  [Hf.code]: Hf,
  [zf.code]: zf,
  [Gf.code]: Gf,
  [Vf.code]: Vf,
  [Wf.code]: Wf,
  [qf.code]: qf,
  [Kf.code]: Kf,
  [Yf.code]: Yf
};
Ff.name + "", Ff.code, $f.name + "", $f.code, Uf.name + "", Uf.code, jf.name + "", jf.code, Hf.name + "", Hf.code, zf.name + "", zf.code, Gf.name + "", Gf.code, Vf.name + "", Vf.code, Wf.name + "", Wf.code, qf.name + "", qf.code, Kf.name + "", Kf.code, Yf.name + "", Yf.code;
var Sze = oZ.map((t) => t.code), xze = (t) => {
  const e = t.indexOf(":");
  if (e === -1)
    throw new Error("Failed to parse stream string. No separator found.");
  const n = t.slice(0, e);
  if (!Sze.includes(n))
    throw new Error(`Failed to parse stream string. Invalid code ${n}.`);
  const r = n, s = t.slice(e + 1), i = JSON.parse(s);
  return Eze[r].parse(i);
};
function mWe(t, e) {
  const n = oZ.find((r) => r.name === t);
  if (!n)
    throw new Error(`Invalid stream part type: ${t}`);
  return `${n.code}:${JSON.stringify(e)}
`;
}
var Tze = 10;
function Cze(t, e) {
  const n = new Uint8Array(e);
  let r = 0;
  for (const s of t)
    n.set(s, r), r += s.length;
  return t.length = 0, n;
}
async function kze({
  stream: t,
  onTextPart: e,
  onReasoningPart: n,
  onDataPart: r,
  onErrorPart: s,
  onToolCallStreamingStartPart: i,
  onToolCallDeltaPart: o,
  onToolCallPart: a,
  onToolResultPart: l,
  onMessageAnnotationsPart: c,
  onFinishMessagePart: u,
  onFinishStepPart: h,
  onStartStepPart: d
}) {
  const f = t.getReader(), g = new TextDecoder(), y = [];
  let p = 0;
  for (; ; ) {
    const { value: m } = await f.read();
    if (m && (y.push(m), p += m.length, m[m.length - 1] !== Tze))
      continue;
    if (y.length === 0)
      break;
    const b = Cze(y, p);
    p = 0;
    const _ = g.decode(b, { stream: !0 }).split(`
`).filter((v) => v !== "").map(xze);
    for (const { type: v, value: w } of _)
      switch (v) {
        case "text":
          await e?.(w);
          break;
        case "reasoning":
          await n?.(w);
          break;
        case "data":
          await r?.(w);
          break;
        case "error":
          await s?.(w);
          break;
        case "message_annotations":
          await c?.(w);
          break;
        case "tool_call_streaming_start":
          await i?.(w);
          break;
        case "tool_call_delta":
          await o?.(w);
          break;
        case "tool_call":
          await a?.(w);
          break;
        case "tool_result":
          await l?.(w);
          break;
        case "finish_message":
          await u?.(w);
          break;
        case "finish_step":
          await h?.(w);
          break;
        case "start_step":
          await d?.(w);
          break;
        default: {
          const E = v;
          throw new Error(`Unknown stream part type: ${E}`);
        }
      }
  }
}
function Aze({
  promptTokens: t,
  completionTokens: e
}) {
  return {
    promptTokens: t,
    completionTokens: e,
    totalTokens: t + e
  };
}
async function Rze({
  stream: t,
  update: e,
  onToolCall: n,
  onFinish: r,
  generateId: s = eZ,
  getCurrentDate: i = () => /* @__PURE__ */ new Date(),
  lastMessage: o
}) {
  var a, l;
  const c = o?.role === "assistant";
  let u = c ? 1 + // find max step in existing tool invocations:
  ((l = (a = o.toolInvocations) == null ? void 0 : a.reduce((b, _) => {
    var v;
    return Math.max(b, (v = _.step) != null ? v : 0);
  }, 0)) != null ? l : 0) : 0;
  const h = c ? structuredClone(o) : {
    id: s(),
    createdAt: i(),
    role: "assistant",
    content: ""
  }, d = [];
  let f = c ? o?.annotations : void 0;
  const g = {};
  let y = {
    completionTokens: NaN,
    promptTokens: NaN,
    totalTokens: NaN
  }, p = "unknown";
  function m() {
    const b = [...d];
    f?.length && (h.annotations = f);
    const _ = {
      // deep copy the message to ensure that deep changes (msg attachments) are updated
      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.
      ...structuredClone(h),
      // add a revision id to ensure that the message is updated with SWR. SWR uses a
      // hashing approach by default to detect changes, but it only works for shallow
      // changes. This is why we need to add a revision id to ensure that the message
      // is updated with SWR (without it, the changes get stuck in SWR and are not
      // forwarded to rendering):
      revisionId: s()
    };
    e({
      message: _,
      data: b,
      replaceLastMessage: c
    });
  }
  await kze({
    stream: t,
    onTextPart(b) {
      h.content += b, m();
    },
    onReasoningPart(b) {
      var _;
      h.reasoning = ((_ = h.reasoning) != null ? _ : "") + b, m();
    },
    onToolCallStreamingStartPart(b) {
      h.toolInvocations == null && (h.toolInvocations = []), g[b.toolCallId] = {
        text: "",
        step: u,
        toolName: b.toolName,
        index: h.toolInvocations.length
      }, h.toolInvocations.push({
        state: "partial-call",
        step: u,
        toolCallId: b.toolCallId,
        toolName: b.toolName,
        args: void 0
      }), m();
    },
    onToolCallDeltaPart(b) {
      const _ = g[b.toolCallId];
      _.text += b.argsTextDelta;
      const { value: v } = wze(_.text);
      h.toolInvocations[_.index] = {
        state: "partial-call",
        step: _.step,
        toolCallId: b.toolCallId,
        toolName: _.toolName,
        args: v
      }, m();
    },
    async onToolCallPart(b) {
      if (g[b.toolCallId] != null ? h.toolInvocations[g[b.toolCallId].index] = {
        state: "call",
        step: u,
        ...b
      } : (h.toolInvocations == null && (h.toolInvocations = []), h.toolInvocations.push({
        state: "call",
        step: u,
        ...b
      })), n) {
        const _ = await n({ toolCall: b });
        _ != null && (h.toolInvocations[h.toolInvocations.length - 1] = {
          state: "result",
          step: u,
          ...b,
          result: _
        });
      }
      m();
    },
    onToolResultPart(b) {
      const _ = h.toolInvocations;
      if (_ == null)
        throw new Error("tool_result must be preceded by a tool_call");
      const v = _.findIndex(
        (w) => w.toolCallId === b.toolCallId
      );
      if (v === -1)
        throw new Error(
          "tool_result must be preceded by a tool_call with the same toolCallId"
        );
      _[v] = {
        ..._[v],
        state: "result",
        ...b
      }, m();
    },
    onDataPart(b) {
      d.push(...b), m();
    },
    onMessageAnnotationsPart(b) {
      f == null ? f = [...b] : f.push(...b), m();
    },
    onFinishStepPart(b) {
      u += 1;
    },
    onStartStepPart(b) {
      c || (h.id = b.messageId);
    },
    onFinishMessagePart(b) {
      p = b.finishReason, b.usage != null && (y = Aze(b.usage));
    },
    onErrorPart(b) {
      throw new Error(b);
    }
  }), r?.({ message: h, finishReason: p, usage: y });
}
async function Ize({
  stream: t,
  onTextPart: e
}) {
  const n = t.pipeThrough(new TextDecoderStream()).getReader();
  for (; ; ) {
    const { done: r, value: s } = await n.read();
    if (r)
      break;
    await e(s);
  }
}
var Pze = () => fetch;
async function Oze({
  api: t,
  body: e,
  streamProtocol: n = "data",
  credentials: r,
  headers: s,
  abortController: i,
  restoreMessagesOnFailure: o,
  onResponse: a,
  onUpdate: l,
  onFinish: c,
  onToolCall: u,
  generateId: h,
  fetch: d = Pze(),
  lastMessage: f
}) {
  var g, y;
  const p = await d(t, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      ...s
    },
    signal: (g = i?.()) == null ? void 0 : g.signal,
    credentials: r
  }).catch((m) => {
    throw o(), m;
  });
  if (a)
    try {
      await a(p);
    } catch (m) {
      throw m;
    }
  if (!p.ok)
    throw o(), new Error(
      (y = await p.text()) != null ? y : "Failed to fetch the chat response."
    );
  if (!p.body)
    throw new Error("The response body is empty.");
  switch (n) {
    case "text": {
      const m = {
        id: h(),
        createdAt: /* @__PURE__ */ new Date(),
        role: "assistant",
        content: ""
      };
      await Ize({
        stream: p.body,
        onTextPart: (b) => {
          m.content += b, l({
            message: { ...m },
            data: [],
            replaceLastMessage: !1
          });
        }
      }), c?.(m, {
        usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },
        finishReason: "unknown"
      });
      return;
    }
    case "data": {
      await Rze({
        stream: p.body,
        update: l,
        lastMessage: f,
        onToolCall: u,
        onFinish({ message: m, finishReason: b, usage: _ }) {
          c && m != null && c(m, { usage: _, finishReason: b });
        },
        generateId: h
      });
      return;
    }
    default: {
      const m = n;
      throw new Error(`Unknown stream protocol: ${m}`);
    }
  }
}
function E1(t) {
  return t?.reduce((e, n) => {
    var r;
    return Math.max(e, (r = n.step) != null ? r : 0);
  }, 0);
}
async function lB(t) {
  if (!t)
    return [];
  if (t instanceof FileList)
    return Promise.all(
      Array.from(t).map(async (e) => {
        const { name: n, type: r } = e, s = await new Promise((i, o) => {
          const a = new FileReader();
          a.onload = (l) => {
            var c;
            i((c = l.target) == null ? void 0 : c.result);
          }, a.onerror = (l) => o(l), a.readAsDataURL(e);
        });
        return {
          name: n,
          contentType: r,
          url: s
        };
      })
    );
  if (Array.isArray(t))
    return t;
  throw new Error("Invalid attachments type");
}
function Dze(t) {
  return Nze(
    bze(t, {
      $refStrategy: "none",
      // no references (to support openapi conversion for google)
      target: "jsonSchema7"
      // note: openai mode breaks various gemini conversions
    }),
    {
      validate: (e) => {
        const n = t.safeParse(e);
        return n.success ? { success: !0, value: n.data } : { success: !1, error: n.error };
      }
    }
  );
}
var TT = Symbol.for("vercel.ai.schema");
function Nze(t, {
  validate: e
} = {}) {
  return {
    [TT]: !0,
    _type: void 0,
    // should never be used directly
    [Jy]: !0,
    jsonSchema: t,
    validate: e
  };
}
function Lze(t) {
  return typeof t == "object" && t !== null && TT in t && t[TT] === !0 && "jsonSchema" in t && "validate" in t;
}
function gWe(t) {
  return Lze(t) ? t : Dze(t);
}
var CT = { exports: {} }, S1 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cB;
function Mze() {
  if (cB) return S1;
  cB = 1;
  var t = I;
  function e(h, d) {
    return h === d && (h !== 0 || 1 / h === 1 / d) || h !== h && d !== d;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, s = t.useEffect, i = t.useLayoutEffect, o = t.useDebugValue;
  function a(h, d) {
    var f = d(), g = r({ inst: { value: f, getSnapshot: d } }), y = g[0].inst, p = g[1];
    return i(
      function() {
        y.value = f, y.getSnapshot = d, l(y) && p({ inst: y });
      },
      [h, f, d]
    ), s(
      function() {
        return l(y) && p({ inst: y }), h(function() {
          l(y) && p({ inst: y });
        });
      },
      [h]
    ), o(f), f;
  }
  function l(h) {
    var d = h.getSnapshot;
    h = h.value;
    try {
      var f = d();
      return !n(h, f);
    } catch {
      return !0;
    }
  }
  function c(h, d) {
    return d();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
  return S1.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : u, S1;
}
var x1 = {}, uB;
function Bze() {
  return uB || (uB = 1, je.env.NODE_ENV !== "production" && function() {
    function t(f, g) {
      return f === g && (f !== 0 || 1 / f === 1 / g) || f !== f && g !== g;
    }
    function e(f, g) {
      u || s.startTransition === void 0 || (u = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var y = g();
      if (!h) {
        var p = g();
        i(y, p) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), h = !0);
      }
      p = o({
        inst: { value: y, getSnapshot: g }
      });
      var m = p[0].inst, b = p[1];
      return l(
        function() {
          m.value = y, m.getSnapshot = g, n(m) && b({ inst: m });
        },
        [f, y, g]
      ), a(
        function() {
          return n(m) && b({ inst: m }), f(function() {
            n(m) && b({ inst: m });
          });
        },
        [f]
      ), c(y), y;
    }
    function n(f) {
      var g = f.getSnapshot;
      f = f.value;
      try {
        var y = g();
        return !i(f, y);
      } catch {
        return !0;
      }
    }
    function r(f, g) {
      return g();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var s = I, i = typeof Object.is == "function" ? Object.is : t, o = s.useState, a = s.useEffect, l = s.useLayoutEffect, c = s.useDebugValue, u = !1, h = !1, d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : e;
    x1.useSyncExternalStore = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : d, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), x1;
}
je.env.NODE_ENV === "production" ? CT.exports = Mze() : CT.exports = Bze();
var Fze = CT.exports, hB = Object.prototype.hasOwnProperty;
function kT(t, e) {
  var n, r;
  if (t === e) return !0;
  if (t && e && (n = t.constructor) === e.constructor) {
    if (n === Date) return t.getTime() === e.getTime();
    if (n === RegExp) return t.toString() === e.toString();
    if (n === Array) {
      if ((r = t.length) === e.length)
        for (; r-- && kT(t[r], e[r]); ) ;
      return r === -1;
    }
    if (!n || typeof t == "object") {
      r = 0;
      for (n in t)
        if (hB.call(t, n) && ++r && !hB.call(e, n) || !(n in e) || !kT(t[n], e[n])) return !1;
      return Object.keys(e).length === r;
    }
  }
  return t !== t && e !== e;
}
const no = /* @__PURE__ */ new WeakMap(), Wo = () => {
}, Zn = (
  /*#__NOINLINE__*/
  Wo()
), AT = Object, wt = (t) => t === Zn, fi = (t) => typeof t == "function", ma = (t, e) => ({
  ...t,
  ...e
}), aZ = (t) => fi(t.then), T1 = {}, ig = {}, I2 = "undefined", M_ = typeof window != I2, RT = typeof document != I2, $ze = () => M_ && typeof window.requestAnimationFrame != I2, lZ = (t, e) => {
  const n = no.get(t);
  return [
    // Getter
    () => !wt(e) && t.get(e) || T1,
    // Setter
    (r) => {
      if (!wt(e)) {
        const s = t.get(e);
        e in ig || (ig[e] = s), n[5](e, ma(s, r), s || T1);
      }
    },
    // Subscriber
    n[6],
    // Get server cache snapshot
    () => !wt(e) && e in ig ? ig[e] : !wt(e) && t.get(e) || T1
  ];
};
let IT = !0;
const Uze = () => IT, [PT, OT] = M_ && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  Wo,
  Wo
], jze = () => {
  const t = RT && document.visibilityState;
  return wt(t) || t !== "hidden";
}, Hze = (t) => (RT && document.addEventListener("visibilitychange", t), PT("focus", t), () => {
  RT && document.removeEventListener("visibilitychange", t), OT("focus", t);
}), zze = (t) => {
  const e = () => {
    IT = !0, t();
  }, n = () => {
    IT = !1;
  };
  return PT("online", e), PT("offline", n), () => {
    OT("online", e), OT("offline", n);
  };
}, Gze = {
  isOnline: Uze,
  isVisible: jze
}, Vze = {
  initFocus: Hze,
  initReconnect: zze
}, dB = !Qe.useId, Zf = !M_ || "Deno" in globalThis, Wze = (t) => $ze() ? window.requestAnimationFrame(t) : setTimeout(t, 1), C1 = Zf ? I.useEffect : I.useLayoutEffect, k1 = typeof navigator < "u" && navigator.connection, fB = !Zf && k1 && ([
  "slow-2g",
  "2g"
].includes(k1.effectiveType) || k1.saveData), og = /* @__PURE__ */ new WeakMap(), A1 = (t, e) => AT.prototype.toString.call(t) === `[object ${e}]`;
let qze = 0;
const DT = (t) => {
  const e = typeof t, n = A1(t, "Date"), r = A1(t, "RegExp"), s = A1(t, "Object");
  let i, o;
  if (AT(t) === t && !n && !r) {
    if (i = og.get(t), i) return i;
    if (i = ++qze + "~", og.set(t, i), Array.isArray(t)) {
      for (i = "@", o = 0; o < t.length; o++)
        i += DT(t[o]) + ",";
      og.set(t, i);
    }
    if (s) {
      i = "#";
      const a = AT.keys(t).sort();
      for (; !wt(o = a.pop()); )
        wt(t[o]) || (i += o + ":" + DT(t[o]) + ",");
      og.set(t, i);
    }
  } else
    i = n ? t.toJSON() : e == "symbol" ? t.toString() : e == "string" ? JSON.stringify(t) : "" + t;
  return i;
}, P2 = (t) => {
  if (fi(t))
    try {
      t = t();
    } catch {
      t = "";
    }
  const e = t;
  return t = typeof t == "string" ? t : (Array.isArray(t) ? t.length : t) ? DT(t) : "", [
    t,
    e
  ];
};
let Kze = 0;
const NT = () => ++Kze, cZ = 0, uZ = 1, hZ = 2, Yze = 3;
var vh = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT: Yze,
  FOCUS_EVENT: cZ,
  MUTATE_EVENT: hZ,
  RECONNECT_EVENT: uZ
};
async function dZ(...t) {
  const [e, n, r, s] = t, i = ma({
    populateCache: !0,
    throwOnError: !0
  }, typeof s == "boolean" ? {
    revalidate: s
  } : s || {});
  let o = i.populateCache;
  const a = i.rollbackOnError;
  let l = i.optimisticData;
  const c = (d) => typeof a == "function" ? a(d) : a !== !1, u = i.throwOnError;
  if (fi(n)) {
    const d = n, f = [], g = e.keys();
    for (const y of g)
      // Skip the special useSWRInfinite and useSWRSubscription keys.
      !/^\$(inf|sub)\$/.test(y) && d(e.get(y)._k) && f.push(y);
    return Promise.all(f.map(h));
  }
  return h(n);
  async function h(d) {
    const [f] = P2(d);
    if (!f) return;
    const [g, y] = lZ(e, f), [p, m, b, _] = no.get(e), v = () => {
      const M = p[f];
      return (fi(i.revalidate) ? i.revalidate(g().data, d) : i.revalidate !== !1) && (delete b[f], delete _[f], M && M[0]) ? M[0](hZ).then(() => g().data) : g().data;
    };
    if (t.length < 3)
      return v();
    let w = r, E;
    const x = NT();
    m[f] = [
      x,
      0
    ];
    const S = !wt(l), T = g(), R = T.data, F = T._c, P = wt(F) ? R : F;
    if (S && (l = fi(l) ? l(P, R) : l, y({
      data: l,
      _c: P
    })), fi(w))
      try {
        w = w(P);
      } catch (M) {
        E = M;
      }
    if (w && aZ(w))
      if (w = await w.catch((M) => {
        E = M;
      }), x !== m[f][0]) {
        if (E) throw E;
        return w;
      } else E && S && c(E) && (o = !0, y({
        data: P,
        _c: Zn
      }));
    if (o && !E)
      if (fi(o)) {
        const M = o(w, P);
        y({
          data: M,
          error: Zn,
          _c: Zn
        });
      } else
        y({
          data: w,
          error: Zn,
          _c: Zn
        });
    if (m[f][1] = NT(), Promise.resolve(v()).then(() => {
      y({
        _c: Zn
      });
    }), E) {
      if (u) throw E;
      return;
    }
    return w;
  }
}
const pB = (t, e) => {
  for (const n in t)
    t[n][0] && t[n][0](e);
}, Zze = (t, e) => {
  if (!no.has(t)) {
    const n = ma(Vze, e), r = {}, s = dZ.bind(Zn, t);
    let i = Wo;
    const o = {}, a = (u, h) => {
      const d = o[u] || [];
      return o[u] = d, d.push(h), () => d.splice(d.indexOf(h), 1);
    }, l = (u, h, d) => {
      t.set(u, h);
      const f = o[u];
      if (f)
        for (const g of f)
          g(h, d);
    }, c = () => {
      if (!no.has(t) && (no.set(t, [
        r,
        {},
        {},
        {},
        s,
        l,
        a
      ]), !Zf)) {
        const u = n.initFocus(setTimeout.bind(Zn, pB.bind(Zn, r, cZ))), h = n.initReconnect(setTimeout.bind(Zn, pB.bind(Zn, r, uZ)));
        i = () => {
          u && u(), h && h(), no.delete(t);
        };
      }
    };
    return c(), [
      t,
      s,
      c,
      i
    ];
  }
  return [
    t,
    no.get(t)[4]
  ];
}, Jze = (t, e, n, r, s) => {
  const i = n.errorRetryCount, o = s.retryCount, a = ~~((Math.random() + 0.5) * (1 << (o < 8 ? o : 8))) * n.errorRetryInterval;
  !wt(i) && o > i || setTimeout(r, a, s);
}, Xze = kT, [fZ, Qze] = Zze(/* @__PURE__ */ new Map()), eGe = ma(
  {
    // events
    onLoadingSlow: Wo,
    onSuccess: Wo,
    onError: Wo,
    onErrorRetry: Jze,
    onDiscarded: Wo,
    // switches
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    // timeouts
    errorRetryInterval: fB ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: fB ? 5e3 : 3e3,
    // providers
    compare: Xze,
    isPaused: () => !1,
    cache: fZ,
    mutate: Qze,
    fallback: {}
  },
  // use web preset by default
  Gze
), tGe = (t, e) => {
  const n = ma(t, e);
  if (e) {
    const { use: r, fallback: s } = t, { use: i, fallback: o } = e;
    r && i && (n.use = r.concat(i)), s && o && (n.fallback = ma(s, o));
  }
  return n;
}, nGe = I.createContext({}), rGe = "$inf$", pZ = M_ && window.__SWR_DEVTOOLS_USE__, sGe = pZ ? window.__SWR_DEVTOOLS_USE__ : [], iGe = () => {
  pZ && (window.__SWR_DEVTOOLS_REACT__ = Qe);
}, oGe = (t) => fi(t[1]) ? [
  t[0],
  t[1],
  t[2] || {}
] : [
  t[0],
  null,
  (t[1] === null ? t[2] : t[1]) || {}
], aGe = () => ma(eGe, I.useContext(nGe)), lGe = (t) => (e, n, r) => t(e, n && ((...i) => {
  const [o] = P2(e), [, , , a] = no.get(fZ);
  if (o.startsWith(rGe))
    return n(...i);
  const l = a[o];
  return wt(l) ? n(...i) : (delete a[o], l);
}), r), cGe = sGe.concat(lGe), uGe = (t) => function(...n) {
  const r = aGe(), [s, i, o] = oGe(n), a = tGe(r, o);
  let l = t;
  const { use: c } = a, u = (c || []).concat(cGe);
  for (let h = u.length; h--; )
    l = u[h](l);
  return l(s, i || a.fetcher || null, a);
}, hGe = (t, e, n) => {
  const r = e[t] || (e[t] = []);
  return r.push(n), () => {
    const s = r.indexOf(n);
    s >= 0 && (r[s] = r[r.length - 1], r.pop());
  };
};
iGe();
const R1 = Qe.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
// and emitting an error.
// We assume that this is only for the `use(thenable)` case, not `use(context)`.
// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
((t) => {
  switch (t.status) {
    case "pending":
      throw t;
    case "fulfilled":
      return t.value;
    case "rejected":
      throw t.reason;
    default:
      throw t.status = "pending", t.then((e) => {
        t.status = "fulfilled", t.value = e;
      }, (e) => {
        t.status = "rejected", t.reason = e;
      }), t;
  }
}), I1 = {
  dedupe: !0
}, dGe = (t, e, n) => {
  const { cache: r, compare: s, suspense: i, fallbackData: o, revalidateOnMount: a, revalidateIfStale: l, refreshInterval: c, refreshWhenHidden: u, refreshWhenOffline: h, keepPreviousData: d } = n, [f, g, y, p] = no.get(r), [m, b] = P2(t), _ = I.useRef(!1), v = I.useRef(!1), w = I.useRef(m), E = I.useRef(e), x = I.useRef(n), S = () => x.current, T = () => S().isVisible() && S().isOnline(), [R, F, P, M] = lZ(r, m), A = I.useRef({}).current, V = wt(o) ? wt(n.fallback) ? Zn : n.fallback[m] : o, ee = (de, _e) => {
    for (const $ in A) {
      const ce = $;
      if (ce === "data") {
        if (!s(de[ce], _e[ce]) && (!wt(de[ce]) || !s(ne, _e[ce])))
          return !1;
      } else if (_e[ce] !== de[ce])
        return !1;
    }
    return !0;
  }, K = I.useMemo(() => {
    const de = !m || !e ? !1 : wt(a) ? S().isPaused() || i ? !1 : l !== !1 : a, _e = (ie) => {
      const ye = ma(ie);
      return delete ye._k, de ? {
        isValidating: !0,
        isLoading: !0,
        ...ye
      } : ye;
    }, $ = R(), ce = M(), re = _e($), W = $ === ce ? re : _e(ce);
    let q = re;
    return [
      () => {
        const ie = _e(R());
        return ee(ie, q) ? (q.data = ie.data, q.isLoading = ie.isLoading, q.isValidating = ie.isValidating, q.error = ie.error, q) : (q = ie, ie);
      },
      () => W
    ];
  }, [
    r,
    m
  ]), te = Fze.useSyncExternalStore(I.useCallback(
    (de) => P(m, (_e, $) => {
      ee($, _e) || de();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      r,
      m
    ]
  ), K[0], K[1]), N = !_.current, L = f[m] && f[m].length > 0, j = te.data, H = wt(j) ? V && aZ(V) ? R1(V) : V : j, U = te.error, Y = I.useRef(H), ne = d ? wt(j) ? Y.current : j : H, he = L && !wt(U) ? !1 : N && !wt(a) ? a : S().isPaused() ? !1 : i ? wt(H) ? !1 : l : wt(H) || l, X = !!(m && e && N && he), z = wt(te.isValidating) ? X : te.isValidating, ue = wt(te.isLoading) ? X : te.isLoading, ae = I.useCallback(
    async (de) => {
      const _e = E.current;
      if (!m || !_e || v.current || S().isPaused())
        return !1;
      let $, ce, re = !0;
      const W = de || {}, q = !y[m] || !W.dedupe, ie = () => dB ? !v.current && m === w.current && _.current : m === w.current, ye = {
        isValidating: !1,
        isLoading: !1
      }, xe = () => {
        F(ye);
      }, fe = () => {
        const ve = y[m];
        ve && ve[1] === ce && delete y[m];
      }, Ce = {
        isValidating: !0
      };
      wt(R().data) && (Ce.isLoading = !0);
      try {
        if (q && (F(Ce), n.loadingTimeout && wt(R().data) && setTimeout(() => {
          re && ie() && S().onLoadingSlow(m, n);
        }, n.loadingTimeout), y[m] = [
          _e(b),
          NT()
        ]), [$, ce] = y[m], $ = await $, q && setTimeout(fe, n.dedupingInterval), !y[m] || y[m][1] !== ce)
          return q && ie() && S().onDiscarded(m), !1;
        ye.error = Zn;
        const ve = g[m];
        if (!wt(ve) && // case 1
        (ce <= ve[0] || // case 2
        ce <= ve[1] || // case 3
        ve[1] === 0))
          return xe(), q && ie() && S().onDiscarded(m), !1;
        const Ee = R().data;
        ye.data = s(Ee, $) ? Ee : $, q && ie() && S().onSuccess($, m, n);
      } catch (ve) {
        fe();
        const Ee = S(), { shouldRetryOnError: oe } = Ee;
        Ee.isPaused() || (ye.error = ve, q && ie() && (Ee.onError(ve, m, Ee), (oe === !0 || fi(oe) && oe(ve)) && (!S().revalidateOnFocus || !S().revalidateOnReconnect || T()) && Ee.onErrorRetry(ve, m, Ee, (Te) => {
          const ke = f[m];
          ke && ke[0] && ke[0](vh.ERROR_REVALIDATE_EVENT, Te);
        }, {
          retryCount: (W.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return re = !1, xe(), !0;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      m,
      r
    ]
  ), be = I.useCallback(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...de) => dZ(r, w.current, ...de),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (C1(() => {
    E.current = e, x.current = n, wt(j) || (Y.current = j);
  }), C1(() => {
    if (!m) return;
    const de = ae.bind(Zn, I1);
    let _e = 0;
    const ce = hGe(m, f, (re, W = {}) => {
      if (re == vh.FOCUS_EVENT) {
        const q = Date.now();
        S().revalidateOnFocus && q > _e && T() && (_e = q + S().focusThrottleInterval, de());
      } else if (re == vh.RECONNECT_EVENT)
        S().revalidateOnReconnect && T() && de();
      else {
        if (re == vh.MUTATE_EVENT)
          return ae();
        if (re == vh.ERROR_REVALIDATE_EVENT)
          return ae(W);
      }
    });
    return v.current = !1, w.current = m, _.current = !0, F({
      _k: b
    }), he && (wt(H) || Zf ? de() : Wze(de)), () => {
      v.current = !0, ce();
    };
  }, [
    m
  ]), C1(() => {
    let de;
    function _e() {
      const ce = fi(c) ? c(R().data) : c;
      ce && de !== -1 && (de = setTimeout($, ce));
    }
    function $() {
      !R().error && (u || S().isVisible()) && (h || S().isOnline()) ? ae(I1).then(_e) : _e();
    }
    return _e(), () => {
      de && (clearTimeout(de), de = -1);
    };
  }, [
    c,
    u,
    h,
    m
  ]), I.useDebugValue(ne), i && wt(H) && m) {
    if (!dB && Zf)
      throw new Error("Fallback data is required when using Suspense in SSR.");
    E.current = e, x.current = n, v.current = !1;
    const de = p[m];
    if (!wt(de)) {
      const _e = be(de);
      R1(_e);
    }
    if (wt(U)) {
      const _e = ae(I1);
      wt(ne) || (_e.status = "fulfilled", _e.value = !0), R1(_e);
    } else
      throw U;
  }
  return {
    mutate: be,
    get data() {
      return A.data = !0, ne;
    },
    get error() {
      return A.error = !0, U;
    },
    get isValidating() {
      return A.isValidating = !0, z;
    },
    get isLoading() {
      return A.isLoading = !0, ue;
    }
  };
}, ag = uGe(dGe);
function fGe(t, e) {
  if (typeof t != "function")
    throw new TypeError(`Expected the first argument to be a \`function\`, got \`${typeof t}\`.`);
  let n, r = 0;
  return function(...i) {
    clearTimeout(n);
    const o = Date.now(), a = o - r, l = e - a;
    l <= 0 ? (r = o, t.apply(this, i)) : n = setTimeout(() => {
      r = Date.now(), t.apply(this, i);
    }, l);
  };
}
var pGe = fGe;
const mGe = /* @__PURE__ */ Is(pGe);
function mB(t, e) {
  return e != null ? mGe(t, e) : t;
}
function gGe({
  api: t = "/api/chat",
  id: e,
  initialMessages: n,
  initialInput: r = "",
  sendExtraMessageFields: s,
  onToolCall: i,
  experimental_prepareRequestBody: o,
  maxSteps: a = 1,
  streamProtocol: l = "data",
  onResponse: c,
  onFinish: u,
  onError: h,
  credentials: d,
  headers: f,
  body: g,
  generateId: y = eZ,
  fetch: p,
  keepLastMessageOnError: m = !0,
  experimental_throttle: b
} = {}) {
  const [_] = I.useState(y), v = e ?? _, w = typeof t == "string" ? [t, v] : v, [E] = I.useState([]), { data: x, mutate: S } = ag(
    [w, "messages"],
    null,
    { fallbackData: n ?? E }
  ), T = I.useRef(x || []);
  I.useEffect(() => {
    T.current = x || [];
  }, [x]);
  const { data: R, mutate: F } = ag([w, "streamData"], null), P = I.useRef(R);
  I.useEffect(() => {
    P.current = R;
  }, [R]);
  const { data: M = !1, mutate: A } = ag(
    [w, "loading"],
    null
  ), { data: V = void 0, mutate: ee } = ag([w, "error"], null), K = I.useRef(null), te = I.useRef({
    credentials: d,
    headers: f,
    body: g
  });
  I.useEffect(() => {
    te.current = {
      credentials: d,
      headers: f,
      body: g
    };
  }, [d, f, g]);
  const N = I.useCallback(
    async (ae) => {
      var be, de, _e;
      const $ = ae.messages.length, ce = E1(
        (be = ae.messages[ae.messages.length - 1]) == null ? void 0 : be.toolInvocations
      );
      try {
        A(!0), ee(void 0);
        const q = new AbortController();
        K.current = q;
        const ie = mB(S, b), ye = mB(
          F,
          b
        ), xe = T.current;
        ie(ae.messages, !1);
        const fe = s ? ae.messages : ae.messages.map(
          ({
            role: ve,
            content: Ee,
            experimental_attachments: oe,
            data: Te,
            annotations: ke,
            toolInvocations: Ge
          }) => ({
            role: ve,
            content: Ee,
            ...oe !== void 0 && {
              experimental_attachments: oe
            },
            ...Te !== void 0 && { data: Te },
            ...ke !== void 0 && { annotations: ke },
            ...Ge !== void 0 && { toolInvocations: Ge }
          })
        ), Ce = P.current;
        await Oze({
          api: t,
          body: (de = o?.({
            id: v,
            messages: ae.messages,
            requestData: ae.data,
            requestBody: ae.body
          })) != null ? de : {
            id: v,
            messages: fe,
            data: ae.data,
            ...te.current.body,
            ...ae.body
          },
          streamProtocol: l,
          credentials: te.current.credentials,
          headers: {
            ...te.current.headers,
            ...ae.headers
          },
          abortController: () => K.current,
          restoreMessagesOnFailure() {
            m || ie(xe, !1);
          },
          onResponse: c,
          onUpdate({ message: ve, data: Ee, replaceLastMessage: oe }) {
            ie(
              [
                ...oe ? ae.messages.slice(
                  0,
                  ae.messages.length - 1
                ) : ae.messages,
                ve
              ],
              !1
            ), Ee?.length && ye(
              [...Ce ?? [], ...Ee],
              !1
            );
          },
          onToolCall: i,
          onFinish: u,
          generateId: y,
          fetch: p,
          lastMessage: ae.messages[ae.messages.length - 1]
        }), K.current = null;
      } catch (q) {
        if (q.name === "AbortError")
          return K.current = null, null;
        h && q instanceof Error && h(q), ee(q);
      } finally {
        A(!1);
      }
      const re = T.current, W = re[re.length - 1];
      // ensure there is a last message:
      W != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):
      (re.length > $ || E1(W.toolInvocations) !== ce) && // check if the feature is enabled:
      a > 1 && // check that next step is possible:
      gB(W) && // check that assistant has not answered yet:
      !W.content && // empty string or undefined
      // limit the number of automatic steps:
      ((_e = E1(W.toolInvocations)) != null ? _e : 0) < a && await N({ messages: re });
    },
    [
      S,
      A,
      t,
      te,
      c,
      u,
      h,
      ee,
      F,
      P,
      l,
      s,
      o,
      i,
      a,
      T,
      K,
      y,
      p,
      m,
      b,
      v
    ]
  ), L = I.useCallback(
    async (ae, {
      data: be,
      headers: de,
      body: _e,
      experimental_attachments: $
    } = {}) => {
      var ce, re;
      const W = await lB(
        $
      ), q = T.current.concat({
        ...ae,
        id: (ce = ae.id) != null ? ce : y(),
        createdAt: (re = ae.createdAt) != null ? re : /* @__PURE__ */ new Date(),
        experimental_attachments: W.length > 0 ? W : void 0
      });
      return N({ messages: q, headers: de, body: _e, data: be });
    },
    [N, y]
  ), j = I.useCallback(
    async ({ data: ae, headers: be, body: de } = {}) => {
      const _e = T.current;
      if (_e.length === 0)
        return null;
      const $ = _e[_e.length - 1];
      return N({
        messages: $.role === "assistant" ? _e.slice(0, -1) : _e,
        headers: be,
        body: de,
        data: ae
      });
    },
    [N]
  ), H = I.useCallback(() => {
    K.current && (K.current.abort(), K.current = null);
  }, []), U = I.useCallback(
    (ae) => {
      typeof ae == "function" && (ae = ae(T.current)), S(ae, !1), T.current = ae;
    },
    [S]
  ), Y = I.useCallback(
    (ae) => {
      typeof ae == "function" && (ae = ae(P.current)), F(ae, !1), P.current = ae;
    },
    [F]
  ), [ne, he] = I.useState(r), X = I.useCallback(
    async (ae, be = {}, de) => {
      var _e;
      if ((_e = ae?.preventDefault) == null || _e.call(ae), !ne && !be.allowEmptySubmit)
        return;
      de && (te.current = {
        ...te.current,
        ...de
      });
      const $ = await lB(
        be.experimental_attachments
      ), re = {
        messages: T.current.concat({
          id: y(),
          createdAt: /* @__PURE__ */ new Date(),
          role: "user",
          content: ne,
          experimental_attachments: $.length > 0 ? $ : void 0
        }),
        headers: be.headers,
        body: be.body,
        data: be.data
      };
      N(re), he("");
    },
    [ne, y, N]
  ), z = (ae) => {
    he(ae.target.value);
  }, ue = I.useCallback(
    ({ toolCallId: ae, result: be }) => {
      const de = T.current.map(
        ($, ce, re) => (
          // update the tool calls in the last assistant message:
          ce === re.length - 1 && $.role === "assistant" && $.toolInvocations ? {
            ...$,
            toolInvocations: $.toolInvocations.map(
              (W) => W.toolCallId === ae ? {
                ...W,
                result: be,
                state: "result"
              } : W
            )
          } : $
        )
      );
      S(de, !1);
      const _e = de[de.length - 1];
      gB(_e) && N({ messages: de });
    },
    [S, N]
  );
  return {
    messages: x || [],
    id: v,
    setMessages: U,
    data: R,
    setData: Y,
    error: V,
    append: L,
    reload: j,
    stop: H,
    input: ne,
    setInput: he,
    handleInputChange: z,
    handleSubmit: X,
    isLoading: M,
    addToolResult: ue
  };
}
function gB(t) {
  return t.role === "assistant" && t.toolInvocations != null && t.toolInvocations.length > 0 && t.toolInvocations.every((e) => "result" in e);
}
var yGe = gGe;
const ro = Ol({
  started: !1,
  aborted: !1,
  showChat: !0
}), bGe = (t) => `
You are an experienced developer who helps people choose the best starter template for their projects.

Available templates:
<template>
  <name>blank</name>
  <description>Empty starter for simple scripts and trivial tasks that don't require a full template setup</description>
  <tags>basic, script</tags>
</template>
${t.map(
  (e) => `
<template>
  <name>${e.name}</name>
  <description>${e.description}</description>
  ${e.tags ? `<tags>${e.tags.join(", ")}</tags>` : ""}
</template>
`
).join(`
`)}

Response Format:
<selection>
  <templateName>{selected template name}</templateName>
  <title>{a proper title for the project}</title>
</selection>

Examples:

<example>
User: I need to build a todo app
Response:
<selection>
  <templateName>react-basic-starter</templateName>
  <title>Simple React todo application</title>
</selection>
</example>

<example>
User: Write a script to generate numbers from 1 to 100
Response:
<selection>
  <templateName>blank</templateName>
  <title>script to generate numbers from 1 to 100</title>
</selection>
</example>

Instructions:
1. For trivial tasks and simple scripts, always recommend the blank template
2. For more complex projects, recommend templates from the provided list
3. Follow the exact XML format
4. Consider both technical requirements and tags
5. If no perfect match exists, recommend the closest option

Important: Provide only the selection tags in your response, no additional text.
MOST IMPORTANT: YOU DONT HAVE TIME TO THINK JUST START RESPONDING BASED ON HUNCH 
`, _Ge = Uj.filter((t) => !t.name.includes("shadcn")), vGe = (t) => {
  try {
    const e = t.match(/<templateName>(.*?)<\/templateName>/), n = t.match(/<title>(.*?)<\/title>/);
    return e ? { template: e[1].trim(), title: n?.[1].trim() || "Untitled Project" } : null;
  } catch (e) {
    return console.error("Error parsing template selection:", e), null;
  }
}, wGe = async (t) => {
  const { message: e, model: n, provider: r } = t, s = {
    message: e,
    model: n,
    provider: r,
    system: bGe(_Ge)
  }, o = await (await fetch("/api/llmcall", {
    method: "POST",
    body: JSON.stringify(s)
  })).json();
  console.log(o);
  const { text: a } = o, l = vGe(a);
  return l || (console.log("No template selected, using blank template"), {
    template: "blank",
    title: ""
  });
}, mZ = async (t, e = "") => {
  const n = "https://api.github.com";
  try {
    const r = nt.get("githubToken") || void 0, s = {
      Accept: "application/vnd.github.v3+json"
    };
    r && (s.Authorization = "token " + r);
    const i = await fetch(`${n}/repos/${t}/contents/${e}`, {
      headers: s
    });
    if (!i.ok)
      throw new Error(`HTTP error! status: ${i.status}`);
    const o = await i.json();
    if (!Array.isArray(o) && o.type === "file") {
      const l = atob(o.content);
      return [
        {
          name: o.name,
          path: o.path,
          content: l
        }
      ];
    }
    return (await Promise.all(
      o.map(async (l) => {
        if (l.type === "dir")
          return await mZ(t, l.path);
        if (l.type === "file") {
          const u = await (await fetch(l.url, {
            headers: s
          })).json(), h = atob(u.content);
          return [
            {
              name: l.name,
              path: l.path,
              content: h
            }
          ];
        }
        return [];
      })
    )).flat();
  } catch (r) {
    throw console.error("Error fetching repo contents:", r), r;
  }
};
async function EGe(t, e) {
  const n = Uj.find((d) => d.name == t);
  if (!n)
    return null;
  const r = n.githubRepo, s = await mZ(r);
  let i = s;
  i = i.filter((d) => d.path.startsWith(".git") == !1);
  const o = ["package-lock.json", "yarn.lock", "pnpm-lock.yaml"];
  i = i.filter((d) => o.includes(d.name) == !1), i = i.filter((d) => d.path.startsWith(".bolt") == !1);
  const a = s.find((d) => d.path.startsWith(".bolt") && d.name == "ignore"), l = {
    files: i,
    ignoreFile: []
  };
  if (a) {
    const d = a.content.split(`
`).map((y) => y.trim()), f = o2().add(d), g = i.filter((y) => f.ignores(y.path));
    l.files = i, l.ignoreFile = g;
  }
  const c = `
<boltArtifact id="imported-files" title="${e || "Importing Starter Files"}" type="bundled">
${l.files.map(
    (d) => `<boltAction type="file" filePath="${d.path}">
${d.content}
</boltAction>`
  ).join(`
`)}
</boltArtifact>
`;
  let u = "";
  const h = s.filter((d) => d.path.startsWith(".bolt")).find((d) => d.name == "prompt");
  return h && (u = `
TEMPLATE INSTRUCTIONS:
${h.content}

IMPORTANT: Dont Forget to install the dependencies before running the app
---
`), l.ignoreFile.length > 0 && (u = u + `
STRICT FILE ACCESS RULES - READ CAREFULLY:

The following files are READ-ONLY and must never be modified:
${l.ignoreFile.map((d) => `- ${d.path}`).join(`
`)}

Permitted actions:
 Import these files as dependencies
 Read from these files
 Reference these files

Strictly forbidden actions:
 Modify any content within these files
 Delete these files
 Rename these files
 Move these files
 Create new versions of these files
 Suggest changes to these files

Any attempt to modify these protected files will result in immediate termination of the operation.

If you need to make changes to functionality, create new files instead of modifying the protected ones listed above.
---
`), u += `
---
template import is done, and you can now use the imported files,
edit only the files that need to be changed, and you can create new files as needed.
NO NOT EDIT/WRITE ANY FILES THAT ALREADY EXIST IN THE PROJECT AND DOES NOT NEED TO BE MODIFIED
---
Now that the Template is imported please continue with my original request
`, {
    assistantMessage: c,
    userMessage: u
  };
}
const SGe = ep({
  enter: "animated fadeInRight",
  exit: "animated fadeOutRight"
}), yB = Sr("Chat");
function yWe() {
  Eu.trace("Chat");
  const { ready: t, initialMessages: e, storeMessageHistory: n, importChat: r, exportChat: s } = oH(), i = mt(oi);
  return I.useEffect(() => {
    We.setReloadedMessages(e.map((o) => o.id));
  }, [e]), /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
    t && /* @__PURE__ */ k.jsx(
      TGe,
      {
        description: i,
        initialMessages: e,
        exportChat: s,
        storeMessageHistory: n,
        importChat: r
      }
    ),
    /* @__PURE__ */ k.jsx(
      kte,
      {
        closeButton: ({ closeToast: o }) => /* @__PURE__ */ k.jsx("button", { className: "Toastify__close-button", onClick: o, children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:x text-lg" }) }),
        icon: ({ type: o }) => {
          switch (o) {
            case "success":
              return /* @__PURE__ */ k.jsx("div", { className: "i-ph:check-bold text-bolt-elements-icon-success text-2xl" });
            case "error":
              return /* @__PURE__ */ k.jsx("div", { className: "i-ph:warning-circle-bold text-bolt-elements-icon-error text-2xl" });
          }
        },
        position: "bottom-right",
        pauseOnFocusLoss: !0,
        transition: SGe
      }
    )
  ] });
}
const xGe = aH(
  (t) => {
    const { messages: e, initialMessages: n, isLoading: r, parseMessages: s, storeMessageHistory: i } = t;
    s(e, r), e.length > n.length && i(e).catch((o) => $e.error(o.message));
  },
  50
), TGe = I.memo(
  ({ description: t, initialMessages: e, storeMessageHistory: n, importChat: r, exportChat: s }) => {
    Bke();
    const i = I.useRef(null), [o, a] = I.useState(e.length > 0), [l, c] = I.useState([]), [u, h] = I.useState([]), [d, f] = vB(), [g, y] = I.useState(!1), p = mt(We.files), m = mt(We.alert), { activeProviders: b, promptId: _, autoSelectTemplate: v, contextOptimizationEnabled: w } = I_e(), [E, x] = I.useState(() => nt.get("selectedModel") || Lye), [S, T] = I.useState(() => {
      const ve = nt.get("selectedProvider");
      return Rb.find((Ee) => Ee.name === ve) || Mye;
    }), { showChat: R } = mt(ro), [F, P] = mte(), [M, A] = I.useState({}), {
      messages: V,
      isLoading: ee,
      input: K,
      handleInputChange: te,
      setInput: N,
      stop: L,
      append: j,
      setMessages: H,
      reload: U,
      error: Y,
      data: ne,
      setData: he
    } = yGe({
      api: "/api/chat",
      body: {
        apiKeys: M,
        files: p,
        promptId: _,
        contextOptimization: w
      },
      sendExtraMessageFields: !0,
      onError: (ve) => {
        yB.error(`Request failed

`, ve, Y), $e.error(
          "There was an error processing your request: " + (ve.message ? ve.message : "No details were returned")
        );
      },
      onFinish: (ve, Ee) => {
        const oe = Ee.usage;
        he(void 0), oe && console.log("Token usage:", oe), yB.debug("Finished streaming");
      },
      initialMessages: e,
      initialInput: nt.get(Dv) || ""
    });
    I.useEffect(() => {
      const ve = d.get("prompt");
      ve && (f({}), re(), j({
        role: "user",
        content: [
          {
            type: "text",
            text: `[Model: ${E}]

[Provider: ${S.name}]

${ve}`
          }
        ]
        // Type assertion to bypass compiler check
      }));
    }, [E, S, d]);
    const { enhancingPrompt: X, promptEnhanced: z, enhancePrompt: ue, resetEnhancer: ae } = Lke(), { parsedMessages: be, parseMessages: de } = Nke(), _e = o ? 400 : 200;
    I.useEffect(() => {
      ro.setKey("started", e.length > 0);
    }, []), I.useEffect(() => {
      xGe({
        messages: V,
        initialMessages: e,
        isLoading: ee,
        parseMessages: de,
        storeMessageHistory: n
      });
    }, [V, ee, de]);
    const $ = () => {
      const ve = i.current;
      ve && (ve.scrollTop = ve.scrollHeight);
    }, ce = () => {
      L(), ro.setKey("aborted", !0), We.abortAllActions();
    };
    I.useEffect(() => {
      const ve = i.current;
      if (ve) {
        ve.style.height = "auto";
        const Ee = ve.scrollHeight;
        ve.style.height = `${Math.min(Ee, _e)}px`, ve.style.overflowY = Ee > _e ? "auto" : "hidden";
      }
    }, [K, i]);
    const re = async () => {
      o || (await Promise.all([
        P("#examples", { opacity: 0, display: "none" }, { duration: 0.1 }),
        P("#intro", { opacity: 0, flex: 1 }, { duration: 0.2, ease: xs })
      ]), ro.setKey("started", !0), a(!0));
    }, W = async (ve, Ee) => {
      const oe = Ee || K;
      if (oe.length === 0 || ee)
        return;
      await We.saveAllFiles(), Y != null && H(V.slice(0, -1));
      const Te = We.getFileModifcations();
      if (ro.setKey("aborted", !1), re(), !o && oe && v) {
        y(!0), H([
          {
            id: `${(/* @__PURE__ */ new Date()).getTime()}`,
            role: "user",
            content: [
              {
                type: "text",
                text: `[Model: ${E}]

[Provider: ${S.name}]

${oe}`
              },
              ...u.map((G) => ({
                type: "image",
                image: G
              }))
            ]
            // Type assertion to bypass compiler check
          }
        ]);
        const { template: ke, title: Ge } = await wGe({
          message: oe,
          model: E,
          provider: S
        });
        if (ke !== "blank") {
          const G = await EGe(ke, Ge).catch((O) => (O.message.includes("rate limit") ? $e.warning(`Rate limit exceeded. Skipping starter template
 Continuing with blank template`) : $e.warning(`Failed to import starter template
 Continuing with blank template`), null));
          if (G) {
            const { assistantMessage: O, userMessage: B } = G;
            H([
              {
                id: `${(/* @__PURE__ */ new Date()).getTime()}`,
                role: "user",
                content: oe
                // annotations: ['hidden'],
              },
              {
                id: `${(/* @__PURE__ */ new Date()).getTime()}`,
                role: "assistant",
                content: O
              },
              {
                id: `${(/* @__PURE__ */ new Date()).getTime()}`,
                role: "user",
                content: `[Model: ${E}]

[Provider: ${S.name}]

${B}`,
                annotations: ["hidden"]
              }
            ]), U(), y(!1);
            return;
          } else {
            H([
              {
                id: `${(/* @__PURE__ */ new Date()).getTime()}`,
                role: "user",
                content: [
                  {
                    type: "text",
                    text: `[Model: ${E}]

[Provider: ${S.name}]

${oe}`
                  },
                  ...u.map((O) => ({
                    type: "image",
                    image: O
                  }))
                ]
                // Type assertion to bypass compiler check
              }
            ]), U(), y(!1);
            return;
          }
        } else {
          H([
            {
              id: `${(/* @__PURE__ */ new Date()).getTime()}`,
              role: "user",
              content: [
                {
                  type: "text",
                  text: `[Model: ${E}]

[Provider: ${S.name}]

${oe}`
                },
                ...u.map((G) => ({
                  type: "image",
                  image: G
                }))
              ]
              // Type assertion to bypass compiler check
            }
          ]), U(), y(!1);
          return;
        }
      }
      Te !== void 0 ? (j({
        role: "user",
        content: [
          {
            type: "text",
            text: `[Model: ${E}]

[Provider: ${S.name}]

${oe}`
          },
          ...u.map((ke) => ({
            type: "image",
            image: ke
          }))
        ]
        // Type assertion to bypass compiler check
      }), We.resetAllFileModifications()) : j({
        role: "user",
        content: [
          {
            type: "text",
            text: `[Model: ${E}]

[Provider: ${S.name}]

${oe}`
          },
          ...u.map((ke) => ({
            type: "image",
            image: ke
          }))
        ]
        // Type assertion to bypass compiler check
      }), N(""), nt.remove(Dv), c([]), h([]), ae(), i.current?.blur();
    }, q = (ve) => {
      te(ve);
    }, ie = I.useCallback(
      qk((ve) => {
        const Ee = ve.target.value.trim();
        nt.set(Dv, Ee, { expires: 30 });
      }, 1e3),
      []
    ), [ye, xe] = Fke();
    I.useEffect(() => {
      const ve = nt.get("apiKeys");
      ve && A(JSON.parse(ve));
    }, []);
    const fe = (ve) => {
      x(ve), nt.set("selectedModel", ve, { expires: 30 });
    }, Ce = (ve) => {
      T(ve), nt.set("selectedProvider", ve.name, { expires: 30 });
    };
    return /* @__PURE__ */ k.jsx(
      v7e,
      {
        ref: F,
        textareaRef: i,
        input: K,
        showChat: R,
        chatStarted: o,
        isStreaming: ee || g,
        enhancingPrompt: X,
        promptEnhanced: z,
        sendMessage: W,
        model: E,
        setModel: fe,
        provider: S,
        setProvider: Ce,
        providerList: b,
        messageRef: ye,
        scrollRef: xe,
        handleInputChange: (ve) => {
          q(ve), ie(ve);
        },
        handleStop: ce,
        description: t,
        importChat: r,
        exportChat: s,
        messages: V.map((ve, Ee) => ve.role === "user" ? ve : {
          ...ve,
          content: be[Ee] || ""
        }),
        enhancePrompt: () => {
          ue(
            K,
            (ve) => {
              N(ve), $();
            },
            E,
            S,
            M
          );
        },
        uploadedFiles: l,
        setUploadedFiles: c,
        imageDataList: u,
        setImageDataList: h,
        actionAlert: m,
        clearAlert: () => We.clearAlert(),
        data: ne
      }
    );
  }
);
function CGe({}) {
  const t = mt(We.showWorkbench), { showChat: e } = mt(ro), n = F7(1024), r = t || !e;
  return /* @__PURE__ */ k.jsx("div", { className: "flex", children: /* @__PURE__ */ k.jsxs("div", { className: "flex border border-bolt-elements-borderColor rounded-md overflow-hidden", children: [
    /* @__PURE__ */ k.jsx(
      bB,
      {
        active: e,
        disabled: !r || n,
        onClick: () => {
          r && ro.setKey("showChat", !e);
        },
        children: /* @__PURE__ */ k.jsx("div", { className: "i-bolt:chat text-sm" })
      }
    ),
    /* @__PURE__ */ k.jsx("div", { className: "w-[1px] bg-bolt-elements-borderColor" }),
    /* @__PURE__ */ k.jsx(
      bB,
      {
        active: t,
        onClick: () => {
          t && !e && ro.setKey("showChat", !0), We.showWorkbench.set(!t);
        },
        children: /* @__PURE__ */ k.jsx("div", { className: "i-ph:code-bold" })
      }
    )
  ] }) });
}
function bB({ active: t = !1, disabled: e = !1, children: n, onClick: r }) {
  return /* @__PURE__ */ k.jsx(
    "button",
    {
      className: qe("flex items-center p-1.5", {
        "bg-bolt-elements-item-backgroundDefault hover:bg-bolt-elements-item-backgroundActive text-bolt-elements-textTertiary hover:text-bolt-elements-textPrimary": !t,
        "bg-bolt-elements-item-backgroundAccent text-bolt-elements-item-contentAccent": t && !e,
        "bg-bolt-elements-item-backgroundDefault text-alpha-gray-20 dark:text-alpha-white-20 cursor-not-allowed": e
      }),
      onClick: r,
      children: n
    }
  );
}
function kGe() {
  const t = mt(oi), { editing: e, handleChange: n, handleBlur: r, handleSubmit: s, handleKeyDown: i, currentDescription: o, toggleEditMode: a } = $ke({
    initialDescription: t,
    syncWithGlobalStore: !0
  });
  return t ? /* @__PURE__ */ k.jsx("div", { className: "flex items-center justify-center", children: e ? /* @__PURE__ */ k.jsxs("form", { onSubmit: s, className: "flex items-center justify-center", children: [
    /* @__PURE__ */ k.jsx(
      "input",
      {
        type: "text",
        className: "bg-bolt-elements-background-depth-1 text-bolt-elements-textPrimary rounded px-2 mr-2 w-fit",
        autoFocus: !0,
        value: o,
        onChange: n,
        onBlur: r,
        onKeyDown: i,
        style: { width: `${Math.max(o.length * 8, 100)}px` }
      }
    ),
    /* @__PURE__ */ k.jsx(ey, { children: /* @__PURE__ */ k.jsx(uu, { tooltip: "Save title", children: /* @__PURE__ */ k.jsx("div", { className: "flex justify-between items-center p-2 rounded-md bg-bolt-elements-item-backgroundAccent", children: /* @__PURE__ */ k.jsx(
      "button",
      {
        type: "submit",
        className: "i-ph:check-bold scale-110 hover:text-bolt-elements-item-contentAccent",
        onMouseDown: s
      }
    ) }) }) })
  ] }) : /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
    o,
    /* @__PURE__ */ k.jsx(ey, { children: /* @__PURE__ */ k.jsx(uu, { tooltip: "Rename chat", children: /* @__PURE__ */ k.jsx("div", { className: "flex justify-between items-center p-2 rounded-md bg-bolt-elements-item-backgroundAccent ml-2", children: /* @__PURE__ */ k.jsx(
      "button",
      {
        type: "button",
        className: "i-ph:pencil-fill scale-110 hover:text-bolt-elements-item-contentAccent",
        onClick: (l) => {
          l.preventDefault(), a();
        }
      }
    ) }) }) })
  ] }) }) : null;
}
function bWe() {
  const t = mt(ro);
  return /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsx(
    "header",
    {
      className: qe("flex items-center p-5 border-b h-[var(--header-height)]", {
        "border-transparent": !t.started,
        "border-bolt-elements-borderColor": t.started
      }),
      children: t.started && /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
        /* @__PURE__ */ k.jsx("span", { className: "flex-1 px-4 truncate text-center text-bolt-elements-textPrimary", children: /* @__PURE__ */ k.jsx(Oo, { children: () => /* @__PURE__ */ k.jsx(kGe, {}) }) }),
        /* @__PURE__ */ k.jsx(Oo, { children: () => /* @__PURE__ */ k.jsx("div", { className: "mr-1", children: /* @__PURE__ */ k.jsx(CGe, {}) }) })
      ] })
    }
  ) });
}
export {
  o2 as $,
  tWe as A,
  eWe as B,
  AG as C,
  yRe as D,
  Ae as E,
  IIe as F,
  JVe as G,
  HRe as H,
  Wt as I,
  VVe as J,
  Cu as K,
  Sx as L,
  D as M,
  dG as N,
  gWe as O,
  xRe as P,
  wze as Q,
  mWe as R,
  ln as S,
  fn as T,
  oH as U,
  a7e as V,
  $e as W,
  Oo as X,
  yWe as Y,
  l7e as Z,
  v7e as _,
  YVe as a,
  PK as a0,
  OK as a1,
  DK as a2,
  bWe as a3,
  QVe as b,
  Er as c,
  ZVe as d,
  ct as e,
  nIe as f,
  XVe as g,
  qr as h,
  WRe as i,
  ys as j,
  jRe as k,
  tIe as l,
  Pn as m,
  Kb as n,
  _a as o,
  WVe as p,
  Qb as q,
  Uu as r,
  MRe as s,
  me as t,
  Ec as u,
  pt as v,
  xn as w,
  fy as x,
  He as y,
  SIe as z
};
